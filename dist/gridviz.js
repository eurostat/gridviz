(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["gridviz"] = factory();
	else
		root["gridviz"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/d3-array/src/ascending.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/ascending.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ascending)
/* harmony export */ });
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/bisect.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/bisect.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bisectCenter: () => (/* binding */ bisectCenter),
/* harmony export */   bisectLeft: () => (/* binding */ bisectLeft),
/* harmony export */   bisectRight: () => (/* binding */ bisectRight),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisector.js */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-array/src/number.js");




const ascendingBisect = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_number_js__WEBPACK_IMPORTED_MODULE_2__["default"]).center;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bisectRight);


/***/ }),

/***/ "./node_modules/d3-array/src/bisector.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/bisector.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ bisector)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./descending.js */ "./node_modules/d3-array/src/descending.js");



function bisector(f) {
  let compare1, compare2, delta;

  // If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We can’t do this
  // for a comparator (except for specific, known comparators) because we can’t
  // tell if the comparator is symmetric, and an asymmetric comparator can’t be
  // used to test whether a single value is comparable.
  if (f.length !== 2) {
    compare1 = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"];
    compare2 = (d, x) => (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"] || f === _descending_js__WEBPACK_IMPORTED_MODULE_1__["default"] ? f : zero;
    compare2 = f;
    delta = f;
  }

  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function zero() {
  return 0;
}


/***/ }),

/***/ "./node_modules/d3-array/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-array/src/descending.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ descending)
/* harmony export */ });
function descending(a, b) {
  return a == null || b == null ? NaN
    : b < a ? -1
    : b > a ? 1
    : b >= a ? 0
    : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/extent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/extent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ extent)
/* harmony export */ });
function extent(values, valueof) {
  let min;
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  }
  return [min, max];
}


/***/ }),

/***/ "./node_modules/d3-array/src/greatest.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/greatest.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ greatest)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");


function greatest(values, compare = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  let max;
  let defined = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, maxValue) > 0
          : (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, value) === 0) {
        max = element;
        maxValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, max) > 0
          : compare(value, value) === 0) {
        max = value;
        defined = true;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "./node_modules/d3-array/src/max.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/max.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ max)
/* harmony export */ });
function max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "./node_modules/d3-array/src/maxIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/maxIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ maxIndex)
/* harmony export */ });
function maxIndex(values, valueof) {
  let max;
  let maxIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  }
  return maxIndex;
}


/***/ }),

/***/ "./node_modules/d3-array/src/min.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/min.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ min)
/* harmony export */ });
function min(values, valueof) {
  let min;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  }
  return min;
}


/***/ }),

/***/ "./node_modules/d3-array/src/minIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/minIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ minIndex)
/* harmony export */ });
function minIndex(values, valueof) {
  let min;
  let minIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  }
  return minIndex;
}


/***/ }),

/***/ "./node_modules/d3-array/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/number.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ number),
/* harmony export */   numbers: () => (/* binding */ numbers)
/* harmony export */ });
function number(x) {
  return x === null ? NaN : +x;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-array/src/permute.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/permute.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ permute)
/* harmony export */ });
function permute(source, keys) {
  return Array.from(keys, key => source[key]);
}


/***/ }),

/***/ "./node_modules/d3-array/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile),
/* harmony export */   quantileIndex: () => (/* binding */ quantileIndex),
/* harmony export */   quantileSorted: () => (/* binding */ quantileSorted)
/* harmony export */ });
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./max.js */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _maxIndex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maxIndex.js */ "./node_modules/d3-array/src/maxIndex.js");
/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./min.js */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var _minIndex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./minIndex.js */ "./node_modules/d3-array/src/minIndex.js");
/* harmony import */ var _quickselect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./quickselect.js */ "./node_modules/d3-array/src/quickselect.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-array/src/sort.js");
/* harmony import */ var _greatest_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./greatest.js */ "./node_modules/d3-array/src/greatest.js");









function quantile(values, p, valueof) {
  values = Float64Array.from((0,_number_js__WEBPACK_IMPORTED_MODULE_5__.numbers)(values, valueof));
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return (0,_min_js__WEBPACK_IMPORTED_MODULE_2__["default"])(values);
  if (p >= 1) return (0,_max_js__WEBPACK_IMPORTED_MODULE_0__["default"])(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = (0,_max_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_quickselect_js__WEBPACK_IMPORTED_MODULE_4__["default"])(values, i0).subarray(0, i0 + 1)),
      value1 = (0,_min_js__WEBPACK_IMPORTED_MODULE_2__["default"])(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function quantileIndex(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {
  if (isNaN(p = +p)) return;
  numbers = Float64Array.from(values, (_, i) => (0,_number_js__WEBPACK_IMPORTED_MODULE_5__["default"])(valueof(values[i], i, values)));
  if (p <= 0) return (0,_minIndex_js__WEBPACK_IMPORTED_MODULE_3__["default"])(numbers);
  if (p >= 1) return (0,_maxIndex_js__WEBPACK_IMPORTED_MODULE_1__["default"])(numbers);
  var numbers,
      index = Uint32Array.from(values, (_, i) => i),
      j = numbers.length - 1,
      i = Math.floor(j * p);
  (0,_quickselect_js__WEBPACK_IMPORTED_MODULE_4__["default"])(index, i, 0, j, (i, j) => (0,_sort_js__WEBPACK_IMPORTED_MODULE_6__.ascendingDefined)(numbers[i], numbers[j]));
  i = (0,_greatest_js__WEBPACK_IMPORTED_MODULE_7__["default"])(index.subarray(0, i + 1), (i) => numbers[i]);
  return i >= 0 ? i : -1;
}


/***/ }),

/***/ "./node_modules/d3-array/src/quickselect.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-array/src/quickselect.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quickselect)
/* harmony export */ });
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-array/src/sort.js");


// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k, left = 0, right = Infinity, compare) {
  k = Math.floor(k);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array.length - 1, right));

  if (!(left <= k && k <= right)) return array;

  compare = compare === undefined ? _sort_js__WEBPACK_IMPORTED_MODULE_0__.ascendingDefined : (0,_sort_js__WEBPACK_IMPORTED_MODULE_0__.compareDefined)(compare);

  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }

  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}


/***/ }),

/***/ "./node_modules/d3-array/src/sort.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/sort.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ascendingDefined: () => (/* binding */ ascendingDefined),
/* harmony export */   compareDefined: () => (/* binding */ compareDefined),
/* harmony export */   "default": () => (/* binding */ sort)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _permute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./permute.js */ "./node_modules/d3-array/src/permute.js");



function sort(values, ...F) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values = Array.from(values);
  let [f] = F;
  if ((f && f.length !== 2) || F.length > 1) {
    const index = Uint32Array.from(values, (d, i) => i);
    if (F.length > 1) {
      F = F.map(f => values.map(f));
      index.sort((i, j) => {
        for (const f of F) {
          const c = ascendingDefined(f[i], f[j]);
          if (c) return c;
        }
      });
    } else {
      f = values.map(f);
      index.sort((i, j) => ascendingDefined(f[i], f[j]));
    }
    return (0,_permute_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values, index);
  }
  return values.sort(compareDefined(f));
}

function compareDefined(compare = _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  if (compare === _ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"]) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a, b) => {
    const x = compare(a, b);
    if (x || x === 0) return x;
    return (compare(b, b) === 0) - (compare(a, a) === 0);
  };
}

function ascendingDefined(a, b) {
  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
}


/***/ }),

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   Rgb: () => (/* binding */ Rgb),
/* harmony export */   brighter: () => (/* binding */ brighter),
/* harmony export */   darker: () => (/* binding */ darker),
/* harmony export */   "default": () => (/* binding */ color),
/* harmony export */   hsl: () => (/* binding */ hsl),
/* harmony export */   hslConvert: () => (/* binding */ hslConvert),
/* harmony export */   rgb: () => (/* binding */ rgb),
/* harmony export */   rgbConvert: () => (/* binding */ rgbConvert)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   extend: () => (/* binding */ extend)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hcl: () => (/* binding */ Hcl),
/* harmony export */   Lab: () => (/* binding */ Lab),
/* harmony export */   "default": () => (/* binding */ lab),
/* harmony export */   gray: () => (/* binding */ gray),
/* harmony export */   hcl: () => (/* binding */ hcl),
/* harmony export */   lch: () => (/* binding */ lch)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_1__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.rgbConvert)(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Lab, lab, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_1__.Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_1__.Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hcl, hcl, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_1__.Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   radians: () => (/* binding */ radians)
/* harmony export */ });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   yesdrag: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nonpassive: () => (/* binding */ nonpassive),
/* harmony export */   nonpassivecapture: () => (/* binding */ nonpassivecapture),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/csv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/csv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csvFormat: () => (/* binding */ csvFormat),
/* harmony export */   csvFormatBody: () => (/* binding */ csvFormatBody),
/* harmony export */   csvFormatRow: () => (/* binding */ csvFormatRow),
/* harmony export */   csvFormatRows: () => (/* binding */ csvFormatRows),
/* harmony export */   csvFormatValue: () => (/* binding */ csvFormatValue),
/* harmony export */   csvParse: () => (/* binding */ csvParse),
/* harmony export */   csvParseRows: () => (/* binding */ csvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var csv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;


/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/tsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/tsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tsvFormat: () => (/* binding */ tsvFormat),
/* harmony export */   tsvFormatBody: () => (/* binding */ tsvFormatBody),
/* harmony export */   tsvFormatRow: () => (/* binding */ tsvFormatRow),
/* harmony export */   tsvFormatRows: () => (/* binding */ tsvFormatRows),
/* harmony export */   tsvFormatValue: () => (/* binding */ tsvFormatValue),
/* harmony export */   tsvParse: () => (/* binding */ tsvParse),
/* harmony export */   tsvParseRows: () => (/* binding */ tsvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var tsv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cubicIn: () => (/* binding */ cubicIn),
/* harmony export */   cubicInOut: () => (/* binding */ cubicInOut),
/* harmony export */   cubicOut: () => (/* binding */ cubicOut)
/* harmony export */ });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/dsv.js":
/*!******************************************!*\
  !*** ./node_modules/d3-fetch/src/dsv.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   csv: () => (/* binding */ csv),
/* harmony export */   "default": () => (/* binding */ dsv),
/* harmony export */   tsv: () => (/* binding */ tsv)
/* harmony export */ });
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/csv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/tsv.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-fetch/src/text.js");



function dsvParse(parse) {
  return function(input, init, row) {
    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
    return (0,_text_js__WEBPACK_IMPORTED_MODULE_3__["default"])(input, init).then(function(response) {
      return parse(response, row);
    });
  };
}

function dsv(delimiter, input, init, row) {
  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
  var format = (0,d3_dsv__WEBPACK_IMPORTED_MODULE_0__["default"])(delimiter);
  return (0,_text_js__WEBPACK_IMPORTED_MODULE_3__["default"])(input, init).then(function(response) {
    return format.parse(response, row);
  });
}

var csv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_1__.csvParse);
var tsv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_2__.tsvParse);


/***/ }),

/***/ "./node_modules/d3-fetch/src/json.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205) return;
  return response.json();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseJson);
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/text.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/text.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseText);
}


/***/ }),

/***/ "./node_modules/d3-format/src/defaultLocale.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/defaultLocale.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultLocale),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   formatPrefix: () => (/* binding */ formatPrefix)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__["default"])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-format/src/exponent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/exponent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatDecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatDecimal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   formatDecimalParts: () => (/* binding */ formatDecimalParts)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatGroup.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatGroup.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatNumerals.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/formatNumerals.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatPrefixAuto.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-format/src/formatPrefixAuto.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   prefixExponent: () => (/* binding */ prefixExponent)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatRounded.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatRounded.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatSpecifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/formatSpecifier.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FormatSpecifier: () => (/* binding */ FormatSpecifier),
/* harmony export */   "default": () => (/* binding */ formatSpecifier)
/* harmony export */ });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "./node_modules/d3-format/src/formatTrim.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-format/src/formatTrim.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatTypes.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatRounded.js */ "./node_modules/d3-format/src/formatRounded.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => (0,_formatRounded_js__WEBPACK_IMPORTED_MODULE_2__["default"])(x * 100, p),
  "r": _formatRounded_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  "s": _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});


/***/ }),

/***/ "./node_modules/d3-format/src/identity.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/identity.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-format/src/locale.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-format/src/locale.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup.js */ "./node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals.js */ "./node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier.js */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTrim.js */ "./node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTypes.js */ "./node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-format/src/identity.js");









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_7__["default"] : (0,_formatGroup_js__WEBPACK_IMPORTED_MODULE_1__["default"])(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_7__["default"] : (0,_formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__["default"])(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "−" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes_js__WEBPACK_IMPORTED_MODULE_5__["default"][type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes_js__WEBPACK_IMPORTED_MODULE_5__["default"][type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0,_formatTrim_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basis: () => (/* binding */ basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ nogamma),
/* harmony export */   gamma: () => (/* binding */ gamma),
/* harmony export */   hue: () => (/* binding */ hue)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lab)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/lab.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__["default"])(start)).l, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__["default"])(end)).l),
      a = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.a, end.a),
      b = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.b, end.b),
      opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rgbBasis: () => (/* binding */ rgbBasis),
/* harmony export */   rgbBasisClosed: () => (/* binding */ rgbBasisClosed)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function rgbGamma(y) {
  var color = (0,_color_js__WEBPACK_IMPORTED_MODULE_3__.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.rgb)(start)).r, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_3__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_2__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   interpolateTransformCss: () => (/* binding */ interpolateTransformCss),
/* harmony export */   interpolateTransformSvg: () => (/* binding */ interpolateTransformSvg)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseSvg, ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseCss: () => (/* binding */ parseCss),
/* harmony export */   parseSvg: () => (/* binding */ parseSvg)
/* harmony export */ });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity : (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  value = value.matrix;
  return (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-random/src/defaultSource.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-random/src/defaultSource.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Math.random);


/***/ }),

/***/ "./node_modules/d3-random/src/normal.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-random/src/normal.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _defaultSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultSource.js */ "./node_modules/d3-random/src/defaultSource.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y;

      // If available, use the second previously-generated uniform random.
      if (x != null) y = x, x = null;

      // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);

      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;

  return randomNormal;
})(_defaultSource_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "./node_modules/d3-scale/src/init.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/init.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initInterpolator: () => (/* binding */ initInterpolator),
/* harmony export */   initRange: () => (/* binding */ initRange)
/* harmony export */ });
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/quantile.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.quantileSorted)(domain, i / n);
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_1__["default"]);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ array)
/* harmony export */ });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we don’t ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_1__.xhtml && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_1__.xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   childMatcher: () => (/* binding */ childMatcher),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   xhtml: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event, node) {
  event = (0,_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_1__.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_1__.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isn’t worried about “live” collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// don’t; we’d rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return !this.node();
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnterNode: () => (/* binding */ EnterNode),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,_matcher_js__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"],
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, before) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function* __WEBPACK_DEFAULT_EXPORT__() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(lower);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(merges, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return Array.from(this);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(raise);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(remove);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");




function arrayAll(select) {
  return function() {
    return (0,_array_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = (0,_selectorAll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(subgroups, parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(update) {
  return new Array(update.length);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   styleValue: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timer: () => (/* binding */ Timer),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   timer: () => (/* binding */ timer),
/* harmony export */   timerFlush: () => (/* binding */ timerFlush)
/* harmony export */ });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__.SCHEDULED && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__.Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   active: () => (/* reexport safe */ _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   interrupt: () => (/* reexport safe */ _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   transition: () => (/* reexport safe */ _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");






/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.STARTING && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDING;
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return this.each(function() {
    (0,_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/cubic.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_2__.cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_0__.Transition) {
    id = name._id, name = name._name;
  } else {
    id = (0,_transition_index_js__WEBPACK_IMPORTED_MODULE_0__.newId)(), (timing = defaultTiming).time = (0,d3_timer__WEBPACK_IMPORTED_MODULE_3__.now)(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        (0,_transition_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(groups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.interpolateTransformSvg : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_2__.tweenValue)(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).delay;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).duration;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).ease;
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/easeVarying.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/easeVarying.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/matcher.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(subgroups, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transition: () => (/* binding */ Transition),
/* harmony export */   "default": () => (/* binding */ transition),
/* harmony export */   newId: () => (/* binding */ newId)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["default"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["default"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"]
      : (c = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__["default"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"])(a, b);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(merges, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__.init : _schedule_js__WEBPACK_IMPORTED_MODULE_0__.set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.on("end.remove", removeFunction(this._id));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CREATED: () => (/* binding */ CREATED),
/* harmony export */   ENDED: () => (/* binding */ ENDED),
/* harmony export */   ENDING: () => (/* binding */ ENDING),
/* harmony export */   RUNNING: () => (/* binding */ RUNNING),
/* harmony export */   SCHEDULED: () => (/* binding */ SCHEDULED),
/* harmony export */   STARTED: () => (/* binding */ STARTED),
/* harmony export */   STARTING: () => (/* binding */ STARTING),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   set: () => (/* binding */ set)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timeout.js");



var emptyOn = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = (0,d3_timer__WEBPACK_IMPORTED_MODULE_1__.timer)(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selector.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(subgroup[i], name, id, i, subgroup, (0,_schedule_js__WEBPACK_IMPORTED_MODULE_2__.get)(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(subgroups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_2__.get)(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            (0,_schedule_js__WEBPACK_IMPORTED_MODULE_2__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(subgroups, parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.constructor;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new Selection(this._groups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.styleValue)(this, name),
        string1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.styleValue)(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.styleValue)(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_2__.set)(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__.interpolateTransformCss : _interpolate_js__WEBPACK_IMPORTED_MODULE_4__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_3__.tweenValue)(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction((0,_tween_js__WEBPACK_IMPORTED_MODULE_0__.tweenValue)(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var name = this._name,
      id0 = this._id,
      id1 = (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.newId)();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id0);
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(groups, this._parents, name, id1);
}


/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   tweenValue: () => (/* binding */ tweenValue)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ZoomEvent)
/* harmony export */ });
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.Transform),
/* harmony export */   zoom: () => (/* reexport safe */ _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   zoomIdentity: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.identity),
/* harmony export */   zoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");




/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform),
/* harmony export */   "default": () => (/* binding */ transform),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_8__.identity;
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"],
      listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_8__.identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_8__.Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_8__.Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_8__.Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this.that).datum();
      listeners.call(
        type,
        this.that,
        new _event_js__WEBPACK_IMPORTED_MODULE_7__["default"](type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_5__.interrupt)(this);
      g.start();
    }

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    (0,d3_drag__WEBPACK_IMPORTED_MODULE_1__["default"])(event.view);
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_9__.nopropagation)(event);
    g.mouse = [p, this.__zoom.invert(p)];
    (0,d3_transition__WEBPACK_IMPORTED_MODULE_5__.interrupt)(this);
    g.start();

    function mousemoved(event) {
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      (0,d3_drag__WEBPACK_IMPORTED_MODULE_1__.yesdrag)(event.view, g.moved);
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(event);
    if (duration > 0) (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).transition().duration(duration).call(schedule, t1, p0, event);
    else (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_9__.nopropagation)(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_5__.interrupt)(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_9__.nopropagation)(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_6__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_6__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_6__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_6__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
}


/***/ }),

/***/ "./src/button/Button.js":
/*!******************************!*\
  !*** ./src/button/Button.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Button: () => (/* binding */ Button)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");


/**
 * Parent class for button elements used to interact with the gridviz viewer.
 *
 * @module button
 * @author Joseph Davies, Julien Gaffuri
 */
class Button {
    /**
     * @param {Object} opts
     * opts.parentNode
     * opts.id
     * opts.title
     * opts.class
     * opts.onClickFunction
     * opts.x
     * opts.y
     */
    constructor(opts = {}) {
        this.map = opts.map
        this.parentNode = opts.parentNode || opts.map.container

        // the div element
        if (opts.id) this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + opts.id)

        if (!this.div || this.div.empty()) {
            this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(document.createElement('div'))
            if (opts.id) this.div.attr('id', opts.id)
        }

        if (opts.title) this.div.attr('title', opts.title)
        if (opts.class) this.div.attr('class', opts.class)

        // add events
        if (opts.onClickFunction) this.div.on('click', opts.onClickFunction)

        //set styles
        this.style(
            'box-shadow',
            '0 7px 8px rgba(0,47,103,.08), 0 0 22px rgba(0,47,103,.04), 0 12px 17px rgba(0,47,103,.04), 0 -4px 4px rgba(0,47,103,.04)'
        ) //.ecl-u-shadow-3
        this.style('background-color', '#ffffff')
        this.style('position', 'absolute')
        this.style('cursor', 'pointer')
        this.style('display', 'flex')
        this.style('justify-content', 'center')
        this.style('align-items', 'center')
        this.style('width', '35px')
        this.style('height', '30px')
        // this.style(padding , '4px'

        // append to parent
        this.parentNode.appendChild(this.div.node())
    }

    /**
     * Apply a style to the button div.
     * @param {string} k
     * @param {string} v
     * @returns {this}
     */
    style(k, v) {
        this.div.style(k, v)
        return this
    }
}


/***/ }),

/***/ "./src/button/FullscreenButton.js":
/*!****************************************!*\
  !*** ./src/button/FullscreenButton.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FullscreenButton: () => (/* binding */ FullscreenButton)
/* harmony export */ });
/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.js */ "./src/button/Button.js");


/**
 * Button for toggling fullscreen mode
 *
 * @module button
 * @author Joseph Davies, Julien Gaffuri
 */
class FullscreenButton extends _Button_js__WEBPACK_IMPORTED_MODULE_0__.Button {
    /**
     * @param {Object} opts
     * opts.parentNode - the node that the button is appended to
     * opts.canvas - the gridviz canvas
     * opts.id
     * opts.title - HTML title attribute
     * opts.class - css class
     * opts.onClickFunction
     * opts.x - x position of the button
     * opts.y - y position of the button
     */

    // default state
    isFullscreen = false

    constructor(opts) {
        super(opts)

        // append fullscreen icon to button container
        this.div.node().innerHTML = `
        <svg
            style="height: 1.2rem; width: 1.2rem; fill:black; margin:0;"
            focusable="false"
            aria-hidden="true"
        >
            <svg fill="#000000" viewBox="0 0 96 96" xmlns="http://www.w3.org/2000/svg">
            <title/>
            <g>
            <path d="M30,0H6A5.9966,5.9966,0,0,0,0,6V30a6,6,0,0,0,12,0V12H30A6,6,0,0,0,30,0Z"/>
            <path d="M90,0H66a6,6,0,0,0,0,12H84V30a6,6,0,0,0,12,0V6A5.9966,5.9966,0,0,0,90,0Z"/>
            <path d="M30,84H12V66A6,6,0,0,0,0,66V90a5.9966,5.9966,0,0,0,6,6H30a6,6,0,0,0,0-12Z"/>
            <path d="M90,60a5.9966,5.9966,0,0,0-6,6V84H66a6,6,0,0,0,0,12H90a5.9966,5.9966,0,0,0,6-6V66A5.9966,5.9966,0,0,0,90,60Z"/>
            </g>
            </svg>
        </svg>
        `

        //save initial map dimensions
        this.defaultHeight = this.map.h
        this.defaultWidth = this.map.w

        // event handler
        this.div.on('click', (e) => {
            this.onClickFunction(e)
        })
        this.div.on('mouseover', (e) => {
            this.style('background-color', 'lightgrey')
        })
        this.div.on('mouseout', (e) => {
            this.style('background-color', '#ffffff')
        })

        //set position
        if (opts.x) {
            this.style('left', opts.x + 'px')
        } else {
            this.style('right', '10px')
        }
        if (opts.y) {
            this.style('top', opts.y + 'px')
        } else {
            this.style('top', '90px')
        }
    }

    onClickFunction(e) {
        if (this.isFullscreen) {
            this.closeFullscreen(this.map.container)
            //resize canvas to default
            this.map.h = this.defaultHeight
            this.map.w = this.defaultWidth
            this.map.geoCanvas.h = this.defaultHeight
            this.map.geoCanvas.w = this.defaultWidth
            this.map.geoCanvas.canvas.setAttribute('width', '' + this.defaultWidth)
            this.map.geoCanvas.canvas.setAttribute('height', '' + this.defaultHeight)
            this.map.redraw()
            this.isFullscreen = false
        } else {
            this.openFullscreen(this.map.container)
            //resize canvas to fullscreen
            this.map.h = window.screen.height
            this.map.w = window.screen.width
            this.isFullscreen = true
        }
    }

    /* Open fullscreen */
    openFullscreen(elem) {
        if (elem.requestFullscreen) {
            elem.requestFullscreen()
        } else if (elem.webkitRequestFullscreen) {
            /* Safari */
            elem.webkitRequestFullscreen()
        } else if (elem.msRequestFullscreen) {
            /* IE11 */
            elem.msRequestFullscreen()
        }
    }

    /* Close fullscreen */
    closeFullscreen() {
        if (document.exitFullscreen) {
            document.exitFullscreen()
        } else if (document.webkitExitFullscreen) {
            /* Safari */
            document.webkitExitFullscreen()
        } else if (document.msExitFullscreen) {
            /* IE11 */
            document.msExitFullscreen()
        }
    }
}


/***/ }),

/***/ "./src/button/ZoomButtons.js":
/*!***********************************!*\
  !*** ./src/button/ZoomButtons.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZoomButtons: () => (/* binding */ ZoomButtons)
/* harmony export */ });
/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.js */ "./src/button/Button.js");


/**
 * Button for toggling fullscreen mode
 *
 * @module button
 * @author Joseph Davies, Julien Gaffuri
 */
class ZoomButtons extends _Button_js__WEBPACK_IMPORTED_MODULE_0__.Button {
    /**
     * @param {Object} opts
     */
    constructor(opts) {
        super(opts)

        this.onZoom = opts.onZoom // custom user event handler
        this.delta = opts.delta || 0.2

        // Create zoom in button
        this.zoomInBtn = document.createElement('a')
        this.zoomInBtn.id = 'zoom-in'
        this.zoomInBtn.className = 'gridviz-zoom-button'
        this.zoomInBtn.title = 'Zoom in'
        this.zoomInBtn.textContent = '+'
        this.zoomInBtn.addEventListener('click', (e) => {
            this.zoomIn(e)
        })
        this.zoomInBtn.addEventListener('mouseover', () => {
            this.zoomInBtn.style.backgroundColor = 'lightgrey'
        })
        this.zoomInBtn.addEventListener('mouseout', () => {
            this.zoomInBtn.style.backgroundColor = '#ffffff'
        })

        // Create zoom out button
        this.zoomOutBtn = document.createElement('a')
        this.zoomOutBtn.id = 'zoom-out'
        this.zoomOutBtn.className = 'gridviz-zoom-button'
        this.zoomOutBtn.title = 'Zoom out'
        this.zoomOutBtn.textContent = '-'
        this.zoomOutBtn.addEventListener('click', (e) => {
            this.zoomOut(e)
        })
        this.zoomOutBtn.addEventListener('mouseover', () => {
            this.zoomOutBtn.style.backgroundColor = 'lightgrey'
        })
        this.zoomOutBtn.addEventListener('mouseout', () => {
            this.zoomOutBtn.style.backgroundColor = '#ffffff'
        })

        // Set common styles for buttons
        const buttons = [this.zoomInBtn, this.zoomOutBtn]
        buttons.forEach((btn, index) => {
            btn.style.alignItems = 'center'
            btn.style.justifyContent = 'center'
            btn.style.display = 'flex'
            btn.style.border = 'none'
            btn.style.color = 'black'
            btn.style.textAlign = 'center'
            btn.style.textDecoration = 'none'
            btn.style.padding = '4px'
            btn.style.fontSize = '24px'
            btn.style.fontWeight = 'bold'
            btn.style.userSelect = 'none'
            btn.style.backgroundColor = '#ffffff'
            if (index === 0) btn.style.borderBottom = '1px solid grey' // Zoom in button only
        })

        // Unset parent class height and display for dual buttons
        this.style('height', 'unset')
        this.style('display', 'unset')

        // Set position
        if (opts.x) {
            this.style('left', opts.x + 'px')
        } else {
            this.style('right', '10px')
        }
        if (opts.y) {
            this.style('top', opts.y + 'px')
        } else {
            this.style('top', '10px')
        }

        // Append buttons to the container
        this.div.node().appendChild(this.zoomInBtn)
        this.div.node().appendChild(this.zoomOutBtn)
    }

    /* Zoom in */
    zoomIn(e) {
        this.map.setZoom(this.map.getZoom() * (1 - this.delta)).redraw()
        if (this.onZoom) this.onZoom(e)
        if (this.map.geoCanvas.onZoomFun) this.map.geoCanvas.onZoomFun(e)
    }

    /* Zoom out */
    zoomOut(e) {
        this.map.setZoom(this.map.getZoom() * (1 + this.delta)).redraw()
        if (this.onZoom) this.onZoom(e)
        if (this.map.geoCanvas.onZoomFun) this.map.geoCanvas.onZoomFun(e)
    }
}


/***/ }),

/***/ "./src/core/Dataset.js":
/*!*****************************!*\
  !*** ./src/core/Dataset.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dataset: () => (/* binding */ Dataset)
/* harmony export */ });
//@ts-check


/**
 * A grid cell.
 * @typedef {{x: number, y: number}} Cell */

/**
 * A dataset component, of grid cells.
 * @abstract
 *
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class Dataset {
    /**
     * @param {import("./Map.js").Map} map The map.
     * @param {string} url The URL of the dataset.
     * @param {number} resolution The dataset resolution, in the CRS geographical unit.
     * @param {{preprocess?:function(Cell):boolean, mixedResolution?:function(Cell):number}} opts
     * @abstract
     */
    constructor(map, url, resolution, opts = {}) {
        /**
         * The map.
         * @protected
         * @type {import("./Map.js").Map} */
        this.map = map

        /**
         * The url of the dataset.
         * @protected
         * @type {string} */
        this.url = url

        /**
         * The dataset resolution in geographical unit.
         * @protected
         * @type {number} */
        this.resolution = resolution

        /**
         * In case the dataset is a dataset with cells having different resolution,
         * this is the function returning the resolution of each cell.
         * @protected
         * @type {(function(Cell):number )| undefined } */
        this.mixedResolution = opts.mixedResolution

        /**
         * A preprocess to run on each cell after loading. It can be used to apply some specific treatment before or compute a new column. And also to determine which cells to keep after loading.
         * @type {(function(Cell):boolean )| undefined } */
        this.preprocess = opts.preprocess || undefined

        /** The cells within the view
         * @protected
         * @type {Array.<Cell>} */
        this.cellsViewCache = []
    }

    /**
     * Request data within a geographic envelope.
     *
     * @abstract
     * @param {import("./GeoCanvas").Envelope|undefined} extGeo
     * @returns {this}
     */
    getData(extGeo = undefined) {
        throw new Error('Method getData not implemented.')
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     * @abstract
     * @param {import("./GeoCanvas").Envelope} extGeo The view geographical envelope.
     * @returns {void}
     */
    updateViewCache(extGeo) {
        throw new Error('Method updateViewCache not implemented.')
    }

    /**
     * Get a cell under a given position, if any.
     *
     * @param {{x:number,y:number}} posGeo
     * @param {Array.<Cell>} cells Some cells from the dataset (a subset if necessary, usually the view cache).
     * @returns {Cell|undefined}
     */
    getCellFromPosition(posGeo, cells) {
        //compute candidate cell position
        /** @type {number} */
        //const r = this.getResolution()
        /** @type {number} */
        //const cellX = r * Math.floor(posGeo.x / r)
        /** @type {number} */
        //const cellY = r * Math.floor(posGeo.y / r)

        /*/get cell
        for (const cell of cells) {
            if (cell.x != cellX) continue
            if (cell.y != cellY) continue
            return cell
        }
        return undefined*/

        //rare case of mixed resolution dataset
        if (this.mixedResolution) {
            for (const c of cells) {
                /** @type {number} */
                const r = +this.mixedResolution(c)
                if (posGeo.x < c.x) continue
                else if (c.x + r < posGeo.x) continue
                else if (posGeo.y < c.y) continue
                else if (c.y + r < posGeo.y) continue
                else return c
            }
            return undefined
        }

        //common case

        /** @type {number} */
        const r = this.getResolution()
        for (const cell of cells) {
            if (posGeo.x < cell.x) continue
            else if (cell.x + r < posGeo.x) continue
            else if (posGeo.y < cell.y) continue
            else if (cell.y + r < posGeo.y) continue
            else return cell
        }
        return undefined
    }

    //getters and setters

    /** @returns {number} */
    getResolution() {
        return this.resolution
    }

    /** @returns {Array.<Cell>} */
    getViewCache() {
        return this.cellsViewCache
    }

    /**
     * Return the relevant dataset for a specified zoom.
     * @param {number} z
     * @param {number} minPixelsPerCell
     * @returns {Dataset|undefined}
     * */
    getDataset(z, minPixelsPerCell) {
        return this
    }
}


/***/ }),

/***/ "./src/core/Drawable.js":
/*!******************************!*\
  !*** ./src/core/Drawable.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Drawable: () => (/* binding */ Drawable)
/* harmony export */ });
//@ts-check


/**
 * This is an abstract class used to group elements shared between Layer and Style classes.
 *
 * @abstract
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class Drawable {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** A function specifying if the element should be visible or not.
         * The function parameter is the zoom level.
         * @type {function(number):boolean} */
        this.visible = opts.visible

        /** A function returning the alpha (transparency/opacity), between 0.0 (fully transparent) and 1.0 (fully opaque).
         *  The function parameter is the zoom level.
         * (see CanvasRenderingContext2D: globalAlpha property)
         * @type {(function(number):number)|undefined} */
        this.alpha = opts.alpha

        /** A function returning the blend operation.
         * The function parameter is the zoom level.
         * (see CanvasRenderingContext2D: globalCompositeOperation property)
         * @type {function(number):GlobalCompositeOperation} */
        this.blendOperation = opts.blendOperation || ((z) => 'source-over')

        /** @type {(function(number):string)|undefined} */
        this.filterColor = opts.filterColor // (z) => "#eee7"
        /** @type {(function(number):GlobalCompositeOperation|"none")|undefined} */
        this.filterBlendOperation = opts.filterBlendOperation // (z) => "multiply"
    }

    /**
     * Draw layer filter.
     *
     * @param {import("./GeoCanvas.js").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @returns {void}
     * @abstract
     */
    drawFilter(geoCanvas) {
        //no filter: return
        if (!this.filterColor) return

        //get filter
        const fc = this.filterColor(geoCanvas.view.z)

        //no filter: return
        if (!fc || fc == 'none') return

        //draw filter

        //set color
        geoCanvas.offscreenCtx.fillStyle = fc

        //save blend mode and set new, if any
        let bo = undefined, bo2 = undefined
        if (this.filterBlendOperation) {
            bo = geoCanvas.offscreenCtx.globalCompositeOperation
            bo2 = this.filterBlendOperation(geoCanvas.view.z)
        }
        if (bo2 && bo2 != "none") geoCanvas.offscreenCtx.globalCompositeOperation = bo2;

        //draw
        geoCanvas.offscreenCtx.fillRect(0, 0, geoCanvas.w, geoCanvas.h)

        //restore blend mode
        if (bo) geoCanvas.offscreenCtx.globalCompositeOperation = bo;

    }
}


/***/ }),

/***/ "./src/core/GeoCanvas.js":
/*!*******************************!*\
  !*** ./src/core/GeoCanvas.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeoCanvas: () => (/* binding */ GeoCanvas)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
//@ts-check


/** @typedef { {xMin: number, xMax: number, yMin: number, yMax: number} } Envelope */

/**
 * A viewshed.
 * @typedef {{x: number, y: number, z: number}} View */

;


/**
 * A HTML canvas for geo data display, enhanced with zoom and pan capabilities.
 *
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class GeoCanvas {
    /**
     * @constructor
     * @param {HTMLCanvasElement} canvas
     * @param {number} x The x coordinate of the view
     * @param {number} y The y coordinate of the view
     * @param {number} z The zoom level of the view (pixel size, in ground m)
     * @param {object} opts
     */
    constructor(canvas, x = 0, y = 0, z = 0, opts = undefined) {
        this.opts = opts || {}

        /** @type {HTMLCanvasElement} */
        this.canvas = canvas

        /** @type {number} */
        this.w = this.canvas.offsetWidth
        /** @type {number} */
        this.h = this.canvas.offsetHeight

        // Adjust canvas width and height based on device pixel ratio
        //const dpr = window.devicePixelRatio || 1 // Get the device pixel ratio
        //this.canvas.width = this.w * dpr // Set canvas width
        //\sthis.canvas.height = this.h * dpr // Set canvas height

        // Create offscreen canvas for drawing operations
        this.offscreenCanvas = document.createElement('canvas')
        this.offscreenCanvas.width = this.w
        this.offscreenCanvas.height = this.h

        const ctx = this.canvas.getContext('2d')
        const offscreenCtx = this.offscreenCanvas.getContext('2d')
        if (!ctx) throw 'Impossible to create canvas 2D context'
        if (!offscreenCtx) throw 'Impossible to create canvas 2D context'
        /**@type {CanvasRenderingContext2D} */
        this.ctx = ctx
        this.offscreenCtx = offscreenCtx
        //this.ctx.scale(dpr, dpr) // Scale the context

        /**
         * z: pixel size, in m/pix
         * @type {View}  */
        this.view = { x: x, y: y, z: z }

        /** Background color.
         * @type {string} */
        this.backgroundColor = opts.backgroundColor || 'white'

        /** @type {function(object|undefined):void} */
        this.onZoomStartFun = opts.onZoomStartFun

        /** @type {function(object|undefined):void} */
        this.onZoomEndFun = opts.onZoomEndFun

        /** @type {function(object|undefined):void} */
        this.onZoomFun = opts.onZoomFun

        //current extent
        /** @type {Envelope} */
        this.extGeo = { xMin: NaN, xMax: NaN, yMin: NaN, yMax: NaN }
        this.updateExtentGeo()

        //rely on d3 for zoom
        if (!opts.disableZoom) {
            let tP = d3_zoom__WEBPACK_IMPORTED_MODULE_1__.zoomIdentity
            // @ts-ignore
            let debounceTimeout = null // Add a debounce timeout variable
            const z = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_1__.zoom)()
                // to make the zooming a bit faster
                .wheelDelta((e) => -e.deltaY * (e.deltaMode === 1 ? 0.07 : e.deltaMode ? 1 : 0.004))
                .on('zoom', (e) => {
                    const t = e.transform
                    const zoomFactor = tP.k / t.k
                    if (zoomFactor == 1) {
                        //pan
                        const dx = tP.x - t.x
                        const dy = tP.y - t.y
                        this.pan(dx * this.view.z, -dy * this.view.z)
                    } else {
                        handleZoom(e, zoomFactor)
                    }
                    tP = t

                    if (this.onZoomFun) this.onZoomFun(e)
                })
                .on('start', (e) => {
                    // start of zoom event
                    // save the current canvas state to keep onscreen during pan/zoom before redrawing
                    this.canvasSave.c = document.createElement('canvas')
                    this.canvasSave.c.setAttribute('width', '' + this.w)
                    this.canvasSave.c.setAttribute('height', '' + this.h)
                    this.canvasSave.c.getContext('2d')?.drawImage(this.canvas, 0, 0)
                    this.canvasSave.dx = 0
                    this.canvasSave.dy = 0
                    this.canvasSave.f = 1
                    if (this.onZoomStartFun) this.onZoomStartFun(e)
                })
                .on('end', (e) => {
                    // end of pan/zoom event
                    this.redraw()
                    this.canvasSave = { c: null, dx: 0, dy: 0, f: 1 }

                    if (this.onZoomEndFun) this.onZoomEndFun(e)
                })
            // @ts-ignore
            z((0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this.canvas))

            const handleZoom = (event, zoomFactor) => {
                // cancel ongoing data requests
                this.cancelCurrentRequests()
                const se = event.sourceEvent

                if (se instanceof WheelEvent) {
                    //zoom at the mouse position
                    this.zoom(
                        zoomFactor,
                        // @ts-ignore
                        this.pixToGeoX(se.offsetX),
                        // @ts-ignore
                        this.pixToGeoY(se.offsetY)
                    )
                } else if (se instanceof TouchEvent) {
                    //compute average position of the touches
                    let tx = 0,
                        ty = 0
                    for (let tt of se.targetTouches) {
                        tx += tt.clientX
                        ty += tt.clientY
                    }
                    tx /= se.targetTouches.length
                    ty /= se.targetTouches.length

                    // Adjust for container's offset
                    // tx -= containerRect.left
                    // ty -= containerRect.top

                    //zoom at this average position
                    this.zoom(zoomFactor, this.pixToGeoX(tx), this.pixToGeoY(ty))
                }
            }
        }

        //center extent
        /** @type {number|undefined} */
        this.xMin = opts.centerExtent ? opts.centerExtent[0] : undefined
        /** @type {number|undefined} */
        this.yMin = opts.centerExtent ? opts.centerExtent[1] : undefined
        /** @type {number|undefined} */
        this.xMax = opts.centerExtent ? opts.centerExtent[2] : undefined
        /** @type {number|undefined} */
        this.yMax = opts.centerExtent ? opts.centerExtent[3] : undefined

        /** Zoom extent, to limit zoom in and out
         *  @type {Array.<number>} */
        this.zoomExtent = opts.zoomExtent || [0, Infinity]

        /** Canvas state, to be used to avoid unnecessary redraws on zoom/pan
         *  @type {{c:HTMLCanvasElement|null,dx:number,dy:number,f:number}} */
        this.canvasSave = { c: null, dx: 0, dy: 0, f: 1 }
    }

    /** @returns {View} */
    getView() {
        return this.view
    }

    /** @param {Array.<number>} v */
    setCenterExtent(v) {
        this.xMin = v[0]
        this.yMin = v[1]
        this.xMax = v[2]
        this.yMax = v[3]
    }
    /** @returns {Array.<number|undefined>} */
    getCenterExtent() {
        return [this.xMin, this.yMin, this.xMax, this.yMax]
    }

    /** @param {Array.<number>} v */
    setZoomExtent(v) {
        this.zoomExtent = v
    }
    /** @returns {Array.<number>} */
    getZoomExtent() {
        return this.zoomExtent
    }

    /** Initialise canvas transform with identity transformation. */
    initCanvasTransform() {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0)
        this.offscreenCtx.setTransform(1, 0, 0, 1, 0, 0)
    }

    /** Initialise canvas transform with geo to screen transformation, so that geo objects can be drawn directly in geo coordinates. */
    setCanvasTransform() {
        const k = 1 / this.view.z
        const tx = -this.view.x / this.view.z + this.w * 0.5
        const ty = this.view.y / this.view.z + this.h * 0.5
        this.ctx.setTransform(k, 0, 0, -k, tx, ty)
        this.offscreenCtx.setTransform(k, 0, 0, -k, tx, ty)
    }

    /** Get the transformation matrix to webGL screen coordinates, within [-1,1]*[-1,1] */
    getWebGLTransform() {
        const kx = 2.0 / (this.w * this.view.z)
        const ky = 2.0 / (this.h * this.view.z)
        return [kx, 0.0, 0.0, 0.0, ky, 0.0, -kx * this.view.x, -ky * this.view.y, 1.0]
    }

    /** The function specifying how to draw the map. */
    redraw() {
        throw new Error('Method redraw not implemented.')
    }

    /** When the zoom level changes, ensures that any ongoing requests are aborted before new ones are initiated. */
    cancelCurrentRequests() {
        throw new Error('Method cancelCurrentRequests not implemented.')
    }

    /**
     * Clear. To be used before a redraw for example.
     * @param {string} color
     */
    clear(color = 'white') {
        if (this.opts.transparentBackground) {
            this.ctx.clearRect(0, 0, this.w, this.h)
            this.offscreenCtx.clearRect(0, 0, this.w, this.h)
        } else {
            if (this.ctx) this.ctx.fillStyle = color
            if (this.offscreenCtx) this.offscreenCtx.fillStyle = color
            this.ctx.fillRect(0, 0, this.w, this.h)
            this.offscreenCtx.fillRect(0, 0, this.w, this.h)
        }
    }

    /**
     * @param {number} dxGeo
     * @param {number} dyGeo
     */
    pan(dxGeo = 0, dyGeo = 0) {
        //ensures x/y extent
        if (this.xMin != undefined && this.view.x + dxGeo < this.xMin) dxGeo = this.xMin - this.view.x
        if (this.yMin != undefined && this.view.y + dyGeo < this.yMin) dyGeo = this.yMin - this.view.y
        if (this.xMax != undefined && this.view.x + dxGeo > this.xMax) dxGeo = this.xMax - this.view.x
        if (this.yMax != undefined && this.view.y + dyGeo > this.yMax) dyGeo = this.yMax - this.view.y

        //pan
        this.view.x += dxGeo
        this.view.y += dyGeo
        this.updateExtentGeo()

        if (this.canvasSave.c) {
            const scale = 1 / this.view.z

            // Update saved canvas offset
            this.canvasSave.dx -= dxGeo * scale
            this.canvasSave.dy += dyGeo * scale

            // clear canvas
            this.clear(this.backgroundColor)

            // this doesnt work on mobile https://github.com/eurostat/gridviz/issues/98
            //this.ctx.drawImage(this.canvasSave.c, this.canvasSave.dx, this.canvasSave.dy)
            this.offscreenCtx.drawImage(this.canvasSave.c, this.canvasSave.dx, this.canvasSave.dy)

            // Render the offscreen canvas to the visible context
            this.ctx.drawImage(this.offscreenCtx.canvas, 0, 0)
        } else {
            console.log('no canvas save')
        }
    }

    /**
     * Zoom.
     * @param {number} f The zoom factor, within ]0, Infinity]. 1 is for no change. <1 to zoom-in, >1 to zoom-out.
     * @param {number} xGeo The x geo position fixed in the screen.
     * @param {number} yGeo The y geo position fixed in the screen.
     */
    zoom(f = 1, xGeo = this.view.x, yGeo = this.view.y) {
        //TODO force geo extend to remain

        //trying to zoom in/out beyond limit
        if (this.zoomExtent[0] == this.view.z && f <= 1) return
        if (this.zoomExtent[1] == this.view.z && f >= 1) return

        //ensure zoom extent preserved
        const newZf = f * this.view.z
        if (newZf < this.zoomExtent[0]) f = this.zoomExtent[0] / this.view.z
        if (newZf > this.zoomExtent[1]) f = this.zoomExtent[1] / this.view.z

        this.view.z *= f

        //compute pan
        let dxGeo = (xGeo - this.view.x) * (1 - f)
        let dyGeo = (yGeo - this.view.y) * (1 - f)

        //ensures x/y extent
        if (this.xMin != undefined && this.view.x + dxGeo < this.xMin) dxGeo = this.xMin - this.view.x
        if (this.yMin != undefined && this.view.y + dyGeo < this.yMin) dyGeo = this.yMin - this.view.y
        if (this.xMax != undefined && this.view.x + dxGeo > this.xMax) dxGeo = this.xMax - this.view.x
        if (this.yMax != undefined && this.view.y + dyGeo > this.yMax) dyGeo = this.yMax - this.view.y

        //pan
        this.view.x += dxGeo
        this.view.y += dyGeo
        this.updateExtentGeo()

        // zoom in on the current canvas state
        if (this.canvasSave.c) {
            this.clear(this.backgroundColor)
            this.canvasSave.f /= f
            this.canvasSave.dx = this.geoToPixX(xGeo) * (1 - this.canvasSave.f)
            this.canvasSave.dy = this.geoToPixY(yGeo) * (1 - this.canvasSave.f)
            this.clear(this.backgroundColor)
            this.offscreenCtx.drawImage(
                this.canvasSave.c,
                this.canvasSave.dx,
                this.canvasSave.dy,
                this.canvasSave.f * this.canvasSave.c.width,
                this.canvasSave.f * this.canvasSave.c.height
            )
            this.ctx.drawImage(
                this.offscreenCanvas, // Use offscreen canvas as the source
                0,
                0, // Position the offscreen canvas at the top-left corner of the main canvas
                this.canvas.width, // The width of the visible canvas
                this.canvas.height // The height of the visible canvas
            )
        }
    }

    /**
     * @param {number} marginPx
     * @returns {Envelope} The envelope of the view, in geo coordinates.
     */
    updateExtentGeo(marginPx = 20) {
        this.extGeo = {
            xMin: this.pixToGeoX(-marginPx),
            xMax: this.pixToGeoX(this.w + marginPx),
            yMin: this.pixToGeoY(this.h + marginPx),
            yMax: this.pixToGeoY(-marginPx),
        }
        return this.extGeo
    }

    /**
     * Check if the object has to be drawn
     *
     * @param {{x:number,y:number}} obj
     */
    toDraw(obj) {
        if (obj.x < this.extGeo.xMin) return false
        if (obj.x > this.extGeo.xMax) return false
        if (obj.y < this.extGeo.yMin) return false
        if (obj.y > this.extGeo.yMax) return false
        return true
    }

    //conversion functions
    /**
     * @param {number} xGeo Geo x coordinate, in m.
     * @returns {number} Screen x coordinate, in pix.
     */
    geoToPixX(xGeo) {
        return (xGeo - this.view.x) / this.view.z + this.w * 0.5
    }
    /**
     * @param {number} yGeo Geo y coordinate, in m.
     * @returns {number} Screen y coordinate, in pix.
     */
    geoToPixY(yGeo) {
        return -(yGeo - this.view.y) / this.view.z + this.h * 0.5
    }
    /**
     * @param {number} x Screen x coordinate, in pix.
     * @returns {number} Geo x coordinate, in m.
     */
    pixToGeoX(x) {
        return (x - this.w * 0.5) * this.view.z + this.view.x
    }
    /**
     * @param {number} y Screen y coordinate, in pix.
     * @returns {number} Geo y coordinate, in m.
     */
    pixToGeoY(y) {
        return -(y - this.h * 0.5) * this.view.z + this.view.y
    }

    /** Get x,y,z elements from URL and assign them to the view. */
    setViewFromURL() {
        const x = GeoCanvas.getParameterByName('x'),
            y = GeoCanvas.getParameterByName('y'),
            z = GeoCanvas.getParameterByName('z')
        if (x != null && x != undefined && !isNaN(+x)) this.view.x = +x
        if (y != null && y != undefined && !isNaN(+y)) this.view.y = +y
        if (z != null && z != undefined && !isNaN(+z)) this.view.z = +z
    }

    /**
     * Get a URL parameter by name.
     *
     * @param {string} name
     * @returns {string | null}
     */
    static getParameterByName(name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]')
        var regex = new RegExp('[\\?&]' + name + '=([^&#]*)'),
            results = regex.exec(location.search)
        return !results ? null : decodeURIComponent(results[1].replace(/\+/g, ' '))
    }
}


/***/ }),

/***/ "./src/core/Layer.js":
/*!***************************!*\
  !*** ./src/core/Layer.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Layer: () => (/* binding */ Layer)
/* harmony export */ });
/* harmony import */ var _Drawable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Drawable.js */ "./src/core/Drawable.js");
//@ts-check


;

/**
 * @module core
 * @abstract
 * @author Joseph Davies, Julien Gaffuri
 */
class Layer extends _Drawable_js__WEBPACK_IMPORTED_MODULE_0__.Drawable {
    /**
     * Draw layer.
     *
     * @param {import("./GeoCanvas").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @param {object} legend
     * @returns {void}
     * @abstract
     */
    draw(geoCanvas, legend = undefined) {
        throw new Error('Method draw not implemented.')
    }
}


/***/ }),

/***/ "./src/core/Legend.js":
/*!****************************!*\
  !*** ./src/core/Legend.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Legend: () => (/* binding */ Legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
//@ts-check


;

/**
 * A legend container.
 *
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class Legend {
    /**
     * @param {Object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** @type {string} */
        this.id = opts.id

        //TODO stop using it. Use style method below instead.

        /** @type {number} @deprecated */
        this.top = opts.top
        /** @type {number} @deprecated */
        this.bottom = opts.bottom
        /** @type {number} @deprecated */
        this.left = opts.left
        /** @type {number} @deprecated */
        this.right = opts.right
        /** @type {string} @deprecated */
        this.background = opts.background || 'none'
        /** @type {string} @deprecated */
        this.padding = opts.padding || '5px'
        /** @type {string} @deprecated */
        this.border = opts.border || '0px'
        /** @type {string} @deprecated */
        this['border-radius'] = opts['border-radius'] || 'none'
        /** @type {string} @deprecated */
        this['box-shadow'] = opts['box-shadow'] || 'none'
        /** @type {string} @deprecated */
        this['font-family'] = opts['font-family'] || 'Helvetica, Arial, sans-serif'
        /** @type {string} @deprecated */
        //this.width = opts.width
        /** @type {string} @deprecated */
        //this.height = opts.height

        //the div element
        if (this.id) this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + this.id)

        if (!this.div || this.div.empty()) {
            this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(document.createElement('div'))
            if (this.id) this.div.attr('id', this.id)
        }

        //set style
        this.div.style('background', this.background)
        this.div.style('padding', this.padding)
        this.div.style('border', this.border)
        this.div.style('border-radius', this['border-radius'])
        this.div.style('box-shadow', this['box-shadow'])
        this.div.style('font-family', this['font-family'])

        //if (this.width) this.div.style('width', this.width)
        //if (this.height) this.div.style('height', this.height)

        //title
        this.title = opts.title
        this.titleFontSize = opts.titleFontSize || '0.8em'
        this.titleFontWeight = opts.titleFontWeight || 'bold'

        //label
        this.labelFontSize = opts.labelFontSize || '0.8em'
        this.labelUnitText = opts.labelUnitText || ''
        this.labelFormat = opts.labelFormat
    }

    makeTitle() {
        if (!this.title) return
        this.div
            .append('div')
            .style('font-size', this.titleFontSize)
            .style('font-weight', this.titleFontWeight)
            .style('margin-bottom', '7px')
            .text(this.title)
    }

    /**
     * Apply a style to the legend div.
     * @param {string} k
     * @param {string} v
     * @returns {this|string}
     */
    style(k, v) {
        if (arguments.length == 1) return this.div.style(k)
        this.div.style(k, v)
        return this
    }

    /**
     * @param {Object} opts
     * @abstract
     */
    update(opts = {}) {
        console.error('Legend update not implemented yet.')
    }
}


/***/ }),

/***/ "./src/core/Map.js":
/*!*************************!*\
  !*** ./src/core/Map.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Map: () => (/* binding */ Map)
/* harmony export */ });
/* harmony import */ var _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GeoCanvas.js */ "./src/core/GeoCanvas.js");
/* harmony import */ var _Tooltip_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Tooltip.js */ "./src/core/Tooltip.js");
/* harmony import */ var _button_ZoomButtons_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../button/ZoomButtons.js */ "./src/button/ZoomButtons.js");
/* harmony import */ var _button_FullscreenButton_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../button/FullscreenButton.js */ "./src/button/FullscreenButton.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
//@ts-check


// internal imports
;




// external imports


/**
 * A gridviz application.
 *
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class Map {
    /**
     * @param {HTMLDivElement} container
     * @param {object} opts
     */
    constructor(container, opts) {
        opts = opts || {}

        /**
         * The layers.
         * @type {Array.<import("./Layer.js").Layer>}
         * */
        this.layers = opts.layers || []

        //get container element
        this.container = container || document.getElementById('gridviz')
        if (!this.container) {
            console.error('Cannot find gridviz container element.')
            return
        }

        //https://css-tricks.com/absolute-positioning-inside-relative-positioning/
        this.container.style.position = 'relative' // container element must have relative positioning

        //set dimensions
        /** @type {number} */
        this.w = opts.w || this.container.offsetWidth
        /** @type {number} */
        this.h = opts.h || this.container.offsetHeight

        // Create the main canvas (for rendering to screen)
        /** @type {HTMLCanvasElement} */
        this._canvas = opts.canvas || this.initialiseCanvas()

        /**  Initialize GeoCanvas
         * @type {GeoCanvas}
         * @private */
        this.geoCanvas = new _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_0__.GeoCanvas(this._canvas, opts.x, opts.y, opts.z, opts)

        this.geoCanvas.redraw = () => {
            this.redraw()
        }
        this.geoCanvas.cancelCurrentRequests = () => {
            // when the zoom level changes, avoid drawing outdated tiles, and ensure that requests are properly aborted when necessary
            for (const layer of this.layers) {
                //multires
                if (layer.dataset?.datasets) {
                    for (const dataset of layer.dataset?.datasets) {
                        if (dataset?.cancelCurrentRequests) dataset.cancelCurrentRequests()
                    }
                }
                //single res
                if (layer.dataset?.cancelCurrentRequests) layer.dataset?.cancelCurrentRequests()
            }
        }

        // legend div
        this.legend = opts.legendContainer
            ? (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(opts.legendContainer) // Wrap the provided HTML node in a D3 selection
            : null
        if (!this.legend) this.initialiseLegend()

        //tooltip

        // set App container as default parent element for tooltip
        if (!opts.tooltip) opts.tooltip = {}
        if (!opts.tooltip.parentElement) opts.tooltip.parentElement = this.container

        /**
         * @private
         * @type {Tooltip} */
        this.tooltip = new _Tooltip_js__WEBPACK_IMPORTED_MODULE_1__.Tooltip(opts.tooltip)

        // add event listeners to container
        this.mouseOverHandler = (e) => this.focusCell(e)
        this.mouseMoveHandler = (e) => this.focusCell(e)
        this.mouseOutHandler = (e) => this.tooltip.hide()
        this.geoCanvas.canvas.addEventListener('mouseover', this.mouseOverHandler)
        this.geoCanvas.canvas.addEventListener('mousemove', this.mouseMoveHandler)
        this.geoCanvas.canvas.addEventListener('mouseout', this.mouseOutHandler)

        // listen for resize events on the App's container and handle them
        this.defineResizeObserver()

        // add extra logic to onZoomStartFun
        this.geoCanvas.onZoomStartFun = (e) => {
            if (opts.onZoomStartFun) opts.onZoomStartFun(e)
            this.tooltip.hide()
        }

        //for mouse over
        /**
         * @private
         * @type {HTMLCanvasElement|null} */
        this.canvasSave = null

        this.selectionRectangleColor = opts.selectionRectangleColor || '#FF6347'
        this.selectionRectangleWidthPix = opts.selectionRectangleWidthPix || (() => 4) //(r,z) => {}

        // transparent background (e.g. leaflet) 'red painting' fix
        this.transparentBackground = opts.transparentBackground

        //set default globalCompositeOperation
        this.defaultGlobalCompositeOperation =
            opts.defaultGlobalCompositeOperation || this.geoCanvas.ctx.globalCompositeOperation
    }

    /**
     * @protected
     * @returns {HTMLCanvasElement}
     */
    initialiseCanvas() {
        const canvas = document.createElement('canvas')
        canvas.setAttribute('width', '' + this.w)
        canvas.setAttribute('height', '' + this.h)
        this.container.appendChild(canvas)
        return canvas
    }

    initialiseLegend() {
        this.legend = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(this.container)
            .append('div') // Create a new container
            .attr('id', 'gridviz-legend')
            .style('position', 'absolute')
            .style('width', 'auto')
            .style('height', 'auto')
            .style('background', '#FFFFFF')
            //.style("padding", this.padding)
            .style('border', '0px')
            //.style('border-radius', '5px')
            .style('box-shadow', '3px 3px 3px grey, -3px -3px 3px #ddd')
            .style('font-family', 'Helvetica, Arial, sans-serif')
            .style('bottom', '15px')
            .style('right', '15px')
        //hide
        //.style("visibility", "hidden")
    }

    /**
     * Set/get layer stack.
     *
     * @param {undefined|import("./Layer.js").Layer|import("./Layer.js").Layer[]} layers
     * @returns { this | import("./Layer.js").Layer[] }
     */
    layers_(layers) {
        if (arguments.length === 0) return this.layers
        if (arguments.length === 1)
            if (Array.isArray(layers)) this.layers = layers
            else this.layers = [layers]
        else this.layers = arguments
        return this
    }

    /** @returns {this} */
    redraw() {
        //remove legend elements
        if (this.legend) this.legend.selectAll('*').remove()

        //clear
        this.geoCanvas.initCanvasTransform()
        this.geoCanvas.clear(this.geoCanvas.backgroundColor)

        const z = this.geoCanvas.view.z
        this.updateExtentGeo()

        //go through the layers
        for (const layer of this.layers) {
            //check if layer is visible
            if (layer.visible && !layer.visible(z)) continue

            //set layer alpha and blend mode
            this.geoCanvas.offscreenCtx.globalAlpha = layer.alpha ? layer.alpha(z) : 1.0
            if (layer.blendOperation) this.geoCanvas.offscreenCtx.globalCompositeOperation = layer.blendOperation(z)

            //set affin transform to draw with geographical coordinates
            this.geoCanvas.setCanvasTransform()

            //draw layer
            layer.draw(this.geoCanvas, this.legend)

            //draw layer filter
            if (layer.filterColor) layer.drawFilter(this.geoCanvas)

            //restore default alpha and blend operation
            this.geoCanvas.offscreenCtx.globalAlpha = 1.0
            this.geoCanvas.offscreenCtx.globalCompositeOperation = this.defaultGlobalCompositeOperation
        }

        // one drawImage call: draw the offscreen canvas to the main canvas
        this.geoCanvas.initCanvasTransform()
        this.geoCanvas.ctx.drawImage(this.geoCanvas.offscreenCanvas, 0, 0)

        this.canvasSave = null

        return this
    }

    /**
     * @param {number} marginPx
     * @returns {import('./GeoCanvas.js').Envelope}
     * @public
     */
    updateExtentGeo(marginPx = 20) {
        return this.geoCanvas.updateExtentGeo(marginPx)
    }

    /** @param {MouseEvent} e */
    focusCell(e) {
        //compute mouse geo position
        const mousePositionGeo = {
            x: this.geoCanvas.pixToGeoX(e.offsetX + this.tooltip.xMouseOffset),
            y: this.geoCanvas.pixToGeoY(e.offsetY + this.tooltip.yMouseOffset),
        }
        /** @type {{cell:import('./Dataset.js').Cell,html:string,resolution:number} | undefined} */
        const focus = this.getCellFocusInfo(mousePositionGeo)

        // Transparent background (Leaflet): redraw base, then draw focus rect directly on the visible canvas
        if (this.transparentBackground) {
            // Always restore the base (offscreen) into the visible canvas
            this.geoCanvas.initCanvasTransform();
            this.geoCanvas.ctx.clearRect(0, 0, this.w, this.h);
            this.geoCanvas.ctx.drawImage(this.geoCanvas.offscreenCanvas, 0, 0);

            if (focus) {
                this.tooltip.html(focus.html);
                this.tooltip.setPosition(e);
                this.tooltip.show();

                const rectWPix = this.selectionRectangleWidthPix
                    ? this.selectionRectangleWidthPix(focus.resolution, this.geoCanvas.view.z)
                    : 4;

                const ctx = this.geoCanvas.ctx; // draw directly on visible canvas
                ctx.save();
                ctx.strokeStyle = this.selectionRectangleColor;
                ctx.lineWidth = rectWPix;
                ctx.beginPath();
                // compute in pixel space (no geo transform on ctx)
                const xPix = this.geoCanvas.geoToPixX(focus.cell.x);
                const yPix = this.geoCanvas.geoToPixY(focus.cell.y);
                const wPix = focus.resolution / this.geoCanvas.view.z;
                const hPix = -wPix; // y axis inverted in geoToPix
                ctx.rect(
                    xPix - rectWPix / 2,
                    yPix + rectWPix / 2,
                    wPix + rectWPix,
                    hPix - rectWPix
                );
                ctx.stroke();
                ctx.restore();
            } else {
                this.tooltip.hide();
            }
            return; // handled
        }

        if (focus) {
            this.tooltip.html(focus.html)
            this.tooltip.setPosition(e)
            this.tooltip.show()

            //show cell position as a rectangle
            if (!this.canvasSave) {
                this.canvasSave = document.createElement('canvas')
                this.canvasSave.setAttribute('width', '' + this.w)
                this.canvasSave.setAttribute('height', '' + this.h)
                this.canvasSave.getContext('2d')?.drawImage(this.geoCanvas.offscreenCanvas, 0, 0)
            } else {
                this.geoCanvas.offscreenCtx.drawImage(this.canvasSave, 0, 0)
            }

            //draw image saved + draw rectangle
            const rectWPix = this.selectionRectangleWidthPix
                ? this.selectionRectangleWidthPix(focus.resolution, this.geoCanvas.view.z)
                : 4
            this.geoCanvas.initCanvasTransform()
            const ctx = this.geoCanvas.offscreenCtx
            ctx.strokeStyle = this.selectionRectangleColor
            ctx.lineWidth = rectWPix
            ctx.beginPath()

            ctx.rect(
                this.geoCanvas.geoToPixX(focus.cell.x) - rectWPix / 2,
                this.geoCanvas.geoToPixY(focus.cell.y) + rectWPix / 2,
                focus.resolution / this.geoCanvas.view.z + rectWPix,
                -focus.resolution / this.geoCanvas.view.z - rectWPix
            )
            ctx.stroke()
            this.geoCanvas.ctx.drawImage(this.geoCanvas.offscreenCanvas, 0, 0)
        } else {
            this.tooltip.hide()
            if (this.canvasSave) this.geoCanvas.ctx.drawImage(this.canvasSave, 0, 0)
        }
    }

    /**
     * Return the cell HTML info at a given geo position.
     * This is usefull for user interactions, to show this info where the user clicks for example.
     *
     * @param {{x:number,y:number}} posGeo
     * @returns {{cell:import('./Dataset.js').Cell,html:string,resolution:number} | undefined}
     * @protected
     */
    getCellFocusInfo(posGeo) {
        //go through the layers, starting from top
        const z = this.geoCanvas.view.z
        for (let i = this.layers.length - 1; i >= 0; i--) {
            /** @type {import("./Layer.js").Layer} */
            const layer = this.layers[i]
            if (layer.visible && !layer.visible(z)) continue
            if (layer.cellInfoHTML === 'none') continue // this is necessary in order to not show tooltips for layers 'on top' (e.g. population circles on top of squares)
            if (!layer.cellInfoHTML) continue
            if (!layer.getDataset) continue
            const dsc = layer.getDataset(z)
            if (!dsc) continue

            //get cell at mouse position
            /** @type {import('./Dataset.js').Cell|undefined} */
            const cell = dsc.getCellFromPosition(posGeo, dsc.getViewCache())
            //console.log(cell, dsc.resolution)
            if (!cell) return undefined

            //rare case for a dataset with mixed resolutions
            if (dsc.mixedResolution) {
                const r = +dsc.mixedResolution(cell)
                const html = layer.cellInfoHTML(cell, r)
                if (!html) return undefined
                return { cell: cell, html: html, resolution: r }
            }

            const html = layer.cellInfoHTML(cell, dsc.getResolution())
            if (!html) return undefined
            return { cell: cell, html: html, resolution: dsc.getResolution() }
        }
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number|undefined} z
     */
    setView(x, y, z = undefined) {
        this.geoCanvas.view.x = x
        this.geoCanvas.view.y = y
        if (z != undefined) this.geoCanvas.view.z = z
        return this
    }

    /** @returns {import('./GeoCanvas.js').View} */
    getView() {
        return this.geoCanvas.view
    }

    /** @returns {number} */
    getZoom() {
        return this.geoCanvas.view.z
    }
    /** @param {number} z @returns {this} */
    setZoom(z) {
        this.geoCanvas.view.z = z
        return this
    }

    /** @returns {Array.<number|undefined>} */
    getCenterExtent() {
        return this.geoCanvas.getCenterExtent()
    }
    /** @param {Array.<number>} val @returns {this} */
    setCenterExtent(val) {
        this.geoCanvas.setCenterExtent(val)
        return this
    }

    /** @returns {Array.<number>} */
    getZoomExtent() {
        return this.geoCanvas.getZoomExtent()
    }
    /** @param {Array.<number>} val @returns {this} */
    setZoomExtent(val) {
        this.geoCanvas.setZoomExtent(val)
        return this
    }

    /** @returns {string} */
    getBackgroundColor() {
        return this.geoCanvas.backgroundColor
    }
    /** @param {string} val @returns {this} */
    setBackgroundColor(val) {
        this.geoCanvas.backgroundColor = val
        return this
    }

    /**
     * Adds a set of zoom buttons to the map
     *
     * @param {object} opts
     * @returns {this}
     */
    addZoomButtons(opts) {
        // * opts.id
        // * opts.onZoom - custom event handler function
        // * opts.x
        // * opts.y
        // * opts.delta - zoom delta applied on each click

        this.zoomButtons = new _button_ZoomButtons_js__WEBPACK_IMPORTED_MODULE_2__.ZoomButtons({
            map: this,
            id: opts?.id || 'gridviz-zoom-buttons-' + this.container.id,
            class: opts?.class,
            x: opts?.x,
            y: opts?.y,
            onZoom: opts?.onZoom,
            delta: opts?.delta || 0.2,
        })

        return this
    }

    /**
     * Adds a fullscreen toggle button to the app
     *
     * @param {object} opts
     * @returns {this}
     */
    addFullscreenButton(opts) {
        // * opts.map - the gridviz map
        // * opts.id
        // * opts.x
        // * opts.y

        this.fullscreenButton = new _button_FullscreenButton_js__WEBPACK_IMPORTED_MODULE_3__.FullscreenButton({
            map: this,
            id: opts?.id || 'gridviz-fullscreen-button',
            class: opts?.class,
            x: opts?.x,
            y: opts?.y,
        })

        return this
    }

    /** @returns {this} */
    setViewFromURL() {
        this.geoCanvas.setViewFromURL()
        return this
    }

    /**
     * @description Add a resize event observer to the Apps container and update the canvas accordingly
     * @memberof App
     */
    defineResizeObserver() {
        // Track whether the observer is currently processing a resize event
        let resizePending = false

        const resizeObserver = new ResizeObserver((entries) => {
            if (!Array.isArray(entries) || !entries.length) return

            let container = this.container

            // Ensure the container has valid dimensions
            if (container.clientWidth > 0 && container.clientHeight > 0) {
                if (!resizePending) {
                    resizePending = true // Prevent overlapping resize triggers

                    window.requestAnimationFrame(() => {
                        resizePending = false // Reset the flag after processing

                        // Check for size changes
                        if (this.h !== container.clientHeight || this.w !== container.clientWidth) {
                            this.h = container.clientHeight
                            this.w = container.clientWidth

                            // Update geoCanvas sizes
                            this.geoCanvas.h = this.h
                            this.geoCanvas.w = this.w
                            this.geoCanvas.canvas.setAttribute('width', String(this.w))
                            this.geoCanvas.canvas.setAttribute('height', String(this.h))
                            this.geoCanvas.offscreenCanvas.setAttribute('width', String(this.w))
                            this.geoCanvas.offscreenCanvas.setAttribute('height', String(this.h))

                            this.redraw()

                            // Optionally reposition UI elements
                            // if (this.zoomButtons) this.zoomButtons.node.style.left = this.w - 50 + 'px';
                            // if (this.fullscreenButton) this.fullscreenButton.node.style.left = this.w - 50 + 'px';
                        }
                    })
                }
            }
        })

        resizeObserver.observe(this.container)
    }

    /**
     * @description Destroy the map and it's event listeners
     * This should significantly reduce the memory used when creating and destroying gridviz map instances (for example in leaflet-gridviz)
     * @memberof App
     */
    destroy() {
        // clear layers
        this.layers = []
        this.bgLayers = []

        // remove event listeners from container
        this.container.removeEventListener('mouseover', this.mouseOverHandler)
        this.container.removeEventListener('mousemove', this.mouseMoveHandler)
        this.container.removeEventListener('mouseout', this.mouseOutHandler)

        // remove canvas
        this.geoCanvas.canvas.remove()

        // remove legend
        this.legend?.remove()

        // remove tooltip
        this.tooltip.tooltip?.remove()
    }
}


/***/ }),

/***/ "./src/core/MultiResolutionDataset.js":
/*!********************************************!*\
  !*** ./src/core/MultiResolutionDataset.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiResolutionDataset: () => (/* binding */ MultiResolutionDataset)
/* harmony export */ });
//@ts-check


/**
 * A multi resolution dataset of grid cells.
 * It consists of different {@link Dataset}s for each resolution.
 *
 * @abstract
 *
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class MultiResolutionDataset {
    /**
     * @param {Array.<number>} resolutions The resolutions of the datasets, in CRS geographical unit.
     * @param {Array.<import("./Dataset").Dataset>|function(number):import("./Dataset").Dataset} datasets The datasets list, one per resolution. Or a function that returns a dataset from a resolution value.
     * @param { {preprocess?:function(import("./Dataset").Cell):boolean} } opts Options. preprocess: A function to apply on each dataset cell to prepare its values. Can be used also to select cells to keep.
     */
    constructor(resolutions, datasets, opts = {}) {
        opts = opts || {}

        /** The resolutions of the datasets, in CRS geographical unit.
         * @type {Array.<number>} */
        this.resolutions = resolutions

        /** The datasets. If the list is not explictely defined, build it from the resolution list with the function
         * @type {Array.<import("./Dataset").Dataset>} */
        this.datasets = typeof datasets === 'function' ? this.resolutions.map(datasets) : datasets

        //there must be as many datasets as resolutions
        if (this.datasets.length > 1 && this.datasets.length != this.resolutions.length)
            throw new Error(
                'Uncompatible number of datasets and resolutions: ' +
                    this.datasets.length +
                    ' ' +
                    this.resolutions.length
            )

        //set dataset preprocesses if specified
        if (opts.preprocess) this.setPrepocesses(opts.preprocess)
    }

    /**
     * Return the relevant dataset for a specified zoom.
     * @param {number} z
     * @param {number} minPixelsPerCell
     * @returns {import("./Dataset").Dataset|undefined}
     * */
    getDataset(z, minPixelsPerCell) {
        //special case whith single dataset
        if (this.datasets.length == 1) return this.datasets[0]

        const rs = this.resolutions
        let i = 0
        let z_ = rs[i] / minPixelsPerCell
        while (z_ < z && i < rs.length) {
            i++
            z_ = rs[i] / minPixelsPerCell
        }
        //if (i == 0) return this.dataset.datasets[0];
        //return this.dataset.datasets[i - 1];
        if (i == rs.length) return this.datasets[rs.length - 1]
        return this.datasets[i]
    }

    /**
     * Set a preprocess function for all datasets.
     * This is a function applied on each cell after it has been loaded.
     *
     * @param {function(import("./Dataset").Cell):boolean} preprocess
     * @returns {this}
     */
    setPrepocesses(preprocess) {
        for (let ds of this.datasets) ds.preprocess = preprocess
        return this
    }

    /**
     * A function to ease the creation of multi resolution datasets.
     *
     * @param {Array.<number>} resolutions The resolutions of the datasets, in CRS geographical unit
     * @param {function(number):import("./Dataset").Dataset} resToDataset Function returning a dataset from a resolution
     * @param { {preprocess?:function(import("./Dataset").Cell):boolean} } opts Options. preprocess: A function to apply on each dataset cell to prepare its values
     * @returns {MultiResolutionDataset}
     */
    /*static make(resolutions, resToDataset, opts) {
        //make datasets
        const dsc = []
        for (const res of resolutions) dsc.push(resToDataset(res))
        //make multi resolution dataset
        return new MultiResolutionDataset(dsc, resolutions, opts)
    }*/
}


/***/ }),

/***/ "./src/core/Style.js":
/*!***************************!*\
  !*** ./src/core/Style.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Style: () => (/* binding */ Style)
/* harmony export */ });
/* harmony import */ var _Drawable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Drawable.js */ "./src/core/Drawable.js");
//@ts-check


;

/** @typedef {"square"|"circle"|"diamond"|"donut"|"triangle_up"|"triangle_down"|"triangle_left"|"triangle_right"|"none"} Shape */

/**
 * viewScale type
 * Returns an object from a list of cells,
 * @typedef {function(Array.<import('./Dataset.js').Cell>,number, number):*} ViewScale */

/**
 * A style, to show a grid dataset.
 *
 * @module core
 * @author Joseph Davies, Julien Gaffuri
 */
class Style extends _Drawable_js__WEBPACK_IMPORTED_MODULE_0__.Drawable {
    /**
     * @abstract
     * @param {{filter?:function(import('./Dataset').Cell):boolean, offset?:function(import('./Dataset').Cell, number, number):{dx:number,dy:number}, visible?:function(number):boolean,alpha?:function(number):number,blendOperation?:function(number):GlobalCompositeOperation,drawFun?:function,viewScale?:ViewScale}} opts
     */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * @type {ViewScale|undefined} */
        this.viewScale = opts.viewScale

        /** A filter function to apply to the cell list, to filter out some cells not to be drawn (such as for example the cells with value=0).
         * @protected
         * @type {(function(import('./Dataset').Cell):boolean) | undefined} */
        this.filter = opts.filter || undefined

        /** An offset. This is to alter the position of all symbols in a given direction. In geographical unit.
         * @protected
         * @type {function(import('./Dataset').Cell,number,number):{dx:number,dy:number}} */
        this.offset = opts.offset || ((c, r, z) => ({ dx: 0, dy: 0 }))

        /** A draw function for the style.
         * @type {function|undefined} */
        this.drawFun = opts.drawFun

        /**
         * @public
         * @type {Array.<import("./Legend").Legend>} */
        this.legends = []
    }

    /**
     * Draw cells.
     *
     * @param {Array.<import('./Dataset').Cell>} cells The cells to draw.
     * @param {import("./GeoCanvas").GeoCanvas} geoCanvas The canvas where to draw them.
     * @param {number} resolution Their resolution (in geographic unit)
     * @abstract
     */
    draw(cells, geoCanvas, resolution) {
        if (this.drawFun) this.drawFun(cells, geoCanvas, resolution)
        else throw new Error('Method draw not implemented.')
    }

    //getters and setters

    /** @returns {function(import('./Dataset').Cell,number,number):{dx:number,dy:number}} */
    getOffset() {
        return this.offset
    }
    /** @param {function(import('./Dataset').Cell,number,number):{dx:number,dy:number}} val @returns {this} */
    setOffset(val) {
        this.offset = val
        return this
    }

    /** Update legends of the style, if any
     * @param {object} opts
     * @returns {this} */
    updateLegends(opts) {
        Style.updateLegendsRecursive(this.legends, opts)
        return this
    }

    /** @private */
    static updateLegendsRecursive(lg, opts) {
        if (Array.isArray(lg)) for (const lg_ of lg) this.updateLegendsRecursive(lg_, opts)
        else lg.update(opts)
    }

    /**
     * @param {Array.<import("./Legend").Legend>} legends
     * @returns {this} */
    addLegends(legends) {
        for (let legend of legends) this.legends.push(legend)
        return this
    }
}


/***/ }),

/***/ "./src/core/Tooltip.js":
/*!*****************************!*\
  !*** ./src/core/Tooltip.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tooltip: () => (/* binding */ Tooltip)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
//@ts-check


;
//import { transition } from "d3-transition";

/**
 * A generic class to make a tooltip.
 * It is a div element, which can be moved under the mouse pointer and filled with some information in html.
 * @module core
 */
class Tooltip {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** @type {string} */
        this.maxWidth = opts.maxWidth || '20em'
        /** @type {string} */
        this.fontSize = opts.fontSize || '1.2em'
        /** @type {string} */
        this.background = opts.background || 'white'
        /** @type {string} */
        this.padding = opts.padding || '5px'
        /** @type {string} */
        this.border = opts.border || '0px'
        /** @type {string} */
        this['border-radius'] = opts['border-radius'] || '0px'
        /** @type {string} */
        this['box-shadow'] = opts['box-shadow'] || '5px 5px 5px grey'
        /** @type {string} */
        this['font-family'] = opts['font-family'] || 'Helvetica, Arial, sans-serif'

        /** @type {number} */
        this.transitionDuration = opts.transitionDuration || 100
        /** @type {number} */
        this.xOffset = opts.xOffset || 30
        /** @type {number} */
        this.yOffset = opts.yOffset || 20
        /** @type {number} */ // e.g. to prevent mouse cursor covering cell being highlighted
        this.yMouseOffset = opts.yMouseOffset || 0
        /** @type {number} */
        this.xMouseOffset = opts.xMouseOffset || 0
        /** @type {HTMLElement} */
        this.parentElement = opts.parentElement || document.body
        /** @type {HTMLElement} */
        this.tooltipElement = opts.tooltipElement || null

        /**
         * @public
         * @type {import("d3-selection").Selection} */
        this.tooltip = opts.tooltipElement
            ? (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(opts.tooltipElement) // Wrap the provided HTML node in a D3 selection
            : (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this.parentElement).append('div').attr('id', 'gridviz-tooltip').attr('class', 'gridviz-tooltip') // create default element

        //initialise
        this.tooltip.style('max-width', this.maxWidth)
        this.tooltip.style('overflow', 'hidden')
        this.tooltip.style('font-size', this.fontSize)
        this.tooltip.style('background', this.background)
        this.tooltip.style('padding', this.padding)
        this.tooltip.style('border', this.border)
        this.tooltip.style('border-radius', this['border-radius'])
        this.tooltip.style('box-shadow', this['box-shadow'])
        this.tooltip.style('font-family', this['font-family'])
        this.tooltip.style('position', 'absolute')
        this.tooltip.style('pointer-events', 'none')
        this.tooltip.style('opacity', '0')
        this.tooltip.style('text-wrap', 'nowrap')
        this.tooltip.style('z-index', 99999999) // important for leaflet-gridviz etc

        // these placeholders are needed to prevent an infinite DOM resizeObserver loop:
        this.tooltip.style('left', '0')
        this.tooltip.style('top', '0')

        // aria-labels (thanks to wahlatlas)
        this.tooltip.attr('role', 'tooltip').attr('aria-live', 'polite')
    }

    /** Show the tooltip */
    show() {
        // @ts-ignore
        this.tooltip.transition().duration(this.transitionDuration).style('opacity', 1)
    }

    /** Hide the tooltip */
    hide() {
        // @ts-ignore
        this.tooltip.transition().duration(this.transitionDuration).style('opacity', 0)
    }

    /**
     * Set the content of the tooltip.
     * @param {string} html
     */
    html(html) {
        this.tooltip.html(html)
    }

    /**
     * Set the position of the tooltip at the mouse event position.
     * @param {MouseEvent} event
     */
    setPosition(event) {
        // Get the bounding rect of the parent container (map2)
        let parentRect = this.parentElement.getBoundingClientRect()

        // Get the mouse position (relative to the parent container)
        let x = event.clientX - parentRect.left + this.xOffset // Relative to parent
        let y = event.clientY - parentRect.top - this.yOffset // Relative to parent

        // Now, apply the position to the tooltip
        this.tooltip.style('left', x + 'px').style('top', y + 'px')

        // Ensure the tooltip stays inside the parent container
        this.ensureTooltipInsideContainer(event, parentRect, this.tooltip.node())
    }
    /**
     * @function ensureTooltipInsideContainer
     * @description Prevents the tooltip from overflowing out of the App container (ensures that the tooltip is inside the gridviz container)
     * @param {MouseEvent} event
     * @param {DOMRect} parentRect
     * @param {HTMLElement} tooltipNode
     */
    ensureTooltipInsideContainer(event, parentRect, tooltipNode) {
        let node = tooltipNode
        let parentWidth = parentRect.width
        let parentHeight = parentRect.height

        // Ensure tooltip doesn't go beyond the right edge
        if (node.offsetLeft + node.clientWidth > parentWidth) {
            let left = event.clientX - node.clientWidth - this.xOffset
            node.style.left = left + 'px'
        }

        // Ensure tooltip doesn't go beyond the bottom edge
        if (node.offsetTop + node.clientHeight > parentHeight) {
            node.style.top = parentHeight - node.clientHeight + 'px'
        }

        // Ensure tooltip doesn't go above the top edge
        if (node.offsetTop < 0) {
            node.style.top = 0 + 'px'
        }

        // Ensure tooltip doesn't go beyond the left edge
        if (node.offsetLeft < 0) {
            node.style.left = 0 + 'px'
        }
    }

    /*
	my.mouseover = function (event, html) {
		if (html) my.html(html);
		my.setPosition(event);
		my.show()
		//this.ensureTooltipInsideContainer();
	};
	
	my.mousemove = function (event) {
		my.setPosition(event);
		//this.ensureTooltipInsideContainer();
	};
	
	my.mouseout = function () {
		my.hide();
	};*/

    style(k, v) {
        if (arguments.length == 1) return this.tooltip.style(k)
        this.tooltip.style(k, v)
        return this
    }

    attr(k, v) {
        if (arguments.length == 1) return this.tooltip.attr(k)
        this.tooltip.attr(k, v)
        return this
    }
}


/***/ }),

/***/ "./src/dataset/CSVGrid.js":
/*!********************************!*\
  !*** ./src/dataset/CSVGrid.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSVGrid: () => (/* binding */ CSVGrid)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
/* harmony import */ var _core_Dataset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Dataset.js */ "./src/core/Dataset.js");
//@ts-check


/** @typedef {{ dims: object, crs: string, tileSizeCell: number, originPoint: {x:number,y:number}, resolutionGeo: number, tilingBounds:import("../core/GeoCanvas.js").Envelope }} GridInfo */

;


/**
 * A dataset composed of a single CSV file (not tiled).
 *
 * @module dataset
 * @author Joseph Davies, Julien Gaffuri
 */
class CSVGrid extends _core_Dataset_js__WEBPACK_IMPORTED_MODULE_1__.Dataset {
    /**
     * @param {import("../core/Map.js").Map} map The map.
     * @param {string} url The URL of the dataset.
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {{preprocess?:(function(import("../core/Dataset.js").Cell):boolean),delimiter?:string}} opts
     */
    constructor(map, url, resolution, opts = {}) {
        super(map, url, resolution, opts)

        /**
         * @private
         * @type {Array.<import("../core/Dataset.js").Cell>} */
        this.cells = []

        /**
         * @private
         * @type {string} */
        this.delimiter = opts.delimiter || ','

        /**
         * @type {string}
         * @private  */
        this.infoLoadingStatus = 'notLoaded'

        //get data
        this.getData(undefined)
    }

    /**
     * Request data within a geographic envelope.
     * @param {import("../core/GeoCanvas.js").Envelope|undefined} e
     */
    getData(e) {
        //check if data already loaded
        if (this.infoLoadingStatus != 'notLoaded') return this

        //load data
        this.infoLoadingStatus = 'loading'
        ;(async () => {
            try {
                const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_0__["default"])(this.delimiter, this.url)

                //convert coordinates in numbers
                for (const c of data) {
                    c.x = +c.x
                    c.y = +c.y
                }

                //preprocess/filter
                if (this.preprocess) {
                    this.cells = []
                    for (const c of data) {
                        const b = this.preprocess(c)
                        if (b == false) continue
                        this.cells.push(c)
                    }
                } else {
                    this.cells = data
                }

                //TODO check if redraw is necessary
                //that is if the dataset belongs to a layer which is visible at the current zoom level

                //redraw map
                if (this.map) this.map.redraw()

                this.infoLoadingStatus = 'loaded'
            } catch (error) {
                //mark as failed
                this.infoLoadingStatus = 'failed'
                this.cells = []
            }
        })()

        return this
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     *
     * @param {import("../core/GeoCanvas.js").Envelope} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //data not loaded yet
        if (!this.cells) return

        this.cellsViewCache = []
        for (const cell of this.cells) {
            if (+cell.x + this.resolution < extGeo.xMin) continue
            if (+cell.x - this.resolution > extGeo.xMax) continue
            if (+cell.y + this.resolution < extGeo.yMin) continue
            if (+cell.y - this.resolution > extGeo.yMax) continue
            this.cellsViewCache.push(cell)
        }
    }
}


/***/ }),

/***/ "./src/dataset/JSGrid.js":
/*!*******************************!*\
  !*** ./src/dataset/JSGrid.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JSGrid: () => (/* binding */ JSGrid)
/* harmony export */ });
/* harmony import */ var _core_Dataset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Dataset.js */ "./src/core/Dataset.js");
//@ts-check


;

/**
 * A dataset composed of cells defined in javascript, or loaded outside of gridviz map.
 *
 * @module dataset
 * @author Joseph Davies, Julien Gaffuri
 */
class JSGrid extends _core_Dataset_js__WEBPACK_IMPORTED_MODULE_0__.Dataset {
    /**
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {Array.<Object>} cells The cells.
     * @param {} opts
     */
    constructor(resolution, cells, opts = {}) {
        super(undefined, '', resolution, opts)

        /**
         * @private
         * @type {Array.<import('../core/Dataset.js').Cell>} */
        this.cells = cells || []
    }

    /**
     * Request data within a geographic envelope.
     *
     * @param {import("../core/GeoCanvas.js").Envelope|undefined} e
     */
    getData(e) {
        return this
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     *
     * @param {import("../core/GeoCanvas.js").Envelope} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //data not loaded yet
        if (!this.cells) return

        this.cellsViewCache = []
        for (const cell of this.cells) {
            if (+cell.x + this.resolution < extGeo.xMin) continue
            if (+cell.x - this.resolution > extGeo.xMax) continue
            if (+cell.y + this.resolution < extGeo.yMin) continue
            if (+cell.y - this.resolution > extGeo.yMax) continue
            this.cellsViewCache.push(cell)
        }
    }
}


/***/ }),

/***/ "./src/dataset/TiledGrid.js":
/*!**********************************!*\
  !*** ./src/dataset/TiledGrid.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TiledGrid: () => (/* binding */ TiledGrid)
/* harmony export */ });
/* harmony import */ var _core_Dataset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Dataset.js */ "./src/core/Dataset.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
//@ts-check


/** @typedef {{ dims: object, crs: string, tileSizeCell: number, originPoint: {x:number,y:number}, resolutionGeo: number, tilingBounds:import("../core/GeoCanvas.js").Envelope }} GridInfo */

// internal
;
//import { monitor, monitorDuration } from '../utils/Utils.js'

// external


/**
 * A tiled dataset, composed of CSV tiles.
 *
 * @module dataset
 * @author Joseph Davies, Julien Gaffuri
 */
class TiledGrid extends _core_Dataset_js__WEBPACK_IMPORTED_MODULE_0__.Dataset {
    /**
     * @param {import("../core/Map.js").Map} map The map.
     * @param {string} url The URL of the dataset.
     * @param {{preprocess?:(function(import("../core/Dataset.js").Cell):boolean), onlyDrawWhenAllTilesReady:boolean}} opts
     */
    constructor(map, url, opts = {}) {
        super(map, url, 0, opts)
        this.onlyDrawWhenAllTilesReady = opts.onlyDrawWhenAllTilesReady || false
        /**
         * The grid info object, from the info.json file.
         *  @type {GridInfo | undefined}
         * @private
         *  */
        this.info = undefined

        /**
         * @type {string}
         * @private  */
        this.infoLoadingStatus = 'notLoaded'

        /**
         * The cache of the loaded tiles. It is double indexed: by xT and then yT.
         * Example: this.cache[xT][yT] returns the tile at [xT][yT] location.
         *
         * @type {object}
         * */
        this.cache = {}

        //launch loading
        this.loadInfo()
    }

    /**
     * Load the info.json from the url.
     * @returns this
     */
    loadInfo() {
        if (!this.info && this.infoLoadingStatus === 'notLoaded') {
            ;(async () => {
                try {
                    const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_2__["default"])(this.url + 'info.json')
                    this.info = data
                    this.resolution = data.resolutionGeo
                    this.infoLoadingStatus = 'loaded'
                    this.map.redraw()
                } catch (error) {
                    //mark as failed
                    this.infoLoadingStatus = 'failed'
                }
            })()
        } else if (this.infoLoadingStatus === 'loaded' || this.infoLoadingStatus === 'failed') this.map.redraw()
        return this
    }

    /**
     * Compute a tiling envelope from a geographical envelope.
     * This is the function to use to know which tiles to download for a geographical view.
     *
     * @param {import("../core/GeoCanvas.js").Envelope} e
     * @returns {import("../core/GeoCanvas.js").Envelope|undefined}
     */
    getTilingEnvelope(e) {
        if (!this.info) {
            this.loadInfo()
            return
        }

        const po = this.info.originPoint,
            r = this.info.resolutionGeo,
            s = this.info.tileSizeCell

        return {
            xMin: Math.floor((e.xMin - po.x) / (r * s)),
            xMax: Math.floor((e.xMax - po.x) / (r * s)),
            yMin: Math.floor((e.yMin - po.y) / (r * s)),
            yMax: Math.floor((e.yMax - po.y) / (r * s)),
        }
    }

    /**
     * Request data within a geographic envelope.
     *
     * @param {import('../core/GeoCanvas.js').Envelope} extGeo
     * @returns {this}
     */
    async getData(extGeo) {
        if (!this.info) return this

        // Create an AbortController for the current data request
        this.abortController = new AbortController()
        const signal = this.abortController.signal

        // Get the tiling envelope and check bounds
        const tb = this.getTilingEnvelope(extGeo)
        if (!tb) return this

        const { xMin: gbXMin, xMax: gbXMax, yMin: gbYMin, yMax: gbYMax } = this.info.tilingBounds

        const xMin = Math.max(tb.xMin, gbXMin)
        const xMax = Math.min(tb.xMax, gbXMax)
        const yMin = Math.max(tb.yMin, gbYMin)
        const yMax = Math.min(tb.yMax, gbYMax)

        const totalTiles = (xMax - xMin + 1) * (yMax - yMin + 1)
        let processedTiles = 0
        const tilePromises = []

        // Iterate over tiles within bounds
        for (let xT = xMin; xT <= xMax; xT++) {
            for (let yT = yMin; yT <= yMax; yT++) {
                if (!this.cache[xT]) this.cache[xT] = {}

                // Skip already loaded tiles or retry failed ones
                if (this.cache[xT][yT] && this.cache[xT][yT] !== 'failed') {
                    ++processedTiles
                    continue
                }

                // Mark tile as loading
                this.cache[xT][yT] = 'loading'

                tilePromises.push(
                    this.loadTile(xT, yT, signal)
                        .then((tile) => {
                            this.cache[xT][yT] = tile

                            // Check if this is the last tile
                            const isLastTile = ++processedTiles === totalTiles
                            this.checkAndRedraw(tile, isLastTile)
                        })
                        .catch(() => {
                            this.cache[xT][yT] = 'failed'
                            ++processedTiles
                        })
                )
            }
        }

        await Promise.allSettled(tilePromises)
        return this
    }

    /**
     * Load a tile.
     *
     * @param {number} xT
     * @param {number} yT
     * @param {AbortSignal} signal
     * @returns {Promise<any>}
     */
    async loadTile(xT, yT, signal) {
        try {
            const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_1__.csv)(`${this.url}${xT}/${yT}.csv`, { signal })

            const cells = this.preprocess ? data.filter((cell) => this.preprocess(cell) !== false) : data

            if (!this.info) throw new Error('Tile info unknown')

            return getGridTile(cells, xT, yT, this.info)
        } catch (error) {
            if (error.name === 'AbortError') {
                console.warn(`Tile request for ${xT}, ${yT} was aborted.`)
            }
            throw error
        }
    }

    /**
     * Cancel ongoing data requests when zoom level changes.
     */
    cancelCurrentRequests() {
        if (this.abortController) {
            this.abortController.abort()
        }
    }

    checkAndRedraw(tile, isLastTile) {
        if (this.map.geoCanvas.canvasSave.c) return; // skip redraws during zoom
        // Check if any visible layer depends on this dataset
        // check if redraw is really needed, that is if:
        // 1. the dataset belongs to a layer which is visible at the current zoom level
        let needsRedraw = false
        //go through the layers
        const z = this.map.getZoom()
        for (const lay of this.map.layers) {
            if (lay.visible && !lay.visible(z)) continue
            if (!lay.getDataset) continue
            if (lay.getDataset(z) != this) continue
            //found one layer. No need to seek more.
            needsRedraw = true
            break
        }

        if (!needsRedraw) return

        // Check if tile intersects the current view
        const env = this.map.updateExtentGeo()
        const { xMin, xMax, yMin, yMax } = tile.extGeo
        if (env.xMax <= xMin || env.xMin >= xMax || env.yMax <= yMin || env.yMin >= yMax) return

        // Trigger redraw
        if (this.onlyDrawWhenAllTilesReady) {
            if (isLastTile) {
                this.map.redraw()
            }
        } else {
            this.map.redraw()
        }
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     * @abstract
     * @param {import("../core/GeoCanvas.js").Envelope} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //
        this.cellsViewCache = []

        //check if info has been loaded
        if (!this.info) return

        //tiles within the scope
        /** @type {import("../core/GeoCanvas.js").Envelope|undefined} */
        const tb = this.getTilingEnvelope(extGeo)
        if (!tb) return

        //grid bounds
        /** @type {import("../core/GeoCanvas.js").Envelope} */
        const gb = this.info.tilingBounds

        for (let xT = Math.max(tb.xMin, gb.xMin); xT <= Math.min(tb.xMax, gb.xMax); xT++) {
            if (!this.cache[xT]) continue
            for (let yT = Math.max(tb.yMin, gb.yMin); yT <= Math.min(tb.yMax, gb.yMax); yT++) {
                //get tile
                /** @type {object} */
                const tile = this.cache[xT][yT]
                if (!tile || typeof tile === 'string') continue

                //get cells
                //this.cellsViewCache = this.cellsViewCache.concat(tile.cells)

                for (const cell of tile.cells) {
                    if (+cell.x + this.resolution < extGeo.xMin) continue
                    if (+cell.x - this.resolution > extGeo.xMax) continue
                    if (+cell.y + this.resolution < extGeo.yMin) continue
                    if (+cell.y - this.resolution > extGeo.yMax) continue
                    this.cellsViewCache.push(cell)
                }
            }
        }
    }
}

function getGridTile(cells, xT, yT, gridInfo) {
    const tile = {}

    /** @type {Array.<import("../core/Dataset").Cell>} */
    tile.cells = cells
    /** @type {number} */
    tile.x = xT
    /** @type {number} */
    tile.y = yT

    const r = gridInfo.resolutionGeo
    const s = gridInfo.tileSizeCell

    /** @type {import("../core/GeoCanvas").Envelope} */
    tile.extGeo = {
        xMin: gridInfo.originPoint.x + r * s * tile.x,
        xMax: gridInfo.originPoint.x + r * s * (tile.x + 1),
        yMin: gridInfo.originPoint.y + r * s * tile.y,
        yMax: gridInfo.originPoint.y + r * s * (tile.y + 1),
    }

    //convert cell coordinates into geographical coordinates
    for (let cell of tile.cells) {
        cell.x = tile.extGeo.xMin + cell.x * r
        cell.y = tile.extGeo.yMin + cell.y * r
    }

    return tile
}


/***/ }),

/***/ "./src/layer/BackgroundLayer.js":
/*!**************************************!*\
  !*** ./src/layer/BackgroundLayer.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundLayer: () => (/* binding */ BackgroundLayer)
/* harmony export */ });
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Layer.js */ "./src/core/Layer.js");
//@ts-check


;

/**
 *
 * A map background layer in "Slippy map" XYZ standard.
 * See https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames
 * https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/#6/27.88/44.48
 *
 * @module layer
 * @author Julien Gaffuri
 */
class BackgroundLayer extends _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The image cache, indexed by z/y/x
         * @private */
        this.cache = {}

        /**
         * @type {string} */
        this.url = opts.url
        /** @type {function(number,number,number):string} */
        this.urlFun = opts.urlFun || ((x, y, z) => this.url + z + '/' + x + '/' + y + '.png')

        /** The ground resolutions of the zoom levels, starting from the smallest (most zoomed-out, usually 0) to the largest (most zoomed-in).
         * Usually divided by 2 for each zoom level increment.
         * @type {Array.<number>} */
        this.resolutions = opts.resolutions
        if (!this.resolutions || this.resolutions.length == 0)
            throw new Error('No resolutions provided for background layer')

        /** The tile size, in number of pixels
         * @type {number} */
        this.nbPix = opts.nbPix || 256

        /** CRS coordinates of top left corner of the top left tile, the one with code /0/0.png.
         * @type {Array.<number>} */
        this.origin = opts.origin || [0, 0]

        /** The code of the smallest (most zoomed-out) zoom level, in case it is not 0.
         * @type {number} */
        this.z0 = opts.z0 || 0

        /** A coefficient to adjust the backgroun resolution with the screen resolution.
         *  If the background images are too pixelised, reduce the value.
         *  If there are too many images to download, increase the value.
         *  Default value is 1.0
         * @type {number} */
        this.pixelationCoefficient = opts.pixelationCoefficient || 1.0
    }

    /**
     * Get z/x/y cache data.
     * @param {number} z
     * @param {number} x
     * @param {number} y
     * @returns {HTMLImageElement|string|undefined}
     * @private
     */
    get(z, x, y) {
        let d = this.cache[z]
        if (!d) return
        d = d[x]
        if (!d) return
        return d[y]
    }

    /**
     * Put image in cache.
     * @param {HTMLImageElement|string} img
     * @param {number} z
     * @param {number} x
     * @param {number} y
     * @returns
     * @private
     */
    put(img, z, x, y) {
        if (!this.cache[z]) this.cache[z] = {}
        if (!this.cache[z][x]) this.cache[z][x] = {}
        this.cache[z][x][y] = img
    }

    /**
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @returns {void}
     */
    draw(geoCanvas) {
        if (!this.resolutions || this.resolutions.length == 0) {
            console.error('No resolutions provided for background layer')
            return
        }

        //
        const z = geoCanvas.view.z
        const x0 = this.origin[0], y0 = this.origin[1]

        //get zoom level and resolution
        let z_ = 0
        for (z_ = 0; z_ < this.resolutions.length; z_++) if (this.resolutions[z_] < z * this.pixelationCoefficient) break
        z_ -= 1
        z_ = Math.max(0, z_)
        z_ = Math.min(z_, this.resolutions.length - 1)
        const res = this.resolutions[z_]
        z_ += this.z0

        const sizeG = this.nbPix * res
        const size = sizeG / z

        //get tile numbers
        const xGeoToTMS = (x) => Math.ceil((x - x0) / sizeG)
        const yGeoToTMS = (y) => Math.ceil(-(y - y0) / sizeG)
        const xMin = xGeoToTMS(geoCanvas.extGeo.xMin) - 1
        const xMax = xGeoToTMS(geoCanvas.extGeo.xMax)
        const yMax = yGeoToTMS(geoCanvas.extGeo.yMin)
        const yMin = yGeoToTMS(geoCanvas.extGeo.yMax) - 1

        //handle images
        for (let x = xMin; x < xMax; x++) {
            for (let y = yMin; y < yMax; y++) {
                //get image
                let img = this.get(z_, x, y)

                //no image: load image from URL
                if (!img) {
                    const img = new Image()
                    this.put(img, z_, x, y)
                    img.onload = () => {
                        geoCanvas.redraw()
                    }
                    img.onerror = () => {
                        //case when no image
                        this.put('failed', z_, x, y)
                    }
                    img.src = this.urlFun(x, y, z_)
                    continue
                }

                //case when no image available
                if (img === 'failed') continue
                if (!(img instanceof HTMLImageElement)) {
                    console.log(img)
                    continue
                }
                if (img.width == 0 || img.height == 0) continue

                //draw image
                const xGeo = x0 + x * sizeG
                const yGeo = y0 - y * sizeG
                try {
                    geoCanvas.initCanvasTransform()
                    geoCanvas.offscreenCtx.drawImage(
                        img,
                        geoCanvas.geoToPixX(xGeo),
                        geoCanvas.geoToPixY(yGeo),
                        size,
                        size
                    )
                    //cg.ctx.drawImage(img, xGeo, yGeo, sizeG, -sizeG)
                } catch (error) {
                    console.error(error)
                }
            }
        }
    }
}


/***/ }),

/***/ "./src/layer/BackgroundLayerImage.js":
/*!*******************************************!*\
  !*** ./src/layer/BackgroundLayerImage.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundLayerImage: () => (/* binding */ BackgroundLayerImage)
/* harmony export */ });
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Layer.js */ "./src/core/Layer.js");
//@ts-check


;

/**
 *
 * A map background layer composed of a single image file, geolocated.
 *
 * @module layer
 * @author Julien Gaffuri
 */
class BackgroundLayerImage extends _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The image file URL
         * @type {string} */
        this.url = opts.url

        /** The image left coordinate
         * @type {number} */
        this.xMin = opts.xMin || 0
        /** The image top coordinate
         *  @type {number} */
        this.yMax = opts.yMax || 0

        /** The image width, in geo unit
         * @type {number} */
        this.width = opts.width || 20000
        /** The image height, in geo unit
         * @type {number} */
        this.height = opts.height || 20000

        /** The image object
         * @type {HTMLImageElement|undefined} */
        this.img = undefined
    }

    /**
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @returns {void}
     */
    draw(geoCanvas) {
        //update map extent
        //geoCanvas.updateExtentGeo(0)

        if (this.img) {
            //the image was already downloaded: draw it

            //compute screen coordinates and size ratio
            const x = geoCanvas.geoToPixX(this.xMin)
            const y = geoCanvas.geoToPixY(this.yMax)
            const z = geoCanvas.getView().z

            //draw image
            geoCanvas.initCanvasTransform()
            geoCanvas.offscreenCtx.drawImage(this.img, x, y, this.width / z, this.height / z)
        } else {
            //retrieve image

            if (!this.img) {
                this.img = new Image()
                this.img.onload = () => {
                    geoCanvas.redraw()
                }
                this.img.onerror = () => {
                    //case when no image
                    console.warn('Could not retrieve background image from', this.url)
                }
            }

            //set URL to launch the download
            this.img.src = this.url
        }
    }
}


/***/ }),

/***/ "./src/layer/BackgroundLayerWMS.js":
/*!*****************************************!*\
  !*** ./src/layer/BackgroundLayerWMS.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundLayerWMS: () => (/* binding */ BackgroundLayerWMS)
/* harmony export */ });
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Layer.js */ "./src/core/Layer.js");
//@ts-check


;

/**
 *
 * A map WMS background layer.
 *
 * @module layer
 * @author Julien Gaffuri
 */
class BackgroundLayerWMS extends _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * @type {string} */
        this.url = opts.url

        /** @type {HTMLImageElement|undefined} */
        this.img = undefined

        /** @type {number|undefined} */
        this.xMin = undefined
        /** @type {number|undefined} */
        this.xMax = undefined
        /** @type {number|undefined} */
        this.yMin = undefined
        /** @type {number|undefined} */
        this.yMax = undefined
    }

    /** Check if the view has moved and a new image needs to be retrieved.
     * @private */
    hasMoved(extGeo) {
        if (extGeo.xMin != this.xMin) return true
        else if (extGeo.xMax != this.xMax) return true
        else if (extGeo.yMin != this.yMin) return true
        else if (extGeo.yMax != this.yMax) return true
        else return false
    }

    /**
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @returns {void}
     */
    draw(geoCanvas) {
        //update map extent
        geoCanvas.updateExtentGeo(0)

        if (!this.hasMoved(geoCanvas.extGeo) && this.img) {
            //the map did not move and the image was already downloaded: draw the image
            geoCanvas.initCanvasTransform()
            geoCanvas.offscreenCtx.drawImage(this.img, 0, 0, geoCanvas.w, geoCanvas.h)
        } else {
            //the map moved: retrieve new image

            //
            this.xMin = geoCanvas.extGeo.xMin
            this.xMax = geoCanvas.extGeo.xMax
            this.yMin = geoCanvas.extGeo.yMin
            this.yMax = geoCanvas.extGeo.yMax

            //build WMS URL
            const url = []
            url.push(this.url)
            url.push('&width=')
            url.push(geoCanvas.w)
            url.push('&height=')
            url.push(geoCanvas.h)
            //bbox: xmin ymin xmax ymax
            url.push('&bbox=')
            url.push(geoCanvas.extGeo.xMin)
            url.push(',')
            url.push(geoCanvas.extGeo.yMin)
            url.push(',')
            url.push(geoCanvas.extGeo.xMax)
            url.push(',')
            url.push(geoCanvas.extGeo.yMax)

            const urlS = url.join('')
            //console.log(urlS)

            if (!this.img) {
                this.img = new Image()
                this.img.onload = () => {
                    geoCanvas.redraw()
                }
                this.img.onerror = () => {
                    //case when no image
                    console.warn('Could not retrieve WMS background image from', urlS)
                }
            }

            //set URL to launch the download
            this.img.src = urlS
        }
    }
}


/***/ }),

/***/ "./src/layer/GeoJSONLayer.js":
/*!***********************************!*\
  !*** ./src/layer/GeoJSONLayer.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeoJSONLayer: () => (/* binding */ GeoJSONLayer)
/* harmony export */ });
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Layer.js */ "./src/core/Layer.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
//@ts-check


;


/**
 * @module layer
 * @author Joseph Davies, Julien Gaffuri
 */
class GeoJSONLayer extends _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * @private
         * @type {string} */
        this.url = opts.url

        /**
         * A preprocess to run on each feature after loading.
         * It can be used to apply some specific treatment before, format the label data, project coordinates, etc.
         * Return false if the label should not be kept.
         * @private
         * @type {function(object):boolean} */
        this.preprocess = opts.preprocess

        //for points
        /**
         * @private
         * @type {function(object,number):string} */
        this.shape = opts.shape || ((f, z) => 'circle')
        /**
         * In pixel
         * @private
         * @type {function(object,number):number} */
        this.size = opts.size || ((f, z) => 10)
        /**
         * @private
         * @type {function(object,number):string} */
        this.strokeStyle = opts.strokeStyle || ((f, z) => 'red')
        /**
         * @private
         * @type {function(object,number):string} */
        this.fillStyle = opts.fillStyle || ((f, z) => 'black')
        /**
         * In pixel
         * @private
         * @type {function(object,number):number} */
        this.lineWidth = opts.lineWidth || ((f, z) => 2)

        //for lines

        /**
         * @private
         * @type {function(object,number):string} */
        this.color = opts.color || ((f, z) => 'gray')
        /**
         * In pixel
         * @private
         * @type {function(object,number):number} */
        this.width = opts.width || ((f, z) => 2)
        /**
         * @private
         * @type {function(object,number):Array.<number>|undefined} */
        this.lineDash = opts.lineDash || ((f, z) => undefined)

        /**
         * @private
         * @type {Array.<object> | undefined} */
        this.fs = undefined

        /**
         * @private
         * @type {string} */
        this.loadingStatus = 'notLoaded'
    }

    /**
     * Draw the layer.
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @returns {void}
     */
    draw(geoCanvas) {
        //load data, if not done yet.
        if (!this.fs) {
            this.load(geoCanvas.redraw)
            return
        }

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        for (const f of this.fs) {
            const gt = f.geometry.type

            if (gt == 'Point') {
                const c = f.geometry.coordinates

                //get style parameters for the point feature
                const shape = this.shape(f, z)
                if (!shape || shape == 'none') continue
                const size = this.size(f, z) * z
                if (!size) continue
                const strokeStyle = this.strokeStyle(f, z)
                const fillStyle = this.fillStyle(f, z)
                const lineWidth = this.lineWidth(f, z) * z

                //set canvas drawing parameters
                if (strokeStyle) ctx.strokeStyle = strokeStyle
                if (fillStyle) ctx.fillStyle = fillStyle
                if (lineWidth) ctx.lineWidth = lineWidth

                if (shape == 'circle') {
                    //draw circle - fill and stroke
                    ctx.beginPath()
                    ctx.arc(c[0], c[1], size / 2, 0, 2 * Math.PI, false)
                    if (fillStyle) ctx.fill()
                    if (strokeStyle && lineWidth) ctx.stroke()
                } else if (shape == 'square') {
                    //draw square - fill and stroke
                    ctx.beginPath()
                    ctx.rect(c[0] - size / 2, c[1] - size / 2, size, size)
                    if (fillStyle) ctx.fill()
                    if (strokeStyle && lineWidth) ctx.stroke()
                } else {
                    console.error('Unexpected shape for point geojson: ' + shape)
                }
            } else if (gt == 'LineString') {
                const cs = f.geometry.coordinates
                if (cs.length < 2) continue

                //set color
                const col = this.color(f, z)
                if (!col || col == 'none') continue
                ctx.strokeStyle = col

                //set linewidth
                const wP = this.width(f, z)
                if (!wP || wP < 0) continue
                ctx.lineWidth = wP * z

                //set line dash
                const ldP = this.lineDash(f, z)
                if (ldP) ctx.setLineDash(ldP)

                //draw line
                ctx.beginPath()
                ctx.moveTo(cs[0][0], cs[0][1])
                for (let i = 1; i < cs.length; i++) ctx.lineTo(cs[i][0], cs[i][1])
                ctx.stroke()
            } else {
                console.log('Unsupported geometry type in GeoJSONLayer: ' + gt)
            }
        }

        //...
        ctx.setLineDash([])
    }

    /**
     * Load data for labels, from URL this.url
     * @param {function():void} callback
     * @private
     */
    async load(callback) {
        if (!this.url) {
            console.log('Failed loading boundaries: No URL specified. ' + this.url)
            this.loadingStatus = 'failed'
            this.labels = []
            return
        }

        //check if data already loaded
        if (this.loadingStatus != 'notLoaded') return

        //load data
        this.loadingStatus = 'loading'

        try {
            const data_ = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_1__["default"])(this.url)

            /** @type { Array.<object> } */
            const data = data_.features

            //preprocess/filter
            if (this.preprocess) {
                this.fs = []
                for (const c of data) {
                    const b = this.preprocess(c)
                    if (b == false) continue
                    this.fs.push(c)
                }
            } else {
                //store labels
                this.fs = data
            }

            this.loadingStatus = 'loaded'

            //redraw
            if (callback) callback()
        } catch (error) {
            console.log('Failed loading boundaries from ' + this.url)
            this.fs = []
            this.loadingStatus = 'failed'
        }
    }
}


/***/ }),

/***/ "./src/layer/GridLayer.js":
/*!********************************!*\
  !*** ./src/layer/GridLayer.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GridLayer: () => (/* binding */ GridLayer)
/* harmony export */ });
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Layer.js */ "./src/core/Layer.js");
//@ts-check


;

/**
 * A layer, which specifies a dataset to be shown with specified styles.
 *
 * @module layer
 * @author Joseph Davies, Julien Gaffuri
 */
class GridLayer extends _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {
    /**
     * @param {import("../core/Dataset").Dataset|import("../core/MultiResolutionDataset").MultiResolutionDataset} dataset The dataset to show.
     * @param {Array.<import("../core/Style").Style>} styles The styles, ordered in drawing order.
     * @param {{visible?:function(number):boolean,alpha?:function(number):number,blendOperation?:function(number):GlobalCompositeOperation,minPixelsPerCell?:number,cellInfoHTML?:function(import("../core/Dataset").Cell):string}} opts
     */
    constructor(dataset, styles, opts = {}) {
        super(opts)
        opts = opts || {}

        /** @type {import("../core/Dataset").Dataset|import("../core/MultiResolutionDataset").MultiResolutionDataset} */
        this.dataset = dataset

        /** @type {Array.<import("../core/Style").Style>} */
        this.styles = styles

        /**
         * This parameter is used when the dataset is a MultiResolutionDataset.
         * It defines the minimum number of pixels a grid cell should have to select the dataset to display based on its resolution.
         * A low value, means that the map will be more detailled (smaller cells).
         * A high value, means that the map will be less detailled (larger cells).
         * This value should be higher than 1, otherwise it means a grid cell is smaller than the screen resolution.
         * For more complex cell representations that require some more map space, this value should be higher.
         * @type {number} */
        this.minPixelsPerCell = opts.minPixelsPerCell || 3

        /**
         * The function returning cell information as HTML.
         * This is typically used for tooltip information.
         * @type {function(import("../core/Dataset").Cell, number):string} */
        this.cellInfoHTML = opts.cellInfoHTML || GridLayer.defaultCellInfoHTML
    }

    /** */
    draw(geoCanvas, legend) {
        //get zoom level
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        //get layer dataset component
        /** @type {import('../core/Dataset.js').Dataset|undefined} */
        const dsc = this.getDataset(z)
        if (!dsc) return

        //launch data download, if necessary
        dsc.getData(geoCanvas.extGeo)

        //update dataset view cache
        dsc.updateViewCache(geoCanvas.extGeo)

        //draw cells, style by style
        for (const s of this.styles) {
            //check if style is visible
            if (s.visible && !s.visible(z)) continue

            //set style alpha and blend mode
            //TODO: multiply by layer alpha ?
            ctx.globalAlpha = s.alpha ? s.alpha(z) : 1.0
            if (s.blendOperation) ctx.globalCompositeOperation = s.blendOperation(z)

            //set affin transform to draw with geographical coordinates
            geoCanvas.setCanvasTransform()

            //draw with style
            s.draw(dsc.getViewCache(), geoCanvas, dsc.getResolution())

            //draw style filter
            if (s.filterColor) s.drawFilter(geoCanvas)
        }

        //add legend element
        if (legend) {
            for (const s of this.styles) {
                //check if style is visible
                if (s.visible && !s.visible(z)) continue
                GridLayer.addLegends(legend, s.legends)

                //case for styles of styles, like kernel smoothing
                //TODO do better
                if (s['styles']) {
                    for (const s2 of s['styles']) {
                        if (s2.visible && !s2.visible(z)) continue
                        GridLayer.addLegends(legend, s2.legends)
                    }
                }
            }
        }
    }

    /** @private */
    static addLegends(legendComp, lg) {
        if (Array.isArray(lg)) for (const lg_ of lg) this.addLegends(legendComp, lg_)
        else legendComp.node().append(lg.div.node())
    }

    /**
     * Return the relevant dataset component for a specified zoom.
     *
     * @param {number} z
     * @returns {import("../core/Dataset").Dataset|undefined}
     * */
    getDataset(z) {
        return this.dataset.getDataset(z, this.minPixelsPerCell)
    }

    /**
     * Set/get style stack.
     *
     * @param {undefined|import("../core/Style").Style|Array.<import("../core/Style").Style>} styles
     * @returns { this | Array.<import("../core/Style").Style> }
     */
    styles_(styles) {
        if (arguments.length === 0) return this.styles
        if (arguments.length === 1)
            if (Array.isArray(styles)) this.styles = styles
            else this.styles = [styles]
        else this.styles = arguments
        return this
    }

    /**
     * The default function returning cell information as HTML.
     * This is typically used for tooltip information.
     *
     * @param {import("../core/Dataset").Cell} cell
     * @returns {string}
     */
    static defaultCellInfoHTML(cell) {
        const buf = []
        for (const key of Object.keys(cell)) {
            if (key === 'x') continue
            if (key === 'y') continue
            buf.push('<b>', key, '</b>', ' : ', cell[key], '<br>')
        }
        return buf.join('')
    }
}


/***/ }),

/***/ "./src/layer/LabelLayer.js":
/*!*********************************!*\
  !*** ./src/layer/LabelLayer.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LabelLayer: () => (/* binding */ LabelLayer)
/* harmony export */ });
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Layer.js */ "./src/core/Layer.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
//@ts-check


;


/** A label. The name is the text to show. (x,y) are the coordinates in the same CRS as the grid.
 * @typedef {{name: string, x:number, y:number }} Label */

/**
 * A (generic) layer for placename labels, to be shown on top of the grid layers.
 * The input is a CSV file with the position (x, y) of the labels and name + some other info on the label importance.
 * If the label data is not in the expected format or in the same CRS as the grid, it can be corrected with the "preprocess" function.
 * The selection of the label, their style (font, weight, etc.) and color can be specified depending on their importance and the zoom level.
 *
 * @module layer
 * @author Joseph Davies, Julien Gaffuri
 */
class LabelLayer extends _core_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The URL of the label data, as CSV file.
         * The file should contain the information for each label such as the text, the position and other information for the display of the label according to the zoom level.
         * If necessary, this data can be reformated with the 'preprocess' parameter.
         * @private
         * @type {string} */
        this.url = opts.url

        /** Specify if and how a label should be drawn, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):string} */
        this.style = opts.style || (() => '1.2em Arial')

        /** Specify the label color, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):string} */
        this.color = opts.color || (opts.dark ? () => 'white' : () => 'black')

        /** Specify the label halo color, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):string} */
        this.haloColor = opts.haloColor || (opts.dark ? () => 'black' : () => 'white')

        /** Specify the label halo width, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):number} */
        this.haloWidth = opts.haloWidth || (() => 2.5)

        /** The anchor where to draw the text, from label position. See HTML-canvas textAlign property.
         * "left" || "right" || "center" || "start" || "end"
         * @private
         * @type {CanvasTextAlign} */
        this.textAlign = opts.textAlign || 'start'

        /**
         * @private
         * @type {Array.<number>} */
        this.offsetPix = opts.offsetPix || [5, 5]

        /**
         * A preprocess to run on each label after loading.
         * It can be used to apply some specific treatment before, format the label data, project coordinates, etc.
         * Return false if the label should not be kept.
         * @private
         * @type {function(Label):boolean} */
        this.preprocess = opts.preprocess

        /**
         * @private
         * @type {Array.<Label> | undefined} */
        this.labels = undefined

        /**
         * @private
         * @type {string} */
        this.loadingStatus = 'notLoaded'
    }

    /**
     * Draw the label layer.
     *
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas The canvas where to draw the layer.
     * @returns {void}
     */
    draw(geoCanvas) {
        //load labels, if not done yet.
        if (!this.labels) {
            this.load(geoCanvas.redraw)
            return
        }

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        //text align
        ctx.textAlign = this.textAlign || 'start'

        //line join and cap
        ctx.lineJoin = 'bevel' //|| "round" || "miter";
        ctx.lineCap = 'butt' //|| "round" || "square";

        //draw in pix coordinates
        geoCanvas.initCanvasTransform()

        //draw labels, one by one
        for (const lb of this.labels) {
            //get label style
            const st = this.style(lb, z)
            if (!st) continue
            ctx.font = st

            //check label within the view, to be drawn
            if (!geoCanvas.toDraw(lb)) continue

            //position
            const xP = geoCanvas.geoToPixX(lb.x) + this.offsetPix[0]
            const yP = geoCanvas.geoToPixY(lb.y) - this.offsetPix[1]

            //label stroke, for the halo
            if (this.haloColor && this.haloWidth) {
                const hc = this.haloColor(lb, z)
                const hw = this.haloWidth(lb, z)
                if (hc && hw && hw > 0) {
                    ctx.strokeStyle = hc
                    ctx.lineWidth = hw
                    ctx.strokeText(lb.name, xP, yP)
                }
            }

            //label fill
            if (this.color) {
                const col = this.color(lb, z)
                if (col) {
                    ctx.fillStyle = col
                    ctx.fillText(lb.name, xP, yP)
                }
            }
        }
    }

    /**
     * Load data for labels, from URL this.url
     * @param {function():void} callback
     * @private
     */
    async load(callback) {
        if (!this.url) {
            console.log('Failed loading labels: No URL specified. ' + this.url)
            this.loadingStatus = 'failed'
            this.labels = []
            return
        }

        //check if data already loaded
        if (this.loadingStatus != 'notLoaded') return

        //load data
        this.loadingStatus = 'loading'

        try {
            /** @type { Array.<Label> } */
            const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_1__.csv)(this.url)

            //preprocess/filter
            if (this.preprocess) {
                this.labels = []
                for (const c of data) {
                    const b = this.preprocess(c)
                    if (b == false) continue
                    this.labels.push(c)
                }
            } else {
                //store labels
                this.labels = data
            }

            this.loadingStatus = 'loaded'

            //redraw
            if (callback) callback()
        } catch (error) {
            console.log('Failed loading labels from ' + this.url)
            this.labels = []
            this.loadingStatus = 'failed'
        }
    }
}


/***/ }),

/***/ "./src/legend/ColorCategoryLegend.js":
/*!*******************************************!*\
  !*** ./src/legend/ColorCategoryLegend.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorCategoryLegend: () => (/* binding */ ColorCategoryLegend)
/* harmony export */ });
/* harmony import */ var _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Legend.js */ "./src/core/Legend.js");
//@ts-check


;

/**
 * A legend element for color categrories.
 *
 * @module legend
 * @author Joseph Davies, Julien Gaffuri
 */
class ColorCategoryLegend extends _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //col/categories array, in display order
        /**
         * @private
         * @type {Array.<[string,string]>} */
        this.colorLabel = opts.colorLabel || [['gray', '-']]

        /**
         * @private
         * @type {import("../core/Style.js").Shape} */
        this.shape = opts.shape || 'circle'
        this.dimension = opts.dimension || { r: 8 }
        this.strokeColor = opts.strokeColor || 'gray'
        this.strokeWidth = opts.strokeWidth || 1
    }

    /**
     */
    update() {
        //clear
        this.div.selectAll('*').remove()

        //title
        this.makeTitle()

        //categories
        const nb = this.colorLabel.length
        if (nb == 0) return

        for (let i = 0; i < nb; i++) {
            const cat = this.colorLabel[i]

            //make div for category
            const d = this.div.append('div')
            //to enable vertical centering
            //.style("position", "relative")

            const sw = this.strokeWidth

            //draw graphic element: box / circle
            if (this.shape === 'square') {
                const h = this.dimension.h || 15
                const w = this.dimension.w || 20
                d.append('div')
                    .style('display', 'inline')

                    .append('svg')
                    .attr('width', w + 2 * sw)
                    .attr('height', h + 2 * sw)

                    .append('rect')
                    .attr('x', sw)
                    .attr('y', sw)
                    .attr('width', w)
                    .attr('height', h)
                    .style('fill', cat[0])
                    .style('stroke', this.strokeColor)
                    .style('stroke-width', this.strokeWidth)
            } else if (this.shape === 'circle') {
                const r = this.dimension.r || 8
                const h = 2 * r + 2 * sw
                d.append('div')
                    .style('display', 'inline')

                    .append('svg')
                    .attr('width', h)
                    .attr('height', h)

                    .append('circle')
                    .attr('cx', r + sw)
                    .attr('cy', r + sw)
                    .attr('r', r)
                    .style('fill', cat[0])
                    .style('stroke', this.strokeColor)
                    .style('stroke-width', this.strokeWidth)
            } else {
                throw new Error('Unexpected shape:' + this.shape)
            }

            //write label text
            d.append('div')
                //show on right of graphic
                .style('display', 'inline')

                //center vertically
                //.style("position", "absolute").style("top", "0").style("bottom", "0")

                .style('padding-left', '5px')
                .style('font-size', this.labelFontSize)
                .text(cat[1])
        }
    }
}


/***/ }),

/***/ "./src/legend/ColorDiscreteLegend.js":
/*!*******************************************!*\
  !*** ./src/legend/ColorDiscreteLegend.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorDiscreteLegend: () => (/* binding */ ColorDiscreteLegend)
/* harmony export */ });
/* harmony import */ var _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Legend.js */ "./src/core/Legend.js");
//@ts-check


;

/**
 * A legend element for discrete color style.
 * Inspiration: https://observablehq.com/@d3/color-legend
 *
 * @module legend
 * @author Julien Gaffuri
 */
class ColorDiscreteLegend extends _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** @private @type {function(import('../core/Style').ViewScale):Array.<string>} */
        this.colors = opts.colors
        /** @private @type {function(import('../core/Style').ViewScale):Array.<number>} */
        this.breaks = opts.breaks

        this.width = opts.width || 300
        this.height = opts.height || 15

        this.tickSize = opts.tickSize || 3

        //label
        this.invert = opts.invert
    }

    /**
     * @param {{viewScale:import('../core/Style').ViewScale} } opts
     */
    update(opts) {
        //clear
        this.div.selectAll('*').remove()

        //title
        this.makeTitle()

        //get colors and breaks
        const colors = this.colors(opts.viewScale)
        const breaks = this.breaks(opts.viewScale)
        if (!breaks) return

        //classes
        const nb = colors.length
        if (nb == 0) return
        const w = this.width / nb

        //make svg element
        const svg = this.div
            .append('svg')
            .attr('width', this.width)
            .attr('height', this.height + this.tickSize + 2 + 10)

        //draw graphic elements
        for (let i = 0; i < nb; i++) {
            svg.append('rect')
                .attr('x', i * w)
                .attr('y', 0)
                .attr('width', w)
                .attr('height', this.height)
                .style('fill', colors[i])
        }

        //tick line
        for (let i = 1; i < nb; i++) {
            svg.append('line')
                .attr('x1', w * i)
                .attr('y1', 0)
                .attr('x2', w * i)
                .attr('y2', this.height + this.tickSize)
                .style('stroke', 'black')
        }

        //labels
        for (let i = 1; i < nb; i++) {
            let label = breaks[i - 1]
            if (isNaN(label) || label == undefined) continue
            if (this.labelFormat) label = this.labelFormat(label, i)

            //label
            svg.append('text')
                .attr('id', 'ticklabel_' + i)
                .attr('x', w * i)
                .attr('y', this.height + this.tickSize + 2)
                .style('font-size', this.labelFontSize)
                //.style("font-weight", "bold")
                //.style("font-family", "Arial")
                .style('text-anchor', 'middle')
                .style('alignment-baseline', 'top')
                .style('dominant-baseline', 'hanging')
                .style('pointer-events', 'none')
                .text(label)
        }
    }
}


/***/ }),

/***/ "./src/legend/ColorLegend.js":
/*!***********************************!*\
  !*** ./src/legend/ColorLegend.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorLegend: () => (/* binding */ ColorLegend)
/* harmony export */ });
/* harmony import */ var _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Legend.js */ "./src/core/Legend.js");
//@ts-check


;

/**
 * A legend element for continuous color style.
 * Inspiration: https://observablehq.com/@d3/color-legend
 *
 * @module legend
 * @author Joseph Davies, Julien Gaffuri
 */
class ColorLegend extends _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //a function [0,1]->color for continuous colors.
        //it can take as second argument the viewscale.
        this.colorScale = opts.colorScale

        //function (t[0,1]) -> value (for label text)
        //it can take as second argument the viewscale.
        this.textScale = opts.textScale || ((t) => t)

        this.margin = opts.margin || 5

        //replace with labels ?
        this.tickSize = opts.tickSize || 6
        this.ticks = opts.ticks || Math.floor(this.width / 50)
        this.tickFormat = opts.tickFormat
        this.tickUnit = opts.tickUnit

        this.fontSize = opts.fontSize || '0.8em'
        this.invert = opts.invert

        this.width = opts.width || 300
        this.height = opts.height || 15
    }

    /**
     * @param {{viewScale:import('../core/Style').ViewScale} } opts
     */
    update(opts) {
        //clear
        this.div.selectAll('*').remove()

        //title
        this.makeTitle()

        const svgW = this.width + 2 * this.margin
        const svgH = this.height + this.margin + this.tickSize + 10
        const svg = this.div.append('svg').attr('width', svgW).attr('height', svgH)
        //  <rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />

        const g = svg.append('g').attr('transform', 'translate(' + this.margin + ' ' + 0 + ')')

        //draw color bar
        const w = this.width,
            h = this.height
        const step = 5
        for (let i = 0; i < w; i += step) {
            let t = i / (w - 1)
            if (this.invert) t = 1 - t
            g.append('rect')
                .attr('x', i)
                .attr('y', 0)
                .attr('width', step)
                .attr('height', h)
                .style('fill', this.colorScale(t, opts.viewScale))
        }

        for (let i = 0; i < this.ticks; i++) {
            let t = i / (this.ticks - 1)

            //tick line
            g.append('line')
                .attr('x1', w * t)
                .attr('y1', 0)
                .attr('x2', w * t)
                .attr('y2', h + this.tickSize)
                .style('stroke', 'black')

            //prepare tick label
            g.append('text')
                .attr('id', 'ticklabel_' + i)
                .attr('x', w * t)
                .attr('y', h + this.tickSize + 2)
                .style('font-size', this.fontSize)
                //.style("font-weight", "bold")
                //.style("font-family", "Arial")
                .style('text-anchor', i == 0 ? 'start' : i == this.ticks - 1 ? 'end' : 'middle')
                .style('alignment-baseline', 'top')
                .style('dominant-baseline', 'hanging')
                .style('pointer-events', 'none')
            //.text("-")
        }

        //update tick labels

        //label text format
        const f = this.tickFormat && this.tickFormat != 'text' ? this.tickFormat : (v) => v
        for (let i = 0; i < this.ticks; i++) {
            let t = i / (this.ticks - 1)

            const v = this.textScale(t, opts.viewScale)
            const text = (v ? f(v) : '0') + (this.tickUnit ? this.tickUnit : '')
            if (text == undefined) continue

            //tick label
            this.div.select('#' + 'ticklabel_' + i).text(text)
        }
    }
}


/***/ }),

/***/ "./src/legend/OrientationLegend.js":
/*!*****************************************!*\
  !*** ./src/legend/OrientationLegend.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OrientationLegend: () => (/* binding */ OrientationLegend),
/* harmony export */   orientationLegend: () => (/* binding */ orientationLegend)
/* harmony export */ });
/* harmony import */ var _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Legend.js */ "./src/core/Legend.js");
//@ts-check


;

/**
 * A legend element for segment orientation.
 *
 * @module legend
 * @author Joseph Davies, Julien Gaffuri
 */
class OrientationLegend extends _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //orientation
        this.orientation = opts.orientation || 0
        //color
        this.color = opts.color || ((resolution, z, viewScale) => 'gray')
        //width
        this.width = opts.width || ((resolution, z, viewScale) => 3 * z)
        //length
        this.length = opts.length || ((resolution, z, viewScale) => resolution)

        //label
        this.label = opts.label || '-'
    }

    /**
     * @param {{ style: import("../style/SegmentStyle.js").SegmentStyle, resolution: number, z: number, viewScale:object }} opts
     */
    update(opts) {
        //clear
        this.div.selectAll('*').remove()

        //title
        this.makeTitle()

        const d = this.div.append('div')

        //compute segment color, width and length
        const color = this.color(opts.resolution, opts.z, opts.viewScale)
        const widthPix = this.width(opts.resolution, opts.z, opts.viewScale) / opts.z
        const lengthPix = this.length(opts.resolution, opts.z, opts.viewScale) / opts.z

        //draw SVG segment
        const svgS = Math.max(lengthPix, widthPix)
        const svg = d.append('svg').attr('width', svgS).attr('height', svgS).style('', 'inline-block')

        const cos = Math.cos((-this.orientation * Math.PI) / 180)
        const sin = Math.sin((-this.orientation * Math.PI) / 180)
        const dc = svgS * 0.5,
            l2 = lengthPix * 0.5
        svg.append('line')
            .attr('x1', dc - cos * l2)
            .attr('y1', dc - sin * l2)
            .attr('x2', dc + cos * l2)
            .attr('y2', dc + sin * l2)
            .style('stroke', color)
            .style('stroke-width', widthPix)

        //label
        d.append('div')
            .style('display', 'inline')
            .style('padding-left', '5px')
            .style('font-size', this.labelFontSize)
            .text(this.label + (this.labelUnitText ? ' ' : '') + this.labelUnitText)
    }
}

/**
 *
 * @param {Array.<number>} orientations
 * @param {Array.<string>} labels
 * @param {object} opts
 * @returns  { Array.<OrientationLegend> }
 */
function orientationLegend(orientations, labels, opts = {}) {
    const legends = []
    for (let i = 0; i < orientations.length; i++) {
        opts.title = i == 0 ? opts.title : undefined
        opts.orientation = orientations[i]
        opts.label = labels[i]
        legends.push(new OrientationLegend(opts))
    }
    return legends
}


/***/ }),

/***/ "./src/legend/SizeLegend.js":
/*!**********************************!*\
  !*** ./src/legend/SizeLegend.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SizeLegend: () => (/* binding */ SizeLegend),
/* harmony export */   sizeDiscreteLegend: () => (/* binding */ sizeDiscreteLegend),
/* harmony export */   sizeDiscreteViewScaleLegend: () => (/* binding */ sizeDiscreteViewScaleLegend),
/* harmony export */   sizeLegend: () => (/* binding */ sizeLegend),
/* harmony export */   sizeLegendViewScale: () => (/* binding */ sizeLegendViewScale)
/* harmony export */ });
/* harmony import */ var _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Legend.js */ "./src/core/Legend.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils.js */ "./src/utils/utils.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
//@ts-check


;



/**
 * A legend element for proportional symbols.
 *
 * @module legend
 * @author Joseph Davies, Julien Gaffuri
 */
class SizeLegend extends _core_Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the text label, from the view scale and list of cells, resolution and zoom
         *  @type { function(object, Array.<import('../core/Dataset.js').Cell>, number, number):(number|string) } */
        this.label = opts.label || undefined

        /** A function returning the size of the legend symbol, in geo UoM, from the viewscale, resolution and zoom
         *  @type { function(object, number, number):number } */
        this.size = opts.size || undefined

        //symbol
        /**  @type {(import("../core/Style").Shape)|"line"} */
        this.shape = opts.shape || 'circle'

        //general case
        this.fillColor = opts.fillColor || 'none'
        this.strokeColor = opts.strokeColor || 'gray'
        this.strokeWidth = opts.strokeWidth || 1

        //for line shape
        //TODO this.orientation = opts.orientation || 0
        this.color = opts.color || 'gray'
        this.length = opts.length || ((resolution, z, viewScale) => resolution)
    }

    /**
     * @param {{ viewScale:object, resolution: number, z:number, cells:Array.<import('../core/Dataset.js').Cell> }} opts
     */
    update(opts) {
        //clear
        this.div.selectAll('*').remove()

        //title
        this.makeTitle()

        //get label. May not be a number (!)
        let label = this.label(opts.viewScale, opts.cells, opts.resolution, opts.z)

        //compute size of symbol, in pix
        let sizePix
        if (this.size) sizePix = this.size(opts.viewScale, opts.resolution, opts.z) / opts.z
        else sizePix = opts.viewScale(+label) / opts.z
        if (!sizePix) return

        //format label, if specified and possible
        if (this.labelFormat && !isNaN(+label)) label = this.labelFormat(label)

        const d = this.div.append('div')
        //to enable vertical centering
        //.style("position", "relative")

        //default svg construction, for square and circle
        const svg = () =>
            d
                .append('svg')
                .attr('width', sizePix + this.strokeWidth + 2)
                .attr('height', sizePix + this.strokeWidth + 2)
                .style('', 'inline-block')

        if (this.shape === 'square') {
            svg()
                .append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', sizePix)
                .attr('height', sizePix)
                .style('fill', this.fillColor)
                .style('stroke', this.strokeColor)
                .style('stroke-width', this.strokeWidth)
        } else if (this.shape === 'circle') {
            // <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
            const r = (sizePix + this.strokeWidth) * 0.5
            svg()
                .append('circle')
                .attr('cx', r + 1)
                .attr('cy', r + 1)
                .attr('r', r)
                .style('fill', this.fillColor)
                .style('stroke', this.strokeColor)
                .style('stroke-width', this.strokeWidth)
        } else if (this.shape === 'donut') {
            //TODO
        } else if (this.shape === 'diamond') {
            //TODO
        } else if (this.shape === 'line') {
            //get segment length
            let lengthPix = this.length
                ? this.length(opts.resolution, opts.z, opts.viewScale)
                : opts.resolution
            lengthPix /= opts.z

            const svg = d
                .append('svg')
                .attr('width', lengthPix)
                .attr('height', sizePix)
                .style('', 'inline-block')

            //TODO orientation
            //<line x1="0" y1="0" x2="200" y2="200" style="stroke:rgb(255,0,0);stroke-width:2" />
            svg.append('line')
                .attr('x1', 0)
                .attr('y1', sizePix / 2)
                .attr('x2', lengthPix)
                .attr('y2', sizePix / 2)
                .style('stroke', this.color)
                .style('stroke-width', sizePix)
        } else {
            throw new Error('Unexpected shape:' + this.shape)
        }

        //label
        d.append('div')
            .style('display', 'inline')
            .style('padding-left', '5px')
            .style('font-size', this.labelFontSize)
            .text(label + (this.labelUnitText ? ' ' : '') + this.labelUnitText)
    }
}

/**
 * @param {Array.<number>} values
 * @param {function(number):number} size
 * @param { object } opts
 * @returns {Array.<SizeLegend>}
 */
function sizeLegend(values, size, opts = {}) {
    const legends = []
    for (let value of values) {
        opts.title = value == values[0] ? opts.title : undefined
        opts.size = () => size(value)
        opts.label = () => value
        legends.push(new SizeLegend(opts))
    }
    return legends
}

/**
 * @param { function(import('../core/Dataset.js').Cell):number } value
 * @param {*} opts
 * @returns {Array.<SizeLegend>}
 */
function sizeLegendViewScale(value, opts = {}) {
    const k = opts.k || [0.9, 0.5, 0.2, 0.05]
    const legends = []
    for (let k_ of k) {
        opts.title = k_ == k[0] ? opts.title : undefined
        opts.label = (viewScale, cells) => (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.nice)(k_ * (0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])(cells, value))
        legends.push(new SizeLegend(opts))
    }
    return legends
}

/**
 * A function which return a stack of size legends for a discrete classification.
 *
 * @param { Array.<number> } breaks
 * @param { Array.<number> } sizes
 * @param { object } opts
 * @returns {Array.<SizeLegend>}
 */
function sizeDiscreteLegend(breaks, sizes, opts = {}) {
    const f = opts.labelFormat || ((x) => x)
    const labelText = opts.labelText || defaultLabelText(f)
    const legends = []
    for (let i = sizes.length - 1; i >= 0; i--) {
        opts.title = i == sizes.length - 1 ? opts.title : undefined
        opts.size = () => sizes[i]
        opts.label = () => labelText(breaks[i - 1], breaks[i])
        legends.push(new SizeLegend(opts))
    }
    return legends
}

/**
 * A function which return a stack of size legends for a discrete classification using a viewscale.
 * @param { number } classNumber
 * @param { object } opts
 * @returns {Array.<SizeLegend>}
 */
function sizeDiscreteViewScaleLegend(classNumber, opts = {}) {
    const f = opts.labelFormat || ((x) => x)
    const labelText = opts.labelText || defaultLabelText(f)
    const legends = []
    const viewScaleFun = opts.viewScaleFun || ((t) => t) //TODO do it differently? At sizelegend level !
    for (let i = classNumber - 1; i >= 0; i--) {
        opts.title = i == classNumber - 1 ? opts.title : undefined
        opts.size = (viewScale) => viewScaleFun(viewScale).values[i]
        opts.label = (viewScale) =>
            labelText(viewScaleFun(viewScale).breaks[i - 1], viewScaleFun(viewScale).breaks[i])
        legends.push(new SizeLegend(opts))
    }
    return legends
}

/**
 * A function that returns a function to format laberls for discrete scale legends.
 * @param { function(number):string } format
 * @returns { function(number|undefined, number|undefined): string }
 */
function defaultLabelText(format) {
    return (v0, v1) => {
        if (v0 == undefined && v1 == undefined) return ''
        if (v1 == undefined) return '> ' + format(v0)
        if (v0 == undefined) return '< ' + format(v1)
        return format(v0) + ' - ' + format(v1)
    }
}


/***/ }),

/***/ "./src/legend/TernaryLegend.js":
/*!*************************************!*\
  !*** ./src/legend/TernaryLegend.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TernaryLegend: () => (/* binding */ TernaryLegend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _core_Legend_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Legend.js */ "./src/core/Legend.js");
//@ts-check


;


/**
 *
 * @module legend
 * @author Julien Gaffuri
 */
class TernaryLegend extends _core_Legend_js__WEBPACK_IMPORTED_MODULE_1__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //classifier
        this.classifier = opts.classifier

        this.width = opts.width || 150
        this.selectionColor = this.selectionColor || 'red'
        this.tooltip = opts.tooltip
        this.texts = opts.texts

        this.leftText = opts.leftText || 'Category 0'
        this.topText = opts.topText || 'Category 1'
        this.rightText = opts.rightText || 'Category 2'

        this.centerCoefficient = opts.centerCoefficient || this.classifier.centerCoefficient
    }

    /**
     * @param {{} } opts
     */
    update(opts) {
        //clear
        this.div.selectAll('*').remove()

        //title
        this.makeTitle()

        const sqrt3over2 = 0.866025
        const w = this.width,
            h = w * sqrt3over2
        const classifier = this.classifier
        const selectionColor = this.selectionColor
        const selectionStrokeWidth = 0
        const tt = this.tooltip
        const texts = this.texts || {}

        const padding = 2
        const fontSize = 12

        //make svg element
        const svg = this.div
            .append('svg')
            .attr('width', w + selectionStrokeWidth)
            .attr('height', h + 4 * padding + 2 * fontSize)

        //top label
        svg.append('text')
            .attr('x', w / 2)
            .attr('y', padding + fontSize)
            .text(this.topText)
            .attr('font-size', fontSize)
            .attr('text-anchor', 'middle')
        //left label
        svg.append('text')
            .attr('x', 0)
            .attr('y', 3 * padding + 2 * fontSize + h)
            .text(this.leftText)
            .attr('font-size', fontSize)
            .attr('text-anchor', 'start')
        //right label
        svg.append('text')
            .attr('x', w)
            .attr('y', 3 * padding + 2 * fontSize + h)
            .text(this.rightText)
            .attr('font-size', fontSize)
            .attr('text-anchor', 'end')

        //triangle group
        const g = svg
            .append('g')
            .attr(
                'transform',
                'translate(' +
                    selectionStrokeWidth / 2 +
                    ' ' +
                    (selectionStrokeWidth / 2 + (2 * padding + fontSize)) +
                    ')'
            )

        //common function for triangle patches
        const setAttributes = (elt, color, text) => {
            //elt.raise();
            elt.attr('fill', color)
                //.attr("stroke", colorOver)
                //.attr("stroke-width", 0)
                //.attr("stroke-linejoin", "round")
                .on('mouseover', function (e) {
                    /*this.parentNode.appendChild(this); select(this).attr("stroke-width", selectionStrokeWidth);*/
                    ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this).attr('fill', selectionColor)
                    if (!tt || !text) return
                    tt.html(text)
                    tt.setPosition(e)
                    tt.show()
                })
                .on('mouseout', function () {
                    /*select(this).attr("stroke-width", 0);*/
                    (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(this).attr('fill', color)
                    if (tt) tt.hide()
                })
            if (tt && text)
                elt.on('mousemove', function (e) {
                    tt.setPosition(e)
                })
        }

        //const [c0, c1, c2] = classifier.center

        //trapezium s0
        const t0 = g
            .append('polygon')
            .attr(
                'points',
                '0,' +
                    h +
                    ' ' +
                    w / 3 +
                    ',' +
                    h +
                    ' ' +
                    w / 2 +
                    ',' +
                    (h * 2) / 3 +
                    ' ' +
                    w / 6 +
                    ',' +
                    (h * 2) / 3
            )
        setAttributes(t0, classifier.colors[0], texts['0'])
        //trapezium s1
        const t1 = g
            .append('polygon')
            .attr(
                'points',
                w / 2 +
                    ',0 ' +
                    (w * 2) / 3 +
                    ',' +
                    h / 3 +
                    ' ' +
                    w / 2 +
                    ',' +
                    (h * 2) / 3 +
                    ' ' +
                    w / 3 +
                    ',' +
                    h / 3
            )
        setAttributes(t1, classifier.colors[1], texts['1'])
        //trapezium s2
        const t2 = g
            .append('polygon')
            .attr(
                'points',
                w +
                    ',' +
                    h +
                    ' ' +
                    (w * 5) / 6 +
                    ',' +
                    (2 * h) / 3 +
                    ' ' +
                    w / 2 +
                    ',' +
                    (h * 2) / 3 +
                    ' ' +
                    (w * 2) / 3 +
                    ',' +
                    h
            )
        setAttributes(t2, classifier.colors[2], texts['2'])
        //triangle s0
        const t0_ = g
            .append('polygon')
            .attr(
                'points',
                w / 2 +
                    ',' +
                    (h * 2) / 3 +
                    ' ' +
                    (w * 5) / 6 +
                    ',' +
                    (h * 2) / 3 +
                    ' ' +
                    (w * 2) / 3 +
                    ',' +
                    h / 3
            )
        setAttributes(t0_, classifier.mixColors[0], texts['m12'])
        //triangle s1
        const t1_ = g
            .append('polygon')
            .attr('points', w / 2 + ',' + (h * 2) / 3 + ' ' + w / 3 + ',' + h + ' ' + (w * 2) / 3 + ',' + h)
        setAttributes(t1_, classifier.mixColors[1], texts['m02'])
        //triangle s2
        const t2_ = g
            .append('polygon')
            .attr(
                'points',
                w / 2 + ',' + (h * 2) / 3 + ' ' + w / 6 + ',' + (h * 2) / 3 + ' ' + w / 3 + ',' + h / 3
            )
        setAttributes(t2_, classifier.mixColors[2], texts['m01'])

        //center
        if (this.centerCoefficient) {
            //TODO make it an hexagon !
            const center = g
                .append('circle')
                .attr('cx', w / 2)
                .attr('cy', (h * 2) / 3)
                .attr('r', (this.centerCoefficient * h) / 3)
            setAttributes(center, classifier.centerColor, texts['center'])
        }

        /*
        let middle, left, top, right, left_, bottom_, right_
        if (!this.real) {

            //0 left triangle
            left = g.append('polygon')
                .attr('points', "0," + h + " " + (w / 3) + "," + h + " " + (w / 6) + "," + (2 * h / 3))
            //1 top triangle
            top = g.append('polygon')
                .attr('points', (w / 3) + "," + (h / 3) + " " + (w * 2 / 3) + "," + (h / 3) + " " + (w / 2) + ",0")
            //2 right triangle
            right = g.append('polygon')
                .attr('points', (w * 2 / 3) + "," + h + " " + w + "," + h + " " + (w * 5 / 6) + "," + (2 * h / 3))
            //middle triangle
            middle = g.append('polygon')
                .attr('points', (w / 2) + "," + (h / 3) + " " + (w / 4) + "," + (h * 5 / 6) + " " + (3 * w / 4) + "," + (h * 5 / 6))
            //01 left trapezium
            left_ = g.append('polygon')
                .attr('points', (w / 6) + "," + (h * 2 / 3) + " " + (w / 4) + "," + (h * 5 / 6) + " " + (w / 2) + "," + (h / 3) + " " + (w / 3) + "," + (h / 3))
            //02 bottom trapezium
            bottom_ = g.append('polygon')
                .attr('points', (w / 3) + "," + (h) + " " + (2 * w / 3) + "," + (h) + " " + (w * 3 / 4) + "," + (h * 5 / 6) + " " + (w / 4) + "," + (h * 5 / 6))
            //12 right trapezium
            right_ = g.append('polygon')
                .attr('points', (w / 2) + "," + (h / 3) + " " + (w * 3 / 4) + "," + (h * 5 / 6) + " " + (w * 5 / 6) + "," + (h * 2 / 3) + " " + (w * 2 / 3) + "," + (h / 3))

        } else {

            //middle triangle
            middle = g.append('polygon')
                .attr('points', (w / 2) + ",0 0," + h + " " + w + "," + h)

            //draw trapezium
            //draw large trapezium first
            for (let i_ = 2; i_ >= 0; i_--) {
                const i = this.classifier.lowIndex[i_]
                const r = this.classifier.lowThreshold[i]
                if (i == 2)
                    //01 left trapezium
                    left_ = g.append('polygon')
                        .attr('points', w / 2 + ",0 0," + h + " " + w * r + "," + h + " " + w * (1 + r) / 2 + "," + r * h)
                else if (i == 1)
                    //02 bottom trapezium
                    bottom_ = g.append('polygon')
                        .attr('points', "0," + h + " " + w + "," + h + " " + w * (1 - r / 2) + "," + h * (1 - r) + " " + r * w / 2 + "," + h * (1 - r))
                else
                    //12 right trapezium
                    right_ = g.append('polygon')
                        .attr('points', w + "," + h + " " + w / 2 + ",0 " + w * (1 - r) / 2 + "," + h * r + " " + w * (1 - r) + "," + h)
            }

            //draw triangles
            //draw large triangles first
            for (let i_ = 2; i_ >= 0; i_--) {
                const i = this.classifier.highIndex[i_]
                const r = this.classifier.highThreshold[i]

                if (i == 2)
                    //2 right triangle
                    right = g.append('polygon')
                        .attr('points', w + "," + h + " " + w * r + "," + h + " " + w * (1 + r) / 2 + "," + h * r)
                else if (i == 1)
                    //1 top triangle
                    top = g.append('polygon')
                        .attr('points', (w / 2) + ",0 " + w * r / 2 + "," + h * (1 - r) + " " + w * (1 - r / 2) + "," + h * (1 - r))
                else
                    //0 left triangle
                    left = g.append('polygon')
                        .attr('points', "0," + h + " " + w * (1 - r) + "," + h + " " + w * (1 - r) / 2 + "," + h * r)
            }

        }*/
    }
}


/***/ }),

/***/ "./src/style/CompositionStyle.js":
/*!***************************************!*\
  !*** ./src/style/CompositionStyle.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CompositionStyle: () => (/* binding */ CompositionStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
//@ts-check


;

/** @typedef {"flag"|"piechart"|"ring"|"segment"|"radar"|"agepyramid"|"halftone"} CompositionType */

/**
 * A style showing the composition of a total in different categories, with different color hues.
 * It consists of a symbol with different parts, whose size reflect the proportion of the corresponding category.
 * For a list of supported symbols, @see CompositionType
 * The symbol can be scaled depending on the cell importance.
 *
 * @module style
 * @author Julien Gaffuri
 */
class CompositionStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        this.color = opts.color

        /**
         * A function returning the type of decomposition symbol of a cell, @see CompositionType
         * @type {function(import("../core/Dataset.js").Cell,number, number,object):CompositionType} */
        this.type = opts.type || (() => 'flag') //(c,r,z,vs) => {}

        /** A function returning the size of a cell in geographical unit.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.size = opts.size || ((c, r) => r) //(c,r,z,vs) => {}

        /** For style types with stripes (flag, segment), the orientation of the stripes (0 for horizontal, other for vertical).
         * @type {function(import("../core/Dataset.js").Cell,number,number,object):number} */
        this.stripesOrientation = opts.stripesOrientation || (() => 0) //(c,r,z,vs) => ...

        /** The function specifying an offset angle for a radar, halftone or pie chart style.
         * The angle is specified in degree. The rotation is anti-clockwise.
         * @type {function(import("../core/Dataset.js").Cell,number,number,object):number} */
        this.offsetAngle = opts.offsetAngle || (() => 0) //(c,r,z,vs) => ...

        /** The function specifying the height of the age pyramid, in geo unit.
         * @type {function(import("../core/Dataset.js").Cell,number,number,object):number} */
        this.agePyramidHeight = opts.agePyramidHeight || ((c, r) => r) //(c,r,z,vs) => ...

        /** For pie chart, this is parameter for internal radius, so that the pie chart looks like a donut.
         * 0 for normal pie charts, 0.5 to empty half of the radius.
         * @type {number} */
        this.pieChartInternalRadiusFactor = opts.pieChartInternalRadiusFactor || 0
    }

    /**
     * Draw cells as squares depending on their value.
     *
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //nb categories - used for radar and agepyramid
        const nbCat = Object.entries(this.color).length

        //draw calls
        for (let cell of cells) {
            //size
            const sG = this.size ? this.size(cell, resolution, z, viewScale) : resolution
            if (!sG) continue

            //get offset
            const offset = this.offset(cell, resolution, z)

            //get symbol type
            const type_ = this.type ? this.type(cell, resolution, z, viewScale) : 'flag'

            //compute center position
            const xc = cell.x + offset.dx + (type_ === 'agepyramid' ? 0 : resolution * 0.5)
            const yc = cell.y + offset.dy + (type_ === 'agepyramid' ? 0 : resolution * 0.5)

            //compute offset angle, when relevant
            const offAng = this.offsetAngle
                ? (this.offsetAngle(cell, resolution, z, viewScale) * Math.PI) / 180
                : 0

            if (type_ === 'agepyramid' || type_ === 'radar' || type_ === 'halftone') {
                //get cell category max value
                let maxVal = -Infinity
                for (let key of Object.keys(this.color)) {
                    const v = +cell[key]
                    if (v > maxVal) maxVal = v
                }

                //cumul
                let cumul = 0
                if (type_ === 'agepyramid' && this.agePyramidHeight)
                    cumul = (resolution - this.agePyramidHeight(cell, resolution, z, viewScale)) / 2
                if (type_ === 'radar' || type_ === 'halftone') cumul = Math.PI / 2 + offAng

                //compute the increment, which is the value to increment the cumul for each category
                const incr =
                    type_ === 'agepyramid'
                        ? (this.agePyramidHeight
                              ? this.agePyramidHeight(cell, resolution, z, viewScale)
                              : resolution) / nbCat
                        : type_ === 'radar' || type_ === 'halftone'
                        ? (2 * Math.PI) / nbCat
                        : undefined
                if (incr === undefined) throw new Error('Unexpected symbol type:' + type_)

                for (let [column, color] of Object.entries(this.color)) {
                    if (type_ === 'agepyramid') {
                        //set category color
                        ctx.fillStyle = color

                        //get category value
                        const val = cell[column]

                        //compute category length - in geo
                        /** @type {number} */
                        const wG = (sG * val) / maxVal

                        //draw bar
                        ctx.fillRect(xc + (resolution - wG) / 2, yc + cumul, wG, incr)

                        //next height
                        cumul += incr
                    } else if (type_ === 'radar') {
                        //set category color
                        ctx.fillStyle = color

                        //get categroy value
                        const val = cell[column]

                        //compute category radius - in geo
                        /** @type {number} */
                        //const rG = this.radius(val, r, stat, cellStat, z)
                        const rG = (sG / 2) * Math.sqrt(val / maxVal)

                        //draw angular sector
                        ctx.beginPath()
                        ctx.moveTo(xc, yc)
                        ctx.arc(xc, yc, rG, cumul - incr, cumul)
                        ctx.lineTo(xc, yc)
                        ctx.fill()

                        //next angular sector
                        cumul += incr
                    } else if (type_ === 'halftone') {
                        //set category color
                        ctx.fillStyle = color

                        //get categroy value
                        const val = cell[column]

                        //compute category radius - in geo
                        /** @type {number} */
                        const rG = sG * 0.333 * Math.sqrt(val / maxVal)

                        //draw circle
                        ctx.beginPath()
                        ctx.arc(
                            xc + resolution * 0.25 * Math.cos(cumul),
                            yc + resolution * 0.25 * Math.sin(cumul),
                            rG,
                            0,
                            2 * Math.PI
                        )
                        ctx.fill()

                        //next angular sector
                        cumul += incr
                    } else {
                        throw new Error('Unexpected symbol type:' + type_)
                    }
                }
            } else {
                //compute total
                let total = 0
                for (let column of Object.keys(this.color)) {
                    const v = +cell[column]
                    if (!v) continue
                    total += v
                }
                if (!total || isNaN(total)) continue

                //draw decomposition symbol
                let cumul = 0
                const d = resolution * (1 - sG / resolution) * 0.5
                const ori = this.stripesOrientation(cell, resolution, z, viewScale)

                for (let [column, color] of Object.entries(this.color)) {
                    //get share
                    const share = cell[column] / total
                    if (!share || isNaN(share)) continue

                    //set color
                    ctx.fillStyle = color

                    //draw symbol part
                    if (type_ === 'flag') {
                        //draw flag stripe
                        if (ori == 0) {
                            //horizontal
                            ctx.fillRect(
                                cell.x + d + offset.dx,
                                cell.y + d + cumul * sG + offset.dy,
                                sG,
                                share * sG
                            )
                        } else {
                            //vertical
                            ctx.fillRect(
                                cell.x + d + cumul * sG + offset.dx,
                                cell.y + d + offset.dy,
                                share * sG,
                                sG
                            )
                        }
                    } else if (type_ === 'piechart') {
                        //draw pie chart angular sector

                        //compute angles
                        const a1 = cumul * 2 * Math.PI
                        const a2 = (cumul + share) * 2 * Math.PI

                        //draw
                        ctx.beginPath()
                        ctx.moveTo(xc, yc)
                        ctx.arc(xc, yc, sG * 0.5, a1 + offAng, a2 + offAng)
                        if (this.pieChartInternalRadiusFactor)
                            ctx.arc(
                                xc,
                                yc,
                                sG * 0.5 * this.pieChartInternalRadiusFactor,
                                a1 + offAng,
                                a2 + offAng,
                                true
                            )
                        ctx.closePath()
                        ctx.fill()
                    } else if (type_ === 'ring') {
                        //draw ring
                        ctx.beginPath()
                        ctx.arc(xc, yc, Math.sqrt(1 - cumul) * sG * 0.5, 0, 2 * Math.PI)
                        ctx.fill()
                    } else if (type_ === 'segment') {
                        //draw segment sections
                        const wG = (sG * sG) / resolution
                        if (ori == 0) {
                            //horizontal
                            ctx.fillRect(
                                cell.x + offset.dx,
                                cell.y + (resolution - wG) / 2 + cumul * wG + offset.dy,
                                resolution,
                                share * wG
                            )
                        } else {
                            //vertical
                            ctx.fillRect(
                                cell.x + cumul * resolution + offset.dx,
                                cell.y + (resolution - wG) / 2 + offset.dy,
                                share * resolution,
                                wG
                            )
                        }
                    } else {
                        throw new Error('Unexpected symbol type:' + type_)
                    }

                    cumul += share
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./src/style/DotDensityStyle.js":
/*!**************************************!*\
  !*** ./src/style/DotDensityStyle.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DotDensityStyle: () => (/* binding */ DotDensityStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
/* harmony import */ var d3_random__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-random */ "./node_modules/d3-random/src/normal.js");
/* harmony import */ var _utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/webGLUtils.js */ "./src/utils/webGLUtils.js");
/* harmony import */ var _utils_WebGLSquareColoring_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/WebGLSquareColoring.js */ "./src/utils/WebGLSquareColoring.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;





/**
 *
 * @module style
 * @author Julien Gaffuri
 */
class DotDensityStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the number of dots for a cell value.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.dotNumber = opts.dotNumber || ((cell, resolution) => resolution / 100) //(c,r,z,vs) => {}

        /** The color of the dots. Same color for all dots within a cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => '#FF5733') //(c,r,z,vs) => {}

        /** A function returning the size of the dots, in geo unit. Same size for all cells.
         * @type {function(number, number,object):number} */
        this.dotSize = opts.dotSize || ((resolution, z) => 1.5 * z) //(c,r,z,vs) => {}

        /** A function returning the sigma of the dots distribution. Same value for all cells.
         * @type {function(number, number,object):number} */
        this.sigma = opts.sigma || ((resolution, z) => resolution / 2) //(c,r,z,vs) => {}
    }

    /**
     * Draw cells as text.
     *
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //get size
        const sGeo = this.dotSize ? this.dotSize(resolution, z, viewScale) : z

        //make random function
        const sig = this.sigma ? this.sigma(resolution, z, viewScale) : resolution * 0.4
        const rand = (0,d3_random__WEBPACK_IMPORTED_MODULE_1__["default"])(0, sig)

        const ctx = geoCanvas.offscreenCtx

        if ((0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_2__.checkWebGLSupport)()) {
            //create canvas and webgl renderer
            const cvWGL = (0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_2__.makeWebGLCanvas)(geoCanvas.w + '', geoCanvas.h + '')
            if (!cvWGL) {
                console.error('No webGL')
                return
            }

            //create webGL program
            const prog = new _utils_WebGLSquareColoring_js__WEBPACK_IMPORTED_MODULE_3__.WebGLSquareColoring(cvWGL.gl, sGeo / z)

            const r2 = resolution / 2

            for (let cell of cells) {
                //get color
                const col = this.color(cell, resolution, z, viewScale)
                if (!col || col === 'none') continue

                //number of dots
                const dotNumber = this.dotNumber(cell, resolution, z, viewScale)

                //get offset
                const offset = this.offset(cell, resolution, z)

                //cell center
                const cx = cell.x + offset.dx + r2
                const cy = cell.y + offset.dy + r2

                //convert color
                const cc = (0,d3_color__WEBPACK_IMPORTED_MODULE_4__["default"])(col)
                if (!cc) return

                //random points
                for (let i = 0; i <= dotNumber; i++)
                    prog.addPointData2(cx + rand(), cy + rand(), cc.r, cc.g, cc.b, cc.opacity)
            }

            //draw
            prog.draw(geoCanvas.getWebGLTransform())

            //draw in canvas geo
            geoCanvas.initCanvasTransform()
            ctx.drawImage(cvWGL.canvas, 0, 0)
        } else {
            for (let cell of cells) {
                //get color
                const col = this.color(cell, resolution, z, viewScale)
                if (!col || col === 'none') continue
                //set color
                ctx.fillStyle = col

                //number of dots
                const dotNumber = this.dotNumber(cell, resolution, z, viewScale)

                //get offset
                const offset = this.offset(cell, resolution, z)

                //draw random dots
                const cx = cell.x + offset.dx + resolution / 2,
                    cy = cell.y + offset.dy + resolution / 2
                for (let i = 0; i <= dotNumber; i++) {
                    ctx.fillRect(cx + rand(), cy + rand(), sGeo, sGeo)
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./src/style/ImageStyle.js":
/*!*********************************!*\
  !*** ./src/style/ImageStyle.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ImageStyle: () => (/* binding */ ImageStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Julien Gaffuri
 */
class ImageStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the image URL of a cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.image = opts.image || (() => '') //(c,r,z,vs) => {}

        /** The image size in ground meters
         *  @type {function(import('../core/Dataset.js').Cell, number, number, object):number}        */
        this.size = opts.size || ((cell, resolution) => resolution)

        /** Dictionnary of preloaded images. url -> image
         * @private
         * @type {object} */
        this.cache = {}
    }

    /**
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     * @override
     */
    async draw(cells, geoCanvas, resolution) {
        //
        const z = geoCanvas.view.z,
            resolutionPix = resolution / z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //draw in screen coordinates
        geoCanvas.initCanvasTransform()

        //
        for (let cell of cells) {
            //get cell image url
            const url = this.image(cell, resolution, z, viewScale)
            if (!url) continue

            //size and position values
            let sizePix = this.size(cell, resolution, z, viewScale) / z
            if (!sizePix) continue

            //get image from cache
            const image = this.cache[url]

            //loading, keep waiting
            if (image == 'loading') return
            //no image: load it
            else if (!image) {
                //tag as loading
                this.cache[url] = 'loading'

                //define image
                const img = new Image()
                img.onload = () => {
                    //store image data in cache and redraw
                    this.cache[url] = img
                    geoCanvas.redraw()
                }
                img.onerror = () => {
                    //case when no image
                    console.warn('Could not retrieve image from', url)
                }
                //set URL to launch the download
                img.src = url
            } else {
                //draw image
                const d = (resolutionPix - sizePix) / 2
                try {
                    geoCanvas.offscreenCtx.drawImage(
                        image,
                        geoCanvas.geoToPixX(cell.x) + d,
                        geoCanvas.geoToPixY(cell.y) + d - resolutionPix,
                        sizePix,
                        sizePix
                    )
                } catch (error) {
                    console.error(error)
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./src/style/IsoFenceStyle.js":
/*!************************************!*\
  !*** ./src/style/IsoFenceStyle.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IsoFenceStyle: () => (/* binding */ IsoFenceStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
/* harmony import */ var _SideStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SideStyle.js */ "./src/style/SideStyle.js");
//@ts-check


;


/** @typedef {{x:number,y:number,or:"v"|"h",c1:import('../core/Dataset.js').Cell|undefined,c2:import('../core/Dataset.js').Cell|undefined}} Side */

/**
 * @module style
 * @author Julien Gaffuri
 */
class IsoFenceStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        this.color = opts.color

        /** A function returning the height of a cell in geographical unit.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.height = opts.height || ((cell, resolution, z, viewScale) => resolution * 0.4)

        /** The perspective angle, in degree, within [-180,180], from [O,x] axis.
         * @type {number} */
        this.angle = opts.angle != undefined ? opts.angle : 50

        /** A function returning the corner line stroke style.
         * @type {function(import('../core/Dataset.js').Cell,number,number,number):string} */
        this.cornerLineStrokeColor = opts.cornerLineStrokeColor || ((c, r, z, angle) => '#999')

        /** A function returning the corner line width.
         * @type {function(import('../core/Dataset.js').Cell,number,number,number):number} */
        this.cornerLineWidth = opts.cornerLineWidth || ((c, r, z, angle) => (angle % 90 == 0 ? 0 : 0.8 * z))

        /**
         * Show vertical cross-sections.
         * @type {boolean} */
        this.sVert = opts.sVert != undefined ? opts.sVert : true

        /**
         * Show horizontal cross-sections.
         * @type {boolean} */
        this.sHor = opts.sHor != undefined ? opts.sHor : true
    }

    /**
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     * @override
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //nb categories - used for radar and agepyramid
        const cats = Object.keys(this.color)

        //half resolution
        const r2 = resolution / 2

        //get offset
        // @ts-ignore
        const offset = this.offset(undefined, resolution, z),
            dx = offset.dx,
            dy = offset.dy

        //make sides
        /**  @type {Array.<Side>} */
        const sides = _SideStyle_js__WEBPACK_IMPORTED_MODULE_1__.SideStyle.buildSides(
            cells,
            resolution,
            this.angle % 180 != 90 && this.sVert,
            this.angle % 180 != 0 && this.sHor
        )

        //
        if (sides.length == 0) return

        //angle in radians
        const aRad = (this.angle * Math.PI) / 180,
            cos = Math.cos(aRad),
            sin = Math.sin(aRad)

        //sort sides so that the back ones are drawn first. This depends on the angle.
        //depending on distance to the reference corner point
        const xCorner = Math.abs(this.angle) < 90 ? geoCanvas.extGeo.xMin : geoCanvas.extGeo.xMax
        const yCorner = this.angle < 0 ? geoCanvas.extGeo.yMax : geoCanvas.extGeo.yMin
        sides.sort(
            (s1, s2) =>
                Math.hypot(s2.x - xCorner, s2.y - yCorner) - Math.hypot(s1.x - xCorner, s1.y - yCorner)
        )

        //prepare function to draw corner line for a cell *c*
        const drawCornerLine = (cell) => {
            if (!cell) return
            //line style
            const lw = this.cornerLineWidth ? this.cornerLineWidth(cell, resolution, z, this.angle) : 0.8 * z
            if (lw == 0) return
            ctx.strokeStyle = this.cornerLineStrokeColor
                ? this.cornerLineStrokeColor(cell, resolution, z, this.angle)
                : '#333'
            ctx.lineWidth = lw

            //height - in geo
            const hG = this.height(cell, resolution, z, viewScale)

            //draw line
            ctx.beginPath()
            ctx.moveTo(cell.x + r2 + dx, cell.y + r2 + dy)
            ctx.lineTo(cell.x + r2 + hG * cos + dx, cell.y + r2 + hG * sin + dy)
            ctx.stroke()
        }

        //draw sides
        ctx.lineCap = 'round'
        for (let side of sides) {
            const c1 = side.c1,
                c2 = side.c2,
                x = side.x,
                y = side.y

            //heights - in geo
            const hG1 = c1 ? this.height(c1, resolution, z, viewScale) : 0,
                hG2 = c2 ? this.height(c2, resolution, z, viewScale) : 0

            //compute totals for both cells
            const total1 = computeTotal(c1, cats),
                total2 = computeTotal(c2, cats)
            if (total1 == 0 && total2 == 0) continue

            let cumul1 = 0,
                cumul2 = 0
            for (let [column, color] of Object.entries(this.color)) {
                //draw stripe of side s and category column

                //get values for both cells
                let v1 = c1 ? +c1[column] : 0
                let v2 = c2 ? +c2[column] : 0
                if (v1 == 0 && v2 == 0) continue

                //compute heights
                const h1 = (hG1 * cumul1) / total1 || 0
                const h1n = (hG1 * (cumul1 + v1)) / total1 || 0
                const h2 = (hG2 * cumul2) / total2 || 0
                const h2n = (hG2 * (cumul2 + v2)) / total2 || 0

                //make path
                ctx.beginPath()
                if (side.or == 'h') {
                    //horizontal side - vertical section
                    //bottom left
                    ctx.moveTo(x + h1 * cos + dx, y - r2 + h1 * sin + dy)
                    //top left
                    ctx.lineTo(x + h2 * cos + dx, y + r2 + h2 * sin + dy)
                    //top right
                    ctx.lineTo(x + h2n * cos + dx, y + r2 + h2n * sin + dy)
                    //bottom right
                    ctx.lineTo(x + h1n * cos + dx, y - r2 + h1n * sin + dy)
                } else {
                    //vertical side - horizontal section
                    //bottom left
                    ctx.moveTo(x - r2 + h1 * cos + dx, y + h1 * sin + dy)
                    //bottom right
                    ctx.lineTo(x + r2 + h2 * cos + dx, y + h2 * sin + dy)
                    //top right
                    ctx.lineTo(x + r2 + h2n * cos + dx, y + h2n * sin + dy)
                    //top left
                    ctx.lineTo(x - r2 + h1n * cos + dx, y + h1n * sin + dy)
                }
                //cg.ctx.closePath()

                //fill
                ctx.fillStyle = color
                ctx.fill()

                cumul1 += v1
                cumul2 += v2

                //TODO draw only one line
                //draw corner line
                //if (side.or == "h") {
                drawCornerLine(c1)
                drawCornerLine(c2)
                //if (this.angle > 0 && side.or == "h") drawCornerLine(c2)
                //else drawCornerLine(c2)
                //}
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}

const computeTotal = (cell, categories) => {
    if (!cell) return 0
    let total = 0
    for (let column of categories) {
        const v = cell[column]
        if (!v) continue
        total += +v
    }
    return total || 0
}


/***/ }),

/***/ "./src/style/JoyPlotStyle.js":
/*!***********************************!*\
  !*** ./src/style/JoyPlotStyle.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JoyPlotStyle: () => (/* binding */ JoyPlotStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Julien Gaffuri
 */
class JoyPlotStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the height of a cell in geographical unit.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.height = opts.height || ((c, r) => r * Math.random()) //(c,r,z,vs) => {}

        /**
         * @type {function(number,{min:number, max:number},number,number):string} */
        this.lineColor = opts.lineColor || ((y, ys, r, z) => '#BBB')
        /**
         * @type {function(number,{min:number, max:number},number,number):number} */
        this.lineWidth = opts.lineWidth || ((y, ys, r, z) => z)
        /**
         * @type {function(number,{min:number, max:number},number,number):string} */
        this.fillColor = opts.fillColor || ((y, ys, r, z) => '#c08c5968')
    }

    /**
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     * @override
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //index cells by y and x
        /**  @type {object} */
        const ind = {}
        for (const cell of cells) {
            let row = ind[cell.y]
            if (!row) {
                row = {}
                ind[cell.y] = row
            }
            row[cell.x] = this.height(cell, resolution, z, viewScale)
        }

        //compute extent
        const e = geoCanvas.extGeo
        if (!e) return
        const xMin = Math.floor(e.xMin / resolution) * resolution
        const xMax = Math.floor(e.xMax / resolution) * resolution
        const yMin = Math.floor(e.yMin / resolution) * resolution
        const yMax = Math.floor(e.yMax / resolution) * resolution

        /**  @type {{min:number, max:number}} */
        const ys = { min: yMin, max: yMax }

        //draw lines, row by row, stating from the top
        ctx.lineJoin = 'round'
        for (let y = yMax; y >= yMin; y -= resolution) {
            //get row
            const row = ind[y]

            //no row
            if (!row) continue

            //place first point
            ctx.beginPath()
            ctx.moveTo(xMin - resolution / 2, y)

            //store the previous height
            /** @type {number|undefined} */
            let hG_

            //go through the line cells
            for (let x = xMin; x <= xMax; x += resolution) {
                //get column value
                /** @type {number} */
                let hG = row[x]
                if (!hG) hG = 0

                if (hG || hG_) {
                    //draw line only when at least one of both values is non-null
                    //TODO test bezierCurveTo
                    ctx.lineTo(x + resolution / 2, y + hG)
                } else {
                    //else move the point
                    ctx.moveTo(x + resolution / 2, y)
                }
                //store the previous value
                hG_ = hG
            }

            //last point
            if (hG_) ctx.lineTo(xMax + resolution / 2, y)

            //draw fill
            const fc = this.fillColor(y, ys, resolution, z)
            if (fc && fc != 'none') {
                ctx.fillStyle = fc
                ctx.fill()
            }

            //draw line
            const lc = this.lineColor(y, ys, resolution, z)
            const lw = this.lineWidth(y, ys, resolution, z)
            if (lc && lc != 'none' && lw > 0) {
                ctx.strokeStyle = lc
                ctx.lineWidth = lw
                ctx.stroke()
            }
        }
    }
}


/***/ }),

/***/ "./src/style/LegoStyle.js":
/*!********************************!*\
  !*** ./src/style/LegoStyle.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LegoStyle: () => (/* binding */ LegoStyle)
/* harmony export */ });
/* harmony import */ var _TanakaStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TanakaStyle.js */ "./src/style/TanakaStyle.js");
/* harmony import */ var _StrokeStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StrokeStyle.js */ "./src/style/StrokeStyle.js");
/* harmony import */ var _SquareColorCategoryWebGLStyle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SquareColorCategoryWebGLStyle.js */ "./src/style/SquareColorCategoryWebGLStyle.js");
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
//@ts-check


;




/**
 * @module style
 * @author Julien Gaffuri
 */
class LegoStyle {
    static get(value, breaks, colors, opts = {}) {
        opts = opts || {}

        //the colors
        //http://www.jennyscrayoncollection.com/2021/06/all-current-lego-colors.html
        //https://leonawicz.github.io/legocolors/reference/figures/README-plot-1.png
        /*opts.colors = opts.colors || [
            '#00852b', //darker green
            '#afd246', //light green
            '#fac80a', //dark yellow
            '#bb805a', //brown
            '#d67923', //mostard
            '#cb4e29', //redish
            '#b40000', //red
            '#720012', //dark red
            //"purple",
            //"#eee" //whithe
        ]*/

        opts.colDark = opts.colDark || '#333'
        opts.colBright = opts.colBright || '#aaa'
        opts.widthFactor = opts.widthFactor || 0.12

        //reuse tanaka as basis
        const ts = _TanakaStyle_js__WEBPACK_IMPORTED_MODULE_0__.TanakaStyle.get(value, breaks, colors, opts)
        //style to show limits between pieces
        const sst = new _StrokeStyle_js__WEBPACK_IMPORTED_MODULE_1__.StrokeStyle({
            strokeColor: () => '#666',
            strokeWidth: (c, r, z) => 0.2 * z,
            filter: opts.filter,
        })

        return [
            ts[0],
            sst,
            ts[1],
            new LegoTopStyle({ colDark: opts.colDark, colBright: opts.colBright, filter: opts.filter }),
        ]
    }

    /**
     * @param {function(import('../core/Dataset.js').Cell):string} code
     * @param {object} color
     * @param {object} opts
     * @returns {Array.<Style>}
     */
    static getCategory(code, color, opts) {
        opts = opts || {}

        opts.colDark = opts.colDark || '#333'
        opts.colBright = opts.colBright || '#aaa'

        //
        const s = new _SquareColorCategoryWebGLStyle_js__WEBPACK_IMPORTED_MODULE_2__.SquareColorCategoryWebGLStyle({ code: code, color: color })
        //style to show limits between pieces
        const sst = new _StrokeStyle_js__WEBPACK_IMPORTED_MODULE_1__.StrokeStyle({ strokeColor: () => '#666', strokeWidth: (c, r, z) => 0.2 * z })

        return [s, sst, new LegoTopStyle({ colDark: opts.colDark, colBright: opts.colBright })]
    }
}

/**
 * A style to draw top circle of lego bricks.
 */
class LegoTopStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_3__.Style {
    /** @param {object|undefined} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}
        this.colDark = opts.colDark || '#333'
        this.colBright = opts.colBright || '#aaa'
    }

    draw(cells, geoCanvas, r) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)
        const ctx = geoCanvas.offscreenCtx

        ctx.lineWidth = 0.6 * geoCanvas.view.z

        //dark part
        ctx.strokeStyle = this.colDark
        for (let c of cells) {
            ctx.beginPath()
            ctx.arc(c.x + r * 0.5, c.y + r * 0.5, r * 0.55 * 0.5, Math.PI / 4, -Math.PI * (3 / 4), true)
            ctx.stroke()
        }

        //bright part
        ctx.strokeStyle = this.colBright
        for (let c of cells) {
            ctx.beginPath()
            ctx.arc(c.x + r * 0.5, c.y + r * 0.5, r * 0.55 * 0.5, Math.PI / 4, -Math.PI * (3 / 4), false)
            ctx.stroke()
        }
    }
}


/***/ }),

/***/ "./src/style/MosaicStyle.js":
/*!**********************************!*\
  !*** ./src/style/MosaicStyle.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MosaicStyle: () => (/* binding */ MosaicStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Julien Gaffuri
 */
class MosaicStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the color of the cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => '#EA6BAC') //(c,r,z,vs) => {}

        /** The mosaic factor, within [0,0.5]. Set to 0 for no mosaic effect. Set to 0.5 for strong mosaic effect.
         * @type {number} */
        this.mosaicFactor = opts.mosaicFactor || 0.15

        /** The mosaic shadow factor, within [0,0.5]. Set to 0 for no mosaic shadow. Set to 0.5 for strong mosaic shadow.
         * @type {number} */
        this.shadowFactor = opts.shadowFactor || 0.2

        /** The mosaic shadow color.
         * @type {string} */
        this.shadowColor = opts.shadowColor || '#555'
    }

    /**
     *
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //set stroke style, for shadow
        ctx.strokeStyle = this.shadowColor
        ctx.lineWidth = this.shadowFactor * resolution
        ctx.lineJoin = 'round'
        ctx.lineCap = 'butt'

        //function to compute position mosaic effect
        const d = resolution * this.mosaicFactor
        const mosaic = () => {
            return { x: Math.random() * d, y: Math.random() * d }
        }

        for (let cell of cells) {
            //set fill color
            const col = this.color ? this.color(cell, resolution, z, viewScale) : undefined
            if (!col || col === 'none') continue
            ctx.fillStyle = col

            //get offset
            const offset = this.offset(cell, resolution, z)

            //compute position mosaic effect
            const ll = mosaic(),
                ul = mosaic(),
                lr = mosaic(),
                ur = mosaic()

            //stroke
            if (this.shadowFactor > 0) {
                ctx.beginPath()
                ctx.moveTo(cell.x + offset.dx + ll.x, cell.y + offset.dy + ll.y)
                ctx.lineTo(cell.x + offset.dx + resolution - lr.x, cell.y + offset.dy + lr.y)
                ctx.lineTo(cell.x + offset.dx + resolution - ur.x, cell.y + offset.dy + resolution - ur.y)
                ctx.stroke()
            }

            //fill

            ctx.beginPath()
            ctx.moveTo(cell.x + offset.dx + ll.x, cell.y + offset.dy + ll.y)
            ctx.lineTo(cell.x + offset.dx + resolution - lr.x, cell.y + offset.dy + lr.y)
            ctx.lineTo(cell.x + offset.dx + resolution - ur.x, cell.y + offset.dy + resolution - ur.y)
            ctx.lineTo(cell.x + offset.dx + ul.x, cell.y + offset.dy + resolution - ul.y)
            ctx.fill()
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./src/style/NinjaStarStyle.js":
/*!*************************************!*\
  !*** ./src/style/NinjaStarStyle.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NinjaStarStyle: () => (/* binding */ NinjaStarStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Joseph Davies, Julien Gaffuri
 */
class NinjaStarStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the color of the cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => '#EA6BAC') //(c,r,z,vs) => {}

        /** A function returning the size of a cell, within [0,1]:
         *  - 0, nothing shown
         *  - 1, entire square
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.size = opts.size || ((cell, resolution) => resolution) //(c,r,z,vs) => {}

        /** A function returning the shape.
         * @type {function(import("../core/Dataset").Cell):string} */
        this.shape = opts.shape || (() => 'o')
    }

    /**
     *
     * @param {Array.<import('../core/Dataset.js').Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        const r2 = resolution * 0.5
        for (let cell of cells) {
            //color
            const col = this.color ? this.color(cell, resolution, z, viewScale) : undefined
            if (!col || col === 'none') continue
            ctx.fillStyle = col

            //size - in geo unit
            let k = this.size(cell, resolution, z, viewScale)
            k = k < 0 ? 0 : k > 1 ? 1 : k
            const sG2 = k * r2

            //shape
            const shape = this.shape ? this.shape(cell) : 'o'
            if (shape === 'none') continue

            //get offset
            //TODO use
            //const offset = this.offset(cell, r, z)

            //center position
            const cx = cell.x + r2
            const cy = cell.y + r2

            if (shape === 'p') {
                ctx.beginPath()
                ctx.moveTo(cx, cy + r2)
                ctx.lineTo(cx + sG2, cy + sG2)
                ctx.lineTo(cx + r2, cy)
                ctx.lineTo(cx + sG2, cy - sG2)
                ctx.lineTo(cx, cy - r2)
                ctx.lineTo(cx - sG2, cy - sG2)
                ctx.lineTo(cx - r2, cy)
                ctx.lineTo(cx - sG2, cy + sG2)
                ctx.fill()
            } else if (shape === 'o') {
                ctx.beginPath()
                ctx.moveTo(cx, cy + sG2)
                ctx.lineTo(cx + r2, cy + r2)
                ctx.lineTo(cx + sG2, cy)
                ctx.lineTo(cx + r2, cy - r2)
                ctx.lineTo(cx, cy - sG2)
                ctx.lineTo(cx - r2, cy - r2)
                ctx.lineTo(cx - sG2, cy)
                ctx.lineTo(cx - r2, cy + r2)
                ctx.fill()
            } else {
                throw new Error('Unexpected shape:' + shape)
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./src/style/PillarStyle.js":
/*!**********************************!*\
  !*** ./src/style/PillarStyle.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PillarStyle: () => (/* binding */ PillarStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Julien Gaffuri
 */
class PillarStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the height of the line representing a cell, in geo unit
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.height = opts.height

        /** A function returning the color of the line representing a cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => '#c08c59') //(c,r,z,vs) => {}

        /** A function returning the width of the line representing a cell, in geo unit
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.width = opts.width || ((cell, resolution) => 0.5 * resolution)

        /** A function returning the width of the line representing a cell, in geo unit
         * @type {function(number, number,object):boolean} */
        this.simple = opts.simple || (() => false)

        /** @type {number} */
        this.viewHeightFactor = opts.viewHeightFactor || 1.5
        //0,0 is the center
        /** @type {number} */
        this.viewSX = opts.viewSX == undefined ? 0 : opts.viewSX
        /** @type {number} */
        this.viewSY = opts.viewSY == undefined ? -0.5 : opts.viewSY

        //TODO replace with sun location ?
        /** @type {number} */
        this.shadowDirection =
            opts.shadowDirection == undefined ? (-40.3 * Math.PI) / 180.0 : opts.shadowDirection
        /** @type {number} */
        this.shadowFactor = opts.shadowFactor || 0.3
        /** @type {string} */
        this.shadowColor = opts.shadowColor || '#00000033'

        /** @type {string} */
        this.outlineCol = opts.outlineCol || '#FFFFFF'
        /** @type {number} */
        this.outlineWidthPix = opts.outlineWidthPix == undefined ? 0.5 : opts.outlineWidthPix
    }

    /**
     * Draw cells as segments.
     *
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //get view center geo position
        const cvx = geoCanvas.view.x + this.viewSX * geoCanvas.w * z
        const cvy = geoCanvas.view.y + this.viewSY * geoCanvas.h * z
        //get view height
        const H = this.viewHeightFactor * (geoCanvas.w + geoCanvas.h) * 0.5 * z

        //sort cells by y and x
        //const distToViewCenter = (c) => { const dx = cvx - c.x, dy = cvy - c.y; return Math.sqrt(dx * dx + dy * dy) }
        cells.sort((c1, c2) => 100000000 * (c2.y - c1.y) + c1.x - c2.x)

        //get simple information
        const simple = this.simple(resolution, z, viewScale)

        ctx.lineCap = simple ? 'butt' : 'round'

        //draw shadows
        ctx.strokeStyle = this.shadowColor
        ctx.fillStyle = this.shadowColor
        for (let cell of cells) {
            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(cell, resolution, z, viewScale) : undefined
            if (!wG || wG < 0) continue

            //height
            /** @type {number|undefined} */
            const hG = this.height ? this.height(cell, resolution, z, viewScale) : undefined
            if (!hG || hG < 0) continue

            //get offset
            //TODO use that
            //const offset = this.offset(c, resolution, z)

            //set width
            ctx.lineWidth = wG

            //compute cell center postition
            const cx = cell.x + resolution / 2
            const cy = cell.y + resolution / 2
            const ls = hG * this.shadowFactor

            //draw segment
            ctx.beginPath()
            ctx.moveTo(cx, cy)
            ctx.lineTo(cx + ls * Math.cos(this.shadowDirection), cy + ls * Math.sin(this.shadowDirection))
            ctx.stroke()

            /*
            if (this.simple) {
                //draw base circle
                cg.ctx.beginPath();
                cg.ctx.arc(
                    cx, cy,
                    wG * 0.5,
                    0, 2 * Math.PI, false);
                //cg.ctx.stroke();
                cg.ctx.fill();
            }*/
        }

        //draw pillars
        for (let cell of cells) {
            //color
            /** @type {string|undefined} */
            const col = this.color ? this.color(cell, resolution, z, viewScale) : undefined
            if (!col) continue

            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(cell, resolution, z, viewScale) : undefined
            if (!wG || wG < 0) continue

            //height
            /** @type {number|undefined} */
            const hG = this.height ? this.height(cell, resolution, z, viewScale) : undefined
            if (!hG || hG < 0) continue

            //get offset
            //TODO use that
            //const offset = this.offset(c, resolution, z)

            //compute cell center postition
            const cx = cell.x + resolution / 2
            const cy = cell.y + resolution / 2

            //compute angle
            const dx = cx - cvx,
                dy = cy - cvy
            const a = Math.atan2(dy, dx)
            const D = Math.sqrt(dx * dx + dy * dy)
            const d = (D * hG) / (H - hG)

            if (simple) {
                //draw segment
                ctx.strokeStyle = col
                ctx.lineWidth = wG
                ctx.beginPath()
                ctx.moveTo(cx, cy)
                ctx.lineTo(cx + d * Math.cos(a), cy + d * Math.sin(a))
                ctx.stroke()
            } else {
                //draw background segment
                ctx.strokeStyle = this.outlineCol
                ctx.lineWidth = wG + 2 * this.outlineWidthPix * z
                ctx.beginPath()
                ctx.moveTo(cx, cy)
                ctx.lineTo(cx + d * Math.cos(a), cy + d * Math.sin(a))
                ctx.stroke()

                //draw segment
                ctx.strokeStyle = col
                ctx.lineWidth = wG
                ctx.beginPath()
                ctx.moveTo(cx, cy)
                ctx.lineTo(cx + d * Math.cos(a), cy + d * Math.sin(a))
                ctx.stroke()

                //draw top circle
                ctx.strokeStyle = this.outlineCol
                //cg.ctx.fillStyle = "#c08c59"
                ctx.lineWidth = this.outlineWidthPix * z
                ctx.beginPath()
                ctx.arc(cx + d * Math.cos(a), cy + d * Math.sin(a), wG * 0.5, 0, 2 * Math.PI, false)
                ctx.stroke()
                //cg.ctx.fill();
            }
        }

        //in case...
        ctx.lineCap = 'butt'

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./src/style/SegmentStyle.js":
/*!***********************************!*\
  !*** ./src/style/SegmentStyle.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SegmentStyle: () => (/* binding */ SegmentStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
//@ts-check


;

/**
 * A style where each cell is represented by a segment whose length, width, color and orientation can vary according to statistical values.
 *
 * @module style
 * @author Julien Gaffuri
 */
class SegmentStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the color of the cell segment.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => '#EA6BAC') //(c,r,z,vs) => {}

        /** A function returning the width of the segment representing a cell, in geo unit
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.width = opts.width || ((cell, resolution) => resolution * 0.1) //(c,r,z,vs) => {}

        /** A function returning the length of the segment representing a cell, in geo unit
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.length = opts.length || ((cell, resolution) => resolution * 0.9) //(c,r,z,vs) => {}

        /** A function returning the orientation (in degrees) of the segment representing a cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.orientation = opts.orientation || (() => 180 * Math.random()) //(c,r,z,vs) => {}
    }

    /**
     * Draw cells as segments.
     *
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //
        ctx.lineCap = 'butt'

        //conversion factor degree -> radian
        const f = Math.PI / 180

        for (let cell of cells) {
            //color
            /** @type {string|undefined} */
            const col = this.color ? this.color(cell, resolution, z, viewScale) : undefined
            if (!col) continue

            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(cell, resolution, z, viewScale) : undefined
            if (!wG || wG < 0) continue

            //length
            /** @type {number|undefined} */
            const lG = this.length ? this.length(cell, resolution, z, viewScale) : undefined
            if (!lG || lG < 0) continue

            //orientation (in radian)
            /** @type {number} */
            const or = this.orientation(cell, resolution, z, viewScale) * f
            if (or === undefined || isNaN(or)) continue

            //get offset
            const offset = this.offset(cell, resolution, z)

            //set color and width
            ctx.strokeStyle = col
            ctx.lineWidth = wG

            //compute segment center postition
            const cx = cell.x + resolution / 2 + offset.dx
            const cy = cell.y + resolution / 2 + offset.dy

            //compute segment direction
            const dx = 0.5 * Math.cos(or) * lG
            const dy = 0.5 * Math.sin(or) * lG

            //draw segment
            ctx.beginPath()
            ctx.moveTo(cx - dx, cy - dy)
            ctx.lineTo(cx + dx, cy + dy)
            ctx.stroke()
        }

        //update legends
        this.updateLegends({ viewScale: viewScale, resolution: resolution, z: z, cells: cells })
    }
}


/***/ }),

/***/ "./src/style/ShapeColorSizeStyle.js":
/*!******************************************!*\
  !*** ./src/style/ShapeColorSizeStyle.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShapeColorSizeStyle: () => (/* binding */ ShapeColorSizeStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
//@ts-check


;

/**
 * A very generic style that shows grid cells with specific color, size and shape.
 * It can be used to show variables as cell colors, cell size, cell shape, or any combination of the three visual variables.
 *
 * @module style
 * @author Joseph Davies, Julien Gaffuri
 */
class ShapeColorSizeStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}
        /** @type {(function(import('../core/Dataset.js').Cell, number, number, object):string) | string} */
        this.color = opts.color || '#EA6BAC'

        /** @type {(function(import('../core/Dataset.js').Cell, number, number, object):number) | number} */
        this.size = opts.size || ((cell, resolution) => resolution)

        /** @type {(function(import("../core/Dataset.js").Cell,number, number,object):import("../core/Style.js").Shape) | string} */
        this.shape = opts.shape || 'square'
    }

    /**
     * Draw cells as squares, with various colors and sizes.
     *
     * @param {Array.<import("../core/Dataset.js").Cell>} cells - The grid cells to draw.
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas - The canvas to draw on.
     * @param {number} resolution - Resolution of the grid.
     * @override
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        const r2 = resolution * 0.5

        // Precompute if color, size, and shape are functions, for efficiency
        const isColorFunction = typeof this.color === 'function'
        const isSizeFunction = typeof this.size === 'function'
        const isShapeFunction = typeof this.shape === 'function'

        const defaultColor = this.color || 'black'
        const defaultSize = this.size || resolution
        const defaultShape = this.shape || 'square'

        // Optimized
        const colorFunction = isColorFunction ? this.color : null
        const sizeFunction = isSizeFunction ? this.size : null
        const shapeFunction = isShapeFunction ? this.shape : null

        for (let c of cells) {
            // Determine color
            //@ts-ignore
            const col = colorFunction ? colorFunction(c, resolution, z, viewScale) : defaultColor
            if (!col || col === 'none') continue

            // Determine size
            //@ts-ignore
            const size = sizeFunction ? sizeFunction(c, resolution, z, viewScale) : defaultSize
            if (!size) continue

            // Determine shape
            //@ts-ignore
            const shape = shapeFunction ? shapeFunction(c, resolution, z, viewScale) : defaultShape
            if (shape === 'none') continue

            //get offset
            const offset = this.offset(c, resolution, z)

            //get context
            const ctx = geoCanvas.offscreenCtx
            ctx.fillStyle = col
            if (shape === 'square') {
                //draw square
                const d = resolution * (1 - size / resolution) * 0.5
                ctx.fillRect(c.x + d + offset.dx, c.y + d + offset.dy, size, size)
            } else if (shape === 'circle') {
                //draw circle
                ctx.beginPath()
                ctx.arc(c.x + r2 + offset.dx, c.y + r2 + offset.dy, size * 0.5, 0, 2 * Math.PI, false)
                ctx.fill()
            } else if (shape === 'donut') {
                //draw donut
                const xc = c.x + r2 + offset.dx,
                    yc = c.y + r2 + offset.dy
                ctx.beginPath()
                ctx.moveTo(xc, yc)
                ctx.arc(xc, yc, r2, 0, 2 * Math.PI)
                ctx.arc(xc, yc, (1 - size / resolution) * r2, 0, 2 * Math.PI, true)
                ctx.closePath()
                ctx.fill()
            } else if (shape === 'diamond') {
                const s2 = size * 0.5
                ctx.beginPath()
                ctx.moveTo(c.x + r2 - s2, c.y + r2)
                ctx.lineTo(c.x + r2, c.y + r2 + s2)
                ctx.lineTo(c.x + r2 + s2, c.y + r2)
                ctx.lineTo(c.x + r2, c.y + r2 - s2)
                ctx.fill()
            } else if (shape === 'triangle_up') {
                const dr2 = (size - resolution) / 2
                ctx.beginPath()
                ctx.moveTo(c.x - dr2, c.y - dr2)
                ctx.lineTo(c.x + r2, c.y + resolution + dr2)
                ctx.lineTo(c.x + resolution + dr2, c.y - dr2)
                ctx.fill()
            } else if (shape === 'triangle_down') {
                const dr2 = (size - resolution) / 2
                ctx.beginPath()
                ctx.moveTo(c.x - dr2, c.y + resolution + dr2)
                ctx.lineTo(c.x + r2, c.y - dr2)
                ctx.lineTo(c.x + resolution + dr2, c.y + resolution + dr2)
                ctx.fill()
            } else if (shape === 'triangle_left') {
                const dr2 = (size - resolution) / 2
                ctx.beginPath()
                ctx.moveTo(c.x + resolution + dr2, c.y + resolution + dr2)
                ctx.lineTo(c.x - dr2, c.y + r2)
                ctx.lineTo(c.x + resolution + dr2, c.y - dr2)
                ctx.fill()
            } else if (shape === 'triangle_right') {
                const dr2 = (size - resolution) / 2
                ctx.beginPath()
                ctx.moveTo(c.x - dr2, c.y - dr2)
                ctx.lineTo(c.x + resolution + dr2, c.y + r2)
                ctx.lineTo(c.x - dr2, c.y + resolution + dr2)
                ctx.fill()
            } else {
                throw new Error('Unexpected shape:' + shape)
            }
        }

        //update legends
        this.updateLegends({ viewScale: viewScale, resolution: resolution, z: z, cells: cells })
    }
}


/***/ }),

/***/ "./src/style/SideCategoryStyle.js":
/*!****************************************!*\
  !*** ./src/style/SideCategoryStyle.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SideCategoryStyle: () => (/* binding */ SideCategoryStyle)
/* harmony export */ });
/* harmony import */ var _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SideStyle.js */ "./src/style/SideStyle.js");
//@ts-check


;

/**
 * A style to show the sides of grid cells based on their different categories.
 *
 * @module style
 * @author Julien Gaffuri
 */
class SideCategoryStyle extends _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__.SideStyle {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the category code of a cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number):string} */
        this.code = opts.code

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        this.color = opts.color
    }

    /**
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        //build sides

        /**  @type {Array.<import('./SideStyle.js').Side>} */
        const sides = _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__.SideStyle.buildSides(cells, resolution)
        if (sides.length == 0) return

        //get side view scale
        const viewScale = this.viewScale ? this.viewScale(sides, resolution, z) : undefined

        //draw sides

        ctx.lineCap = 'butt'
        const r2 = resolution * 0.5
        for (let side of sides) {
            //get category codes for both cells
            const code1 = side.c1 ? this.code(side.c1, resolution, z) : undefined
            const code2 = side.c2 ? this.code(side.c2, resolution, z) : undefined
            if (code1 == code2) continue

            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(side, resolution, z, viewScale) : undefined
            if (!wG || wG <= 0) continue
            const w2 = wG * 0.5

            //set width
            ctx.lineWidth = wG

            //draw segment with correct orientation
            if (side.or === 'h') {
                //top line
                if (code2) {
                    ctx.beginPath()
                    ctx.strokeStyle = this.color[code2]
                    ctx.moveTo(side.x - r2, side.y + w2)
                    ctx.lineTo(side.x + r2, side.y + w2)
                    ctx.stroke()
                }

                //bottom line
                if (code1) {
                    ctx.beginPath()
                    ctx.strokeStyle = this.color[code1]
                    ctx.moveTo(side.x - r2, side.y - w2)
                    ctx.lineTo(side.x + r2, side.y - w2)
                    ctx.stroke()
                }
            } else {
                //right line
                if (code2) {
                    ctx.beginPath()
                    ctx.strokeStyle = this.color[code2]
                    ctx.moveTo(side.x + w2, side.y - r2)
                    ctx.lineTo(side.x + w2, side.y + r2)
                    ctx.stroke()
                }

                //left line
                if (code1) {
                    ctx.beginPath()
                    ctx.strokeStyle = this.color[code1]
                    ctx.moveTo(side.x - w2, side.y - r2)
                    ctx.lineTo(side.x - w2, side.y + r2)
                    ctx.stroke()
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./src/style/SideStyle.js":
/*!********************************!*\
  !*** ./src/style/SideStyle.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SideStyle: () => (/* binding */ SideStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
//@ts-check


;

/** @typedef {{ x:number, y:number, or:"v"|"h", c1:(import('../core/Dataset').Cell)|undefined, c2:(import('../core/Dataset').Cell)|undefined }} Side */

/**
 * @typedef {function(Array.<Side>,number, number):*} SideViewScale */

/**
 * @module style
 * @author Julien Gaffuri
 */
class SideStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts = {}) {
        super(opts)

        /** A function returning the color of a cell side.
         * @type {function(Side, number, number, object):string} */
        this.color = opts.color || ((side, resolution, z, sideViewScale) => '#EA6BAC')

        /** A function returning the width of a cell side, in geo unit
         * @type {function(Side, number, number, object):number} */
        this.width = opts.width || ((side, resolution, z, sideViewScale) => resolution / 5)

        /** A function returning the length of a cell side, in geo unit
         * @type {function(Side, number, number, object):number} */
        this.length = opts.length || ((side, resolution, z, sideViewScale) => resolution)

        /** Set to A or true so that the side is drawn as a diamond */
        this.diamond = opts.diamond
    }

    /**
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {number} resolution
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        //build sides

        /**  @type {Array.<Side>} */
        const sides = SideStyle.buildSides(cells, resolution)
        if (sides.length == 0) return

        //get side view scale
        const viewScale = this.viewScale ? this.viewScale(sides, resolution, z) : undefined

        //draw sides

        ctx.lineCap = 'butt'
        const r2 = resolution * 0.5
        for (let side of sides) {
            //color
            /** @type {string|undefined} */
            const col = this.color ? this.color(side, resolution, z, viewScale) : undefined
            if (!col || col == 'none') continue

            if (this.diamond) {
                //set color
                ctx.fillStyle = col

                //draw diamond
                const x = side.x,
                    y = side.y
                ctx.beginPath()
                ctx.moveTo(x - r2, y)
                ctx.lineTo(x, y + r2)
                ctx.lineTo(x + r2, y)
                ctx.lineTo(x, y - r2)
                ctx.closePath()
                ctx.fill()
            } else {
                //width
                /** @type {number|undefined} */
                const wG = this.width ? this.width(side, resolution, z, viewScale) : undefined
                if (!wG || wG <= 0) continue

                //length
                /** @type {number|undefined} */
                const lG = this.length ? this.length(side, resolution, z, viewScale) : undefined
                if (!lG || lG <= 0) continue
                const lG2 = lG * 0.5

                //set width
                ctx.lineWidth = wG
                //set color
                ctx.strokeStyle = col

                //draw segment with correct orientation
                const x = side.x,
                    y = side.y
                ctx.beginPath()
                if (side.or === 'v') {
                    ctx.moveTo(x, y - lG2)
                    ctx.lineTo(x, y + lG2)
                } else {
                    ctx.moveTo(x - lG2, y)
                    ctx.lineTo(x + lG2, y)
                }
                ctx.stroke()
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }

    /**
     *
     * @param {Array.<import('../core/Dataset').Cell>} cells The cells to use to build the sides.
     * @param {number} resolution The cells resolution
     * @param {boolean} withHorizontal Set to true to build horizontal sides, false otherwise.
     * @param {boolean} withVertical Set to true to build vertical sides, false otherwise.
     * @param {boolean} center Set to true so that the side coordinate are those of its center point rather than its left/bottom point (the side x,y coordinates are those of the left point for horizontal sides, and of the bottom point for vertical sides)
     * @returns { Array.<Side> }
     */
    static buildSides(cells, resolution, withHorizontal = true, withVertical = true, center = true) {
        /** @type { Array.<Side> } */
        const sides = []

        const r2 = center ? resolution / 2 : 0

        //make horizontal sides
        //sort cells by x and y
        cells.sort((c1, c2) => (c2.x == c1.x ? c1.y - c2.y : c1.x - c2.x))
        let c1 = cells[0]
        for (let i = 1; i < cells.length; i++) {
            let c2 = cells[i]

            if (c1.y + resolution == c2.y && c1.x == c2.x)
                //cells in same column and touch along horizontal side
                //make shared side
                sides.push({
                    or: 'h',
                    x: c1.x + r2,
                    y: c2.y,
                    c1: c1,
                    c2: c2,
                })
            else {
                //cells do not touch along horizontal side
                //make two sides: top one for c1, bottom for c2
                sides.push({
                    or: 'h',
                    x: c1.x + r2,
                    y: c1.y + resolution,
                    c1: c1,
                    c2: undefined,
                })
                sides.push({
                    or: 'h',
                    x: c2.x + r2,
                    y: c2.y,
                    c1: undefined,
                    c2: c2,
                })
            }

            c1 = c2
        }

        //make vertical sides
        //sort cells by y and x
        cells.sort((c1, c2) => (c2.y == c1.y ? c1.x - c2.x : c1.y - c2.y))
        c1 = cells[0]
        for (let i = 1; i < cells.length; i++) {
            let c2 = cells[i]

            if (c1.x + resolution == c2.x && c1.y == c2.y)
                //cells in same row and touch along vertical side
                //make shared side
                sides.push({
                    or: 'v',
                    x: c1.x + resolution,
                    y: c1.y + r2,
                    c1: c1,
                    c2: c2,
                })
            else {
                //cells do not touch along vertical side
                //make two sides: right one for c1, left for c2
                sides.push({
                    or: 'v',
                    x: c1.x + resolution,
                    y: c1.y + r2,
                    c1: c1,
                    c2: undefined,
                })
                sides.push({
                    or: 'v',
                    x: c2.x,
                    y: c2.y + r2,
                    c1: undefined,
                    c2: c2,
                })
            }

            c1 = c2
        }
        return sides
    }
}


/***/ }),

/***/ "./src/style/SquareColorCategoryWebGLStyle.js":
/*!****************************************************!*\
  !*** ./src/style/SquareColorCategoryWebGLStyle.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SquareColorCategoryWebGLStyle: () => (/* binding */ SquareColorCategoryWebGLStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
/* harmony import */ var _utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webGLUtils.js */ "./src/utils/webGLUtils.js");
/* harmony import */ var _utils_WebGLSquareColoringCatAdvanced_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/WebGLSquareColoringCatAdvanced.js */ "./src/utils/WebGLSquareColoringCatAdvanced.js");
//@ts-check


;



/**
 * Style based on webGL
 * To show cells as colored squares, from categories.
 * All cells are drawn as squares, with the same size
 *
 * @module style
 * @author Julien Gaffuri
 */
class SquareColorCategoryWebGLStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * A function returning the category code of the cell, for coloring.
         * @type {function(import('../core/Dataset.js').Cell):string} */
        this.code = opts.code

        /**
         * The dictionary (code -> color) which gives the color of each category code.
         * @type {object} */
        opts.color = opts.color || undefined

        /** @type { Array.<string> } */
        const codes = Object.keys(opts.color)

        /** @type { object } @private */
        this.catToI = {}
        for (let i = 0; i < codes.length; i++) this.catToI[codes[i]] = i + ''

        /** @type { Array.<string> } @private */
        this.colors = []
        for (const code of codes) this.colors.push(opts.color['' + code])

        /**
         * A function returning the size of the cells, in geographical unit. All cells have the same size.
         * @type {function(number,number):number} */
        this.size = opts.size // (resolution, z) => ...

        /**
         * @private
         * @type { WebGLSquareColoringCatAdvanced } */
        this.wgp = new _utils_WebGLSquareColoringCatAdvanced_js__WEBPACK_IMPORTED_MODULE_2__.WebGLSquareColoringCatAdvanced(this.colors)
    }

    /**
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //add vertice and fragment data
        const r2 = resolution / 2
        let c,
            nb = cells.length
        const verticesBuffer = []
        const iBuffer = []
        for (let i = 0; i < nb; i++) {
            c = cells[i]
            const cat = this.code(c)
            if (cat == undefined) {
                console.log('Unexpected category: ' + cat)
                continue
            }
            /** @type {number} */
            const i_ = this.catToI[cat]
            if (isNaN(+i_)) {
                console.log('Unexpected category index: ' + cat + ' ' + i_)
                continue
            }
            verticesBuffer.push(c.x + r2, c.y + r2)
            iBuffer.push(+i_)
        }

        //create canvas and webgl renderer
        const cvWGL = (0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.makeWebGLCanvas)(geoCanvas.w + '', geoCanvas.h + '')
        if (!cvWGL) {
            console.error('No webGL')
            return
        }

        //draw
        const sizeGeo = this.size ? this.size(resolution, z) : resolution + 0.2 * z
        this.wgp.draw(cvWGL.gl, verticesBuffer, iBuffer, geoCanvas.getWebGLTransform(), sizeGeo / z)

        //draw in canvas geo
        geoCanvas.initCanvasTransform()
        geoCanvas.offscreenCtx.drawImage(cvWGL.canvas, 0, 0)

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z })
    }
}


/***/ }),

/***/ "./src/style/SquareColorWebGLStyle.js":
/*!********************************************!*\
  !*** ./src/style/SquareColorWebGLStyle.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SquareColorWebGLStyle: () => (/* binding */ SquareColorWebGLStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
/* harmony import */ var _utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webGLUtils.js */ "./src/utils/webGLUtils.js");
/* harmony import */ var _utils_WebGLSquareColoringAdvanced_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/WebGLSquareColoringAdvanced.js */ "./src/utils/WebGLSquareColoringAdvanced.js");
//@ts-check


;



/**
 * Style based on webGL
 * To show cells as colored squares, with computation of the colors on GPU side (faster than JavaScript side).
 * Alls squares with the same size
 *
 * @module style
 * @author Julien Gaffuri
 */
class SquareColorWebGLStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * A function returning a t value (within [0,1]) for a cell.
         * @type {function(import('../core/Dataset.js').Cell,number,number,object):number} */
        this.tFun = opts.tFun //(c,r,z,vs) => {}

        /**
         * Distribution stretching method.
         * The stretching is performed on GPU side (fragment shader).
         * @type {{ fun:string, alpha:number }} */
        this.stretching = opts.stretching

        /**
         * The sample of the color ramp.
         * The color is computed on GPU side (fragment shader) based on those values (linear interpolation).
         * @type {Array.<string>} */
        this.colors =
            opts.colors ||
            [
                'rgb(158, 1, 66)',
                'rgb(248, 142, 83)',
                'rgb(251, 248, 176)',
                'rgb(137, 207, 165)',
                'rgb(94, 79, 162)',
            ].reverse()
        if (opts.color)
            this.colors = [
                opts.color(0),
                opts.color(0.2),
                opts.color(0.4),
                opts.color(0.6),
                opts.color(0.8),
                opts.color(1),
            ]

        /**
         * Define the opacity of the style, within [0,1].
         * If this opacity is defined, the individual color opacity will be ignored.
         * @type {function(number,number):number} */
        this.opacity = opts.opacity // (r,z) => ...

        /**
         * A function returning the size of the cells, in geographical unit. All cells have the same size.
         * @type {function(number,number):number} */
        this.size = opts.size // (resolution, z) => ...
    }

    /**
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //create canvas and webgl renderer
        //for opacity control, see: https://webglfundamentals.org/webgl/lessons/webgl-and-alpha.html
        const cvWGL = (0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.makeWebGLCanvas)(
            geoCanvas.w + '',
            geoCanvas.h + '',
            this.opacity != undefined ? { premultipliedAlpha: false } : undefined
        )
        if (!cvWGL) {
            console.error('No webGL')
            return
        }

        //add vertice and fragment data
        const r2 = resolution / 2
        const verticesBuffer = []
        const tBuffer = []
        for (let cell of cells) {
            const t = this.tFun(cell, resolution, z, viewScale)
            if (t == null || t == undefined) continue
            verticesBuffer.push(cell.x + r2, cell.y + r2)
            tBuffer.push(t > 1 ? 1 : t < 0 ? 0 : t)
        }

        //compute pixel size
        const sizeGeo = this.size ? this.size(resolution, z) : resolution + 0.2 * z

        //compute opacity
        const op = this.opacity ? this.opacity(resolution, z) : undefined

        //
        const wgp = new _utils_WebGLSquareColoringAdvanced_js__WEBPACK_IMPORTED_MODULE_2__.WebGLSquareColoringAdvanced(cvWGL.gl, this.colors, this.stretching, sizeGeo / z, op)

        //draw
        wgp.draw(verticesBuffer, tBuffer, geoCanvas.getWebGLTransform())

        // draw in canvas geo
        // NOTE: drawing each tile this way is very inefficient. WebGL is best used with fewer, heavier/larger draw calls.
        geoCanvas.initCanvasTransform()
        geoCanvas.offscreenCtx.drawImage(cvWGL.canvas, 0, 0)

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./src/style/StrokeStyle.js":
/*!**********************************!*\
  !*** ./src/style/StrokeStyle.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StrokeStyle: () => (/* binding */ StrokeStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Julien Gaffuri
 */
class StrokeStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the color of the cell.
         * @type {function(import('../core/Dataset.js').Cell,number,number,object):string} */
        this.strokeColor = opts.strokeColor || (() => '#666') //(c,r,z,vs) => {}

        /** A function returning the size of a cell in geographical unit.
         * @type {function(import('../core/Dataset.js').Cell,number,number,object):number} */
        this.size = opts.size || ((cell, resolution) => resolution) //(c,r,z,vs) => {}

        /** The stroke line width in geographical unit.
         * @type {function(import('../core/Dataset.js').Cell,number,number,object):number} */
        this.strokeWidth = opts.strokeWidth || ((cell, resolution, z) => z * 1.5) //(c,r,z,vs) => {}

        /** A function returning the shape of a cell.
         * @type {function(import("../core/Dataset.js").Cell,number,number,object):import("../core/Style.js").Shape} */
        this.shape = opts.shape || (() => 'square') //(c,r,z,vs) => {}
    }

    /**
     * Draw cells as squares, with various colors and size.
     *
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        const r2 = resolution * 0.5
        for (let c of cells) {
            //color
            const col = this.strokeColor ? this.strokeColor(c, resolution, z, viewScale) : undefined
            if (!col || col === 'none') continue
            ctx.strokeStyle = col

            //size - in geo unit
            const size = this.size ? this.size(c, resolution, z, viewScale) : resolution

            //width
            const wi = this.strokeWidth ? this.strokeWidth(c, resolution, z, viewScale) : 1 * z
            if (!wi || wi <= 0) continue
            ctx.lineWidth = wi

            //shape
            const shape = this.shape ? this.shape(c, resolution, z, viewScale) : 'square'
            if (shape === 'none') continue

            //get offset
            const offset = this.offset(c, resolution, z)

            if (shape === 'square') {
                //draw square
                const d = resolution * (1 - size / resolution) * 0.5
                ctx.beginPath()
                ctx.rect(c.x + d + offset.dx, c.y + d + offset.dy, size, size)
                ctx.stroke()
            } else if (shape === 'circle') {
                //draw circle
                ctx.beginPath()
                ctx.arc(c.x + r2 + offset.dx, c.y + r2 + offset.dy, size * 0.5, 0, 2 * Math.PI, false)
                ctx.stroke()
            } else if (shape === 'diamond') {
                const s2 = size * 0.5
                ctx.beginPath()
                ctx.moveTo(c.x + r2 - s2, c.y + r2)
                ctx.lineTo(c.x + r2, c.y + r2 + s2)
                ctx.lineTo(c.x + r2 + s2, c.y + r2)
                ctx.lineTo(c.x + r2, c.y + r2 - s2)
                ctx.lineTo(c.x + r2 - s2, c.y + r2)
                ctx.stroke()
            } else if (shape === 'donut') {
                console.error('Not implemented')
            } else if (shape === 'triangle_up') {
                const dr2 = (size - resolution) / 2
                ctx.beginPath()
                ctx.moveTo(c.x - dr2, c.y - dr2)
                ctx.lineTo(c.x + r2, c.y + resolution + dr2)
                ctx.lineTo(c.x + resolution + dr2, c.y - dr2)
                ctx.closePath()
                ctx.stroke()
            } else if (shape === 'triangle_down') {
                const dr2 = (size - resolution) / 2
                ctx.beginPath()
                ctx.moveTo(c.x - dr2, c.y + resolution + dr2)
                ctx.lineTo(c.x + r2, c.y - dr2)
                ctx.lineTo(c.x + resolution + dr2, c.y + resolution + dr2)
                ctx.closePath()
                ctx.stroke()
            } else if (shape === 'triangle_left') {
                const dr2 = (size - resolution) / 2
                ctx.beginPath()
                ctx.moveTo(c.x + resolution + dr2, c.y + resolution + dr2)
                ctx.lineTo(c.x - dr2, c.y + r2)
                ctx.lineTo(c.x + resolution + dr2, c.y - dr2)
                ctx.closePath()
                ctx.stroke()
            } else if (shape === 'triangle_right') {
                const dr2 = (size - resolution) / 2
                ctx.beginPath()
                ctx.moveTo(c.x - dr2, c.y - dr2)
                ctx.lineTo(c.x + resolution + dr2, c.y + r2)
                ctx.lineTo(c.x - dr2, c.y + resolution + dr2)
                ctx.closePath()
                ctx.stroke()
            } else {
                throw new Error('Unexpected shape:' + shape)
            }
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./src/style/TanakaStyle.js":
/*!**********************************!*\
  !*** ./src/style/TanakaStyle.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TanakaStyle: () => (/* binding */ TanakaStyle)
/* harmony export */ });
/* harmony import */ var _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SideStyle.js */ "./src/style/SideStyle.js");
/* harmony import */ var _SquareColorCategoryWebGLStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SquareColorCategoryWebGLStyle.js */ "./src/style/SquareColorCategoryWebGLStyle.js");
/* harmony import */ var _utils_scale_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/scale.js */ "./src/utils/scale.js");
//@ts-check


;



/**
 * @see https://manifold.net/doc/mfd9/example__tanaka_contours.htm
 *
 * @module style
 * @author Julien Gaffuri
 */
class TanakaStyle {
    /**
     * @param {function(import('../core/Dataset.js').Cell):number} value Function that returns the value of a cell
     * @param {Array.<number>} breaks The break values
     * @param {Array.<string>} colors The colors, one more than the break values
     * @param {object} opts
     * @returns {Array.<import("../core/Style").Style>}
     */
    static get(value, breaks, colors, opts = {}) {
        //shadow colors
        opts.colorDark = opts.colorDark || '#111'
        opts.colorBright = opts.colorBright || '#ddd'

        /** @type { function(number, number):number } */
        opts.width =
            opts.width ||
            ((sideValue, resolution, z) => {
                const minWG = 1 * z
                const maxWG = 4 * z
                const step = (maxWG - minWG) / 3
                return Math.min(minWG + (sideValue - 1) * step, maxWG)
            })

        //make classifier
        const classifier = (0,_utils_scale_js__WEBPACK_IMPORTED_MODULE_2__.classifier)(breaks)
        //make colors table
        const colorsDict = {}
        for (let i = 0; i < colors.length; i++) colorsDict[i + ''] = colors[i]

        const cellStyle = new _SquareColorCategoryWebGLStyle_js__WEBPACK_IMPORTED_MODULE_1__.SquareColorCategoryWebGLStyle({
            code: (cell) => classifier(value(cell)),
            color: colorsDict,
        })

        const getSideValue = (side) => {
            const cl1 = side.c1 ? classifier(value(side.c1)) : -1
            const cl2 = side.c2 ? classifier(value(side.c2)) : -1
            return cl1 - cl2
        }

        /** The side style, for the shadow effect */
        const sideStyle = new _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__.SideStyle({
            //white or black, depending on orientation and value
            color: (side) => {
                const v = getSideValue(side)
                if (v === 0) return
                if (side.or === 'v') return v < 0 ? opts.colorBright : opts.colorDark
                return v < 0 ? opts.colorDark : opts.colorBright
            },
            //width depends on the value, that is the number of classes of difference
            width: (side, resolution, z) => opts.width(Math.abs(getSideValue(side)), resolution, z),
        })

        return [cellStyle, sideStyle]
    }
}


/***/ }),

/***/ "./src/style/TextStyle.js":
/*!********************************!*\
  !*** ./src/style/TextStyle.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextStyle: () => (/* binding */ TextStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
//@ts-check


;

/**
 * @module style
 * @author Julien Gaffuri
 */
class TextStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the text of a cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.text = opts.text || (() => 'X') //(c,r,z,vs) => {}

        /** A function returning the color of the cell.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => 'black') //(c,r,z,vs) => {}

        /** A function returning the font size of a cell in geo unit.
         * @type {function(import('../core/Dataset.js').Cell, number, number,object):number} */
        this.fontSize = opts.fontSize || ((cell, resolution) => resolution) //(c,r,z,vs) => {}

        /** The text font family.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.fontFamily = opts.fontFamily || (() => 'Arial')

        /** The text font weight.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.fontWeight = opts.fontWeight || (() => 'bold')
    }

    /**
     * Draw cells as text.
     *
     * @param {Array.<import("../core/Dataset").Cell>} cells
     * @param {import("../core/GeoCanvas").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx
        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //draw with HTML canvas
        //in screen coordinates
        geoCanvas.initCanvasTransform()

        for (let cell of cells) {
            //get cell text
            const text = this.text ? this.text(cell, resolution, z, viewScale) : undefined
            if (text == undefined || text == null || text + '' === '') continue

            //color
            const col = this.color ? this.color(cell, resolution, z, viewScale) : undefined
            if (!col) continue
            ctx.fillStyle = col

            //font size
            //size - in pixel unit
            const fontSizePix = this.fontSize(cell, resolution, z, viewScale) / z
            if (!fontSizePix) continue

            //set font
            const fontFamily = this.fontFamily ? this.fontFamily(cell, resolution, z, viewScale) : 'Arial'
            const fontWeight = this.fontWeight ? this.fontWeight(cell, resolution, z, viewScale) : 'bold'
            ctx.font = fontWeight + ' ' + fontSizePix + 'px ' + fontFamily

            //get offset
            const offset = this.offset(cell, resolution, z)

            //text position
            ctx.textAlign = 'center'
            const tx = geoCanvas.geoToPixX(cell.x + resolution * 0.5 + offset.dx)
            const ty = geoCanvas.geoToPixY(cell.y + resolution * 0.5 + offset.dy) + fontSizePix * 0.3 //it should be 0.5 but 0.3 seems to work better

            //draw the text
            ctx.fillText(text, tx, ty)
        }

        //update legends
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }

    /**
     * Build a function [0,1]->string for characters legend
     *
     * @param {Array.<string>} chars
     * @param {(function(number):number)|undefined} scale
     * @returns {function(number):string}
     */
    static textScale(chars, scale = undefined) {
        const nb = chars.length
        return (t) => {
            if (scale) t = scale(t)
            if (t == 0) return ''
            if (t >= 1) return chars[nb - 1]
            return chars[Math.floor(t * nb)]
        }
    }
}


/***/ }),

/***/ "./src/style/TimeSeriesStyle.js":
/*!**************************************!*\
  !*** ./src/style/TimeSeriesStyle.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TimeSeriesStyle: () => (/* binding */ TimeSeriesStyle)
/* harmony export */ });
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Style.js */ "./src/core/Style.js");
//@ts-check


;

/** @typedef {"first"|"bottom"|"center"|"top"|"last"} AnchorModeYEnum */

/**
 * Show cell as timeseries chart
 * Can be used for sparkline map of https://datagistips.hypotheses.org/488
 *
 * @module style
 * @author Julien Gaffuri
 */
class TimeSeriesStyle extends _core_Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The columns of the time series, ordered in chronological order.
         * @type {Array.<string>} */
        this.ts = opts.ts

        /** A function specifying when a value should be considered as "no data" and thus not ignored. The line will have a break at these values.
         * @type {function(string):boolean} */
        this.noData = opts.noData || ((v) => v === undefined || v == '' || v === null || isNaN(+v))

        //x
        /** in geo unit
         * @type {function(import("../core/Dataset.js").Cell,number,number):number} */
        this.offsetX = opts.offsetX || ((c, r, z) => 0)
        /** @type {function(import("../core/Dataset.js").Cell,number,number):number} */
        this.width = opts.width || ((c, r, z) => r)

        //y
        /** in geo unit
         * @type {function(import("../core/Dataset.js").Cell,number,number):number} */
        this.offsetY = opts.offsetY || ((c, r, z) => 0)
        /** @type {function(import("../core/Dataset.js").Cell,number,number):number} */
        this.height = opts.height || ((c, r, z) => r)
        /** @type {function(import("../core/Dataset.js").Cell,number,number):AnchorModeYEnum} */
        this.anchorModeY = opts.anchorModeY || ((c, r, z) => 'center')

        /** A function returning the width of the line, in geo unit
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):number} */
        this.lineWidth = opts.lineWidth || ((v, r, s, z) => 1.5 * z)

        /** A function returning the color of the chart.
         * @type {function(import('../core/Dataset.js').Cell, number, number, object):string} */
        this.color = opts.color || (() => 'black') //(c,r,z,vs) => {}
    }

    /**
     * Draw cells as text.
     *
     * @param {Array.<import("../core/Dataset.js").Cell>} cells
     * @param {import("../core/GeoCanvas.js").GeoCanvas} geoCanvas
     * @param {number} resolution
     */
    draw(cells, geoCanvas, resolution) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //
        const z = geoCanvas.view.z
        const ctx = geoCanvas.offscreenCtx

        //get view scale
        const viewScale = this.viewScale ? this.viewScale(cells, resolution, z) : undefined

        //compute cell amplitude
        const getAmplitude = (c) => {
            let min, max
            for (let t of this.ts) {
                const val = c[t]
                if (val == undefined) continue
                if (min == undefined || val < min) min = val
                if (max == undefined || val > max) max = val
            }
            if (min == undefined) return undefined
            return max - min
        }

        //compute max amplitude
        let ampMax
        for (let c of cells) {
            const amp = getAmplitude(c)
            if (amp == undefined) continue
            if (ampMax == undefined || amp > ampMax) ampMax = amp
        }
        if (!ampMax) return

        const nb = this.ts.length

        ctx.lineCap = 'butt'
        for (let c of cells) {
            //line width
            /** @type {number|undefined} */
            const wG = this.lineWidth ? this.lineWidth(c, resolution, z, viewScale) : undefined
            if (!wG || wG < 0) continue

            //line color
            /** @type {string|undefined} */
            const col = this.color ? this.color(c, resolution, z, viewScale) : undefined
            if (!col) continue

            //x
            const offX = this.offsetX ? this.offsetX(c, resolution, z) : 0
            if (offX == undefined || isNaN(offX)) continue
            const w = this.width ? this.width(c, resolution, z) : resolution
            if (w == undefined || isNaN(w)) continue

            //y
            const offY = this.offsetY ? this.offsetY(c, resolution, z) : 0
            if (offY == undefined || isNaN(offY)) continue
            const h = this.height ? this.height(c, resolution, z) : resolution
            if (h == undefined || isNaN(h)) continue
            const anchY = this.anchorModeY ? this.anchorModeY(c, resolution, z) : 'center'
            if (!anchY) continue

            ctx.lineWidth = wG
            ctx.strokeStyle = col

            //compute anchor Y figures
            let val0, y0
            if (anchY === 'first') {
                //get first value
                val0 = c[this.ts[0]]
                y0 = 0
            } else if (anchY === 'last') {
                //get last value
                val0 = c[this.ts[this.ts.length - 1]]
                y0 = 0
            } else if (anchY === 'bottom') {
                //get min
                for (let t of this.ts) {
                    const val = +c[t]
                    if (val == undefined) continue
                    if (val0 == undefined || val < val0) val0 = val
                }
                y0 = 0
            } else if (anchY === 'top') {
                //get max
                for (let t of this.ts) {
                    const val = +c[t]
                    if (val == undefined) continue
                    if (val0 == undefined || val > val0) val0 = val
                }
                y0 = resolution
            } else if (anchY === 'center') {
                //get min and max
                let min, max
                for (let t of this.ts) {
                    const val = c[t]
                    if (val == undefined) continue
                    if (min == undefined || val < min) min = val
                    if (max == undefined || val > max) max = val
                }
                val0 = (+max + +min) * 0.5
                y0 = resolution / 2
            } else {
                console.log('Unexpected anchorModeY: ' + anchY)
                continue
            }

            /*/draw line
            if (val0 == undefined || isNaN(val0)) continue
            cg.ctx.beginPath()
            const sX = w / (nb - 1)
            for (let i = 0; i < nb; i++) {
                const val = c[this.ts[i]]
                if (val == undefined || isNaN(val)) break
                if (i == 0)
                    cg.ctx.moveTo(c.x + i * sX + offX, c.y + y0 + (val - val0) * h / ampMax + offY)
                else
                    cg.ctx.lineTo(c.x + i * sX + offX, c.y + y0 + (val - val0) * h / ampMax + offY)
            }
            cg.ctx.stroke()*/

            //draw line, segment by segment
            const sX = w / (nb - 1)

            //handle first point
            let v0 = c[this.ts[0]]
            if (!this.noData(v0)) {
                ctx.beginPath()
                ctx.moveTo(c.x + offX, c.y + y0 + ((v0 - val0) * h) / ampMax + offY)
            }
            //console.log(v0, isNaN(v0))

            let v1
            for (let i = 1; i < nb; i++) {
                v1 = c[this.ts[i]]

                //draw segment from v0 to v1

                //both points 'no data'
                if (this.noData(v0) && this.noData(v1)) {
                    //second point 'no data'
                } else if (!this.noData(v0) && this.noData(v1)) {
                    ctx.stroke()

                    //first point 'no data'
                } else if (this.noData(v0) && !this.noData(v1)) {
                    ctx.beginPath()
                    ctx.moveTo(c.x + i * sX + offX, c.y + y0 + ((v1 - val0) * h) / ampMax + offY)

                    //both points have data: trace line
                } else {
                    ctx.lineTo(c.x + i * sX + offX, c.y + y0 + ((v1 - val0) * h) / ampMax + offY)
                    //if it is the last point, stroke
                    if (i == nb - 1) ctx.stroke()
                }
                v0 = v1
            }
        }

        //update legend, if any
        this.updateLegends({ style: this, resolution: resolution, z: z, viewScale: viewScale })
    }
}


/***/ }),

/***/ "./src/utils/WebGLSquareColoring.js":
/*!******************************************!*\
  !*** ./src/utils/WebGLSquareColoring.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLSquareColoring: () => (/* binding */ WebGLSquareColoring)
/* harmony export */ });
/* harmony import */ var _webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webGLUtils.js */ "./src/utils/webGLUtils.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * Everything to easily draw colored squares with webGL.
 * All the same size, but different fill color.
 */
class WebGLSquareColoring {
    /**
     *
     * @param {WebGLRenderingContext} gl
     */
    constructor(gl, sizePix) {
        this.gl = gl
        this.sizePix = sizePix || 10.0

        this.program = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.initShaderProgram)(
            gl,
            (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(
                gl,
                gl.VERTEX_SHADER,
                `
            attribute vec2 pos;
            uniform float sizePix;
            uniform mat3 mat;
            attribute vec4 color;
            varying vec4 vColor;
            void main() {
              gl_Position = vec4(mat * vec3(pos, 1.0), 1.0);
              gl_PointSize = sizePix;
              vColor = color;
            }
          `
            ),
            (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(
                gl,
                gl.FRAGMENT_SHADER,
                `
            precision mediump float;
            varying vec4 vColor;
            void main(void) {
                vec4 vColor_ = vColor / 255.0;
                vColor_[3] = 255.0 * vColor_[3];
                gl_FragColor = vColor_;
            }`
            )
        )
        gl.useProgram(this.program)

        //buffer data
        this.verticesBuffer = []
        this.colorsBuffer = []
    }

    /** Add data to vertices/size/color buffers for color squares drawing */
    addPointData(xC, yC, col) {
        //convert color
        const cc = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(col)
        //const cc = {r:45,g:87,b:98,opacity:0.9}
        if (!cc) return

        //vertices
        this.verticesBuffer.push(xC, yC)
        //color
        this.colorsBuffer.push(cc.r, cc.g, cc.b, cc.opacity)
    }

    addPointData2(xC, yC, r, g, b, opacity) {
        //vertices
        this.verticesBuffer.push(xC, yC)
        //color
        this.colorsBuffer.push(r, g, b, opacity)
    }

    /**  */
    draw(transfoMat) {
        const gl = this.gl

        //vertice data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesBuffer), gl.STATIC_DRAW)
        const position = gl.getAttribLocation(this.program, 'pos')
        gl.vertexAttribPointer(
            position,
            2, //numComponents
            gl.FLOAT, //type
            false, //normalise
            0, //stride
            0 //offset
        )
        gl.enableVertexAttribArray(position)

        //color data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.colorsBuffer), gl.STATIC_DRAW)
        var color = gl.getAttribLocation(this.program, 'color')
        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(color)

        //sizePix
        gl.uniform1f(gl.getUniformLocation(this.program, 'sizePix'), 1.0 * this.sizePix)

        //transformation
        gl.uniformMatrix3fv(gl.getUniformLocation(this.program, 'mat'), false, new Float32Array(transfoMat))

        // Enable the depth test
        //gl.enable(gl.DEPTH_TEST);
        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT)
        // Set the view port
        //gl.viewport(0, 0, cg.w, cg.h);

        gl.drawArrays(gl.POINTS, 0, this.verticesBuffer.length / 2)
    }
}


/***/ }),

/***/ "./src/utils/WebGLSquareColoringAdvanced.js":
/*!**************************************************!*\
  !*** ./src/utils/WebGLSquareColoringAdvanced.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLSquareColoringAdvanced: () => (/* binding */ WebGLSquareColoringAdvanced)
/* harmony export */ });
/* harmony import */ var _webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webGLUtils.js */ "./src/utils/webGLUtils.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * Everything to easily draw colored squares with webGL.
 * All the same size, but different fill color.
 * The color interpolation is computed in the fragment shader program, by the GPU, thus it is less flexible but faster.
 */
class WebGLSquareColoringAdvanced {
    //see:
    //https://webglfundamentals.org/webgl/lessons/fr/webgl-shaders-and-glsl.html#les-uniforms-dans-les-shaders-de-vertex
    //https://thebookofshaders.com/glossary/?search=mix
    //https://thebookofshaders.com/06/
    //https://thebookofshaders.com/glossary/

    /**
     *
     * @param {*} gl
     * @param {Array.<String>} colors
     * @param {{fun:string,alpha:number}} stretching
     * @param {number} sizePix
     * @param {number|undefined} globalOpacity
     */
    constructor(gl, colors, stretching, sizePix = 10, globalOpacity = undefined) {
        /** @type {WebGLRenderingContext} */
        this.gl = gl
        //gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        /** @type {WebGLShader} */
        const vShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(
            gl,
            gl.VERTEX_SHADER,
            `
        attribute vec2 pos;
        uniform float sizePix;
        uniform mat3 mat;

        attribute float t;
        varying float vt;

        void main() {
          gl_Position = vec4(mat * vec3(pos, 1.0), 1.0);
          gl_PointSize = sizePix;
          vt = t;
        }
      `
        )

        //prepare fragment shader code
        //declare the uniform and other variables
        let fshString =
            '' +
            'precision mediump float;\n' +
            'varying float vt;\n' +
            'uniform float alpha;\n' +
            (() => {
                const out = []
                for (let i = 0; i < colors.length; i++) out.push('uniform vec4 c' + i + ';\n')
                return out.join('')
            })() +
            //start the main function, apply the stretching of t
            'void main(void) {\n'

        if (stretching) {
            if (stretching.fun == 'pow')
                //sPow = (t, alpha = 3) => Math.pow(t, alpha);
                fshString += '   float t = pow(vt, alpha);\n'
            else if (stretching.fun == 'powInv')
                //sPowRev = (t, alpha = 3) => 1 - Math.pow(1 - t, 1 / alpha);
                fshString += '   float t = 1.0-pow(1.0-vt, 1.0/alpha);\n'
            else if (stretching.fun == 'exp')
                //sExp = (t, alpha = 3) => alpha == 0 ? t : (Math.exp(t * alpha) - 1) / (Math.exp(alpha) - 1);
                fshString +=
                    stretching.alpha == 0
                        ? `float t = vt;`
                        : '   float t = (exp(vt * alpha) - 1.0) / (exp(alpha) - 1.0);\n'
            else if (stretching.fun == 'log')
                //sExpRev = (t, alpha = 3) => alpha == 0 ? t : 1 - (1 / alpha) * Math.log(Math.exp(alpha) * (1 - t) + t);
                fshString +=
                    stretching.alpha == 0
                        ? `float t = vt;`
                        : '   float t = 1.0 - (1.0 / alpha) * log(exp(alpha) * (1.0 - vt) + vt);\n'
            else if (stretching.fun == 'circle') {
                if (stretching.alpha == 0)
                    //if (alpha == 0) return t;
                    fshString += '   float t = vt;\n'
                else if (stretching.alpha == 1)
                    // if (alpha == 1) return Math.sqrt(2 * t - t * t);
                    fshString += '   float t = sqrt(vt * (2.0 - vt));\n'
                else {
                    //const a = alpha / (1 - alpha);
                    //return Math.sqrt(1 / (a * a) + t * (2 / a + 2 - t)) - 1 / a;
                    fshString +=
                        '   float a = alpha / (1.0 - alpha);\n' +
                        '   float t = sqrt(1.0 / (a * a) + vt * ( 2.0/a + 2.0 - vt )) - 1.0 / a;\n'
                }
            } else if (stretching.fun == 'circleInv') {
                // 1 - sCircleLow(1 - t, alpha)
                if (stretching.alpha == 0)
                    //if (alpha == 0) return t;
                    fshString += '   float t = vt;\n'
                else if (stretching.alpha == 1)
                    // if (alpha == 1) return Math.sqrt(2 * t - t * t);
                    fshString += '   float t = 1.0 - sqrt((1.0 - vt) * (1.0 + vt));\n'
                else {
                    //const a = alpha / (1 - alpha);
                    //return Math.sqrt(1 / (a * a) + (2 * t) / a + 2 * t - t * t) - 1 / a;
                    fshString +=
                        '   float a = alpha / (1.0 - alpha);\n' +
                        '   float t = 1.0 - sqrt(1.0 / (a * a) + (1.0-vt) * ( 2.0/a + 1.0 + vt )) + 1.0 / a;\n'
                }
            } else {
                console.error('Unexpected stretching function code: ' + stretching.fun)
                fshString += '   float t = vt;\n'
            }
        } else {
            fshString += '   float t = vt;\n'
        }

        //choose initial and final colors, and adjust t value
        if (colors.length == 1) fshString += '   vec4 cI=c0;\n   vec4 cF=c0;\n'
        else if (colors.length == 2) fshString += '   vec4 cI=c0;\n   vec4 cF=c1;\n'
        else {
            const nb = colors.length - 1
            const nbs = nb + '.0'
            fshString += '   vec4 cI;\n'
            fshString += '   vec4 cF;\n'
            fshString += '   if(t<1.0/' + nbs + ') { cI=c0; cF=c1; t=t*' + nbs + '; }\n'
            for (let i = 2; i < nb; i++)
                fshString +=
                    '   else if(t<' +
                    i +
                    '.0/' +
                    nbs +
                    ') { cI=c' +
                    (i - 1) +
                    '; cF=c' +
                    i +
                    '; t=' +
                    nbs +
                    '*t-' +
                    (i - 1) +
                    '.0; }\n'
            fshString +=
                '   else { cI=c' + (nb - 1) + '; cF=c' + nb + '; t=' + nbs + '*t-' + (nb - 1) + '.0; }\n'
        }

        //one single color
        if (colors.length == 1) fshString += '   gl_FragColor = vec4(c0[0], c0[1], c0[2], c0[3]);}\n'
        //set interpolated color, between initial and final one
        else fshString += '   gl_FragColor = mix(cI, cF, t);}\n'

        //console.log(fshString)

        /** @type {WebGLShader} */
        const fShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(gl, gl.FRAGMENT_SHADER, fshString)

        /** @type {WebGLProgram} */
        this.program = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.initShaderProgram)(gl, vShader, fShader)
        gl.useProgram(this.program)

        //set uniforms

        //sizePix
        //TODO: bug here. Seems to be limited to some threshold value (around 250).
        gl.uniform1f(gl.getUniformLocation(this.program, 'sizePix'), 1.0 * sizePix)

        //stretching alpha factor
        gl.uniform1f(gl.getUniformLocation(this.program, 'alpha'), stretching ? 1.0 * stretching.alpha : 0.0)

        //colors
        for (let i = 0; i < colors.length; i++) {
            const c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(colors[i])

            let opacity = c.opacity
            if (c.opacity == 1 && globalOpacity != undefined) opacity = globalOpacity

            gl.uniform4fv(gl.getUniformLocation(this.program, 'c' + i), [
                +c.r / 255.0,
                +c.g / 255.0,
                +c.b / 255.0,
                +opacity,
            ])
        }
    }

    /**  */
    draw(verticesBuffer, tBuffer, transfoMat) {
        const gl = this.gl
        const program = this.program

        //vertice data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesBuffer), gl.STATIC_DRAW)
        const position = gl.getAttribLocation(program, 'pos')
        gl.vertexAttribPointer(
            position,
            2, //numComponents
            gl.FLOAT, //type
            false, //normalise
            0, //stride
            0 //offset
        )
        gl.enableVertexAttribArray(position)

        //t data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tBuffer), gl.STATIC_DRAW)
        const t = gl.getAttribLocation(program, 't')
        gl.vertexAttribPointer(t, 1, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(t)

        //transformation
        gl.uniformMatrix3fv(gl.getUniformLocation(program, 'mat'), false, new Float32Array(transfoMat))

        // Enable the depth test
        //gl.enable(gl.DEPTH_TEST);
        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT)
        // Set the view port
        //gl.viewport(0, 0, cg.w, cg.h);

        gl.drawArrays(gl.POINTS, 0, verticesBuffer.length / 2)
    }
}


/***/ }),

/***/ "./src/utils/WebGLSquareColoringCatAdvanced.js":
/*!*****************************************************!*\
  !*** ./src/utils/WebGLSquareColoringCatAdvanced.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLSquareColoringCatAdvanced: () => (/* binding */ WebGLSquareColoringCatAdvanced)
/* harmony export */ });
/* harmony import */ var _webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webGLUtils.js */ "./src/utils/webGLUtils.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * Everything to easily draw colored squares with webGL.
 * All the same size, but different fill color.
 * Color based on categories.
 */
class WebGLSquareColoringCatAdvanced {
    /**
     * @param {Array.<string>} colors
     */
    constructor(colors) {
        /**
         * @type {Array.<string>} */
        this.colors = colors

        /** Vector shader program
         * @type {string} */
        this.vshString = `
        attribute vec2 pos;
        uniform float sizePix;
        uniform mat3 mat;

        attribute float i;
        varying float vi;

        void main() {
          gl_Position = vec4(mat * vec3(pos, 1.0), 1.0);
          gl_PointSize = sizePix;
          vi = i;
        }
        `

        //prepare fragment shader code
        //declare the uniform and other variables
        const out = []
        out.push('precision mediump float;\nvarying float vi;\n')
        //add color uniforms
        out.push('uniform vec4')
        for (let i = 0; i < colors.length; i++) {
            if (i > 0) out.push(',')
            out.push(' c' + i)
        }
        out.push(';\n')
        //start the main function
        out.push('void main(void) {\n')
        //choose color i
        for (let i = 0; i < colors.length; i++) {
            if (i > 0) out.push('else ')
            out.push('if(vi==')
            out.push(i)
            out.push('.0) gl_FragColor = vec4(c')
            out.push(i)
            out.push('[0], c')
            out.push(i)
            out.push('[1], c')
            out.push(i)
            out.push('[2], c')
            out.push(i)
            out.push('[3]);\n')
        }
        out.push('else gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}')
        /** Fragment shader program
         * @type {string} */
        this.fshString = out.join('')
    }

    /**  */
    draw(gl, verticesBuffer, iBuffer, transfoMat, sizePix = 10) {
        /** @type {WebGLShader} */
        const vShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(gl, gl.VERTEX_SHADER, this.vshString)

        /** @type {WebGLShader} */
        const fShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(gl, gl.FRAGMENT_SHADER, this.fshString)

        /** @type {WebGLProgram} */
        const program = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.initShaderProgram)(gl, vShader, fShader)
        gl.useProgram(program)

        //set uniforms

        //sizePix
        gl.uniform1f(gl.getUniformLocation(program, 'sizePix'), 1.0 * sizePix)

        //colors
        for (let i = 0; i < this.colors.length; i++) {
            const c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(this.colors[i])
            gl.uniform4fv(gl.getUniformLocation(program, 'c' + i), [
                +c.r / 255.0,
                +c.g / 255.0,
                +c.b / 255.0,
                +c.opacity,
            ])
        }

        //vertice data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesBuffer), gl.STATIC_DRAW)
        const position = gl.getAttribLocation(program, 'pos')
        gl.vertexAttribPointer(
            position,
            2, //numComponents
            gl.FLOAT, //type
            false, //normalise
            0, //stride
            0 //offset
        )
        gl.enableVertexAttribArray(position)

        //i data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(iBuffer), gl.STATIC_DRAW)
        const i = gl.getAttribLocation(program, 'i')
        gl.vertexAttribPointer(i, 1, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(i)

        //transformation
        gl.uniformMatrix3fv(gl.getUniformLocation(program, 'mat'), false, new Float32Array(transfoMat))

        // Enable the depth test
        //gl.enable(gl.DEPTH_TEST);
        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT)
        // Set the view port
        //gl.viewport(0, 0, cg.w, cg.h);

        gl.drawArrays(gl.POINTS, 0, verticesBuffer.length / 2)
    }
}


/***/ }),

/***/ "./src/utils/scale.js":
/*!****************************!*\
  !*** ./src/utils/scale.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   classifier: () => (/* binding */ classifier),
/* harmony export */   colorClassifier: () => (/* binding */ colorClassifier),
/* harmony export */   discreteColors: () => (/* binding */ discreteColors),
/* harmony export */   viewScale: () => (/* binding */ viewScale),
/* harmony export */   viewScaleColor: () => (/* binding */ viewScaleColor),
/* harmony export */   viewScaleColorQuantile: () => (/* binding */ viewScaleColorQuantile),
/* harmony export */   viewScaleCombination: () => (/* binding */ viewScaleCombination),
/* harmony export */   viewScaleQuantile: () => (/* binding */ viewScaleQuantile)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
//@ts-check


;


/**
 * A scale is simply a function that map a domain to a range.
 * @typedef {function(number):number} Scale */

/**
 * A scale whose range is a color (string).
 * @typedef {function(number):string} ColorScale */

/**
 * @module utils
 */

/**
 * Generic function for view scale - continuous or discrete
 *
 * @param {{ valueFunction:function(import("../core/Dataset").Cell):number, minValue?:number, minSizePix?:number, maxSizeFactor?:number, range?:[number, number], domain?:[number, number], stretching?:function(number):number, classNumber?:number}} opts
 * @returns {function(Array.<import("../core/Dataset").Cell>):Scale}
 */
const viewScale = (opts) => {
    const valueFunction = opts.valueFunction
    const minValue = opts.minValue || 0
    const minSizePix = opts.minSizePix || 0
    const maxSizeFactor = opts.maxSizeFactor || 1
    const stretching = opts.stretching
    const range_ = opts.range
    const domain_ = opts.domain
    const classNumber = opts.classNumber
    return (cells, resolution, z) => {
        const domain = domain_ || [minValue, (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(cells, valueFunction)]
        const range = range_ || [minSizePix * z, resolution * maxSizeFactor]
        const domainSize = domain[1] - domain[0],
            domainMin = domain[0]
        const rangeSize = range[1] - range[0],
            rangeMin = range[0]
        return (t) => {
            //scale to [0,1]
            t = (t - domainMin) / domainSize
            //stretch
            if (stretching) t = stretching(t)
            //classify
            if (classNumber) t = t == 1 ? 1 : Math.floor(t * classNumber) / (classNumber - 1)
            //scale to range
            return rangeMin + t * rangeSize
        }
    }
}

/**
 * Generic function for view scale - quantile
 *
 * @param {{ valueFunction:function(import("../core/Dataset").Cell):number, classNumber?:number, minSizePix?:number, maxSizeFactor?:number }} opts
 * @returns {function(Array.<import("../core/Dataset").Cell>):Scale}
 */
const viewScaleQuantile = (opts) => {
    const valueFunction = opts.valueFunction
    const classNumber = opts.classNumber || 12
    const minSizePix = opts.minSizePix || 1
    const maxSizeFactor = opts.maxSizeFactor || 1
    const scale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_2__["default"])()
    return (cells, resolution, z) => {
        scale.domain(cells.map(valueFunction))
        const minSizeGeo = minSizePix * z,
            maxSizeGeo = resolution * maxSizeFactor
        scale.range(
            Array.from(
                { length: classNumber },
                (_, i) => minSizeGeo + (i * (maxSizeGeo - minSizeGeo)) / (classNumber - 1)
            )
        )
        scale.breaks = scale.quantiles()
        scale.values = scale.range()
        return scale
    }
}

/**
 * Generic function for color view scale - continuous or discrete
 *
 * @param {{ valueFunction:function(import("../core/Dataset").Cell):number, colorScale?:function(number):string, colors?:Array.<string>, stretching?:function(number):number }} opts
 * @returns {function(Array.<import("../core/Dataset").Cell>):ColorScale}
 */
const viewScaleColor = (opts) => {
    const valueFunction = opts.valueFunction
    const stretching = opts.stretching
    let colorScale = opts.colorScale || (() => 'purple')

    //discrete colors case: build continuous color scale from discrete ones.
    const nbClass = opts.colors?.length
    if (opts.colors && nbClass)
        colorScale = (t) => opts.colors[t == 1 ? nbClass - 1 : Math.floor(t * nbClass)]

    return (cells) => {
        if (cells.length == 0 || !cells) return
        /** @type {[undefined, undefined] | [number, number]} */
        const domain = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__["default"])(cells, valueFunction)
        if (domain[0] == undefined) return
        const domainSize = domain[1] - domain[0]
        const scale = (t) => {
            //scale to [0,1]
            t = (t - domain[0]) / domainSize
            //stretch
            if (stretching) t = stretching(t)
            return colorScale(t)
        }
        //function that return the domain value from the [0,1] range.
        scale.invert = (t) => {
            if (stretching) t = stretching.invert(t)
            return domain[0] + t * domainSize
        }
        //discrete colors: return the breaks
        if (opts.colors && nbClass) {
            scale.breaks = []
            for (let i = 1; i < nbClass; i++) scale.breaks.push(scale.invert(i / nbClass))
        }

        return scale
    }
}

/**
 * Generic function for color view scale - quantile
 *
 * @param {{ valueFunction:function(import("../core/Dataset").Cell):number, classNumber?:number, colors?:Array.<string>, colorScale?:function(number):string }} opts
 * @returns {function(Array.<import("../core/Dataset").Cell>):ColorScale}
 */
const viewScaleColorQuantile = (opts) => {
    const valueFunction = opts.valueFunction
    const classNumber = opts.classNumber || 12

    let colors = opts.colors
    if (opts.colorScale) colors = discreteColors(opts.colorScale, classNumber)
    colors =
        colors ||
        Array.from(
            { length: classNumber },
            (_, i) => 'rgb(' + Math.floor((255 * i) / (classNumber - 1)) + ',150,150)'
        )

    const scale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_2__["default"])().range(colors)
    return (cells) => {
        scale.domain(cells.map(valueFunction))
        scale.breaks = scale.quantiles()
        scale.colors = colors
        return scale
    }
}

/**
 * Combine view scale functions
 *
 * @param {*} obj
 * @returns {function}
 */
const viewScaleCombination = (obj) => {
    //obj: prop and a function to call
    return (cells, resolution, z) => {
        const out = {}
        for (const p in obj) {
            out[p] = obj[p](cells, resolution, z)
        }
        return out
    }
}

/**
 * Return a classifier function from break values.
 * The classifier function returns the class id (from 0 to breaks.length) from a value to classifiy.
 * @param {Array.<number>} breaks the breaks
 */
function classifier(breaks) {
    const bl = breaks.length
    const classifier = (value) => {
        let i = 0
        while (i < bl) {
            const break_ = breaks[i]
            if (value <= break_) return i
            i++
        }
        return i
    }
    classifier.breaks = breaks
    return classifier
}

/**
 * Return a color classifier function from break values.
 * The classifier function returns the color from a value to classifiy.
 * There should be one color more than break values.
 * @param {Array.<number>} breaks the breaks
 * @param {Array.<string>} colors the colors
 */
function colorClassifier(breaks, colors) {
    const classifier_ = classifier(breaks)
    const colorClassifier = (value) => colors[classifier_(value)]
    colorClassifier.breaks = breaks
    colorClassifier.colors = colors
    return colorClassifier
}

/**
 * Make array of colors from a colorScale.
 * It is a kind of sampling, or un-interpolation
 *
 * @param {function(number):string} colorScale
 * @param {number} nb
 */
function discreteColors(colorScale, nb) {
    if (nb == 1) return [colorScale(0.5)]
    const out = []
    for (let i = 0; i < nb; i++) out.push(colorScale(i / (nb - 1)))
    return out
}


/***/ }),

/***/ "./src/utils/stretching.js":
/*!*********************************!*\
  !*** ./src/utils/stretching.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circularInverseScale: () => (/* binding */ circularInverseScale),
/* harmony export */   circularScale: () => (/* binding */ circularScale),
/* harmony export */   exponentialScale: () => (/* binding */ exponentialScale),
/* harmony export */   logarithmicScale: () => (/* binding */ logarithmicScale),
/* harmony export */   powerInverseScale: () => (/* binding */ powerInverseScale),
/* harmony export */   powerScale: () => (/* binding */ powerScale)
/* harmony export */ });
//@ts-check


/**
 * @module utils
 */

//TODO invert for circular
//TODO use Math.sqrt
//TODO validate

/**
 * Some function [0,1]->[0,1] to stretch range of values.
 * @see https://github.com/eurostat/gridviz/blob/master/docs/reference.md#stretching
 * @see https://observablehq.com/@jgaffuri/stretching
 */

//identity function
const identity = (t) => t
identity.invert = identity

/**
 * @param {number} base
 * @returns {function(number):number}
 */
const exponentialScale = (base = 3) => {
    if (base == 0) return identity
    const a = Math.exp(base) - 1
    const f = (t) => (Math.exp(t * base) - 1) / a
    f.invert = (t) => Math.log(a * t + 1) / base
    return f
}

/**
 * @param {number} base
 * @returns {function(number):number}
 */
const logarithmicScale = (base = 3) => {
    if (base == 0) return identity
    const a = Math.exp(base),
        b = 1 - a
    const f = (t) => 1 - Math.log(a + t * b) / base
    f.invert = (t) => (Math.exp((1 - t) * base) - a) / b
    return f
}

/**
 * @param {number} exponent
 * @returns {function(number):number}
 */
const powerScale = (exponent = 3) => {
    if (exponent == 1) return identity
    //TODO if (exponent == 0.5) return Math.sqrt
    const f = (t) => Math.pow(t, exponent)
    const a = 1 / exponent
    f.invert = (t) => Math.pow(t, a)
    return f
}

/**
 * @param {number} exponent
 * @returns {function(number):number}
 */
const powerInverseScale = (exponent = 3) => {
    if (exponent == 1) return identity
    //TODO if (exponent == 2) return t => 1 - Math.sqrt(1 - t)
    const a = 1 / exponent
    const f = (t) => 1 - Math.pow(1 - t, a)
    f.invert = (t) => 1 - Math.pow(1 - t, exponent)
    return f
}

/**
 * @param {number} circularity
 * @returns {function(number):number}
 */
const circularScale = (circularity = 0.8) => {
    if (circularity == 0) return identity
    if (circularity == 1) return (t) => Math.sqrt(t * (2 - t))
    else {
        const a = circularity / (1 - circularity)
        return (t) => Math.sqrt(1 / (a * a) + t * (2 / a + 2 - t)) - 1 / a
    }
}

/**
 * @param {number} circularity
 * @returns {function(number):number}
 */
const circularInverseScale = (circularity = 0.8) => {
    if (circularity == 0) return identity
    const f = circularScale(circularity)
    return (t) => 1 - f(1 - t)
}

//test
/*
const test = (f, fun, a, err = 1e-12) => {
    for (let t = 0; t <= 1; t += 1 / 50) {
        const er = t - f.invert(f(t))
        if (Math.abs(er) < err) continue
        console.log(fun, a, er)
    }
}

for (let fun of [powerScale, powerInverseScale])
    for (let exp = -30; exp <= 50; exp += 1) {
        if (exp == 0) continue
        const f = fun(exp)
        test(f, fun, exp)
    }


for (let fun of [exponentialScale, logarithmicScale])
    for (let base = -20; base <= 20; base += 1) {
        //if (exp == 0) continue
        const f = fun(base)
        test(f, fun, base, 1e-10)
    }
*/


/***/ }),

/***/ "./src/utils/ternary.js":
/*!******************************!*\
  !*** ./src/utils/ternary.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ternaryClassifier: () => (/* binding */ ternaryClassifier),
/* harmony export */   ternaryColorClassifier: () => (/* binding */ ternaryColorClassifier)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/lab.js");
//@ts-check


;

const ternaryClassifier = (properties, totalFunction, opts = {}) => {
    //the three properties
    const p0 = properties[0],
        p1 = properties[1],
        p2 = properties[2]

    //the classifier center point. sum must be equal to 1
    const [c0, c1, c2] = opts.center || [1 / 3, 1 / 3, 1 / 3]

    //parameter to decide wether to use mixed classes m0, m1, m2.
    const withMixedClasses = opts.withMixedClasses != undefined ? opts.withMixedClasses : true

    //parameter to decide wether to use a central class, and the size of this central class.
    //set to 0 or undefined for not showing any central class. Set to 1 for a central class that contains the mix classes
    const cc = opts.centerCoefficient ? 1 - opts.centerCoefficient : undefined

    //the output classifier method
    const fun = (c) => {
        //get total
        const tot = totalFunction(c)
        if (!tot) return undefined
        //compute shares
        const [s0, s1, s2] = [+c[p0] / tot, +c[p1] / tot, +c[p2] / tot]

        //class 0
        if (s0 >= c0 && s1 <= c1 && s2 <= c2) {
            //central class near class 0
            if (cc != undefined && (s2 - c2) * (c1 - cc * c1) >= (s1 - cc * c1) * (cc * c2 - c2))
                return 'center'
            return '0'
        }
        //class 1
        if (s0 <= c0 && s1 >= c1 && s2 <= c2) {
            //central class near class 1
            if (cc != undefined && (s2 - c2) * (c0 - cc * c0) >= (s0 - cc * c0) * (cc * c2 - c2))
                return 'center'
            return '1'
        }
        //class 2
        if (s0 <= c0 && s1 <= c1 && s2 >= c2) {
            //central class near class 2
            if (cc != undefined && (s1 - c1) * (c0 - cc * c0) >= (s0 - cc * c0) * (cc * c1 - c1))
                return 'center'
            return '2'
        }
        //middle class 0 - intersection class 1 and 2
        if (s0 <= c0 && s1 >= c1 && s2 >= c2) {
            //central class
            if (cc != undefined && s0 > cc * c0) return 'center'
            if (withMixedClasses) return 'm12'
            return s1 > s2 ? '1' : '2'
        }
        //middle class 1 - intersection class 0 and 1
        if (s0 >= c0 && s1 <= c1 && s2 >= c2) {
            //central class
            if (cc != undefined && s1 > cc * c1) return 'center'
            if (withMixedClasses) return 'm02'
            return s0 > s2 ? '0' : '2'
        }
        //middle class 2 - intersection class 0 and 1
        if (s0 >= c0 && s1 >= c1 && s2 <= c2) {
            //central class
            if (cc != undefined && s2 > cc * c2) return 'center'
            if (withMixedClasses) return 'm01'
            return s1 > s0 ? '1' : '0'
        }
        //should not happen
        return 'unknown'
    }

    //attach information to output function
    fun.center = [c0, c1, c2]
    fun.centerCoefficient = opts.centerCoefficient

    return fun
}

const ternaryColorClassifier = (properties, totalFunction, colors, opts = {}) => {
    //the three colors
    const [color0, color1, color2] = colors || ['red', 'green', 'blue']

    //the color interpolation function
    const colorInterpolation = opts.colorInterpolation || d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["default"]

    //parameter to decide wether to use mixed classes.
    const withMixedClasses = opts.withMixedClasses != undefined ? opts.withMixedClasses : true
    //https://d3js.org/d3-interpolate/color
    const mixColorFunction = (color1, color2) => colorInterpolation(color1, color2)(0.5)
    //the colors corresponding to the mixed classes
    const [mixColor0, mixColor1, mixColor2] =
        opts.mixedColors || withMixedClasses
            ? [
                  mixColorFunction(color1, color2),
                  mixColorFunction(color0, color2),
                  mixColorFunction(color0, color1),
              ]
            : []

    //the central color, used for the central class, if any. The central class is the class of relatively balanced values, around the center point
    const centerColor =
        opts.centerColor || colorInterpolation(mixColorFunction(color0, color1), color2)(0.333)

    //make classifier
    const classifier = ternaryClassifier(properties, totalFunction, opts)

    //the output color classifier method
    const fun = (c) => {
        const cla = classifier(c)
        if (cla == '0') return color0
        if (cla == '1') return color1
        if (cla == '2') return color2
        if (cla == 'm12') return mixColor0
        if (cla == 'm02') return mixColor1
        if (cla == 'm01') return mixColor2
        if (cla == 'center') return centerColor
        return opts.defaultColor || 'black'
    }
    fun.center = classifier.center
    fun.centerCoefficient = opts.centerCoefficient
    fun.colors = [color0, color1, color2]
    fun.mixColors = [mixColor0, mixColor1, mixColor2]
    fun.centerColor = centerColor
    fun.classifier = classifier

    return fun
}




// OLD VERSIONS

/*
const orderedIndexesDec = arr => [...arr.keys()].sort((a, b) => arr[b] - arr[a]);
const orderedIndexesInc = arr => [...arr.keys()].sort((a, b) => arr[a] - arr[b]);

export const ternaryClassifier = (properties, totalFunction, opts = {}) => {
    const lowThreshold = opts.lowThreshold || [1 / 3, 1 / 3, 1 / 3]
    const highThreshold = opts.highThreshold || [2 / 3, 2 / 3, 2 / 3]
    const colors = opts.colors || ["red", "green", "blue"]
    const colorInterpolation = opts.colorInterpolation || interpolateLab

    //https://d3js.org/d3-interpolate/color
    const middleColorFunction = (color1, color2) => colorInterpolation(color1, color2)(0.5)
    const middleColors = opts.middleColors || [middleColorFunction(colors[1], colors[2]), middleColorFunction(colors[0], colors[2]), middleColorFunction(colors[0], colors[1])]
    const centerColor = opts.centerColor || colorInterpolation(middleColors[2], colors[2])(0.333)

    const high_ = orderedIndexesDec(highThreshold)
    const low_ = orderedIndexesInc(lowThreshold)

    const p0 = properties[0], p1 = properties[1], p2 = properties[2]
    const fun = c => {
        //get total
        const tot = totalFunction(c)
        if (!tot) return undefined
        //compute shares
        const shares = [+c[p0] / tot, +c[p1] / tot, +c[p2] / tot]
        //return colors
        //start first with the extreme high (triangles): from the larger value (small triangle) to the lower value (large triangle)
        for (let i of high_) if (shares[i] > highThreshold[i]) return colors[i]
        //then draw the extreme low (trapeziums): from the lower value (small trapeziums) to the larger values (large trapezium)
        for (let i of low_) if (shares[i] < lowThreshold[i]) return middleColors[i]
        //else central color
        return centerColor
    }
    fun.lowThreshold = lowThreshold
    fun.highThreshold = highThreshold
    fun.colors = colors
    fun.middleColors = middleColors
    fun.centerColor = centerColor
    fun.lowIndex = low_
    fun.highIndex = high_
    return fun
}
*/

/*
export const ternaryClassifier3 = (properties, totalFunction, opts = {}) => {
    const [a01, a12, a20] = opts.thresholds || [1/3, 1/3, 1/3]
    const [c0, c1, c2] = opts.colors || ["red", "green", "blue"]
    const centerColor = opts.centerColor || "gray"

    const fff = a => a == 1 ? Infinity : a / (1 - a)
    const c01 = fff(a01), c12 = fff(a12), c20 = fff(a20)

    const p0 = properties[0], p1 = properties[1], p2 = properties[2]
    const fun = c => {
        //get total
        const tot = totalFunction(c)
        if (!tot) return undefined
        //compute shares
        const [s0, s1, s2] = [+c[p0] / tot, +c[p1] / tot, +c[p2] / tot]
        //return colors
        if (s0 * c01 > s1 && s0 > s2 * c20) return c0
        else if (s1 > s0 * c01 && s1 * c12 > s2) return c1
        else if (s2 * c20 > s0 && s2 > s1 * c12) return c2
        else return centerColor
    }
    fun.colors = [c0, c1, c2]
    fun.centerColor = centerColor
    return fun
}
*/


/***/ }),

/***/ "./src/utils/utils.js":
/*!****************************!*\
  !*** ./src/utils/utils.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getClass: () => (/* binding */ getClass),
/* harmony export */   nice: () => (/* binding */ nice)
/* harmony export */ });
//@ts-check


/**
 * Get the class id from a value and class break values
 *
 * @param {number} v the value
 * @param {Array.<number>} breaks the breaks
 * @returns The class id, from 0 to breaks.length
 * @deprecated use getClassifier instead.
 */
function getClass(v, breaks) {
    if (!breaks) return
    if (breaks.length == 0) return 0
    if (v <= breaks[0]) return 0
    for (let i = 1; i < breaks.length; i++) if (breaks[i - 1] < v && v <= breaks[i]) return i
    return breaks.length
}

//take 'nice' value (power of ten, or multiple)
function nice(v, multiples = [8, 6, 5, 4, 2.5, 2]) {
    //compute bigger power of ten below
    const v_ = Math.pow(10, Math.floor(Math.log10(v)))
    for (let multiple of multiples) if (v_ * multiple <= v) return v_ * multiple
    return v_
}

/*
//no longer used
export function loadImage(src) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function () { resolve(img); };
        img.onerror = function () { reject(new Error('Error loading image')); };
        img.src = src;
    });
}
*/

/*
export let monitor = false

let previousDate
export function monitorDuration(message) {
    const nowDate = Date.now()

    //first call
    if (!previousDate) {
        previousDate = nowDate
        console.log(previousDate, message)
        return
    }

    const d = nowDate - previousDate
    previousDate = nowDate
    console.log(d, message)
}
*/


/***/ }),

/***/ "./src/utils/webGLUtils.js":
/*!*********************************!*\
  !*** ./src/utils/webGLUtils.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkWebGLSupport: () => (/* binding */ checkWebGLSupport),
/* harmony export */   createShader: () => (/* binding */ createShader),
/* harmony export */   initShaderProgram: () => (/* binding */ initShaderProgram),
/* harmony export */   makeWebGLCanvas: () => (/* binding */ makeWebGLCanvas)
/* harmony export */ });
//@ts-check


/**
 * @param {string} width
 * @param {string} height
 * @param {object} opts
 * @returns {{canvas:HTMLCanvasElement, gl:WebGLRenderingContext}}
 */
function makeWebGLCanvas(width, height, opts = {}) {
    const canvas = document.createElement('canvas')
    canvas.setAttribute('width', width)
    canvas.setAttribute('height', height)
    /** @type {WebGLRenderingContext} */
    const gl = canvas.getContext('webgl', opts)
    if (!gl) {
        throw new Error('Unable to initialize WebGL. Your browser or machine may not support it.')
    }
    return { canvas: canvas, gl: gl }
}

/**
 * Initialize a shader program, so WebGL knows how to draw our data
 *
 * @param {WebGLRenderingContext} gl
 * @param  {...WebGLShader} shaders
 * @returns {WebGLProgram}
 */
function initShaderProgram(gl, ...shaders) {
    /** @type {WebGLProgram|null} */
    const program = gl.createProgram()
    if (program == null) throw new Error('Cannot create webGL program')
    for (const shader of shaders) gl.attachShader(program, shader)
    gl.linkProgram(program)
    if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program
    throw new Error(gl.getProgramInfoLog(program) || 'Cannot create webGL program (2)')
}

/**
 * Creates a shader of the given type, uploads the source and compiles it.
 *
 * @param {WebGLRenderingContext} gl
 * @param {number} type
 * @param  {...string} sources
 * @returns {WebGLShader}
 */
function createShader(gl, type, ...sources) {
    /** @type {WebGLShader|null} */
    const shader = gl.createShader(type)
    if (shader == null) throw new Error('Cannot create webGL shader')
    gl.shaderSource(shader, sources.join('\n'))
    gl.compileShader(shader)
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader
    throw new Error(gl.getShaderInfoLog(shader) || 'Cannot create webGL shader (2)')
}

/**
 * Check if webGL is supported
 *
 * @returns {boolean}
 */
function checkWebGLSupport() {
    try {
        const canvas = document.createElement('canvas')
        return !!(
            !!window.WebGLRenderingContext &&
            (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
        )
    } catch (err) {
        return false
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundLayer: () => (/* reexport safe */ _layer_BackgroundLayer_js__WEBPACK_IMPORTED_MODULE_29__.BackgroundLayer),
/* harmony export */   BackgroundLayerImage: () => (/* reexport safe */ _layer_BackgroundLayerImage_js__WEBPACK_IMPORTED_MODULE_31__.BackgroundLayerImage),
/* harmony export */   BackgroundLayerWMS: () => (/* reexport safe */ _layer_BackgroundLayerWMS_js__WEBPACK_IMPORTED_MODULE_30__.BackgroundLayerWMS),
/* harmony export */   CSVGrid: () => (/* reexport safe */ _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_7__.CSVGrid),
/* harmony export */   ColorCategoryLegend: () => (/* reexport safe */ _legend_ColorCategoryLegend_js__WEBPACK_IMPORTED_MODULE_36__.ColorCategoryLegend),
/* harmony export */   ColorDiscreteLegend: () => (/* reexport safe */ _legend_ColorDiscreteLegend_js__WEBPACK_IMPORTED_MODULE_35__.ColorDiscreteLegend),
/* harmony export */   ColorLegend: () => (/* reexport safe */ _legend_ColorLegend_js__WEBPACK_IMPORTED_MODULE_34__.ColorLegend),
/* harmony export */   CompositionStyle: () => (/* reexport safe */ _style_CompositionStyle_js__WEBPACK_IMPORTED_MODULE_12__.CompositionStyle),
/* harmony export */   Dataset: () => (/* reexport safe */ _core_Dataset_js__WEBPACK_IMPORTED_MODULE_4__.Dataset),
/* harmony export */   DotDensityStyle: () => (/* reexport safe */ _style_DotDensityStyle_js__WEBPACK_IMPORTED_MODULE_18__.DotDensityStyle),
/* harmony export */   GeoCanvas: () => (/* reexport safe */ _core_GeoCanvas_js__WEBPACK_IMPORTED_MODULE_1__.GeoCanvas),
/* harmony export */   GeoJSONLayer: () => (/* reexport safe */ _layer_GeoJSONLayer_js__WEBPACK_IMPORTED_MODULE_33__.GeoJSONLayer),
/* harmony export */   GridLayer: () => (/* reexport safe */ _layer_GridLayer_js__WEBPACK_IMPORTED_MODULE_28__.GridLayer),
/* harmony export */   ImageStyle: () => (/* reexport safe */ _style_ImageStyle_js__WEBPACK_IMPORTED_MODULE_27__.ImageStyle),
/* harmony export */   IsoFenceStyle: () => (/* reexport safe */ _style_IsoFenceStyle_js__WEBPACK_IMPORTED_MODULE_26__.IsoFenceStyle),
/* harmony export */   JSGrid: () => (/* reexport safe */ _dataset_JSGrid_js__WEBPACK_IMPORTED_MODULE_8__.JSGrid),
/* harmony export */   JoyPlotStyle: () => (/* reexport safe */ _style_JoyPlotStyle_js__WEBPACK_IMPORTED_MODULE_11__.JoyPlotStyle),
/* harmony export */   LabelLayer: () => (/* reexport safe */ _layer_LabelLayer_js__WEBPACK_IMPORTED_MODULE_32__.LabelLayer),
/* harmony export */   Layer: () => (/* reexport safe */ _core_Layer_js__WEBPACK_IMPORTED_MODULE_3__.Layer),
/* harmony export */   LegoStyle: () => (/* reexport safe */ _style_LegoStyle_js__WEBPACK_IMPORTED_MODULE_20__.LegoStyle),
/* harmony export */   Map: () => (/* reexport safe */ _core_Map_js__WEBPACK_IMPORTED_MODULE_0__.Map),
/* harmony export */   MosaicStyle: () => (/* reexport safe */ _style_MosaicStyle_js__WEBPACK_IMPORTED_MODULE_23__.MosaicStyle),
/* harmony export */   MultiResolutionDataset: () => (/* reexport safe */ _core_MultiResolutionDataset_js__WEBPACK_IMPORTED_MODULE_5__.MultiResolutionDataset),
/* harmony export */   NinjaStarStyle: () => (/* reexport safe */ _style_NinjaStarStyle_js__WEBPACK_IMPORTED_MODULE_24__.NinjaStarStyle),
/* harmony export */   OrientationLegend: () => (/* reexport safe */ _legend_OrientationLegend_js__WEBPACK_IMPORTED_MODULE_38__.OrientationLegend),
/* harmony export */   PillarStyle: () => (/* reexport safe */ _style_PillarStyle_js__WEBPACK_IMPORTED_MODULE_15__.PillarStyle),
/* harmony export */   SegmentStyle: () => (/* reexport safe */ _style_SegmentStyle_js__WEBPACK_IMPORTED_MODULE_13__.SegmentStyle),
/* harmony export */   ShapeColorSizeStyle: () => (/* reexport safe */ _style_ShapeColorSizeStyle_js__WEBPACK_IMPORTED_MODULE_9__.ShapeColorSizeStyle),
/* harmony export */   SideCategoryStyle: () => (/* reexport safe */ _style_SideCategoryStyle_js__WEBPACK_IMPORTED_MODULE_17__.SideCategoryStyle),
/* harmony export */   SideStyle: () => (/* reexport safe */ _style_SideStyle_js__WEBPACK_IMPORTED_MODULE_16__.SideStyle),
/* harmony export */   SizeLegend: () => (/* reexport safe */ _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_37__.SizeLegend),
/* harmony export */   SquareColorCategoryWebGLStyle: () => (/* reexport safe */ _style_SquareColorCategoryWebGLStyle_js__WEBPACK_IMPORTED_MODULE_22__.SquareColorCategoryWebGLStyle),
/* harmony export */   SquareColorWebGLStyle: () => (/* reexport safe */ _style_SquareColorWebGLStyle_js__WEBPACK_IMPORTED_MODULE_21__.SquareColorWebGLStyle),
/* harmony export */   StrokeStyle: () => (/* reexport safe */ _style_StrokeStyle_js__WEBPACK_IMPORTED_MODULE_10__.StrokeStyle),
/* harmony export */   Style: () => (/* reexport safe */ _core_Style_js__WEBPACK_IMPORTED_MODULE_2__.Style),
/* harmony export */   TanakaStyle: () => (/* reexport safe */ _style_TanakaStyle_js__WEBPACK_IMPORTED_MODULE_19__.TanakaStyle),
/* harmony export */   TernaryLegend: () => (/* reexport safe */ _legend_TernaryLegend_js__WEBPACK_IMPORTED_MODULE_39__.TernaryLegend),
/* harmony export */   TextStyle: () => (/* reexport safe */ _style_TextStyle_js__WEBPACK_IMPORTED_MODULE_14__.TextStyle),
/* harmony export */   TiledGrid: () => (/* reexport safe */ _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_6__.TiledGrid),
/* harmony export */   TimeSeriesStyle: () => (/* reexport safe */ _style_TimeSeriesStyle_js__WEBPACK_IMPORTED_MODULE_25__.TimeSeriesStyle),
/* harmony export */   circularInverseScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_40__.circularInverseScale),
/* harmony export */   circularScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_40__.circularScale),
/* harmony export */   classifier: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_41__.classifier),
/* harmony export */   colorClassifier: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_41__.colorClassifier),
/* harmony export */   discreteColors: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_41__.discreteColors),
/* harmony export */   exponentialScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_40__.exponentialScale),
/* harmony export */   getParameterByName: () => (/* binding */ getParameterByName),
/* harmony export */   logarithmicScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_40__.logarithmicScale),
/* harmony export */   nice: () => (/* reexport safe */ _utils_utils_js__WEBPACK_IMPORTED_MODULE_43__.nice),
/* harmony export */   orientationLegend: () => (/* reexport safe */ _legend_OrientationLegend_js__WEBPACK_IMPORTED_MODULE_38__.orientationLegend),
/* harmony export */   powerInverseScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_40__.powerInverseScale),
/* harmony export */   powerScale: () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_40__.powerScale),
/* harmony export */   sizeDiscreteLegend: () => (/* reexport safe */ _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_37__.sizeDiscreteLegend),
/* harmony export */   sizeDiscreteViewScaleLegend: () => (/* reexport safe */ _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_37__.sizeDiscreteViewScaleLegend),
/* harmony export */   sizeLegend: () => (/* reexport safe */ _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_37__.sizeLegend),
/* harmony export */   sizeLegendViewScale: () => (/* reexport safe */ _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_37__.sizeLegendViewScale),
/* harmony export */   ternaryClassifier: () => (/* reexport safe */ _utils_ternary_js__WEBPACK_IMPORTED_MODULE_42__.ternaryClassifier),
/* harmony export */   ternaryColorClassifier: () => (/* reexport safe */ _utils_ternary_js__WEBPACK_IMPORTED_MODULE_42__.ternaryColorClassifier),
/* harmony export */   viewScale: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_41__.viewScale),
/* harmony export */   viewScaleColor: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_41__.viewScaleColor),
/* harmony export */   viewScaleColorQuantile: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_41__.viewScaleColorQuantile),
/* harmony export */   viewScaleCombination: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_41__.viewScaleCombination),
/* harmony export */   viewScaleQuantile: () => (/* reexport safe */ _utils_scale_js__WEBPACK_IMPORTED_MODULE_41__.viewScaleQuantile)
/* harmony export */ });
/* harmony import */ var _core_Map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Map.js */ "./src/core/Map.js");
/* harmony import */ var _core_GeoCanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/GeoCanvas.js */ "./src/core/GeoCanvas.js");
/* harmony import */ var _core_Style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/Style.js */ "./src/core/Style.js");
/* harmony import */ var _core_Layer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/Layer.js */ "./src/core/Layer.js");
/* harmony import */ var _core_Dataset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/Dataset.js */ "./src/core/Dataset.js");
/* harmony import */ var _core_MultiResolutionDataset_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/MultiResolutionDataset.js */ "./src/core/MultiResolutionDataset.js");
/* harmony import */ var _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dataset/TiledGrid.js */ "./src/dataset/TiledGrid.js");
/* harmony import */ var _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dataset/CSVGrid.js */ "./src/dataset/CSVGrid.js");
/* harmony import */ var _dataset_JSGrid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dataset/JSGrid.js */ "./src/dataset/JSGrid.js");
/* harmony import */ var _style_ShapeColorSizeStyle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./style/ShapeColorSizeStyle.js */ "./src/style/ShapeColorSizeStyle.js");
/* harmony import */ var _style_StrokeStyle_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style/StrokeStyle.js */ "./src/style/StrokeStyle.js");
/* harmony import */ var _style_JoyPlotStyle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./style/JoyPlotStyle.js */ "./src/style/JoyPlotStyle.js");
/* harmony import */ var _style_CompositionStyle_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./style/CompositionStyle.js */ "./src/style/CompositionStyle.js");
/* harmony import */ var _style_SegmentStyle_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./style/SegmentStyle.js */ "./src/style/SegmentStyle.js");
/* harmony import */ var _style_TextStyle_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./style/TextStyle.js */ "./src/style/TextStyle.js");
/* harmony import */ var _style_PillarStyle_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./style/PillarStyle.js */ "./src/style/PillarStyle.js");
/* harmony import */ var _style_SideStyle_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./style/SideStyle.js */ "./src/style/SideStyle.js");
/* harmony import */ var _style_SideCategoryStyle_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./style/SideCategoryStyle.js */ "./src/style/SideCategoryStyle.js");
/* harmony import */ var _style_DotDensityStyle_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./style/DotDensityStyle.js */ "./src/style/DotDensityStyle.js");
/* harmony import */ var _style_TanakaStyle_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style/TanakaStyle.js */ "./src/style/TanakaStyle.js");
/* harmony import */ var _style_LegoStyle_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./style/LegoStyle.js */ "./src/style/LegoStyle.js");
/* harmony import */ var _style_SquareColorWebGLStyle_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./style/SquareColorWebGLStyle.js */ "./src/style/SquareColorWebGLStyle.js");
/* harmony import */ var _style_SquareColorCategoryWebGLStyle_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./style/SquareColorCategoryWebGLStyle.js */ "./src/style/SquareColorCategoryWebGLStyle.js");
/* harmony import */ var _style_MosaicStyle_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./style/MosaicStyle.js */ "./src/style/MosaicStyle.js");
/* harmony import */ var _style_NinjaStarStyle_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./style/NinjaStarStyle.js */ "./src/style/NinjaStarStyle.js");
/* harmony import */ var _style_TimeSeriesStyle_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./style/TimeSeriesStyle.js */ "./src/style/TimeSeriesStyle.js");
/* harmony import */ var _style_IsoFenceStyle_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./style/IsoFenceStyle.js */ "./src/style/IsoFenceStyle.js");
/* harmony import */ var _style_ImageStyle_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./style/ImageStyle.js */ "./src/style/ImageStyle.js");
/* harmony import */ var _layer_GridLayer_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./layer/GridLayer.js */ "./src/layer/GridLayer.js");
/* harmony import */ var _layer_BackgroundLayer_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./layer/BackgroundLayer.js */ "./src/layer/BackgroundLayer.js");
/* harmony import */ var _layer_BackgroundLayerWMS_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./layer/BackgroundLayerWMS.js */ "./src/layer/BackgroundLayerWMS.js");
/* harmony import */ var _layer_BackgroundLayerImage_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./layer/BackgroundLayerImage.js */ "./src/layer/BackgroundLayerImage.js");
/* harmony import */ var _layer_LabelLayer_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./layer/LabelLayer.js */ "./src/layer/LabelLayer.js");
/* harmony import */ var _layer_GeoJSONLayer_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./layer/GeoJSONLayer.js */ "./src/layer/GeoJSONLayer.js");
/* harmony import */ var _legend_ColorLegend_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./legend/ColorLegend.js */ "./src/legend/ColorLegend.js");
/* harmony import */ var _legend_ColorDiscreteLegend_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./legend/ColorDiscreteLegend.js */ "./src/legend/ColorDiscreteLegend.js");
/* harmony import */ var _legend_ColorCategoryLegend_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./legend/ColorCategoryLegend.js */ "./src/legend/ColorCategoryLegend.js");
/* harmony import */ var _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./legend/SizeLegend.js */ "./src/legend/SizeLegend.js");
/* harmony import */ var _legend_OrientationLegend_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./legend/OrientationLegend.js */ "./src/legend/OrientationLegend.js");
/* harmony import */ var _legend_TernaryLegend_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./legend/TernaryLegend.js */ "./src/legend/TernaryLegend.js");
/* harmony import */ var _utils_stretching_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./utils/stretching.js */ "./src/utils/stretching.js");
/* harmony import */ var _utils_scale_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./utils/scale.js */ "./src/utils/scale.js");
/* harmony import */ var _utils_ternary_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./utils/ternary.js */ "./src/utils/ternary.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./utils/utils.js */ "./src/utils/utils.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
//@ts-check


// the application







// export dataset types




// export styles








//export { ContourStyle } from './style/ContourStyle.js'












// export additional layers







// export legends







// export { goToStraight, zoomTo } from "./utils/zoomUtils"





;
const getParameterByName = _core_GeoCanvas_js__WEBPACK_IMPORTED_MODULE_1__.GeoCanvas.getParameterByName

// set default d3 locale
;
(0,d3_format__WEBPACK_IMPORTED_MODULE_44__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', '€'],
})

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUF5QixJQUFJO0FBQzdCLHdDQUF3QyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDMUQsd0NBQXdDLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSTtBQUMxRCwwQ0FBMEMsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSTtBQUNuRSwwQ0FBMEMsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSTtBQUNuRSx3Q0FBd0MsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJO0FBQzFELDBDQUEwQyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlLFlBQVksU0FBUztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3hIb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsOENBQU07QUFDdkM7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFD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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzdTQTtBQUNZO0FBQ1o7QUFDQSxDQUF3QztBQUN4QztBQUNBLGNBQWMsb0VBQW9FO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLGlEQUFLO0FBQzNDLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1GQUFtRjtBQUNyRztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEVBQTRFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5RUFBeUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUVBQXlFO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5RUFBeUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJDQUEyQztBQUMxRCxlQUFlLDBDQUEwQztBQUN6RCxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Ozs7OztXQ1BBLHdGOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RCxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDWTtBQUNaO0FBQ0E7QUFDbUM7QUFDWTtBQUNSO0FBQ0E7QUFDSTtBQUM4QjtBQUN6RTtBQUNBO0FBQ2tEO0FBQ0o7QUFDRjtBQUM1QztBQUNBO0FBQ29FO0FBQ2hCO0FBQ0U7QUFDUTtBQUNSO0FBQ047QUFDSTtBQUNKO0FBQ2hELFdBQVcsZUFBZTtBQUNzQztBQUNKO0FBQ1I7QUFDSjtBQUN3QjtBQUNnQjtBQUNwQztBQUNNO0FBQ0U7QUFDSjtBQUNOO0FBQ2xEO0FBQ0E7QUFDZ0Q7QUFDWTtBQUNNO0FBQ0k7QUFDcEI7QUFDSTtBQUN0RDtBQUNBO0FBQ3FEO0FBQ2dCO0FBQ0E7QUFPdEM7QUFDcUQ7QUFDM0I7QUFDekQ7QUFDQSxZQUFZLHVCQUF1QjtBQUNFO0FBQ0w7QUFDRTtBQUNLO0FBQ3ZDO0FBQ0EsQ0FBK0M7QUFDeEMsMkJBQTJCLHlEQUFTO0FBQzNDO0FBQ0E7QUFDQSxDQUErQztBQUMvQyxzREFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZHZpei93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYXNjZW5kaW5nLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9iaXNlY3Rvci5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9kZXNjZW5kaW5nLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2V4dGVudC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9ncmVhdGVzdC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tYXguanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWF4SW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWluLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21pbkluZGV4LmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL251bWJlci5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9wZXJtdXRlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3F1YW50aWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3F1aWNrc2VsZWN0LmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3NvcnQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvZGVmaW5lLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2xhYi5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9tYXRoLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtZGlzcGF0Y2gvc3JjL2Rpc3BhdGNoLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9kcmFnLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtZHJhZy9zcmMvbm9ldmVudC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWRzdi9zcmMvY3N2LmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtZHN2L3NyYy9kc3YuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1kc3Yvc3JjL3Rzdi5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWVhc2Uvc3JjL2N1YmljLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtZmV0Y2gvc3JjL2Rzdi5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWZldGNoL3NyYy9qc29uLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtZmV0Y2gvc3JjL3RleHQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2RlZmF1bHRMb2NhbGUuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2V4cG9uZW50LmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXREZWNpbWFsLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRHcm91cC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0TnVtZXJhbHMuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFByZWZpeEF1dG8uanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFJvdW5kZWQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFNwZWNpZmllci5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0VHJpbS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0VHlwZXMuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9sb2NhbGUuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYmFzaXMuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYmFzaXNDbG9zZWQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbGFiLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL251bWJlci5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9yZ2IuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvc3RyaW5nLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9kZWNvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2luZGV4LmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9wYXJzZS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy96b29tLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtcmFuZG9tL3NyYy9kZWZhdWx0U291cmNlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtcmFuZG9tL3NyYy9ub3JtYWwuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvaW5pdC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9xdWFudGlsZS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9jcmVhdG9yLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9tYXRjaGVyLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9uYW1lc3BhY2UuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2FwcGVuZC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jYWxsLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vY2xhc3NlZC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2Nsb25lLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0YS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2RhdHVtLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lYWNoLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZW1wdHkuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbnRlci5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2V4aXQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9odG1sLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pbnNlcnQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2pvaW4uanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9sb3dlci5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL21lcmdlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL25vZGVzLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vb24uanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vcmRlci5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3Byb3BlcnR5LmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcmFpc2UuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3RBbGwuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zZWxlY3RDaGlsZC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdENoaWxkcmVuLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2l6ZS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NvcnQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zcGFyc2UuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zdHlsZS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3RleHQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdG9yLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3RvckFsbC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc291cmNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3dpbmRvdy5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy90aW1lb3V0LmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL3RpbWVyLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvYWN0aXZlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9pbnRlcnJ1cHQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vaW50ZXJydXB0LmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvc2VsZWN0aW9uL3RyYW5zaXRpb24uanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2F0dHIuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2F0dHJUd2Vlbi5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZGVsYXkuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2R1cmF0aW9uLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9lYXNlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9lYXNlVmFyeWluZy5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZW5kLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2luZGV4LmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9pbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL29uLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NjaGVkdWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0aW9uLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zdHlsZS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc3R5bGVUd2Vlbi5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vdGV4dC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vdGV4dFR3ZWVuLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90d2Vlbi5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL2dyaWR2aXovLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL25vZXZlbnQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy96b29tLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvYnV0dG9uL0J1dHRvbi5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL2J1dHRvbi9GdWxsc2NyZWVuQnV0dG9uLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvYnV0dG9uL1pvb21CdXR0b25zLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvY29yZS9EYXRhc2V0LmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvY29yZS9EcmF3YWJsZS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL2NvcmUvR2VvQ2FudmFzLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvY29yZS9MYXllci5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL2NvcmUvTGVnZW5kLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvY29yZS9NYXAuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL3NyYy9jb3JlL011bHRpUmVzb2x1dGlvbkRhdGFzZXQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL3NyYy9jb3JlL1N0eWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvY29yZS9Ub29sdGlwLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvZGF0YXNldC9DU1ZHcmlkLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvZGF0YXNldC9KU0dyaWQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL3NyYy9kYXRhc2V0L1RpbGVkR3JpZC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL2xheWVyL0JhY2tncm91bmRMYXllci5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL2xheWVyL0JhY2tncm91bmRMYXllckltYWdlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvbGF5ZXIvQmFja2dyb3VuZExheWVyV01TLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvbGF5ZXIvR2VvSlNPTkxheWVyLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvbGF5ZXIvR3JpZExheWVyLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvbGF5ZXIvTGFiZWxMYXllci5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL2xlZ2VuZC9Db2xvckNhdGVnb3J5TGVnZW5kLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvbGVnZW5kL0NvbG9yRGlzY3JldGVMZWdlbmQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL3NyYy9sZWdlbmQvQ29sb3JMZWdlbmQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL3NyYy9sZWdlbmQvT3JpZW50YXRpb25MZWdlbmQuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL3NyYy9sZWdlbmQvU2l6ZUxlZ2VuZC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL2xlZ2VuZC9UZXJuYXJ5TGVnZW5kLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvc3R5bGUvQ29tcG9zaXRpb25TdHlsZS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL3N0eWxlL0RvdERlbnNpdHlTdHlsZS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL3N0eWxlL0ltYWdlU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL3NyYy9zdHlsZS9Jc29GZW5jZVN0eWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvc3R5bGUvSm95UGxvdFN0eWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvc3R5bGUvTGVnb1N0eWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvc3R5bGUvTW9zYWljU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL3NyYy9zdHlsZS9OaW5qYVN0YXJTdHlsZS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL3N0eWxlL1BpbGxhclN0eWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvc3R5bGUvU2VnbWVudFN0eWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvc3R5bGUvU2hhcGVDb2xvclNpemVTdHlsZS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL3N0eWxlL1NpZGVDYXRlZ29yeVN0eWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvc3R5bGUvU2lkZVN0eWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvc3R5bGUvU3F1YXJlQ29sb3JDYXRlZ29yeVdlYkdMU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL3NyYy9zdHlsZS9TcXVhcmVDb2xvcldlYkdMU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL3NyYy9zdHlsZS9TdHJva2VTdHlsZS5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL3N0eWxlL1RhbmFrYVN0eWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvc3R5bGUvVGV4dFN0eWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvc3R5bGUvVGltZVNlcmllc1N0eWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvdXRpbHMvV2ViR0xTcXVhcmVDb2xvcmluZy5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL3V0aWxzL1dlYkdMU3F1YXJlQ29sb3JpbmdBZHZhbmNlZC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL3V0aWxzL1dlYkdMU3F1YXJlQ29sb3JpbmdDYXRBZHZhbmNlZC5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL3V0aWxzL3NjYWxlLmpzIiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvdXRpbHMvc3RyZXRjaGluZy5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL3V0aWxzL3Rlcm5hcnkuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei8uL3NyYy91dGlscy91dGlscy5qcyIsIndlYnBhY2s6Ly9ncmlkdml6Ly4vc3JjL3V0aWxzL3dlYkdMVXRpbHMuanMiLCJ3ZWJwYWNrOi8vZ3JpZHZpei93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9ncmlkdml6L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9ncmlkdml6L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vZ3JpZHZpei93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2dyaWR2aXovLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZ3JpZHZpelwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJncmlkdml6XCJdID0gZmFjdG9yeSgpO1xufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuICIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhID09IG51bGwgfHwgYiA9PSBudWxsID8gTmFOIDogYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZy5qc1wiO1xuaW1wb3J0IGJpc2VjdG9yIGZyb20gXCIuL2Jpc2VjdG9yLmpzXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuXG5jb25zdCBhc2NlbmRpbmdCaXNlY3QgPSBiaXNlY3Rvcihhc2NlbmRpbmcpO1xuZXhwb3J0IGNvbnN0IGJpc2VjdFJpZ2h0ID0gYXNjZW5kaW5nQmlzZWN0LnJpZ2h0O1xuZXhwb3J0IGNvbnN0IGJpc2VjdExlZnQgPSBhc2NlbmRpbmdCaXNlY3QubGVmdDtcbmV4cG9ydCBjb25zdCBiaXNlY3RDZW50ZXIgPSBiaXNlY3RvcihudW1iZXIpLmNlbnRlcjtcbmV4cG9ydCBkZWZhdWx0IGJpc2VjdFJpZ2h0O1xuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmcuanNcIjtcbmltcG9ydCBkZXNjZW5kaW5nIGZyb20gXCIuL2Rlc2NlbmRpbmcuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmlzZWN0b3IoZikge1xuICBsZXQgY29tcGFyZTEsIGNvbXBhcmUyLCBkZWx0YTtcblxuICAvLyBJZiBhbiBhY2Nlc3NvciBpcyBzcGVjaWZpZWQsIHByb21vdGUgaXQgdG8gYSBjb21wYXJhdG9yLiBJbiB0aGlzIGNhc2Ugd2VcbiAgLy8gY2FuIHRlc3Qgd2hldGhlciB0aGUgc2VhcmNoIHZhbHVlIGlzIChzZWxmLSkgY29tcGFyYWJsZS4gV2UgY2Fu4oCZdCBkbyB0aGlzXG4gIC8vIGZvciBhIGNvbXBhcmF0b3IgKGV4Y2VwdCBmb3Igc3BlY2lmaWMsIGtub3duIGNvbXBhcmF0b3JzKSBiZWNhdXNlIHdlIGNhbuKAmXRcbiAgLy8gdGVsbCBpZiB0aGUgY29tcGFyYXRvciBpcyBzeW1tZXRyaWMsIGFuZCBhbiBhc3ltbWV0cmljIGNvbXBhcmF0b3IgY2Fu4oCZdCBiZVxuICAvLyB1c2VkIHRvIHRlc3Qgd2hldGhlciBhIHNpbmdsZSB2YWx1ZSBpcyBjb21wYXJhYmxlLlxuICBpZiAoZi5sZW5ndGggIT09IDIpIHtcbiAgICBjb21wYXJlMSA9IGFzY2VuZGluZztcbiAgICBjb21wYXJlMiA9IChkLCB4KSA9PiBhc2NlbmRpbmcoZihkKSwgeCk7XG4gICAgZGVsdGEgPSAoZCwgeCkgPT4gZihkKSAtIHg7XG4gIH0gZWxzZSB7XG4gICAgY29tcGFyZTEgPSBmID09PSBhc2NlbmRpbmcgfHwgZiA9PT0gZGVzY2VuZGluZyA/IGYgOiB6ZXJvO1xuICAgIGNvbXBhcmUyID0gZjtcbiAgICBkZWx0YSA9IGY7XG4gIH1cblxuICBmdW5jdGlvbiBsZWZ0KGEsIHgsIGxvID0gMCwgaGkgPSBhLmxlbmd0aCkge1xuICAgIGlmIChsbyA8IGhpKSB7XG4gICAgICBpZiAoY29tcGFyZTEoeCwgeCkgIT09IDApIHJldHVybiBoaTtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgbWlkID0gKGxvICsgaGkpID4+PiAxO1xuICAgICAgICBpZiAoY29tcGFyZTIoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTtcbiAgICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICAgIH0gd2hpbGUgKGxvIDwgaGkpO1xuICAgIH1cbiAgICByZXR1cm4gbG87XG4gIH1cblxuICBmdW5jdGlvbiByaWdodChhLCB4LCBsbyA9IDAsIGhpID0gYS5sZW5ndGgpIHtcbiAgICBpZiAobG8gPCBoaSkge1xuICAgICAgaWYgKGNvbXBhcmUxKHgsIHgpICE9PSAwKSByZXR1cm4gaGk7XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IG1pZCA9IChsbyArIGhpKSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUyKGFbbWlkXSwgeCkgPD0gMCkgbG8gPSBtaWQgKyAxO1xuICAgICAgICBlbHNlIGhpID0gbWlkO1xuICAgICAgfSB3aGlsZSAobG8gPCBoaSk7XG4gICAgfVxuICAgIHJldHVybiBsbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbnRlcihhLCB4LCBsbyA9IDAsIGhpID0gYS5sZW5ndGgpIHtcbiAgICBjb25zdCBpID0gbGVmdChhLCB4LCBsbywgaGkgLSAxKTtcbiAgICByZXR1cm4gaSA+IGxvICYmIGRlbHRhKGFbaSAtIDFdLCB4KSA+IC1kZWx0YShhW2ldLCB4KSA/IGkgLSAxIDogaTtcbiAgfVxuXG4gIHJldHVybiB7bGVmdCwgY2VudGVyLCByaWdodH07XG59XG5cbmZ1bmN0aW9uIHplcm8oKSB7XG4gIHJldHVybiAwO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhID09IG51bGwgfHwgYiA9PSBudWxsID8gTmFOXG4gICAgOiBiIDwgYSA/IC0xXG4gICAgOiBiID4gYSA/IDFcbiAgICA6IGIgPj0gYSA/IDBcbiAgICA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4dGVudCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IG1pbjtcbiAgbGV0IG1heDtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPj0gdmFsdWUpIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh2YWx1ZSA+PSB2YWx1ZSkgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbbWluLCBtYXhdO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmcuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ3JlYXRlc3QodmFsdWVzLCBjb21wYXJlID0gYXNjZW5kaW5nKSB7XG4gIGxldCBtYXg7XG4gIGxldCBkZWZpbmVkID0gZmFsc2U7XG4gIGlmIChjb21wYXJlLmxlbmd0aCA9PT0gMSkge1xuICAgIGxldCBtYXhWYWx1ZTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdmFsdWVzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNvbXBhcmUoZWxlbWVudCk7XG4gICAgICBpZiAoZGVmaW5lZFxuICAgICAgICAgID8gYXNjZW5kaW5nKHZhbHVlLCBtYXhWYWx1ZSkgPiAwXG4gICAgICAgICAgOiBhc2NlbmRpbmcodmFsdWUsIHZhbHVlKSA9PT0gMCkge1xuICAgICAgICBtYXggPSBlbGVtZW50O1xuICAgICAgICBtYXhWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBkZWZpbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmIChkZWZpbmVkXG4gICAgICAgICAgPyBjb21wYXJlKHZhbHVlLCBtYXgpID4gMFxuICAgICAgICAgIDogY29tcGFyZSh2YWx1ZSwgdmFsdWUpID09PSAwKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICBkZWZpbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1heCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IG1heDtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbFxuICAgICAgICAgICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbFxuICAgICAgICAgICYmIChtYXggPCB2YWx1ZSB8fCAobWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1heEluZGV4KHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWF4O1xuICBsZXQgbWF4SW5kZXggPSAtMTtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgKytpbmRleDtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1heCA8IHZhbHVlIHx8IChtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1heCA9IHZhbHVlLCBtYXhJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1heCA8IHZhbHVlIHx8IChtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1heCA9IHZhbHVlLCBtYXhJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4SW5kZXg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaW4odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtaW47XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGxcbiAgICAgICAgICAmJiAobWluID4gdmFsdWUgfHwgKG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGxcbiAgICAgICAgICAmJiAobWluID4gdmFsdWUgfHwgKG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaW5JbmRleCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IG1pbjtcbiAgbGV0IG1pbkluZGV4ID0gLTE7XG4gIGxldCBpbmRleCA9IC0xO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICsraW5kZXg7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbFxuICAgICAgICAgICYmIChtaW4gPiB2YWx1ZSB8fCAobWluID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtaW4gPSB2YWx1ZSwgbWluSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbFxuICAgICAgICAgICYmIChtaW4gPiB2YWx1ZSB8fCAobWluID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtaW4gPSB2YWx1ZSwgbWluSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbkluZGV4O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbnVtYmVyKHgpIHtcbiAgcmV0dXJuIHggPT09IG51bGwgPyBOYU4gOiAreDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBudW1iZXJzKHZhbHVlcywgdmFsdWVvZikge1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwZXJtdXRlKHNvdXJjZSwga2V5cykge1xuICByZXR1cm4gQXJyYXkuZnJvbShrZXlzLCBrZXkgPT4gc291cmNlW2tleV0pO1xufVxuIiwiaW1wb3J0IG1heCBmcm9tIFwiLi9tYXguanNcIjtcbmltcG9ydCBtYXhJbmRleCBmcm9tIFwiLi9tYXhJbmRleC5qc1wiO1xuaW1wb3J0IG1pbiBmcm9tIFwiLi9taW4uanNcIjtcbmltcG9ydCBtaW5JbmRleCBmcm9tIFwiLi9taW5JbmRleC5qc1wiO1xuaW1wb3J0IHF1aWNrc2VsZWN0IGZyb20gXCIuL3F1aWNrc2VsZWN0LmpzXCI7XG5pbXBvcnQgbnVtYmVyLCB7bnVtYmVyc30gZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5pbXBvcnQge2FzY2VuZGluZ0RlZmluZWR9IGZyb20gXCIuL3NvcnQuanNcIjtcbmltcG9ydCBncmVhdGVzdCBmcm9tIFwiLi9ncmVhdGVzdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGlsZSh2YWx1ZXMsIHAsIHZhbHVlb2YpIHtcbiAgdmFsdWVzID0gRmxvYXQ2NEFycmF5LmZyb20obnVtYmVycyh2YWx1ZXMsIHZhbHVlb2YpKTtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpIHx8IGlzTmFOKHAgPSArcCkpIHJldHVybjtcbiAgaWYgKHAgPD0gMCB8fCBuIDwgMikgcmV0dXJuIG1pbih2YWx1ZXMpO1xuICBpZiAocCA+PSAxKSByZXR1cm4gbWF4KHZhbHVlcyk7XG4gIHZhciBuLFxuICAgICAgaSA9IChuIC0gMSkgKiBwLFxuICAgICAgaTAgPSBNYXRoLmZsb29yKGkpLFxuICAgICAgdmFsdWUwID0gbWF4KHF1aWNrc2VsZWN0KHZhbHVlcywgaTApLnN1YmFycmF5KDAsIGkwICsgMSkpLFxuICAgICAgdmFsdWUxID0gbWluKHZhbHVlcy5zdWJhcnJheShpMCArIDEpKTtcbiAgcmV0dXJuIHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBpMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGlsZVNvcnRlZCh2YWx1ZXMsIHAsIHZhbHVlb2YgPSBudW1iZXIpIHtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpIHx8IGlzTmFOKHAgPSArcCkpIHJldHVybjtcbiAgaWYgKHAgPD0gMCB8fCBuIDwgMikgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1swXSwgMCwgdmFsdWVzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1tuIC0gMV0sIG4gLSAxLCB2YWx1ZXMpO1xuICB2YXIgbixcbiAgICAgIGkgPSAobiAtIDEpICogcCxcbiAgICAgIGkwID0gTWF0aC5mbG9vcihpKSxcbiAgICAgIHZhbHVlMCA9ICt2YWx1ZW9mKHZhbHVlc1tpMF0sIGkwLCB2YWx1ZXMpLFxuICAgICAgdmFsdWUxID0gK3ZhbHVlb2YodmFsdWVzW2kwICsgMV0sIGkwICsgMSwgdmFsdWVzKTtcbiAgcmV0dXJuIHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBpMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGlsZUluZGV4KHZhbHVlcywgcCwgdmFsdWVvZiA9IG51bWJlcikge1xuICBpZiAoaXNOYU4ocCA9ICtwKSkgcmV0dXJuO1xuICBudW1iZXJzID0gRmxvYXQ2NEFycmF5LmZyb20odmFsdWVzLCAoXywgaSkgPT4gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSk7XG4gIGlmIChwIDw9IDApIHJldHVybiBtaW5JbmRleChudW1iZXJzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuIG1heEluZGV4KG51bWJlcnMpO1xuICB2YXIgbnVtYmVycyxcbiAgICAgIGluZGV4ID0gVWludDMyQXJyYXkuZnJvbSh2YWx1ZXMsIChfLCBpKSA9PiBpKSxcbiAgICAgIGogPSBudW1iZXJzLmxlbmd0aCAtIDEsXG4gICAgICBpID0gTWF0aC5mbG9vcihqICogcCk7XG4gIHF1aWNrc2VsZWN0KGluZGV4LCBpLCAwLCBqLCAoaSwgaikgPT4gYXNjZW5kaW5nRGVmaW5lZChudW1iZXJzW2ldLCBudW1iZXJzW2pdKSk7XG4gIGkgPSBncmVhdGVzdChpbmRleC5zdWJhcnJheSgwLCBpICsgMSksIChpKSA9PiBudW1iZXJzW2ldKTtcbiAgcmV0dXJuIGkgPj0gMCA/IGkgOiAtMTtcbn1cbiIsImltcG9ydCB7YXNjZW5kaW5nRGVmaW5lZCwgY29tcGFyZURlZmluZWR9IGZyb20gXCIuL3NvcnQuanNcIjtcblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcXVpY2tzZWxlY3Rcbi8vIElTQyBsaWNlbnNlLCBDb3B5cmlnaHQgMjAxOCBWbGFkaW1pciBBZ2Fmb25raW4uXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWlja3NlbGVjdChhcnJheSwgaywgbGVmdCA9IDAsIHJpZ2h0ID0gSW5maW5pdHksIGNvbXBhcmUpIHtcbiAgayA9IE1hdGguZmxvb3Ioayk7XG4gIGxlZnQgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIGxlZnQpKTtcbiAgcmlnaHQgPSBNYXRoLmZsb29yKE1hdGgubWluKGFycmF5Lmxlbmd0aCAtIDEsIHJpZ2h0KSk7XG5cbiAgaWYgKCEobGVmdCA8PSBrICYmIGsgPD0gcmlnaHQpKSByZXR1cm4gYXJyYXk7XG5cbiAgY29tcGFyZSA9IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IGFzY2VuZGluZ0RlZmluZWQgOiBjb21wYXJlRGVmaW5lZChjb21wYXJlKTtcblxuICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG4gICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xuICAgICAgY29uc3QgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICBjb25zdCBtID0gayAtIGxlZnQgKyAxO1xuICAgICAgY29uc3QgeiA9IE1hdGgubG9nKG4pO1xuICAgICAgY29uc3QgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICBjb25zdCBzZCA9IDAuNSAqIE1hdGguc3FydCh6ICogcyAqIChuIC0gcykgLyBuKSAqIChtIC0gbiAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgIGNvbnN0IG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBtICogcyAvIG4gKyBzZCkpO1xuICAgICAgY29uc3QgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgIHF1aWNrc2VsZWN0KGFycmF5LCBrLCBuZXdMZWZ0LCBuZXdSaWdodCwgY29tcGFyZSk7XG4gICAgfVxuXG4gICAgY29uc3QgdCA9IGFycmF5W2tdO1xuICAgIGxldCBpID0gbGVmdDtcbiAgICBsZXQgaiA9IHJpZ2h0O1xuXG4gICAgc3dhcChhcnJheSwgbGVmdCwgayk7XG4gICAgaWYgKGNvbXBhcmUoYXJyYXlbcmlnaHRdLCB0KSA+IDApIHN3YXAoYXJyYXksIGxlZnQsIHJpZ2h0KTtcblxuICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgc3dhcChhcnJheSwgaSwgaiksICsraSwgLS1qO1xuICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyYXlbaV0sIHQpIDwgMCkgKytpO1xuICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyYXlbal0sIHQpID4gMCkgLS1qO1xuICAgIH1cblxuICAgIGlmIChjb21wYXJlKGFycmF5W2xlZnRdLCB0KSA9PT0gMCkgc3dhcChhcnJheSwgbGVmdCwgaik7XG4gICAgZWxzZSArK2osIHN3YXAoYXJyYXksIGosIHJpZ2h0KTtcblxuICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcbiAgICBpZiAoayA8PSBqKSByaWdodCA9IGogLSAxO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBzd2FwKGFycmF5LCBpLCBqKSB7XG4gIGNvbnN0IHQgPSBhcnJheVtpXTtcbiAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgYXJyYXlbal0gPSB0O1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmcuanNcIjtcbmltcG9ydCBwZXJtdXRlIGZyb20gXCIuL3Blcm11dGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc29ydCh2YWx1ZXMsIC4uLkYpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZXNbU3ltYm9sLml0ZXJhdG9yXSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsdWVzIGlzIG5vdCBpdGVyYWJsZVwiKTtcbiAgdmFsdWVzID0gQXJyYXkuZnJvbSh2YWx1ZXMpO1xuICBsZXQgW2ZdID0gRjtcbiAgaWYgKChmICYmIGYubGVuZ3RoICE9PSAyKSB8fCBGLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBpbmRleCA9IFVpbnQzMkFycmF5LmZyb20odmFsdWVzLCAoZCwgaSkgPT4gaSk7XG4gICAgaWYgKEYubGVuZ3RoID4gMSkge1xuICAgICAgRiA9IEYubWFwKGYgPT4gdmFsdWVzLm1hcChmKSk7XG4gICAgICBpbmRleC5zb3J0KChpLCBqKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZiBvZiBGKSB7XG4gICAgICAgICAgY29uc3QgYyA9IGFzY2VuZGluZ0RlZmluZWQoZltpXSwgZltqXSk7XG4gICAgICAgICAgaWYgKGMpIHJldHVybiBjO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZiA9IHZhbHVlcy5tYXAoZik7XG4gICAgICBpbmRleC5zb3J0KChpLCBqKSA9PiBhc2NlbmRpbmdEZWZpbmVkKGZbaV0sIGZbal0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHBlcm11dGUodmFsdWVzLCBpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcy5zb3J0KGNvbXBhcmVEZWZpbmVkKGYpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVEZWZpbmVkKGNvbXBhcmUgPSBhc2NlbmRpbmcpIHtcbiAgaWYgKGNvbXBhcmUgPT09IGFzY2VuZGluZykgcmV0dXJuIGFzY2VuZGluZ0RlZmluZWQ7XG4gIGlmICh0eXBlb2YgY29tcGFyZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY29tcGFyZSBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgcmV0dXJuIChhLCBiKSA9PiB7XG4gICAgY29uc3QgeCA9IGNvbXBhcmUoYSwgYik7XG4gICAgaWYgKHggfHwgeCA9PT0gMCkgcmV0dXJuIHg7XG4gICAgcmV0dXJuIChjb21wYXJlKGIsIGIpID09PSAwKSAtIChjb21wYXJlKGEsIGEpID09PSAwKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzY2VuZGluZ0RlZmluZWQoYSwgYikge1xuICByZXR1cm4gKGEgPT0gbnVsbCB8fCAhKGEgPj0gYSkpIC0gKGIgPT0gbnVsbCB8fCAhKGIgPj0gYikpIHx8IChhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMCk7XG59XG4iLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIENvbG9yKCkge31cblxuZXhwb3J0IHZhciBkYXJrZXIgPSAwLjc7XG5leHBvcnQgdmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxudmFyIHJlSSA9IFwiXFxcXHMqKFsrLV0/XFxcXGQrKVxcXFxzKlwiLFxuICAgIHJlTiA9IFwiXFxcXHMqKFsrLV0/KD86XFxcXGQqXFxcXC4pP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KVxcXFxzKlwiLFxuICAgIHJlUCA9IFwiXFxcXHMqKFsrLV0/KD86XFxcXGQqXFxcXC4pP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KSVcXFxccypcIixcbiAgICByZUhleCA9IC9eIyhbMC05YS1mXXszLDh9KSQvLFxuICAgIHJlUmdiSW50ZWdlciA9IG5ldyBSZWdFeHAoYF5yZ2JcXFxcKCR7cmVJfSwke3JlSX0sJHtyZUl9XFxcXCkkYCksXG4gICAgcmVSZ2JQZXJjZW50ID0gbmV3IFJlZ0V4cChgXnJnYlxcXFwoJHtyZVB9LCR7cmVQfSwke3JlUH1cXFxcKSRgKSxcbiAgICByZVJnYmFJbnRlZ2VyID0gbmV3IFJlZ0V4cChgXnJnYmFcXFxcKCR7cmVJfSwke3JlSX0sJHtyZUl9LCR7cmVOfVxcXFwpJGApLFxuICAgIHJlUmdiYVBlcmNlbnQgPSBuZXcgUmVnRXhwKGBecmdiYVxcXFwoJHtyZVB9LCR7cmVQfSwke3JlUH0sJHtyZU59XFxcXCkkYCksXG4gICAgcmVIc2xQZXJjZW50ID0gbmV3IFJlZ0V4cChgXmhzbFxcXFwoJHtyZU59LCR7cmVQfSwke3JlUH1cXFxcKSRgKSxcbiAgICByZUhzbGFQZXJjZW50ID0gbmV3IFJlZ0V4cChgXmhzbGFcXFxcKCR7cmVOfSwke3JlUH0sJHtyZVB9LCR7cmVOfVxcXFwpJGApO1xuXG52YXIgbmFtZWQgPSB7XG4gIGFsaWNlYmx1ZTogMHhmMGY4ZmYsXG4gIGFudGlxdWV3aGl0ZTogMHhmYWViZDcsXG4gIGFxdWE6IDB4MDBmZmZmLFxuICBhcXVhbWFyaW5lOiAweDdmZmZkNCxcbiAgYXp1cmU6IDB4ZjBmZmZmLFxuICBiZWlnZTogMHhmNWY1ZGMsXG4gIGJpc3F1ZTogMHhmZmU0YzQsXG4gIGJsYWNrOiAweDAwMDAwMCxcbiAgYmxhbmNoZWRhbG1vbmQ6IDB4ZmZlYmNkLFxuICBibHVlOiAweDAwMDBmZixcbiAgYmx1ZXZpb2xldDogMHg4YTJiZTIsXG4gIGJyb3duOiAweGE1MmEyYSxcbiAgYnVybHl3b29kOiAweGRlYjg4NyxcbiAgY2FkZXRibHVlOiAweDVmOWVhMCxcbiAgY2hhcnRyZXVzZTogMHg3ZmZmMDAsXG4gIGNob2NvbGF0ZTogMHhkMjY5MWUsXG4gIGNvcmFsOiAweGZmN2Y1MCxcbiAgY29ybmZsb3dlcmJsdWU6IDB4NjQ5NWVkLFxuICBjb3Juc2lsazogMHhmZmY4ZGMsXG4gIGNyaW1zb246IDB4ZGMxNDNjLFxuICBjeWFuOiAweDAwZmZmZixcbiAgZGFya2JsdWU6IDB4MDAwMDhiLFxuICBkYXJrY3lhbjogMHgwMDhiOGIsXG4gIGRhcmtnb2xkZW5yb2Q6IDB4Yjg4NjBiLFxuICBkYXJrZ3JheTogMHhhOWE5YTksXG4gIGRhcmtncmVlbjogMHgwMDY0MDAsXG4gIGRhcmtncmV5OiAweGE5YTlhOSxcbiAgZGFya2toYWtpOiAweGJkYjc2YixcbiAgZGFya21hZ2VudGE6IDB4OGIwMDhiLFxuICBkYXJrb2xpdmVncmVlbjogMHg1NTZiMmYsXG4gIGRhcmtvcmFuZ2U6IDB4ZmY4YzAwLFxuICBkYXJrb3JjaGlkOiAweDk5MzJjYyxcbiAgZGFya3JlZDogMHg4YjAwMDAsXG4gIGRhcmtzYWxtb246IDB4ZTk5NjdhLFxuICBkYXJrc2VhZ3JlZW46IDB4OGZiYzhmLFxuICBkYXJrc2xhdGVibHVlOiAweDQ4M2Q4YixcbiAgZGFya3NsYXRlZ3JheTogMHgyZjRmNGYsXG4gIGRhcmtzbGF0ZWdyZXk6IDB4MmY0ZjRmLFxuICBkYXJrdHVycXVvaXNlOiAweDAwY2VkMSxcbiAgZGFya3Zpb2xldDogMHg5NDAwZDMsXG4gIGRlZXBwaW5rOiAweGZmMTQ5MyxcbiAgZGVlcHNreWJsdWU6IDB4MDBiZmZmLFxuICBkaW1ncmF5OiAweDY5Njk2OSxcbiAgZGltZ3JleTogMHg2OTY5NjksXG4gIGRvZGdlcmJsdWU6IDB4MWU5MGZmLFxuICBmaXJlYnJpY2s6IDB4YjIyMjIyLFxuICBmbG9yYWx3aGl0ZTogMHhmZmZhZjAsXG4gIGZvcmVzdGdyZWVuOiAweDIyOGIyMixcbiAgZnVjaHNpYTogMHhmZjAwZmYsXG4gIGdhaW5zYm9ybzogMHhkY2RjZGMsXG4gIGdob3N0d2hpdGU6IDB4ZjhmOGZmLFxuICBnb2xkOiAweGZmZDcwMCxcbiAgZ29sZGVucm9kOiAweGRhYTUyMCxcbiAgZ3JheTogMHg4MDgwODAsXG4gIGdyZWVuOiAweDAwODAwMCxcbiAgZ3JlZW55ZWxsb3c6IDB4YWRmZjJmLFxuICBncmV5OiAweDgwODA4MCxcbiAgaG9uZXlkZXc6IDB4ZjBmZmYwLFxuICBob3RwaW5rOiAweGZmNjliNCxcbiAgaW5kaWFucmVkOiAweGNkNWM1YyxcbiAgaW5kaWdvOiAweDRiMDA4MixcbiAgaXZvcnk6IDB4ZmZmZmYwLFxuICBraGFraTogMHhmMGU2OGMsXG4gIGxhdmVuZGVyOiAweGU2ZTZmYSxcbiAgbGF2ZW5kZXJibHVzaDogMHhmZmYwZjUsXG4gIGxhd25ncmVlbjogMHg3Y2ZjMDAsXG4gIGxlbW9uY2hpZmZvbjogMHhmZmZhY2QsXG4gIGxpZ2h0Ymx1ZTogMHhhZGQ4ZTYsXG4gIGxpZ2h0Y29yYWw6IDB4ZjA4MDgwLFxuICBsaWdodGN5YW46IDB4ZTBmZmZmLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogMHhmYWZhZDIsXG4gIGxpZ2h0Z3JheTogMHhkM2QzZDMsXG4gIGxpZ2h0Z3JlZW46IDB4OTBlZTkwLFxuICBsaWdodGdyZXk6IDB4ZDNkM2QzLFxuICBsaWdodHBpbms6IDB4ZmZiNmMxLFxuICBsaWdodHNhbG1vbjogMHhmZmEwN2EsXG4gIGxpZ2h0c2VhZ3JlZW46IDB4MjBiMmFhLFxuICBsaWdodHNreWJsdWU6IDB4ODdjZWZhLFxuICBsaWdodHNsYXRlZ3JheTogMHg3Nzg4OTksXG4gIGxpZ2h0c2xhdGVncmV5OiAweDc3ODg5OSxcbiAgbGlnaHRzdGVlbGJsdWU6IDB4YjBjNGRlLFxuICBsaWdodHllbGxvdzogMHhmZmZmZTAsXG4gIGxpbWU6IDB4MDBmZjAwLFxuICBsaW1lZ3JlZW46IDB4MzJjZDMyLFxuICBsaW5lbjogMHhmYWYwZTYsXG4gIG1hZ2VudGE6IDB4ZmYwMGZmLFxuICBtYXJvb246IDB4ODAwMDAwLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAweDY2Y2RhYSxcbiAgbWVkaXVtYmx1ZTogMHgwMDAwY2QsXG4gIG1lZGl1bW9yY2hpZDogMHhiYTU1ZDMsXG4gIG1lZGl1bXB1cnBsZTogMHg5MzcwZGIsXG4gIG1lZGl1bXNlYWdyZWVuOiAweDNjYjM3MSxcbiAgbWVkaXVtc2xhdGVibHVlOiAweDdiNjhlZSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDB4MDBmYTlhLFxuICBtZWRpdW10dXJxdW9pc2U6IDB4NDhkMWNjLFxuICBtZWRpdW12aW9sZXRyZWQ6IDB4YzcxNTg1LFxuICBtaWRuaWdodGJsdWU6IDB4MTkxOTcwLFxuICBtaW50Y3JlYW06IDB4ZjVmZmZhLFxuICBtaXN0eXJvc2U6IDB4ZmZlNGUxLFxuICBtb2NjYXNpbjogMHhmZmU0YjUsXG4gIG5hdmFqb3doaXRlOiAweGZmZGVhZCxcbiAgbmF2eTogMHgwMDAwODAsXG4gIG9sZGxhY2U6IDB4ZmRmNWU2LFxuICBvbGl2ZTogMHg4MDgwMDAsXG4gIG9saXZlZHJhYjogMHg2YjhlMjMsXG4gIG9yYW5nZTogMHhmZmE1MDAsXG4gIG9yYW5nZXJlZDogMHhmZjQ1MDAsXG4gIG9yY2hpZDogMHhkYTcwZDYsXG4gIHBhbGVnb2xkZW5yb2Q6IDB4ZWVlOGFhLFxuICBwYWxlZ3JlZW46IDB4OThmYjk4LFxuICBwYWxldHVycXVvaXNlOiAweGFmZWVlZSxcbiAgcGFsZXZpb2xldHJlZDogMHhkYjcwOTMsXG4gIHBhcGF5YXdoaXA6IDB4ZmZlZmQ1LFxuICBwZWFjaHB1ZmY6IDB4ZmZkYWI5LFxuICBwZXJ1OiAweGNkODUzZixcbiAgcGluazogMHhmZmMwY2IsXG4gIHBsdW06IDB4ZGRhMGRkLFxuICBwb3dkZXJibHVlOiAweGIwZTBlNixcbiAgcHVycGxlOiAweDgwMDA4MCxcbiAgcmViZWNjYXB1cnBsZTogMHg2NjMzOTksXG4gIHJlZDogMHhmZjAwMDAsXG4gIHJvc3licm93bjogMHhiYzhmOGYsXG4gIHJveWFsYmx1ZTogMHg0MTY5ZTEsXG4gIHNhZGRsZWJyb3duOiAweDhiNDUxMyxcbiAgc2FsbW9uOiAweGZhODA3MixcbiAgc2FuZHlicm93bjogMHhmNGE0NjAsXG4gIHNlYWdyZWVuOiAweDJlOGI1NyxcbiAgc2Vhc2hlbGw6IDB4ZmZmNWVlLFxuICBzaWVubmE6IDB4YTA1MjJkLFxuICBzaWx2ZXI6IDB4YzBjMGMwLFxuICBza3libHVlOiAweDg3Y2VlYixcbiAgc2xhdGVibHVlOiAweDZhNWFjZCxcbiAgc2xhdGVncmF5OiAweDcwODA5MCxcbiAgc2xhdGVncmV5OiAweDcwODA5MCxcbiAgc25vdzogMHhmZmZhZmEsXG4gIHNwcmluZ2dyZWVuOiAweDAwZmY3ZixcbiAgc3RlZWxibHVlOiAweDQ2ODJiNCxcbiAgdGFuOiAweGQyYjQ4YyxcbiAgdGVhbDogMHgwMDgwODAsXG4gIHRoaXN0bGU6IDB4ZDhiZmQ4LFxuICB0b21hdG86IDB4ZmY2MzQ3LFxuICB0dXJxdW9pc2U6IDB4NDBlMGQwLFxuICB2aW9sZXQ6IDB4ZWU4MmVlLFxuICB3aGVhdDogMHhmNWRlYjMsXG4gIHdoaXRlOiAweGZmZmZmZixcbiAgd2hpdGVzbW9rZTogMHhmNWY1ZjUsXG4gIHllbGxvdzogMHhmZmZmMDAsXG4gIHllbGxvd2dyZWVuOiAweDlhY2QzMlxufTtcblxuZGVmaW5lKENvbG9yLCBjb2xvciwge1xuICBjb3B5KGNoYW5uZWxzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IHRoaXMuY29uc3RydWN0b3IsIHRoaXMsIGNoYW5uZWxzKTtcbiAgfSxcbiAgZGlzcGxheWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkuZGlzcGxheWFibGUoKTtcbiAgfSxcbiAgaGV4OiBjb2xvcl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogY29sb3JfZm9ybWF0SGV4LFxuICBmb3JtYXRIZXg4OiBjb2xvcl9mb3JtYXRIZXg4LFxuICBmb3JtYXRIc2w6IGNvbG9yX2Zvcm1hdEhzbCxcbiAgZm9ybWF0UmdiOiBjb2xvcl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiBjb2xvcl9mb3JtYXRSZ2Jcbn0pO1xuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdEhleCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIZXg4KCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRIZXg4KCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhzbCgpIHtcbiAgcmV0dXJuIGhzbENvbnZlcnQodGhpcykuZm9ybWF0SHNsKCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdFJnYigpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0UmdiKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbG9yKGZvcm1hdCkge1xuICB2YXIgbSwgbDtcbiAgZm9ybWF0ID0gKGZvcm1hdCArIFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKG0gPSByZUhleC5leGVjKGZvcm1hdCkpID8gKGwgPSBtWzFdLmxlbmd0aCwgbSA9IHBhcnNlSW50KG1bMV0sIDE2KSwgbCA9PT0gNiA/IHJnYm4obSkgLy8gI2ZmMDAwMFxuICAgICAgOiBsID09PSAzID8gbmV3IFJnYigobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpLCAxKSAvLyAjZjAwXG4gICAgICA6IGwgPT09IDggPyByZ2JhKG0gPj4gMjQgJiAweGZmLCBtID4+IDE2ICYgMHhmZiwgbSA+PiA4ICYgMHhmZiwgKG0gJiAweGZmKSAvIDB4ZmYpIC8vICNmZjAwMDAwMFxuICAgICAgOiBsID09PSA0ID8gcmdiYSgobSA+PiAxMiAmIDB4ZikgfCAobSA+PiA4ICYgMHhmMCksIChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4ZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpKSAvIDB4ZmYpIC8vICNmMDAwXG4gICAgICA6IG51bGwpIC8vIGludmFsaWQgaGV4XG4gICAgICA6IChtID0gcmVSZ2JJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0sIG1bMl0sIG1bM10sIDEpIC8vIHJnYigyNTUsIDAsIDApXG4gICAgICA6IChtID0gcmVSZ2JQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIDEpIC8vIHJnYigxMDAlLCAwJSwgMCUpXG4gICAgICA6IChtID0gcmVSZ2JhSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKSAvLyByZ2JhKDI1NSwgMCwgMCwgMSlcbiAgICAgIDogKG0gPSByZVJnYmFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIG1bNF0pIC8vIHJnYigxMDAlLCAwJSwgMCUsIDEpXG4gICAgICA6IChtID0gcmVIc2xQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIDEpIC8vIGhzbCgxMjAsIDUwJSwgNTAlKVxuICAgICAgOiAobSA9IHJlSHNsYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgbVs0XSkgLy8gaHNsYSgxMjAsIDUwJSwgNTAlLCAxKVxuICAgICAgOiBuYW1lZC5oYXNPd25Qcm9wZXJ0eShmb3JtYXQpID8gcmdibihuYW1lZFtmb3JtYXRdKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgOiBmb3JtYXQgPT09IFwidHJhbnNwYXJlbnRcIiA/IG5ldyBSZ2IoTmFOLCBOYU4sIE5hTiwgMClcbiAgICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gcmdibihuKSB7XG4gIHJldHVybiBuZXcgUmdiKG4gPj4gMTYgJiAweGZmLCBuID4+IDggJiAweGZmLCBuICYgMHhmZiwgMSk7XG59XG5cbmZ1bmN0aW9uIHJnYmEociwgZywgYiwgYSkge1xuICBpZiAoYSA8PSAwKSByID0gZyA9IGIgPSBOYU47XG4gIHJldHVybiBuZXcgUmdiKHIsIGcsIGIsIGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiQ29udmVydChvKSB7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IFJnYjtcbiAgbyA9IG8ucmdiKCk7XG4gIHJldHVybiBuZXcgUmdiKG8uciwgby5nLCBvLmIsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHJnYkNvbnZlcnQocikgOiBuZXcgUmdiKHIsIGcsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMuciA9ICtyO1xuICB0aGlzLmcgPSArZztcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoUmdiLCByZ2IsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjbGFtcCgpIHtcbiAgICByZXR1cm4gbmV3IFJnYihjbGFtcGkodGhpcy5yKSwgY2xhbXBpKHRoaXMuZyksIGNsYW1waSh0aGlzLmIpLCBjbGFtcGEodGhpcy5vcGFjaXR5KSk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlKCkge1xuICAgIHJldHVybiAoLTAuNSA8PSB0aGlzLnIgJiYgdGhpcy5yIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuZyAmJiB0aGlzLmcgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5iICYmIHRoaXMuYiA8IDI1NS41KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBoZXg6IHJnYl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogcmdiX2Zvcm1hdEhleCxcbiAgZm9ybWF0SGV4ODogcmdiX2Zvcm1hdEhleDgsXG4gIGZvcm1hdFJnYjogcmdiX2Zvcm1hdFJnYixcbiAgdG9TdHJpbmc6IHJnYl9mb3JtYXRSZ2Jcbn0pKTtcblxuZnVuY3Rpb24gcmdiX2Zvcm1hdEhleCgpIHtcbiAgcmV0dXJuIGAjJHtoZXgodGhpcy5yKX0ke2hleCh0aGlzLmcpfSR7aGV4KHRoaXMuYil9YDtcbn1cblxuZnVuY3Rpb24gcmdiX2Zvcm1hdEhleDgoKSB7XG4gIHJldHVybiBgIyR7aGV4KHRoaXMucil9JHtoZXgodGhpcy5nKX0ke2hleCh0aGlzLmIpfSR7aGV4KChpc05hTih0aGlzLm9wYWNpdHkpID8gMSA6IHRoaXMub3BhY2l0eSkgKiAyNTUpfWA7XG59XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRSZ2IoKSB7XG4gIGNvbnN0IGEgPSBjbGFtcGEodGhpcy5vcGFjaXR5KTtcbiAgcmV0dXJuIGAke2EgPT09IDEgPyBcInJnYihcIiA6IFwicmdiYShcIn0ke2NsYW1waSh0aGlzLnIpfSwgJHtjbGFtcGkodGhpcy5nKX0sICR7Y2xhbXBpKHRoaXMuYil9JHthID09PSAxID8gXCIpXCIgOiBgLCAke2F9KWB9YDtcbn1cblxuZnVuY3Rpb24gY2xhbXBhKG9wYWNpdHkpIHtcbiAgcmV0dXJuIGlzTmFOKG9wYWNpdHkpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG9wYWNpdHkpKTtcbn1cblxuZnVuY3Rpb24gY2xhbXBpKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodmFsdWUpIHx8IDApKTtcbn1cblxuZnVuY3Rpb24gaGV4KHZhbHVlKSB7XG4gIHZhbHVlID0gY2xhbXBpKHZhbHVlKTtcbiAgcmV0dXJuICh2YWx1ZSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIHZhbHVlLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gaHNsYShoLCBzLCBsLCBhKSB7XG4gIGlmIChhIDw9IDApIGggPSBzID0gbCA9IE5hTjtcbiAgZWxzZSBpZiAobCA8PSAwIHx8IGwgPj0gMSkgaCA9IHMgPSBOYU47XG4gIGVsc2UgaWYgKHMgPD0gMCkgaCA9IE5hTjtcbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBuZXcgSHNsKG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IEhzbDtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBvO1xuICBvID0gby5yZ2IoKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBoID0gTmFOLFxuICAgICAgcyA9IG1heCAtIG1pbixcbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGlmIChzKSB7XG4gICAgaWYgKHIgPT09IG1heCkgaCA9IChnIC0gYikgLyBzICsgKGcgPCBiKSAqIDY7XG4gICAgZWxzZSBpZiAoZyA9PT0gbWF4KSBoID0gKGIgLSByKSAvIHMgKyAyO1xuICAgIGVsc2UgaCA9IChyIC0gZykgLyBzICsgNDtcbiAgICBzIC89IGwgPCAwLjUgPyBtYXggKyBtaW4gOiAyIC0gbWF4IC0gbWluO1xuICAgIGggKj0gNjA7XG4gIH0gZWxzZSB7XG4gICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaHNsQ29udmVydChoKSA6IG5ldyBIc2woaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBIc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEhzbCwgaHNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXIoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiKCkge1xuICAgIHZhciBoID0gdGhpcy5oICUgMzYwICsgKHRoaXMuaCA8IDApICogMzYwLFxuICAgICAgICBzID0gaXNOYU4oaCkgfHwgaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMsXG4gICAgICAgIGwgPSB0aGlzLmwsXG4gICAgICAgIG0yID0gbCArIChsIDwgMC41ID8gbCA6IDEgLSBsKSAqIHMsXG4gICAgICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGhzbDJyZ2IoaCA+PSAyNDAgPyBoIC0gMjQwIDogaCArIDEyMCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCA8IDEyMCA/IGggKyAyNDAgOiBoIC0gMTIwLCBtMSwgbTIpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfSxcbiAgY2xhbXAoKSB7XG4gICAgcmV0dXJuIG5ldyBIc2woY2xhbXBoKHRoaXMuaCksIGNsYW1wdCh0aGlzLnMpLCBjbGFtcHQodGhpcy5sKSwgY2xhbXBhKHRoaXMub3BhY2l0eSkpO1xuICB9LFxuICBkaXNwbGF5YWJsZSgpIHtcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5zICYmIHRoaXMucyA8PSAxIHx8IGlzTmFOKHRoaXMucykpXG4gICAgICAgICYmICgwIDw9IHRoaXMubCAmJiB0aGlzLmwgPD0gMSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgZm9ybWF0SHNsKCkge1xuICAgIGNvbnN0IGEgPSBjbGFtcGEodGhpcy5vcGFjaXR5KTtcbiAgICByZXR1cm4gYCR7YSA9PT0gMSA/IFwiaHNsKFwiIDogXCJoc2xhKFwifSR7Y2xhbXBoKHRoaXMuaCl9LCAke2NsYW1wdCh0aGlzLnMpICogMTAwfSUsICR7Y2xhbXB0KHRoaXMubCkgKiAxMDB9JSR7YSA9PT0gMSA/IFwiKVwiIDogYCwgJHthfSlgfWA7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24gY2xhbXBoKHZhbHVlKSB7XG4gIHZhbHVlID0gKHZhbHVlIHx8IDApICUgMzYwO1xuICByZXR1cm4gdmFsdWUgPCAwID8gdmFsdWUgKyAzNjAgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2xhbXB0KHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWx1ZSB8fCAwKSk7XG59XG5cbi8qIEZyb20gRnZEIDEzLjM3LCBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDMgKi9cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgbTEsIG0yKSB7XG4gIHJldHVybiAoaCA8IDYwID8gbTEgKyAobTIgLSBtMSkgKiBoIC8gNjBcbiAgICAgIDogaCA8IDE4MCA/IG0yXG4gICAgICA6IGggPCAyNDAgPyBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwXG4gICAgICA6IG0xKSAqIDI1NTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBmYWN0b3J5LCBwcm90b3R5cGUpIHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gZmFjdG9yeS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIHByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHBhcmVudCwgZGVmaW5pdGlvbikge1xuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgZm9yICh2YXIga2V5IGluIGRlZmluaXRpb24pIHByb3RvdHlwZVtrZXldID0gZGVmaW5pdGlvbltrZXldO1xuICByZXR1cm4gcHJvdG90eXBlO1xufVxuIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5pbXBvcnQge0NvbG9yLCByZ2JDb252ZXJ0LCBSZ2J9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5pbXBvcnQge2RlZ3JlZXMsIHJhZGlhbnN9IGZyb20gXCIuL21hdGguanNcIjtcblxuLy8gaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BtYm9zdG9jay9sYWItYW5kLXJnYlxuY29uc3QgSyA9IDE4LFxuICAgIFhuID0gMC45NjQyMixcbiAgICBZbiA9IDEsXG4gICAgWm4gPSAwLjgyNTIxLFxuICAgIHQwID0gNCAvIDI5LFxuICAgIHQxID0gNiAvIDI5LFxuICAgIHQyID0gMyAqIHQxICogdDEsXG4gICAgdDMgPSB0MSAqIHQxICogdDE7XG5cbmZ1bmN0aW9uIGxhYkNvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIExhYikgcmV0dXJuIG5ldyBMYWIoby5sLCBvLmEsIG8uYiwgby5vcGFjaXR5KTtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHJldHVybiBoY2wybGFiKG8pO1xuICBpZiAoIShvIGluc3RhbmNlb2YgUmdiKSkgbyA9IHJnYkNvbnZlcnQobyk7XG4gIHZhciByID0gcmdiMmxyZ2Ioby5yKSxcbiAgICAgIGcgPSByZ2IybHJnYihvLmcpLFxuICAgICAgYiA9IHJnYjJscmdiKG8uYiksXG4gICAgICB5ID0geHl6MmxhYigoMC4yMjI1MDQ1ICogciArIDAuNzE2ODc4NiAqIGcgKyAwLjA2MDYxNjkgKiBiKSAvIFluKSwgeCwgejtcbiAgaWYgKHIgPT09IGcgJiYgZyA9PT0gYikgeCA9IHogPSB5OyBlbHNlIHtcbiAgICB4ID0geHl6MmxhYigoMC40MzYwNzQ3ICogciArIDAuMzg1MDY0OSAqIGcgKyAwLjE0MzA4MDQgKiBiKSAvIFhuKTtcbiAgICB6ID0geHl6MmxhYigoMC4wMTM5MzIyICogciArIDAuMDk3MTA0NSAqIGcgKyAwLjcxNDE3MzMgKiBiKSAvIFpuKTtcbiAgfVxuICByZXR1cm4gbmV3IExhYigxMTYgKiB5IC0gMTYsIDUwMCAqICh4IC0geSksIDIwMCAqICh5IC0geiksIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5KGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIG5ldyBMYWIobCwgMCwgMCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGxhYkNvbnZlcnQobCkgOiBuZXcgTGFiKGwsIGEsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLmEgPSArYTtcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoTGFiLCBsYWIsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXIoaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiKCkge1xuICAgIHZhciB5ID0gKHRoaXMubCArIDE2KSAvIDExNixcbiAgICAgICAgeCA9IGlzTmFOKHRoaXMuYSkgPyB5IDogeSArIHRoaXMuYSAvIDUwMCxcbiAgICAgICAgeiA9IGlzTmFOKHRoaXMuYikgPyB5IDogeSAtIHRoaXMuYiAvIDIwMDtcbiAgICB4ID0gWG4gKiBsYWIyeHl6KHgpO1xuICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7XG4gICAgeiA9IFpuICogbGFiMnh5eih6KTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGxyZ2IycmdiKCAzLjEzMzg1NjEgKiB4IC0gMS42MTY4NjY3ICogeSAtIDAuNDkwNjE0NiAqIHopLFxuICAgICAgbHJnYjJyZ2IoLTAuOTc4NzY4NCAqIHggKyAxLjkxNjE0MTUgKiB5ICsgMC4wMzM0NTQwICogeiksXG4gICAgICBscmdiMnJnYiggMC4wNzE5NDUzICogeCAtIDAuMjI4OTkxNCAqIHkgKyAxLjQwNTI0MjcgKiB6KSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gIHJldHVybiB0ID4gdDMgPyBNYXRoLnBvdyh0LCAxIC8gMykgOiB0IC8gdDIgKyB0MDtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eih0KSB7XG4gIHJldHVybiB0ID4gdDEgPyB0ICogdCAqIHQgOiB0MiAqICh0IC0gdDApO1xufVxuXG5mdW5jdGlvbiBscmdiMnJnYih4KSB7XG4gIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpO1xufVxuXG5mdW5jdGlvbiByZ2IybHJnYih4KSB7XG4gIHJldHVybiAoeCAvPSAyNTUpIDw9IDAuMDQwNDUgPyB4IC8gMTIuOTIgOiBNYXRoLnBvdygoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xufVxuXG5mdW5jdGlvbiBoY2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHJldHVybiBuZXcgSGNsKG8uaCwgby5jLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBMYWIpKSBvID0gbGFiQ29udmVydChvKTtcbiAgaWYgKG8uYSA9PT0gMCAmJiBvLmIgPT09IDApIHJldHVybiBuZXcgSGNsKE5hTiwgMCA8IG8ubCAmJiBvLmwgPCAxMDAgPyAwIDogTmFOLCBvLmwsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gTWF0aC5hdGFuMihvLmIsIG8uYSkgKiBkZWdyZWVzO1xuICByZXR1cm4gbmV3IEhjbChoIDwgMCA/IGggKyAzNjAgOiBoLCBNYXRoLnNxcnQoby5hICogby5hICsgby5iICogby5iKSwgby5sLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGNoKGwsIGMsIGgsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGwpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQoaCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLmMgPSArYztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5mdW5jdGlvbiBoY2wybGFiKG8pIHtcbiAgaWYgKGlzTmFOKG8uaCkpIHJldHVybiBuZXcgTGFiKG8ubCwgMCwgMCwgby5vcGFjaXR5KTtcbiAgdmFyIGggPSBvLmggKiByYWRpYW5zO1xuICByZXR1cm4gbmV3IExhYihvLmwsIE1hdGguY29zKGgpICogby5jLCBNYXRoLnNpbihoKSAqIG8uYywgby5vcGFjaXR5KTtcbn1cblxuZGVmaW5lKEhjbCwgaGNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXIoaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sIC0gSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYigpIHtcbiAgICByZXR1cm4gaGNsMmxhYih0aGlzKS5yZ2IoKTtcbiAgfVxufSkpO1xuIiwiZXhwb3J0IGNvbnN0IHJhZGlhbnMgPSBNYXRoLlBJIC8gMTgwO1xuZXhwb3J0IGNvbnN0IGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xuIiwidmFyIG5vb3AgPSB7dmFsdWU6ICgpID0+IHt9fTtcblxuZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgXyA9IHt9LCB0OyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEodCA9IGFyZ3VtZW50c1tpXSArIFwiXCIpIHx8ICh0IGluIF8pIHx8IC9bXFxzLl0vLnRlc3QodCkpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0KTtcbiAgICBfW3RdID0gW107XG4gIH1cbiAgcmV0dXJuIG5ldyBEaXNwYXRjaChfKTtcbn1cblxuZnVuY3Rpb24gRGlzcGF0Y2goXykge1xuICB0aGlzLl8gPSBfO1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMsIHR5cGVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICBpZiAodCAmJiAhdHlwZXMuaGFzT3duUHJvcGVydHkodCkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0KTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuRGlzcGF0Y2gucHJvdG90eXBlID0gZGlzcGF0Y2gucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlzcGF0Y2gsXG4gIG9uOiBmdW5jdGlvbih0eXBlbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgXyA9IHRoaXMuXyxcbiAgICAgICAgVCA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiwgXyksXG4gICAgICAgIHQsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IFQubGVuZ3RoO1xuXG4gICAgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmV0dXJuIHRoZSBjYWxsYmFjayBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSAmJiAodCA9IGdldChfW3RdLCB0eXBlbmFtZS5uYW1lKSkpIHJldHVybiB0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGEgdHlwZSB3YXMgc3BlY2lmaWVkLCBzZXQgdGhlIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICAvLyBPdGhlcndpc2UsIGlmIGEgbnVsbCBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZW1vdmUgY2FsbGJhY2tzIG9mIHRoZSBnaXZlbiBuYW1lLlxuICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIiArIGNhbGxiYWNrKTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrID09IG51bGwpIGZvciAodCBpbiBfKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29weSA9IHt9LCBfID0gdGhpcy5fO1xuICAgIGZvciAodmFyIHQgaW4gXykgY29weVt0XSA9IF9bdF0uc2xpY2UoKTtcbiAgICByZXR1cm4gbmV3IERpc3BhdGNoKGNvcHkpO1xuICB9LFxuICBjYWxsOiBmdW5jdGlvbih0eXBlLCB0aGF0KSB7XG4gICAgaWYgKChuID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgYXJncyA9IG5ldyBBcnJheShuKSwgaSA9IDAsIG4sIHQ7IGkgPCBuOyArK2kpIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24odHlwZSwgdGhhdCwgYXJncykge1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh2YXIgdCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0KHR5cGUsIG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aCwgYzsgaSA8IG47ICsraSkge1xuICAgIGlmICgoYyA9IHR5cGVbaV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQodHlwZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmICh0eXBlW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHR5cGVbaV0gPSBub29wLCB0eXBlID0gdHlwZS5zbGljZSgwLCBpKS5jb25jYXQodHlwZS5zbGljZShpICsgMSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB0eXBlLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiBjYWxsYmFja30pO1xuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGlzcGF0Y2g7XG4iLCJpbXBvcnQge3NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IG5vZXZlbnQsIHtub25wYXNzaXZlY2FwdHVyZX0gZnJvbSBcIi4vbm9ldmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2aWV3KSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBzZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fX25vc2VsZWN0ID0gcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0O1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IFwibm9uZVwiO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5ZXNkcmFnKHZpZXcsIG5vY2xpY2spIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG51bGwpO1xuICBpZiAobm9jbGljaykge1xuICAgIHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbm9ldmVudCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbnVsbCk7IH0sIDApO1xuICB9XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSByb290Ll9fbm9zZWxlY3Q7XG4gICAgZGVsZXRlIHJvb3QuX19ub3NlbGVjdDtcbiAgfVxufVxuIiwiLy8gVGhlc2UgYXJlIHR5cGljYWxseSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggbm9ldmVudCB0byBlbnN1cmUgdGhhdCB3ZSBjYW5cbi8vIHByZXZlbnREZWZhdWx0IG9uIHRoZSBldmVudC5cbmV4cG9ydCBjb25zdCBub25wYXNzaXZlID0ge3Bhc3NpdmU6IGZhbHNlfTtcbmV4cG9ydCBjb25zdCBub25wYXNzaXZlY2FwdHVyZSA9IHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiBmYWxzZX07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3Byb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cbiIsImltcG9ydCBkc3YgZnJvbSBcIi4vZHN2LmpzXCI7XG5cbnZhciBjc3YgPSBkc3YoXCIsXCIpO1xuXG5leHBvcnQgdmFyIGNzdlBhcnNlID0gY3N2LnBhcnNlO1xuZXhwb3J0IHZhciBjc3ZQYXJzZVJvd3MgPSBjc3YucGFyc2VSb3dzO1xuZXhwb3J0IHZhciBjc3ZGb3JtYXQgPSBjc3YuZm9ybWF0O1xuZXhwb3J0IHZhciBjc3ZGb3JtYXRCb2R5ID0gY3N2LmZvcm1hdEJvZHk7XG5leHBvcnQgdmFyIGNzdkZvcm1hdFJvd3MgPSBjc3YuZm9ybWF0Um93cztcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0Um93ID0gY3N2LmZvcm1hdFJvdztcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0VmFsdWUgPSBjc3YuZm9ybWF0VmFsdWU7XG4iLCJ2YXIgRU9MID0ge30sXG4gICAgRU9GID0ge30sXG4gICAgUVVPVEUgPSAzNCxcbiAgICBORVdMSU5FID0gMTAsXG4gICAgUkVUVVJOID0gMTM7XG5cbmZ1bmN0aW9uIG9iamVjdENvbnZlcnRlcihjb2x1bW5zKSB7XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIGNvbHVtbnMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobmFtZSkgKyBcIjogZFtcIiArIGkgKyBcIl0gfHwgXFxcIlxcXCJcIjtcbiAgfSkuam9pbihcIixcIikgKyBcIn1cIik7XG59XG5cbmZ1bmN0aW9uIGN1c3RvbUNvbnZlcnRlcihjb2x1bW5zLCBmKSB7XG4gIHZhciBvYmplY3QgPSBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucyk7XG4gIHJldHVybiBmdW5jdGlvbihyb3csIGkpIHtcbiAgICByZXR1cm4gZihvYmplY3Qocm93KSwgaSwgY29sdW1ucyk7XG4gIH07XG59XG5cbi8vIENvbXB1dGUgdW5pcXVlIGNvbHVtbnMgaW4gb3JkZXIgb2YgZGlzY292ZXJ5LlxuZnVuY3Rpb24gaW5mZXJDb2x1bW5zKHJvd3MpIHtcbiAgdmFyIGNvbHVtblNldCA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBjb2x1bW5zID0gW107XG5cbiAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgIGZvciAodmFyIGNvbHVtbiBpbiByb3cpIHtcbiAgICAgIGlmICghKGNvbHVtbiBpbiBjb2x1bW5TZXQpKSB7XG4gICAgICAgIGNvbHVtbnMucHVzaChjb2x1bW5TZXRbY29sdW1uXSA9IGNvbHVtbik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29sdW1ucztcbn1cblxuZnVuY3Rpb24gcGFkKHZhbHVlLCB3aWR0aCkge1xuICB2YXIgcyA9IHZhbHVlICsgXCJcIiwgbGVuZ3RoID0gcy5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oMCkgKyBzIDogcztcbn1cblxuZnVuY3Rpb24gZm9ybWF0WWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyIDwgMCA/IFwiLVwiICsgcGFkKC15ZWFyLCA2KVxuICAgIDogeWVhciA+IDk5OTkgPyBcIitcIiArIHBhZCh5ZWFyLCA2KVxuICAgIDogcGFkKHllYXIsIDQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpLFxuICAgICAgbWludXRlcyA9IGRhdGUuZ2V0VVRDTWludXRlcygpLFxuICAgICAgc2Vjb25kcyA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgbWlsbGlzZWNvbmRzID0gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgcmV0dXJuIGlzTmFOKGRhdGUpID8gXCJJbnZhbGlkIERhdGVcIlxuICAgICAgOiBmb3JtYXRZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgNCkgKyBcIi1cIiArIHBhZChkYXRlLmdldFVUQ01vbnRoKCkgKyAxLCAyKSArIFwiLVwiICsgcGFkKGRhdGUuZ2V0VVRDRGF0ZSgpLCAyKVxuICAgICAgKyAobWlsbGlzZWNvbmRzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIjpcIiArIHBhZChzZWNvbmRzLCAyKSArIFwiLlwiICsgcGFkKG1pbGxpc2Vjb25kcywgMykgKyBcIlpcIlxuICAgICAgOiBzZWNvbmRzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIjpcIiArIHBhZChzZWNvbmRzLCAyKSArIFwiWlwiXG4gICAgICA6IG1pbnV0ZXMgfHwgaG91cnMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiWlwiXG4gICAgICA6IFwiXCIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWxpbWl0ZXIpIHtcbiAgdmFyIHJlRm9ybWF0ID0gbmV3IFJlZ0V4cChcIltcXFwiXCIgKyBkZWxpbWl0ZXIgKyBcIlxcblxccl1cIiksXG4gICAgICBERUxJTUlURVIgPSBkZWxpbWl0ZXIuY2hhckNvZGVBdCgwKTtcblxuICBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBmKSB7XG4gICAgdmFyIGNvbnZlcnQsIGNvbHVtbnMsIHJvd3MgPSBwYXJzZVJvd3ModGV4dCwgZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgICBpZiAoY29udmVydCkgcmV0dXJuIGNvbnZlcnQocm93LCBpIC0gMSk7XG4gICAgICBjb2x1bW5zID0gcm93LCBjb252ZXJ0ID0gZiA/IGN1c3RvbUNvbnZlcnRlcihyb3csIGYpIDogb2JqZWN0Q29udmVydGVyKHJvdyk7XG4gICAgfSk7XG4gICAgcm93cy5jb2x1bW5zID0gY29sdW1ucyB8fCBbXTtcbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUm93cyh0ZXh0LCBmKSB7XG4gICAgdmFyIHJvd3MgPSBbXSwgLy8gb3V0cHV0IHJvd3NcbiAgICAgICAgTiA9IHRleHQubGVuZ3RoLFxuICAgICAgICBJID0gMCwgLy8gY3VycmVudCBjaGFyYWN0ZXIgaW5kZXhcbiAgICAgICAgbiA9IDAsIC8vIGN1cnJlbnQgbGluZSBudW1iZXJcbiAgICAgICAgdCwgLy8gY3VycmVudCB0b2tlblxuICAgICAgICBlb2YgPSBOIDw9IDAsIC8vIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9GP1xuICAgICAgICBlb2wgPSBmYWxzZTsgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0w/XG5cbiAgICAvLyBTdHJpcCB0aGUgdHJhaWxpbmcgbmV3bGluZS5cbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KE4gLSAxKSA9PT0gTkVXTElORSkgLS1OO1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBSRVRVUk4pIC0tTjtcblxuICAgIGZ1bmN0aW9uIHRva2VuKCkge1xuICAgICAgaWYgKGVvZikgcmV0dXJuIEVPRjtcbiAgICAgIGlmIChlb2wpIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MO1xuXG4gICAgICAvLyBVbmVzY2FwZSBxdW90ZXMuXG4gICAgICB2YXIgaSwgaiA9IEksIGM7XG4gICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGopID09PSBRVU9URSkge1xuICAgICAgICB3aGlsZSAoSSsrIDwgTiAmJiB0ZXh0LmNoYXJDb2RlQXQoSSkgIT09IFFVT1RFIHx8IHRleHQuY2hhckNvZGVBdCgrK0kpID09PSBRVU9URSk7XG4gICAgICAgIGlmICgoaSA9IEkpID49IE4pIGVvZiA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKChjID0gdGV4dC5jaGFyQ29kZUF0KEkrKykpID09PSBORVdMSU5FKSBlb2wgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gTkVXTElORSkgKytJOyB9XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGogKyAxLCBpIC0gMSkucmVwbGFjZSgvXCJcIi9nLCBcIlxcXCJcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgbmV4dCBkZWxpbWl0ZXIgb3IgbmV3bGluZS5cbiAgICAgIHdoaWxlIChJIDwgTikge1xuICAgICAgICBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSA9IEkrKykpID09PSBORVdMSU5FKSBlb2wgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gTkVXTElORSkgKytJOyB9XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IERFTElNSVRFUikgY29udGludWU7XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGosIGkpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gbGFzdCB0b2tlbiBiZWZvcmUgRU9GLlxuICAgICAgcmV0dXJuIGVvZiA9IHRydWUsIHRleHQuc2xpY2UoaiwgTik7XG4gICAgfVxuXG4gICAgd2hpbGUgKCh0ID0gdG9rZW4oKSkgIT09IEVPRikge1xuICAgICAgdmFyIHJvdyA9IFtdO1xuICAgICAgd2hpbGUgKHQgIT09IEVPTCAmJiB0ICE9PSBFT0YpIHJvdy5wdXNoKHQpLCB0ID0gdG9rZW4oKTtcbiAgICAgIGlmIChmICYmIChyb3cgPSBmKHJvdywgbisrKSkgPT0gbnVsbCkgY29udGludWU7XG4gICAgICByb3dzLnB1c2gocm93KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiByb3dzLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKHJvd1tjb2x1bW5dKTtcbiAgICAgIH0pLmpvaW4oZGVsaW1pdGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdChyb3dzLCBjb2x1bW5zKSB7XG4gICAgaWYgKGNvbHVtbnMgPT0gbnVsbCkgY29sdW1ucyA9IGluZmVyQ29sdW1ucyhyb3dzKTtcbiAgICByZXR1cm4gW2NvbHVtbnMubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcildLmNvbmNhdChwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSB7XG4gICAgaWYgKGNvbHVtbnMgPT0gbnVsbCkgY29sdW1ucyA9IGluZmVyQ29sdW1ucyhyb3dzKTtcbiAgICByZXR1cm4gcHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um93cyhyb3dzKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKGZvcm1hdFJvdykuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvdyhyb3cpIHtcbiAgICByZXR1cm4gcm93Lm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCJcbiAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyBmb3JtYXREYXRlKHZhbHVlKVxuICAgICAgICA6IHJlRm9ybWF0LnRlc3QodmFsdWUgKz0gXCJcIikgPyBcIlxcXCJcIiArIHZhbHVlLnJlcGxhY2UoL1wiL2csIFwiXFxcIlxcXCJcIikgKyBcIlxcXCJcIlxuICAgICAgICA6IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgcGFyc2VSb3dzOiBwYXJzZVJvd3MsXG4gICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgZm9ybWF0Qm9keTogZm9ybWF0Qm9keSxcbiAgICBmb3JtYXRSb3dzOiBmb3JtYXRSb3dzLFxuICAgIGZvcm1hdFJvdzogZm9ybWF0Um93LFxuICAgIGZvcm1hdFZhbHVlOiBmb3JtYXRWYWx1ZVxuICB9O1xufVxuIiwiaW1wb3J0IGRzdiBmcm9tIFwiLi9kc3YuanNcIjtcblxudmFyIHRzdiA9IGRzdihcIlxcdFwiKTtcblxuZXhwb3J0IHZhciB0c3ZQYXJzZSA9IHRzdi5wYXJzZTtcbmV4cG9ydCB2YXIgdHN2UGFyc2VSb3dzID0gdHN2LnBhcnNlUm93cztcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0ID0gdHN2LmZvcm1hdDtcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0Qm9keSA9IHRzdi5mb3JtYXRCb2R5O1xuZXhwb3J0IHZhciB0c3ZGb3JtYXRSb3dzID0gdHN2LmZvcm1hdFJvd3M7XG5leHBvcnQgdmFyIHRzdkZvcm1hdFJvdyA9IHRzdi5mb3JtYXRSb3c7XG5leHBvcnQgdmFyIHRzdkZvcm1hdFZhbHVlID0gdHN2LmZvcm1hdFZhbHVlO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW4odCkge1xuICByZXR1cm4gdCAqIHQgKiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNPdXQodCkge1xuICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG59XG4iLCJpbXBvcnQge2NzdlBhcnNlLCBkc3ZGb3JtYXQsIHRzdlBhcnNlfSBmcm9tIFwiZDMtZHN2XCI7XG5pbXBvcnQgdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5cbmZ1bmN0aW9uIGRzdlBhcnNlKHBhcnNlKSB7XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaW5pdCwgcm93KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGluaXQgPT09IFwiZnVuY3Rpb25cIikgcm93ID0gaW5pdCwgaW5pdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGV4dChpbnB1dCwgaW5pdCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHBhcnNlKHJlc3BvbnNlLCByb3cpO1xuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkc3YoZGVsaW1pdGVyLCBpbnB1dCwgaW5pdCwgcm93KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBpbml0ID09PSBcImZ1bmN0aW9uXCIpIHJvdyA9IGluaXQsIGluaXQgPSB1bmRlZmluZWQ7XG4gIHZhciBmb3JtYXQgPSBkc3ZGb3JtYXQoZGVsaW1pdGVyKTtcbiAgcmV0dXJuIHRleHQoaW5wdXQsIGluaXQpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gZm9ybWF0LnBhcnNlKHJlc3BvbnNlLCByb3cpO1xuICB9KTtcbn1cblxuZXhwb3J0IHZhciBjc3YgPSBkc3ZQYXJzZShjc3ZQYXJzZSk7XG5leHBvcnQgdmFyIHRzdiA9IGRzdlBhcnNlKHRzdlBhcnNlKTtcbiIsImZ1bmN0aW9uIHJlc3BvbnNlSnNvbihyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgXCIgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA1KSByZXR1cm47XG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gIHJldHVybiBmZXRjaChpbnB1dCwgaW5pdCkudGhlbihyZXNwb25zZUpzb24pO1xufVxuIiwiZnVuY3Rpb24gcmVzcG9uc2VUZXh0KHJlc3BvbnNlKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyBcIiBcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gZmV0Y2goaW5wdXQsIGluaXQpLnRoZW4ocmVzcG9uc2VUZXh0KTtcbn1cbiIsImltcG9ydCBmb3JtYXRMb2NhbGUgZnJvbSBcIi4vbG9jYWxlLmpzXCI7XG5cbnZhciBsb2NhbGU7XG5leHBvcnQgdmFyIGZvcm1hdDtcbmV4cG9ydCB2YXIgZm9ybWF0UHJlZml4O1xuXG5kZWZhdWx0TG9jYWxlKHtcbiAgdGhvdXNhbmRzOiBcIixcIixcbiAgZ3JvdXBpbmc6IFszXSxcbiAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgbG9jYWxlID0gZm9ybWF0TG9jYWxlKGRlZmluaXRpb24pO1xuICBmb3JtYXQgPSBsb2NhbGUuZm9ybWF0O1xuICBmb3JtYXRQcmVmaXggPSBsb2NhbGUuZm9ybWF0UHJlZml4O1xuICByZXR1cm4gbG9jYWxlO1xufVxuIiwiaW1wb3J0IHtmb3JtYXREZWNpbWFsUGFydHN9IGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCA9IGZvcm1hdERlY2ltYWxQYXJ0cyhNYXRoLmFicyh4KSksIHggPyB4WzFdIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gTWF0aC5hYnMoeCA9IE1hdGgucm91bmQoeCkpID49IDFlMjFcbiAgICAgID8geC50b0xvY2FsZVN0cmluZyhcImVuXCIpLnJlcGxhY2UoLywvZywgXCJcIilcbiAgICAgIDogeC50b1N0cmluZygxMCk7XG59XG5cbi8vIENvbXB1dGVzIHRoZSBkZWNpbWFsIGNvZWZmaWNpZW50IGFuZCBleHBvbmVudCBvZiB0aGUgc3BlY2lmaWVkIG51bWJlciB4IHdpdGhcbi8vIHNpZ25pZmljYW50IGRpZ2l0cyBwLCB3aGVyZSB4IGlzIHBvc2l0aXZlIGFuZCBwIGlzIGluIFsxLCAyMV0gb3IgdW5kZWZpbmVkLlxuLy8gRm9yIGV4YW1wbGUsIGZvcm1hdERlY2ltYWxQYXJ0cygxLjIzKSByZXR1cm5zIFtcIjEyM1wiLCAwXS5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREZWNpbWFsUGFydHMoeCwgcCkge1xuICBpZiAoKGkgPSAoeCA9IHAgPyB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyAvLyBOYU4sIMKxSW5maW5pdHlcbiAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcblxuICAvLyBUaGUgc3RyaW5nIHJldHVybmVkIGJ5IHRvRXhwb25lbnRpYWwgZWl0aGVyIGhhcyB0aGUgZm9ybSBcXGRcXC5cXGQrZVstK11cXGQrXG4gIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXG4gIHJldHVybiBbXG4gICAgY29lZmZpY2llbnQubGVuZ3RoID4gMSA/IGNvZWZmaWNpZW50WzBdICsgY29lZmZpY2llbnQuc2xpY2UoMikgOiBjb2VmZmljaWVudCxcbiAgICAreC5zbGljZShpICsgMSlcbiAgXTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGdyb3VwaW5nLCB0aG91c2FuZHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCB3aWR0aCkge1xuICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICB0ID0gW10sXG4gICAgICAgIGogPSAwLFxuICAgICAgICBnID0gZ3JvdXBpbmdbMF0sXG4gICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICB3aGlsZSAoaSA+IDAgJiYgZyA+IDApIHtcbiAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgdC5wdXNoKHZhbHVlLnN1YnN0cmluZyhpIC09IGcsIGkgKyBnKSk7XG4gICAgICBpZiAoKGxlbmd0aCArPSBnICsgMSkgPiB3aWR0aCkgYnJlYWs7XG4gICAgICBnID0gZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBncm91cGluZy5sZW5ndGhdO1xuICAgIH1cblxuICAgIHJldHVybiB0LnJldmVyc2UoKS5qb2luKHRob3VzYW5kcyk7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihudW1lcmFscykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWzAtOV0vZywgZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIG51bWVyYWxzWytpXTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCB2YXIgcHJlZml4RXhwb25lbnQ7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsUGFydHMoeCwgcCk7XG4gIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgZXhwb25lbnQgPSBkWzFdLFxuICAgICAgaSA9IGV4cG9uZW50IC0gKHByZWZpeEV4cG9uZW50ID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQgLyAzKSkpICogMykgKyAxLFxuICAgICAgbiA9IGNvZWZmaWNpZW50Lmxlbmd0aDtcbiAgcmV0dXJuIGkgPT09IG4gPyBjb2VmZmljaWVudFxuICAgICAgOiBpID4gbiA/IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGkgLSBuICsgMSkuam9pbihcIjBcIilcbiAgICAgIDogaSA+IDAgPyBjb2VmZmljaWVudC5zbGljZSgwLCBpKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoaSlcbiAgICAgIDogXCIwLlwiICsgbmV3IEFycmF5KDEgLSBpKS5qb2luKFwiMFwiKSArIGZvcm1hdERlY2ltYWxQYXJ0cyh4LCBNYXRoLm1heCgwLCBwICsgaSAtIDEpKVswXTsgLy8gbGVzcyB0aGFuIDF5IVxufVxuIiwiaW1wb3J0IHtmb3JtYXREZWNpbWFsUGFydHN9IGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgcCkge1xuICB2YXIgZCA9IGZvcm1hdERlY2ltYWxQYXJ0cyh4LCBwKTtcbiAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICBleHBvbmVudCA9IGRbMV07XG4gIHJldHVybiBleHBvbmVudCA8IDAgPyBcIjAuXCIgKyBuZXcgQXJyYXkoLWV4cG9uZW50KS5qb2luKFwiMFwiKSArIGNvZWZmaWNpZW50XG4gICAgICA6IGNvZWZmaWNpZW50Lmxlbmd0aCA+IGV4cG9uZW50ICsgMSA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGV4cG9uZW50ICsgMSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGV4cG9uZW50ICsgMSlcbiAgICAgIDogY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoZXhwb25lbnQgLSBjb2VmZmljaWVudC5sZW5ndGggKyAyKS5qb2luKFwiMFwiKTtcbn1cbiIsIi8vIFtbZmlsbF1hbGlnbl1bc2lnbl1bc3ltYm9sXVswXVt3aWR0aF1bLF1bLnByZWNpc2lvbl1bfl1bdHlwZV1cbnZhciByZSA9IC9eKD86KC4pPyhbPD49Xl0pKT8oWytcXC0oIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KH4pPyhbYS16JV0pPyQvaTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICBpZiAoIShtYXRjaCA9IHJlLmV4ZWMoc3BlY2lmaWVyKSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0OiBcIiArIHNwZWNpZmllcik7XG4gIHZhciBtYXRjaDtcbiAgcmV0dXJuIG5ldyBGb3JtYXRTcGVjaWZpZXIoe1xuICAgIGZpbGw6IG1hdGNoWzFdLFxuICAgIGFsaWduOiBtYXRjaFsyXSxcbiAgICBzaWduOiBtYXRjaFszXSxcbiAgICBzeW1ib2w6IG1hdGNoWzRdLFxuICAgIHplcm86IG1hdGNoWzVdLFxuICAgIHdpZHRoOiBtYXRjaFs2XSxcbiAgICBjb21tYTogbWF0Y2hbN10sXG4gICAgcHJlY2lzaW9uOiBtYXRjaFs4XSAmJiBtYXRjaFs4XS5zbGljZSgxKSxcbiAgICB0cmltOiBtYXRjaFs5XSxcbiAgICB0eXBlOiBtYXRjaFsxMF1cbiAgfSk7XG59XG5cbmZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUgPSBGb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlOyAvLyBpbnN0YW5jZW9mXG5cbmV4cG9ydCBmdW5jdGlvbiBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gIHRoaXMuZmlsbCA9IHNwZWNpZmllci5maWxsID09PSB1bmRlZmluZWQgPyBcIiBcIiA6IHNwZWNpZmllci5maWxsICsgXCJcIjtcbiAgdGhpcy5hbGlnbiA9IHNwZWNpZmllci5hbGlnbiA9PT0gdW5kZWZpbmVkID8gXCI+XCIgOiBzcGVjaWZpZXIuYWxpZ24gKyBcIlwiO1xuICB0aGlzLnNpZ24gPSBzcGVjaWZpZXIuc2lnbiA9PT0gdW5kZWZpbmVkID8gXCItXCIgOiBzcGVjaWZpZXIuc2lnbiArIFwiXCI7XG4gIHRoaXMuc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHNwZWNpZmllci5zeW1ib2wgKyBcIlwiO1xuICB0aGlzLnplcm8gPSAhIXNwZWNpZmllci56ZXJvO1xuICB0aGlzLndpZHRoID0gc3BlY2lmaWVyLndpZHRoID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiArc3BlY2lmaWVyLndpZHRoO1xuICB0aGlzLmNvbW1hID0gISFzcGVjaWZpZXIuY29tbWE7XG4gIHRoaXMucHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogK3NwZWNpZmllci5wcmVjaXNpb247XG4gIHRoaXMudHJpbSA9ICEhc3BlY2lmaWVyLnRyaW07XG4gIHRoaXMudHlwZSA9IHNwZWNpZmllci50eXBlID09PSB1bmRlZmluZWQgPyBcIlwiIDogc3BlY2lmaWVyLnR5cGUgKyBcIlwiO1xufVxuXG5Gb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZpbGxcbiAgICAgICsgdGhpcy5hbGlnblxuICAgICAgKyB0aGlzLnNpZ25cbiAgICAgICsgdGhpcy5zeW1ib2xcbiAgICAgICsgKHRoaXMuemVybyA/IFwiMFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBNYXRoLm1heCgxLCB0aGlzLndpZHRoIHwgMCkpXG4gICAgICArICh0aGlzLmNvbW1hID8gXCIsXCIgOiBcIlwiKVxuICAgICAgKyAodGhpcy5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBcIi5cIiArIE1hdGgubWF4KDAsIHRoaXMucHJlY2lzaW9uIHwgMCkpXG4gICAgICArICh0aGlzLnRyaW0gPyBcIn5cIiA6IFwiXCIpXG4gICAgICArIHRoaXMudHlwZTtcbn07XG4iLCIvLyBUcmltcyBpbnNpZ25pZmljYW50IHplcm9zLCBlLmcuLCByZXBsYWNlcyAxLjIwMDBrIHdpdGggMS4yay5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHMpIHtcbiAgb3V0OiBmb3IgKHZhciBuID0gcy5sZW5ndGgsIGkgPSAxLCBpMCA9IC0xLCBpMTsgaSA8IG47ICsraSkge1xuICAgIHN3aXRjaCAoc1tpXSkge1xuICAgICAgY2FzZSBcIi5cIjogaTAgPSBpMSA9IGk7IGJyZWFrO1xuICAgICAgY2FzZSBcIjBcIjogaWYgKGkwID09PSAwKSBpMCA9IGk7IGkxID0gaTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBpZiAoIStzW2ldKSBicmVhayBvdXQ7IGlmIChpMCA+IDApIGkwID0gMDsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpMCA+IDAgPyBzLnNsaWNlKDAsIGkwKSArIHMuc2xpY2UoaTEgKyAxKSA6IHM7XG59XG4iLCJpbXBvcnQgZm9ybWF0RGVjaW1hbCBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5pbXBvcnQgZm9ybWF0UHJlZml4QXV0byBmcm9tIFwiLi9mb3JtYXRQcmVmaXhBdXRvLmpzXCI7XG5pbXBvcnQgZm9ybWF0Um91bmRlZCBmcm9tIFwiLi9mb3JtYXRSb3VuZGVkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgXCIlXCI6ICh4LCBwKSA9PiAoeCAqIDEwMCkudG9GaXhlZChwKSxcbiAgXCJiXCI6ICh4KSA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDIpLFxuICBcImNcIjogKHgpID0+IHggKyBcIlwiLFxuICBcImRcIjogZm9ybWF0RGVjaW1hbCxcbiAgXCJlXCI6ICh4LCBwKSA9PiB4LnRvRXhwb25lbnRpYWwocCksXG4gIFwiZlwiOiAoeCwgcCkgPT4geC50b0ZpeGVkKHApLFxuICBcImdcIjogKHgsIHApID0+IHgudG9QcmVjaXNpb24ocCksXG4gIFwib1wiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZyg4KSxcbiAgXCJwXCI6ICh4LCBwKSA9PiBmb3JtYXRSb3VuZGVkKHggKiAxMDAsIHApLFxuICBcInJcIjogZm9ybWF0Um91bmRlZCxcbiAgXCJzXCI6IGZvcm1hdFByZWZpeEF1dG8sXG4gIFwiWFwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSxcbiAgXCJ4XCI6ICh4KSA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59XG4iLCJpbXBvcnQgZXhwb25lbnQgZnJvbSBcIi4vZXhwb25lbnQuanNcIjtcbmltcG9ydCBmb3JtYXRHcm91cCBmcm9tIFwiLi9mb3JtYXRHcm91cC5qc1wiO1xuaW1wb3J0IGZvcm1hdE51bWVyYWxzIGZyb20gXCIuL2Zvcm1hdE51bWVyYWxzLmpzXCI7XG5pbXBvcnQgZm9ybWF0U3BlY2lmaWVyIGZyb20gXCIuL2Zvcm1hdFNwZWNpZmllci5qc1wiO1xuaW1wb3J0IGZvcm1hdFRyaW0gZnJvbSBcIi4vZm9ybWF0VHJpbS5qc1wiO1xuaW1wb3J0IGZvcm1hdFR5cGVzIGZyb20gXCIuL2Zvcm1hdFR5cGVzLmpzXCI7XG5pbXBvcnQge3ByZWZpeEV4cG9uZW50fSBmcm9tIFwiLi9mb3JtYXRQcmVmaXhBdXRvLmpzXCI7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxudmFyIG1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXAsXG4gICAgcHJlZml4ZXMgPSBbXCJ5XCIsXCJ6XCIsXCJhXCIsXCJmXCIsXCJwXCIsXCJuXCIsXCLCtVwiLFwibVwiLFwiXCIsXCJrXCIsXCJNXCIsXCJHXCIsXCJUXCIsXCJQXCIsXCJFXCIsXCJaXCIsXCJZXCJdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihsb2NhbGUpIHtcbiAgdmFyIGdyb3VwID0gbG9jYWxlLmdyb3VwaW5nID09PSB1bmRlZmluZWQgfHwgbG9jYWxlLnRob3VzYW5kcyA9PT0gdW5kZWZpbmVkID8gaWRlbnRpdHkgOiBmb3JtYXRHcm91cChtYXAuY2FsbChsb2NhbGUuZ3JvdXBpbmcsIE51bWJlciksIGxvY2FsZS50aG91c2FuZHMgKyBcIlwiKSxcbiAgICAgIGN1cnJlbmN5UHJlZml4ID0gbG9jYWxlLmN1cnJlbmN5ID09PSB1bmRlZmluZWQgPyBcIlwiIDogbG9jYWxlLmN1cnJlbmN5WzBdICsgXCJcIixcbiAgICAgIGN1cnJlbmN5U3VmZml4ID0gbG9jYWxlLmN1cnJlbmN5ID09PSB1bmRlZmluZWQgPyBcIlwiIDogbG9jYWxlLmN1cnJlbmN5WzFdICsgXCJcIixcbiAgICAgIGRlY2ltYWwgPSBsb2NhbGUuZGVjaW1hbCA9PT0gdW5kZWZpbmVkID8gXCIuXCIgOiBsb2NhbGUuZGVjaW1hbCArIFwiXCIsXG4gICAgICBudW1lcmFscyA9IGxvY2FsZS5udW1lcmFscyA9PT0gdW5kZWZpbmVkID8gaWRlbnRpdHkgOiBmb3JtYXROdW1lcmFscyhtYXAuY2FsbChsb2NhbGUubnVtZXJhbHMsIFN0cmluZykpLFxuICAgICAgcGVyY2VudCA9IGxvY2FsZS5wZXJjZW50ID09PSB1bmRlZmluZWQgPyBcIiVcIiA6IGxvY2FsZS5wZXJjZW50ICsgXCJcIixcbiAgICAgIG1pbnVzID0gbG9jYWxlLm1pbnVzID09PSB1bmRlZmluZWQgPyBcIuKIklwiIDogbG9jYWxlLm1pbnVzICsgXCJcIixcbiAgICAgIG5hbiA9IGxvY2FsZS5uYW4gPT09IHVuZGVmaW5lZCA/IFwiTmFOXCIgOiBsb2NhbGUubmFuICsgXCJcIjtcblxuICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyKSB7XG4gICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG5cbiAgICB2YXIgZmlsbCA9IHNwZWNpZmllci5maWxsLFxuICAgICAgICBhbGlnbiA9IHNwZWNpZmllci5hbGlnbixcbiAgICAgICAgc2lnbiA9IHNwZWNpZmllci5zaWduLFxuICAgICAgICBzeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sLFxuICAgICAgICB6ZXJvID0gc3BlY2lmaWVyLnplcm8sXG4gICAgICAgIHdpZHRoID0gc3BlY2lmaWVyLndpZHRoLFxuICAgICAgICBjb21tYSA9IHNwZWNpZmllci5jb21tYSxcbiAgICAgICAgcHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbixcbiAgICAgICAgdHJpbSA9IHNwZWNpZmllci50cmltLFxuICAgICAgICB0eXBlID0gc3BlY2lmaWVyLnR5cGU7XG5cbiAgICAvLyBUaGUgXCJuXCIgdHlwZSBpcyBhbiBhbGlhcyBmb3IgXCIsZ1wiLlxuICAgIGlmICh0eXBlID09PSBcIm5cIikgY29tbWEgPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBUaGUgXCJcIiB0eXBlLCBhbmQgYW55IGludmFsaWQgdHlwZSwgaXMgYW4gYWxpYXMgZm9yIFwiLjEyfmdcIi5cbiAgICBlbHNlIGlmICghZm9ybWF0VHlwZXNbdHlwZV0pIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkICYmIChwcmVjaXNpb24gPSAxMiksIHRyaW0gPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBJZiB6ZXJvIGZpbGwgaXMgc3BlY2lmaWVkLCBwYWRkaW5nIGdvZXMgYWZ0ZXIgc2lnbiBhbmQgYmVmb3JlIGRpZ2l0cy5cbiAgICBpZiAoemVybyB8fCAoZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSkgemVybyA9IHRydWUsIGZpbGwgPSBcIjBcIiwgYWxpZ24gPSBcIj1cIjtcblxuICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgIC8vIEZvciBTSS1wcmVmaXgsIHRoZSBzdWZmaXggaXMgbGF6aWx5IGNvbXB1dGVkLlxuICAgIHZhciBwcmVmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lQcmVmaXggOiBzeW1ib2wgPT09IFwiI1wiICYmIC9bYm94WF0vLnRlc3QodHlwZSkgPyBcIjBcIiArIHR5cGUudG9Mb3dlckNhc2UoKSA6IFwiXCIsXG4gICAgICAgIHN1ZmZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVN1ZmZpeCA6IC9bJXBdLy50ZXN0KHR5cGUpID8gcGVyY2VudCA6IFwiXCI7XG5cbiAgICAvLyBXaGF0IGZvcm1hdCBmdW5jdGlvbiBzaG91bGQgd2UgdXNlP1xuICAgIC8vIElzIHRoaXMgYW4gaW50ZWdlciB0eXBlP1xuICAgIC8vIENhbiB0aGlzIHR5cGUgZ2VuZXJhdGUgZXhwb25lbnRpYWwgbm90YXRpb24/XG4gICAgdmFyIGZvcm1hdFR5cGUgPSBmb3JtYXRUeXBlc1t0eXBlXSxcbiAgICAgICAgbWF5YmVTdWZmaXggPSAvW2RlZmdwcnMlXS8udGVzdCh0eXBlKTtcblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdCBwcmVjaXNpb24gaWYgbm90IHNwZWNpZmllZCxcbiAgICAvLyBvciBjbGFtcCB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbiB0byB0aGUgc3VwcG9ydGVkIHJhbmdlLlxuICAgIC8vIEZvciBzaWduaWZpY2FudCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzEsIDIxXS5cbiAgICAvLyBGb3IgZml4ZWQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFswLCAyMF0uXG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyA2XG4gICAgICAgIDogL1tncHJzXS8udGVzdCh0eXBlKSA/IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKVxuICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgdmFyIHZhbHVlUHJlZml4ID0gcHJlZml4LFxuICAgICAgICAgIHZhbHVlU3VmZml4ID0gc3VmZml4LFxuICAgICAgICAgIGksIG4sIGM7XG5cbiAgICAgIGlmICh0eXBlID09PSBcImNcIikge1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9IGZvcm1hdFR5cGUodmFsdWUpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgc2lnbi4gLTAgaXMgbm90IGxlc3MgdGhhbiAwLCBidXQgMSAvIC0wIGlzIVxuICAgICAgICB2YXIgdmFsdWVOZWdhdGl2ZSA9IHZhbHVlIDwgMCB8fCAxIC8gdmFsdWUgPCAwO1xuXG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGluaXRpYWwgZm9ybWF0dGluZy5cbiAgICAgICAgdmFsdWUgPSBpc05hTih2YWx1ZSkgPyBuYW4gOiBmb3JtYXRUeXBlKE1hdGguYWJzKHZhbHVlKSwgcHJlY2lzaW9uKTtcblxuICAgICAgICAvLyBUcmltIGluc2lnbmlmaWNhbnQgemVyb3MuXG4gICAgICAgIGlmICh0cmltKSB2YWx1ZSA9IGZvcm1hdFRyaW0odmFsdWUpO1xuXG4gICAgICAgIC8vIElmIGEgbmVnYXRpdmUgdmFsdWUgcm91bmRzIHRvIHplcm8gYWZ0ZXIgZm9ybWF0dGluZywgYW5kIG5vIGV4cGxpY2l0IHBvc2l0aXZlIHNpZ24gaXMgcmVxdWVzdGVkLCBoaWRlIHRoZSBzaWduLlxuICAgICAgICBpZiAodmFsdWVOZWdhdGl2ZSAmJiArdmFsdWUgPT09IDAgJiYgc2lnbiAhPT0gXCIrXCIpIHZhbHVlTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgICAgdmFsdWVQcmVmaXggPSAodmFsdWVOZWdhdGl2ZSA/IChzaWduID09PSBcIihcIiA/IHNpZ24gOiBtaW51cykgOiBzaWduID09PSBcIi1cIiB8fCBzaWduID09PSBcIihcIiA/IFwiXCIgOiBzaWduKSArIHZhbHVlUHJlZml4O1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9ICh0eXBlID09PSBcInNcIiA/IHByZWZpeGVzWzggKyBwcmVmaXhFeHBvbmVudCAvIDNdIDogXCJcIikgKyB2YWx1ZVN1ZmZpeCArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAvLyBCcmVhayB0aGUgZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGludGVnZXIg4oCcdmFsdWXigJ0gcGFydCB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBncm91cGVkLCBhbmQgZnJhY3Rpb25hbCBvciBleHBvbmVudGlhbCDigJxzdWZmaXjigJ0gcGFydCB0aGF0IGlzIG5vdC5cbiAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksIDQ4ID4gYyB8fCBjID4gNTcpIHtcbiAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmICF6ZXJvKSB2YWx1ZSA9IGdyb3VwKHZhbHVlLCBJbmZpbml0eSk7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWVQcmVmaXgubGVuZ3RoICsgdmFsdWUubGVuZ3RoICsgdmFsdWVTdWZmaXgubGVuZ3RoLFxuICAgICAgICAgIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiB6ZXJvKSB2YWx1ZSA9IGdyb3VwKHBhZGRpbmcgKyB2YWx1ZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIHZhbHVlU3VmZml4Lmxlbmd0aCA6IEluZmluaXR5KSwgcGFkZGluZyA9IFwiXCI7XG5cbiAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBmaW5hbCBvdXRwdXQgYmFzZWQgb24gdGhlIGRlc2lyZWQgYWxpZ25tZW50LlxuICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICBjYXNlIFwiPFwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmc7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiPVwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgcGFkZGluZyArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiXlwiOiB2YWx1ZSA9IHBhZGRpbmcuc2xpY2UoMCwgbGVuZ3RoID0gcGFkZGluZy5sZW5ndGggPj4gMSkgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nLnNsaWNlKGxlbmd0aCk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB2YWx1ZSA9IHBhZGRpbmcgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtZXJhbHModmFsdWUpO1xuICAgIH1cblxuICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNwZWNpZmllciArIFwiXCI7XG4gICAgfTtcblxuICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgIHZhciBmID0gbmV3Rm9ybWF0KChzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSwgc3BlY2lmaWVyLnR5cGUgPSBcImZcIiwgc3BlY2lmaWVyKSksXG4gICAgICAgIGUgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyxcbiAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzggKyBlIC8gM107XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogbmV3Rm9ybWF0LFxuICAgIGZvcm1hdFByZWZpeDogZm9ybWF0UHJlZml4XG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYmFzaXModDEsIHYwLCB2MSwgdjIsIHYzKSB7XG4gIHZhciB0MiA9IHQxICogdDEsIHQzID0gdDIgKiB0MTtcbiAgcmV0dXJuICgoMSAtIDMgKiB0MSArIDMgKiB0MiAtIHQzKSAqIHYwXG4gICAgICArICg0IC0gNiAqIHQyICsgMyAqIHQzKSAqIHYxXG4gICAgICArICgxICsgMyAqIHQxICsgMyAqIHQyIC0gMyAqIHQzKSAqIHYyXG4gICAgICArIHQzICogdjMpIC8gNjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0IDw9IDAgPyAodCA9IDApIDogdCA+PSAxID8gKHQgPSAxLCBuIC0gMSkgOiBNYXRoLmZsb29yKHQgKiBuKSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaV0sXG4gICAgICAgIHYyID0gdmFsdWVzW2kgKyAxXSxcbiAgICAgICAgdjAgPSBpID4gMCA/IHZhbHVlc1tpIC0gMV0gOiAyICogdjEgLSB2MixcbiAgICAgICAgdjMgPSBpIDwgbiAtIDEgPyB2YWx1ZXNbaSArIDJdIDogMiAqIHYyIC0gdjE7XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuIiwiaW1wb3J0IHtiYXNpc30gZnJvbSBcIi4vYmFzaXMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoKCh0ICU9IDEpIDwgMCA/ICsrdCA6IHQpICogbiksXG4gICAgICAgIHYwID0gdmFsdWVzWyhpICsgbiAtIDEpICUgbl0sXG4gICAgICAgIHYxID0gdmFsdWVzW2kgJSBuXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbKGkgKyAxKSAlIG5dLFxuICAgICAgICB2MyA9IHZhbHVlc1soaSArIDIpICUgbl07XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmZ1bmN0aW9uIGxpbmVhcihhLCBkKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKyB0ICogZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnRpYWwoYSwgYiwgeSkge1xuICByZXR1cm4gYSA9IE1hdGgucG93KGEsIHkpLCBiID0gTWF0aC5wb3coYiwgeSkgLSBhLCB5ID0gMSAvIHksIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coYSArIHQgKiBiLCB5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh1ZShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQgPiAxODAgfHwgZCA8IC0xODAgPyBkIC0gMzYwICogTWF0aC5yb3VuZChkIC8gMzYwKSA6IGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnYW1tYSh5KSB7XG4gIHJldHVybiAoeSA9ICt5KSA9PT0gMSA/IG5vZ2FtbWEgOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIgLSBhID8gZXhwb25lbnRpYWwoYSwgYiwgeSkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9nYW1tYShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCB4ID0+ICgpID0+IHg7XG4iLCJpbXBvcnQge2xhYiBhcyBjb2xvckxhYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IgZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFiKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGwgPSBjb2xvcigoc3RhcnQgPSBjb2xvckxhYihzdGFydCkpLmwsIChlbmQgPSBjb2xvckxhYihlbmQpKS5sKSxcbiAgICAgIGEgPSBjb2xvcihzdGFydC5hLCBlbmQuYSksXG4gICAgICBiID0gY29sb3Ioc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBzdGFydC5sID0gbCh0KTtcbiAgICBzdGFydC5hID0gYSh0KTtcbiAgICBzdGFydC5iID0gYih0KTtcbiAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSAqICgxIC0gdCkgKyBiICogdDtcbiAgfTtcbn1cbiIsImltcG9ydCB7cmdiIGFzIGNvbG9yUmdifSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBiYXNpcyBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuaW1wb3J0IGJhc2lzQ2xvc2VkIGZyb20gXCIuL2Jhc2lzQ2xvc2VkLmpzXCI7XG5pbXBvcnQgbm9nYW1tYSwge2dhbW1hfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gcmdiR2FtbWEoeSkge1xuICB2YXIgY29sb3IgPSBnYW1tYSh5KTtcblxuICBmdW5jdGlvbiByZ2Ioc3RhcnQsIGVuZCkge1xuICAgIHZhciByID0gY29sb3IoKHN0YXJ0ID0gY29sb3JSZ2Ioc3RhcnQpKS5yLCAoZW5kID0gY29sb3JSZ2IoZW5kKSkuciksXG4gICAgICAgIGcgPSBjb2xvcihzdGFydC5nLCBlbmQuZyksXG4gICAgICAgIGIgPSBjb2xvcihzdGFydC5iLCBlbmQuYiksXG4gICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuciA9IHIodCk7XG4gICAgICBzdGFydC5nID0gZyh0KTtcbiAgICAgIHN0YXJ0LmIgPSBiKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICByZ2IuZ2FtbWEgPSByZ2JHYW1tYTtcblxuICByZXR1cm4gcmdiO1xufSkoMSk7XG5cbmZ1bmN0aW9uIHJnYlNwbGluZShzcGxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9ycykge1xuICAgIHZhciBuID0gY29sb3JzLmxlbmd0aCxcbiAgICAgICAgciA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgZyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgaSwgY29sb3I7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgY29sb3IgPSBjb2xvclJnYihjb2xvcnNbaV0pO1xuICAgICAgcltpXSA9IGNvbG9yLnIgfHwgMDtcbiAgICAgIGdbaV0gPSBjb2xvci5nIHx8IDA7XG4gICAgICBiW2ldID0gY29sb3IuYiB8fCAwO1xuICAgIH1cbiAgICByID0gc3BsaW5lKHIpO1xuICAgIGcgPSBzcGxpbmUoZyk7XG4gICAgYiA9IHNwbGluZShiKTtcbiAgICBjb2xvci5vcGFjaXR5ID0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29sb3IuciA9IHIodCk7XG4gICAgICBjb2xvci5nID0gZyh0KTtcbiAgICAgIGNvbG9yLmIgPSBiKHQpO1xuICAgICAgcmV0dXJuIGNvbG9yICsgXCJcIjtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgdmFyIHJnYkJhc2lzID0gcmdiU3BsaW5lKGJhc2lzKTtcbmV4cG9ydCB2YXIgcmdiQmFzaXNDbG9zZWQgPSByZ2JTcGxpbmUoYmFzaXNDbG9zZWQpO1xuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxudmFyIHJlQSA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZyxcbiAgICByZUIgPSBuZXcgUmVnRXhwKHJlQS5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gemVybyhiKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25lKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYih0KSArIFwiXCI7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGJpID0gcmVBLmxhc3RJbmRleCA9IHJlQi5sYXN0SW5kZXggPSAwLCAvLyBzY2FuIGluZGV4IGZvciBuZXh0IG51bWJlciBpbiBiXG4gICAgICBhbSwgLy8gY3VycmVudCBtYXRjaCBpbiBhXG4gICAgICBibSwgLy8gY3VycmVudCBtYXRjaCBpbiBiXG4gICAgICBicywgLy8gc3RyaW5nIHByZWNlZGluZyBjdXJyZW50IG51bWJlciBpbiBiLCBpZiBhbnlcbiAgICAgIGkgPSAtMSwgLy8gaW5kZXggaW4gc1xuICAgICAgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcblxuICAvLyBDb2VyY2UgaW5wdXRzIHRvIHN0cmluZ3MuXG4gIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuXG4gIC8vIEludGVycG9sYXRlIHBhaXJzIG9mIG51bWJlcnMgaW4gYSAmIGIuXG4gIHdoaWxlICgoYW0gPSByZUEuZXhlYyhhKSlcbiAgICAgICYmIChibSA9IHJlQi5leGVjKGIpKSkge1xuICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkgeyAvLyBhIHN0cmluZyBwcmVjZWRlcyB0aGUgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIGlmICgoYW0gPSBhbVswXSkgPT09IChibSA9IGJtWzBdKSkgeyAvLyBudW1iZXJzIGluIGEgJiBiIG1hdGNoXG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYm07XG4gICAgfSBlbHNlIHsgLy8gaW50ZXJwb2xhdGUgbm9uLW1hdGNoaW5nIG51bWJlcnNcbiAgICAgIHNbKytpXSA9IG51bGw7XG4gICAgICBxLnB1c2goe2k6IGksIHg6IG51bWJlcihhbSwgYm0pfSk7XG4gICAgfVxuICAgIGJpID0gcmVCLmxhc3RJbmRleDtcbiAgfVxuXG4gIC8vIEFkZCByZW1haW5zIG9mIGIuXG4gIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgYnMgPSBiLnNsaWNlKGJpKTtcbiAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICBlbHNlIHNbKytpXSA9IGJzO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBvcHRpbWl6YXRpb24gZm9yIG9ubHkgYSBzaW5nbGUgbWF0Y2guXG4gIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgbnVtYmVycyBhbmQgcmVqb2luIHRoZSBzdHJpbmcuXG4gIHJldHVybiBzLmxlbmd0aCA8IDIgPyAocVswXVxuICAgICAgPyBvbmUocVswXS54KVxuICAgICAgOiB6ZXJvKGIpKVxuICAgICAgOiAoYiA9IHEubGVuZ3RoLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgICAgICB9KTtcbn1cbiIsInZhciBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcblxuZXhwb3J0IHZhciBpZGVudGl0eSA9IHtcbiAgdHJhbnNsYXRlWDogMCxcbiAgdHJhbnNsYXRlWTogMCxcbiAgcm90YXRlOiAwLFxuICBza2V3WDogMCxcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcbiAgaWYgKHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSkgYSAvPSBzY2FsZVgsIGIgLz0gc2NhbGVYO1xuICBpZiAoc2tld1ggPSBhICogYyArIGIgKiBkKSBjIC09IGEgKiBza2V3WCwgZCAtPSBiICogc2tld1g7XG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xuICBpZiAoYSAqIGQgPCBiICogYykgYSA9IC1hLCBiID0gLWIsIHNrZXdYID0gLXNrZXdYLCBzY2FsZVggPSAtc2NhbGVYO1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0ZVg6IGUsXG4gICAgdHJhbnNsYXRlWTogZixcbiAgICByb3RhdGU6IE1hdGguYXRhbjIoYiwgYSkgKiBkZWdyZWVzLFxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi4vbnVtYmVyLmpzXCI7XG5pbXBvcnQge3BhcnNlQ3NzLCBwYXJzZVN2Z30gZnJvbSBcIi4vcGFyc2UuanNcIjtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2UsIHB4Q29tbWEsIHB4UGFyZW4sIGRlZ1BhcmVuKSB7XG5cbiAgZnVuY3Rpb24gcG9wKHMpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPyBzLnBvcCgpICsgXCIgXCIgOiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKFwidHJhbnNsYXRlKFwiLCBudWxsLCBweENvbW1hLCBudWxsLCBweFBhcmVuKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgfHwgeWIpIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHhiICsgcHhDb21tYSArIHliICsgcHhQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcm90YXRlKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgLSBiID4gMTgwKSBiICs9IDM2MDsgZWxzZSBpZiAoYiAtIGEgPiAxODApIGEgKz0gMzYwOyAvLyBzaG9ydGVzdCBwYXRoXG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNrZXdYKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgIT09IDEgfHwgeWIgIT09IDEpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiICsgeGIgKyBcIixcIiArIHliICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcbiAgICBhID0gcGFyc2UoYSksIGIgPSBwYXJzZShiKTtcbiAgICB0cmFuc2xhdGUoYS50cmFuc2xhdGVYLCBhLnRyYW5zbGF0ZVksIGIudHJhbnNsYXRlWCwgYi50cmFuc2xhdGVZLCBzLCBxKTtcbiAgICByb3RhdGUoYS5yb3RhdGUsIGIucm90YXRlLCBzLCBxKTtcbiAgICBza2V3WChhLnNrZXdYLCBiLnNrZXdYLCBzLCBxKTtcbiAgICBzY2FsZShhLnNjYWxlWCwgYS5zY2FsZVksIGIuc2NhbGVYLCBiLnNjYWxlWSwgcywgcSk7XG4gICAgYSA9IGIgPSBudWxsOyAvLyBnY1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XG4gICAgICB3aGlsZSAoKytpIDwgbikgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VDc3MsIFwicHgsIFwiLCBcInB4KVwiLCBcImRlZylcIik7XG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VTdmcsIFwiLCBcIiwgXCIpXCIsIFwiKVwiKTtcbiIsImltcG9ydCBkZWNvbXBvc2UsIHtpZGVudGl0eX0gZnJvbSBcIi4vZGVjb21wb3NlLmpzXCI7XG5cbnZhciBzdmdOb2RlO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ3NzKHZhbHVlKSB7XG4gIGNvbnN0IG0gPSBuZXcgKHR5cGVvZiBET01NYXRyaXggPT09IFwiZnVuY3Rpb25cIiA/IERPTU1hdHJpeCA6IFdlYktpdENTU01hdHJpeCkodmFsdWUgKyBcIlwiKTtcbiAgcmV0dXJuIG0uaXNJZGVudGl0eSA/IGlkZW50aXR5IDogZGVjb21wb3NlKG0uYSwgbS5iLCBtLmMsIG0uZCwgbS5lLCBtLmYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKCFzdmdOb2RlKSBzdmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICBzdmdOb2RlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB2YWx1ZSk7XG4gIGlmICghKHZhbHVlID0gc3ZnTm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpKSkgcmV0dXJuIGlkZW50aXR5O1xuICB2YWx1ZSA9IHZhbHVlLm1hdHJpeDtcbiAgcmV0dXJuIGRlY29tcG9zZSh2YWx1ZS5hLCB2YWx1ZS5iLCB2YWx1ZS5jLCB2YWx1ZS5kLCB2YWx1ZS5lLCB2YWx1ZS5mKTtcbn1cbiIsInZhciBlcHNpbG9uMiA9IDFlLTEyO1xuXG5mdW5jdGlvbiBjb3NoKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSArIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHNpbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpIC0gMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gdGFuaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCgyICogeCkpIC0gMSkgLyAoeCArIDEpO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gem9vbVJobyhyaG8sIHJobzIsIHJobzQpIHtcblxuICAvLyBwMCA9IFt1eDAsIHV5MCwgdzBdXG4gIC8vIHAxID0gW3V4MSwgdXkxLCB3MV1cbiAgZnVuY3Rpb24gem9vbShwMCwgcDEpIHtcbiAgICB2YXIgdXgwID0gcDBbMF0sIHV5MCA9IHAwWzFdLCB3MCA9IHAwWzJdLFxuICAgICAgICB1eDEgPSBwMVswXSwgdXkxID0gcDFbMV0sIHcxID0gcDFbMl0sXG4gICAgICAgIGR4ID0gdXgxIC0gdXgwLFxuICAgICAgICBkeSA9IHV5MSAtIHV5MCxcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgICAgaSxcbiAgICAgICAgUztcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgdTAg4omFIHUxLlxuICAgIGlmIChkMiA8IGVwc2lsb24yKSB7XG4gICAgICBTID0gTWF0aC5sb2codzEgLyB3MCkgLyByaG87XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHV4MCArIHQgKiBkeCxcbiAgICAgICAgICB1eTAgKyB0ICogZHksXG4gICAgICAgICAgdzAgKiBNYXRoLmV4cChyaG8gKiB0ICogUylcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZW5lcmFsIGNhc2UuXG4gICAgZWxzZSB7XG4gICAgICB2YXIgZDEgPSBNYXRoLnNxcnQoZDIpLFxuICAgICAgICAgIGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgcmhvNCAqIGQyKSAvICgyICogdzAgKiByaG8yICogZDEpLFxuICAgICAgICAgIGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gcmhvNCAqIGQyKSAvICgyICogdzEgKiByaG8yICogZDEpLFxuICAgICAgICAgIHIwID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIwICogYjAgKyAxKSAtIGIwKSxcbiAgICAgICAgICByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XG4gICAgICBTID0gKHIxIC0gcjApIC8gcmhvO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHMgPSB0ICogUyxcbiAgICAgICAgICAgIGNvc2hyMCA9IGNvc2gocjApLFxuICAgICAgICAgICAgdSA9IHcwIC8gKHJobzIgKiBkMSkgKiAoY29zaHIwICogdGFuaChyaG8gKiBzICsgcjApIC0gc2luaChyMCkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHV4MCArIHUgKiBkeCxcbiAgICAgICAgICB1eTAgKyB1ICogZHksXG4gICAgICAgICAgdzAgKiBjb3NocjAgLyBjb3NoKHJobyAqIHMgKyByMClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpLmR1cmF0aW9uID0gUyAqIDEwMDAgKiByaG8gLyBNYXRoLlNRUlQyO1xuXG4gICAgcmV0dXJuIGk7XG4gIH1cblxuICB6b29tLnJobyA9IGZ1bmN0aW9uKF8pIHtcbiAgICB2YXIgXzEgPSBNYXRoLm1heCgxZS0zLCArXyksIF8yID0gXzEgKiBfMSwgXzQgPSBfMiAqIF8yO1xuICAgIHJldHVybiB6b29tUmhvKF8xLCBfMiwgXzQpO1xuICB9O1xuXG4gIHJldHVybiB6b29tO1xufSkoTWF0aC5TUVJUMiwgMiwgNCk7XG4iLCJleHBvcnQgZGVmYXVsdCBNYXRoLnJhbmRvbTtcbiIsImltcG9ydCBkZWZhdWx0U291cmNlIGZyb20gXCIuL2RlZmF1bHRTb3VyY2UuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHNvdXJjZVJhbmRvbU5vcm1hbChzb3VyY2UpIHtcbiAgZnVuY3Rpb24gcmFuZG9tTm9ybWFsKG11LCBzaWdtYSkge1xuICAgIHZhciB4LCByO1xuICAgIG11ID0gbXUgPT0gbnVsbCA/IDAgOiArbXU7XG4gICAgc2lnbWEgPSBzaWdtYSA9PSBudWxsID8gMSA6ICtzaWdtYTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeTtcblxuICAgICAgLy8gSWYgYXZhaWxhYmxlLCB1c2UgdGhlIHNlY29uZCBwcmV2aW91c2x5LWdlbmVyYXRlZCB1bmlmb3JtIHJhbmRvbS5cbiAgICAgIGlmICh4ICE9IG51bGwpIHkgPSB4LCB4ID0gbnVsbDtcblxuICAgICAgLy8gT3RoZXJ3aXNlLCBnZW5lcmF0ZSBhIG5ldyB4IGFuZCB5LlxuICAgICAgZWxzZSBkbyB7XG4gICAgICAgIHggPSBzb3VyY2UoKSAqIDIgLSAxO1xuICAgICAgICB5ID0gc291cmNlKCkgKiAyIC0gMTtcbiAgICAgICAgciA9IHggKiB4ICsgeSAqIHk7XG4gICAgICB9IHdoaWxlICghciB8fCByID4gMSk7XG5cbiAgICAgIHJldHVybiBtdSArIHNpZ21hICogeSAqIE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHIpIC8gcik7XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbU5vcm1hbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21Ob3JtYWw7XG5cbiAgcmV0dXJuIHJhbmRvbU5vcm1hbDtcbn0pKGRlZmF1bHRTb3VyY2UpO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGluaXRSYW5nZShkb21haW4sIHJhbmdlKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogYnJlYWs7XG4gICAgY2FzZSAxOiB0aGlzLnJhbmdlKGRvbWFpbik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRoaXMucmFuZ2UocmFuZ2UpLmRvbWFpbihkb21haW4pOyBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRJbnRlcnBvbGF0b3IoZG9tYWluLCBpbnRlcnBvbGF0b3IpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHtcbiAgICAgIGlmICh0eXBlb2YgZG9tYWluID09PSBcImZ1bmN0aW9uXCIpIHRoaXMuaW50ZXJwb2xhdG9yKGRvbWFpbik7XG4gICAgICBlbHNlIHRoaXMucmFuZ2UoZG9tYWluKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aGlzLmRvbWFpbihkb21haW4pO1xuICAgICAgaWYgKHR5cGVvZiBpbnRlcnBvbGF0b3IgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5pbnRlcnBvbGF0b3IoaW50ZXJwb2xhdG9yKTtcbiAgICAgIGVsc2UgdGhpcy5yYW5nZShpbnRlcnBvbGF0b3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiaW1wb3J0IHthc2NlbmRpbmcsIGJpc2VjdCwgcXVhbnRpbGVTb3J0ZWQgYXMgdGhyZXNob2xkfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YW50aWxlKCkge1xuICB2YXIgZG9tYWluID0gW10sXG4gICAgICByYW5nZSA9IFtdLFxuICAgICAgdGhyZXNob2xkcyA9IFtdLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gMCwgbiA9IE1hdGgubWF4KDEsIHJhbmdlLmxlbmd0aCk7XG4gICAgdGhyZXNob2xkcyA9IG5ldyBBcnJheShuIC0gMSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRocmVzaG9sZHNbaSAtIDFdID0gdGhyZXNob2xkKGRvbWFpbiwgaSAvIG4pO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsIHx8IGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogcmFuZ2VbYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgfVxuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXSA6IFtcbiAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXG4gICAgICBpIDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW2ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXVxuICAgIF07XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAobGV0IGQgb2YgXykgaWYgKGQgIT0gbnVsbCAmJiAhaXNOYU4oZCA9ICtkKSkgZG9tYWluLnB1c2goZCk7XG4gICAgZG9tYWluLnNvcnQoYXNjZW5kaW5nKTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gQXJyYXkuZnJvbShfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5xdWFudGlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhyZXNob2xkcy5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpbGUoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiLy8gR2l2ZW4gc29tZXRoaW5nIGFycmF5IGxpa2UgKG9yIG51bGwpLCByZXR1cm5zIHNvbWV0aGluZyB0aGF0IGlzIHN0cmljdGx5IGFuXG4vLyBhcnJheS4gVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IGFycmF5LWxpa2Ugb2JqZWN0cyBwYXNzZWQgdG8gZDMuc2VsZWN0QWxsXG4vLyBvciBzZWxlY3Rpb24uc2VsZWN0QWxsIGFyZSBjb252ZXJ0ZWQgaW50byBwcm9wZXIgYXJyYXlzIHdoZW4gY3JlYXRpbmcgYVxuLy8gc2VsZWN0aW9uOyB3ZSBkb27igJl0IGV2ZXIgd2FudCB0byBjcmVhdGUgYSBzZWxlY3Rpb24gYmFja2VkIGJ5IGEgbGl2ZVxuLy8gSFRNTENvbGxlY3Rpb24gb3IgTm9kZUxpc3QuIEhvd2V2ZXIsIG5vdGUgdGhhdCBzZWxlY3Rpb24uc2VsZWN0QWxsIHdpbGwgdXNlIGFcbi8vIHN0YXRpYyBOb2RlTGlzdCBhcyBhIGdyb3VwLCBzaW5jZSBpdCBzYWZlbHkgZGVyaXZlZCBmcm9tIHF1ZXJ5U2VsZWN0b3JBbGwuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcnJheSh4KSB7XG4gIHJldHVybiB4ID09IG51bGwgPyBbXSA6IEFycmF5LmlzQXJyYXkoeCkgPyB4IDogQXJyYXkuZnJvbSh4KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi9uYW1lc3BhY2UuanNcIjtcbmltcG9ydCB7eGh0bWx9IGZyb20gXCIuL25hbWVzcGFjZXMuanNcIjtcblxuZnVuY3Rpb24gY3JlYXRvckluaGVyaXQobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50LFxuICAgICAgICB1cmkgPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICByZXR1cm4gdXJpID09PSB4aHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSB4aHRtbFxuICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSlcbiAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModXJpLCBuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRvckZpeGVkKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIChmdWxsbmFtZS5sb2NhbFxuICAgICAgPyBjcmVhdG9yRml4ZWRcbiAgICAgIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkTWF0Y2hlcihzZWxlY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufVxuXG4iLCJpbXBvcnQgbmFtZXNwYWNlcyBmcm9tIFwiLi9uYW1lc3BhY2VzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHByZWZpeCA9IG5hbWUgKz0gXCJcIiwgaSA9IHByZWZpeC5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICByZXR1cm4gbmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpID8ge3NwYWNlOiBuYW1lc3BhY2VzW3ByZWZpeF0sIGxvY2FsOiBuYW1lfSA6IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG59XG4iLCJleHBvcnQgdmFyIHhodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIHhodG1sOiB4aHRtbCxcbiAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbn07XG4iLCJpbXBvcnQgc291cmNlRXZlbnQgZnJvbSBcIi4vc291cmNlRXZlbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQsIG5vZGUpIHtcbiAgZXZlbnQgPSBzb3VyY2VFdmVudChldmVudCk7XG4gIGlmIChub2RlID09PSB1bmRlZmluZWQpIG5vZGUgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBpZiAobm9kZSkge1xuICAgIHZhciBzdmcgPSBub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBub2RlO1xuICAgIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgcG9pbnQueCA9IGV2ZW50LmNsaWVudFgsIHBvaW50LnkgPSBldmVudC5jbGllbnRZO1xuICAgICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0obm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgICB9XG4gICAgaWYgKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gW2V2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSBub2RlLmNsaWVudExlZnQsIGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCAtIG5vZGUuY2xpZW50VG9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtldmVudC5wYWdlWCwgZXZlbnQucGFnZVldO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb24sIHJvb3R9IGZyb20gXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKV1dLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbW3NlbGVjdG9yXV0sIHJvb3QpO1xufVxuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4uL2NyZWF0b3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9KTtcbn1cbiIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSBcIi4uL25hbWVzcGFjZS5qc1wiO1xuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHYpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICByZXR1cm4gZnVsbG5hbWUubG9jYWxcbiAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbClcbiAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZShmdWxsbmFtZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkpKShmdWxsbmFtZSwgdmFsdWUpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gIGFyZ3VtZW50c1swXSA9IHRoaXM7XG4gIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZnVuY3Rpb24gY2xhc3NBcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy50cmltKCkuc3BsaXQoL158XFxzKy8pO1xufVxuXG5mdW5jdGlvbiBjbGFzc0xpc3Qobm9kZSkge1xuICByZXR1cm4gbm9kZS5jbGFzc0xpc3QgfHwgbmV3IENsYXNzTGlzdChub2RlKTtcbn1cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KG5vZGUpIHtcbiAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gIHRoaXMuX25hbWVzID0gY2xhc3NBcnJheShub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xufVxuXG5DbGFzc0xpc3QucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fbmFtZXMuc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICBjb250YWluczogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpID49IDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNsYXNzZWRBZGQobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QuYWRkKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFJlbW92ZShub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5yZW1vdmUobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkVHJ1ZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZEFkZCh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGYWxzZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZFJlbW92ZSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGdW5jdGlvbihuYW1lcywgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICh2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gY2xhc3NlZEFkZCA6IGNsYXNzZWRSZW1vdmUpKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIG5hbWVzID0gY2xhc3NBcnJheShuYW1lICsgXCJcIik7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIGxpc3QgPSBjbGFzc0xpc3QodGhpcy5ub2RlKCkpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICghbGlzdC5jb250YWlucyhuYW1lc1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGNsYXNzZWRGdW5jdGlvbiA6IHZhbHVlXG4gICAgICA/IGNsYXNzZWRUcnVlXG4gICAgICA6IGNsYXNzZWRGYWxzZSkobmFtZXMsIHZhbHVlKSk7XG59XG4iLCJmdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KCkge1xuICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lTm9kZShmYWxzZSksIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dFNpYmxpbmcpIDogY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZURlZXAoKSB7XG4gIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKHRydWUpLCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzLm5leHRTaWJsaW5nKSA6IGNsb25lO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWVwKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChkZWVwID8gc2VsZWN0aW9uX2Nsb25lRGVlcCA6IHNlbGVjdGlvbl9jbG9uZVNoYWxsb3cpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQge0VudGVyTm9kZX0gZnJvbSBcIi4vZW50ZXIuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi4vY29uc3RhbnQuanNcIjtcblxuZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgbm9kZSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBmaXQgaW50byB1cGRhdGUuXG4gIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAvLyBQdXQgYW55IHJlbWFpbmluZyBkYXRhIGludG8gZW50ZXIuXG4gIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZG9u4oCZdCBmaXQgaW50byBleGl0LlxuICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEtleShwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhLCBrZXkpIHtcbiAgdmFyIGksXG4gICAgICBub2RlLFxuICAgICAgbm9kZUJ5S2V5VmFsdWUgPSBuZXcgTWFwLFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICBrZXlWYWx1ZXMgPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpLFxuICAgICAga2V5VmFsdWU7XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIG5vZGUuXG4gIC8vIElmIG11bHRpcGxlIG5vZGVzIGhhdmUgdGhlIHNhbWUga2V5LCB0aGUgZHVwbGljYXRlcyBhcmUgYWRkZWQgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBrZXlWYWx1ZXNbaV0gPSBrZXlWYWx1ZSA9IGtleS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSArIFwiXCI7XG4gICAgICBpZiAobm9kZUJ5S2V5VmFsdWUuaGFzKGtleVZhbHVlKSkge1xuICAgICAgICBleGl0W2ldID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVCeUtleVZhbHVlLnNldChrZXlWYWx1ZSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIGRhdHVtLlxuICAvLyBJZiB0aGVyZSBhIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5LCBqb2luIGFuZCBhZGQgaXQgdG8gdXBkYXRlLlxuICAvLyBJZiB0aGVyZSBpcyBub3QgKG9yIHRoZSBrZXkgaXMgYSBkdXBsaWNhdGUpLCBhZGQgaXQgdG8gZW50ZXIuXG4gIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBrZXlWYWx1ZSA9IGtleS5jYWxsKHBhcmVudCwgZGF0YVtpXSwgaSwgZGF0YSkgKyBcIlwiO1xuICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWUuZ2V0KGtleVZhbHVlKSkge1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgbm9kZUJ5S2V5VmFsdWUuZGVsZXRlKGtleVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGFueSByZW1haW5pbmcgbm9kZXMgdGhhdCB3ZXJlIG5vdCBib3VuZCB0byBkYXRhIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWVzW2ldKSA9PT0gbm9kZSkpIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkYXR1bShub2RlKSB7XG4gIHJldHVybiBub2RlLl9fZGF0YV9fO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIEFycmF5LmZyb20odGhpcywgZGF0dW0pO1xuXG4gIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgIHBhcmVudHMgPSB0aGlzLl9wYXJlbnRzLFxuICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCh2YWx1ZSk7XG5cbiAgZm9yICh2YXIgbSA9IGdyb3Vwcy5sZW5ndGgsIHVwZGF0ZSA9IG5ldyBBcnJheShtKSwgZW50ZXIgPSBuZXcgQXJyYXkobSksIGV4aXQgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHNbal0sXG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2pdLFxuICAgICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgICAgZGF0YSA9IGFycmF5bGlrZSh2YWx1ZS5jYWxsKHBhcmVudCwgcGFyZW50ICYmIHBhcmVudC5fX2RhdGFfXywgaiwgcGFyZW50cykpLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGVudGVyR3JvdXAgPSBlbnRlcltqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgdXBkYXRlR3JvdXAgPSB1cGRhdGVbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIGV4aXRHcm91cCA9IGV4aXRbal0gPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpO1xuXG4gICAgYmluZChwYXJlbnQsIGdyb3VwLCBlbnRlckdyb3VwLCB1cGRhdGVHcm91cCwgZXhpdEdyb3VwLCBkYXRhLCBrZXkpO1xuXG4gICAgLy8gTm93IGNvbm5lY3QgdGhlIGVudGVyIG5vZGVzIHRvIHRoZWlyIGZvbGxvd2luZyB1cGRhdGUgbm9kZSwgc3VjaCB0aGF0XG4gICAgLy8gYXBwZW5kQ2hpbGQgY2FuIGluc2VydCB0aGUgbWF0ZXJpYWxpemVkIGVudGVyIG5vZGUgYmVmb3JlIHRoaXMgbm9kZSxcbiAgICAvLyByYXRoZXIgdGhhbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQgbm9kZS5cbiAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMCwgcHJldmlvdXMsIG5leHQ7IGkwIDwgZGF0YUxlbmd0aDsgKytpMCkge1xuICAgICAgaWYgKHByZXZpb3VzID0gZW50ZXJHcm91cFtpMF0pIHtcbiAgICAgICAgaWYgKGkwID49IGkxKSBpMSA9IGkwICsgMTtcbiAgICAgICAgd2hpbGUgKCEobmV4dCA9IHVwZGF0ZUdyb3VwW2kxXSkgJiYgKytpMSA8IGRhdGFMZW5ndGgpO1xuICAgICAgICBwcmV2aW91cy5fbmV4dCA9IG5leHQgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGUgPSBuZXcgU2VsZWN0aW9uKHVwZGF0ZSwgcGFyZW50cyk7XG4gIHVwZGF0ZS5fZW50ZXIgPSBlbnRlcjtcbiAgdXBkYXRlLl9leGl0ID0gZXhpdDtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuLy8gR2l2ZW4gc29tZSBkYXRhLCB0aGlzIHJldHVybnMgYW4gYXJyYXktbGlrZSB2aWV3IG9mIGl0OiBhbiBvYmplY3QgdGhhdFxuLy8gZXhwb3NlcyBhIGxlbmd0aCBwcm9wZXJ0eSBhbmQgYWxsb3dzIG51bWVyaWMgaW5kZXhpbmcuIE5vdGUgdGhhdCB1bmxpa2Vcbi8vIHNlbGVjdEFsbCwgdGhpcyBpc27igJl0IHdvcnJpZWQgYWJvdXQg4oCcbGl2ZeKAnSBjb2xsZWN0aW9ucyBiZWNhdXNlIHRoZSByZXN1bHRpbmdcbi8vIGFycmF5IHdpbGwgb25seSBiZSB1c2VkIGJyaWVmbHkgd2hpbGUgZGF0YSBpcyBiZWluZyBib3VuZC4gKEl0IGlzIHBvc3NpYmxlIHRvXG4vLyBjYXVzZSB0aGUgZGF0YSB0byBjaGFuZ2Ugd2hpbGUgaXRlcmF0aW5nIGJ5IHVzaW5nIGEga2V5IGZ1bmN0aW9uLCBidXQgcGxlYXNlXG4vLyBkb27igJl0OyB3ZeKAmWQgcmF0aGVyIGF2b2lkIGEgZ3JhdHVpdG91cyBjb3B5LilcbmZ1bmN0aW9uIGFycmF5bGlrZShkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBcImxlbmd0aFwiIGluIGRhdGFcbiAgICA/IGRhdGEgLy8gQXJyYXksIFR5cGVkQXJyYXksIE5vZGVMaXN0LCBhcnJheS1saWtlXG4gICAgOiBBcnJheS5mcm9tKGRhdGEpOyAvLyBNYXAsIFNldCwgaXRlcmFibGUsIHN0cmluZywgb3IgYW55dGhpbmcgZWxzZVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKVxuICAgICAgOiB0aGlzLm5vZGUoKS5fX2RhdGFfXztcbn1cbiIsImltcG9ydCBkZWZhdWx0VmlldyBmcm9tIFwiLi4vd2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQobm9kZSwgdHlwZSwgcGFyYW1zKSB7XG4gIHZhciB3aW5kb3cgPSBkZWZhdWx0Vmlldyhub2RlKSxcbiAgICAgIGV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuXG4gIGlmICh0eXBlb2YgZXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGV2ZW50ID0gbmV3IGV2ZW50KHR5cGUsIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBpZiAocGFyYW1zKSBldmVudC5pbml0RXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlKSwgZXZlbnQuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcbiAgICBlbHNlIGV2ZW50LmluaXRFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UpO1xuICB9XG5cbiAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hDb25zdGFudCh0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gZGlzcGF0Y2hGdW5jdGlvblxuICAgICAgOiBkaXNwYXRjaENvbnN0YW50KSh0eXBlLCBwYXJhbXMpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGNhbGxiYWNrLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5ub2RlKCk7XG59XG4iLCJpbXBvcnQgc3BhcnNlIGZyb20gXCIuL3NwYXJzZS5qc1wiO1xuaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9lbnRlciB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRW50ZXJOb2RlKHBhcmVudCwgZGF0dW0pIHtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHRoaXMubmFtZXNwYWNlVVJJID0gcGFyZW50Lm5hbWVzcGFjZVVSSTtcbiAgdGhpcy5fbmV4dCA9IG51bGw7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2RhdGFfXyA9IGRhdHVtO1xufVxuXG5FbnRlck5vZGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRW50ZXJOb2RlLFxuICBhcHBlbmRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHRoaXMuX25leHQpOyB9LFxuICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNoaWxkLCBuZXh0KSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTsgfSxcbiAgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTsgfSxcbiAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfVxufTtcbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlLmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2V4aXQgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IG1hdGNoZXIgZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJmdW5jdGlvbiBodG1sUmVtb3ZlKCkge1xuICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGh0bWxDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaHRtbEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IGh0bWxSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGh0bWxGdW5jdGlvblxuICAgICAgICAgIDogaHRtbENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLmlubmVySFRNTDtcbn1cbiIsImltcG9ydCBzZWxlY3Rpb25fc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3RBbGwgZnJvbSBcIi4vc2VsZWN0QWxsLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdENoaWxkIGZyb20gXCIuL3NlbGVjdENoaWxkLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdENoaWxkcmVuIGZyb20gXCIuL3NlbGVjdENoaWxkcmVuLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2ZpbHRlciBmcm9tIFwiLi9maWx0ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGF0YSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VudGVyIGZyb20gXCIuL2VudGVyLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2V4aXQgZnJvbSBcIi4vZXhpdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9qb2luIGZyb20gXCIuL2pvaW4uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbWVyZ2UgZnJvbSBcIi4vbWVyZ2UuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fb3JkZXIgZnJvbSBcIi4vb3JkZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc29ydCBmcm9tIFwiLi9zb3J0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2NhbGwgZnJvbSBcIi4vY2FsbC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9ub2RlcyBmcm9tIFwiLi9ub2Rlcy5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9ub2RlIGZyb20gXCIuL25vZGUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2l6ZSBmcm9tIFwiLi9zaXplLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VtcHR5IGZyb20gXCIuL2VtcHR5LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2VhY2ggZnJvbSBcIi4vZWFjaC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9hdHRyIGZyb20gXCIuL2F0dHIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc3R5bGUgZnJvbSBcIi4vc3R5bGUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcHJvcGVydHkgZnJvbSBcIi4vcHJvcGVydHkuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2xhc3NlZCBmcm9tIFwiLi9jbGFzc2VkLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3RleHQgZnJvbSBcIi4vdGV4dC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9odG1sIGZyb20gXCIuL2h0bWwuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmFpc2UgZnJvbSBcIi4vcmFpc2UuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fbG93ZXIgZnJvbSBcIi4vbG93ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fYXBwZW5kIGZyb20gXCIuL2FwcGVuZC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9pbnNlcnQgZnJvbSBcIi4vaW5zZXJ0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3JlbW92ZSBmcm9tIFwiLi9yZW1vdmUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2xvbmUgZnJvbSBcIi4vY2xvbmUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGF0dW0gZnJvbSBcIi4vZGF0dW0uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fb24gZnJvbSBcIi4vb24uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZGlzcGF0Y2ggZnJvbSBcIi4vZGlzcGF0Y2guanNcIjtcbmltcG9ydCBzZWxlY3Rpb25faXRlcmF0b3IgZnJvbSBcIi4vaXRlcmF0b3IuanNcIjtcblxuZXhwb3J0IHZhciByb290ID0gW251bGxdO1xuXG5leHBvcnQgZnVuY3Rpb24gU2VsZWN0aW9uKGdyb3VwcywgcGFyZW50cykge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XV0sIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc2VsZWN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn1cblxuU2VsZWN0aW9uLnByb3RvdHlwZSA9IHNlbGVjdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTZWxlY3Rpb24sXG4gIHNlbGVjdDogc2VsZWN0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiBzZWxlY3Rpb25fc2VsZWN0QWxsLFxuICBzZWxlY3RDaGlsZDogc2VsZWN0aW9uX3NlbGVjdENoaWxkLFxuICBzZWxlY3RDaGlsZHJlbjogc2VsZWN0aW9uX3NlbGVjdENoaWxkcmVuLFxuICBmaWx0ZXI6IHNlbGVjdGlvbl9maWx0ZXIsXG4gIGRhdGE6IHNlbGVjdGlvbl9kYXRhLFxuICBlbnRlcjogc2VsZWN0aW9uX2VudGVyLFxuICBleGl0OiBzZWxlY3Rpb25fZXhpdCxcbiAgam9pbjogc2VsZWN0aW9uX2pvaW4sXG4gIG1lcmdlOiBzZWxlY3Rpb25fbWVyZ2UsXG4gIHNlbGVjdGlvbjogc2VsZWN0aW9uX3NlbGVjdGlvbixcbiAgb3JkZXI6IHNlbGVjdGlvbl9vcmRlcixcbiAgc29ydDogc2VsZWN0aW9uX3NvcnQsXG4gIGNhbGw6IHNlbGVjdGlvbl9jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX25vZGVzLFxuICBub2RlOiBzZWxlY3Rpb25fbm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3NpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fZW1wdHksXG4gIGVhY2g6IHNlbGVjdGlvbl9lYWNoLFxuICBhdHRyOiBzZWxlY3Rpb25fYXR0cixcbiAgc3R5bGU6IHNlbGVjdGlvbl9zdHlsZSxcbiAgcHJvcGVydHk6IHNlbGVjdGlvbl9wcm9wZXJ0eSxcbiAgY2xhc3NlZDogc2VsZWN0aW9uX2NsYXNzZWQsXG4gIHRleHQ6IHNlbGVjdGlvbl90ZXh0LFxuICBodG1sOiBzZWxlY3Rpb25faHRtbCxcbiAgcmFpc2U6IHNlbGVjdGlvbl9yYWlzZSxcbiAgbG93ZXI6IHNlbGVjdGlvbl9sb3dlcixcbiAgYXBwZW5kOiBzZWxlY3Rpb25fYXBwZW5kLFxuICBpbnNlcnQ6IHNlbGVjdGlvbl9pbnNlcnQsXG4gIHJlbW92ZTogc2VsZWN0aW9uX3JlbW92ZSxcbiAgY2xvbmU6IHNlbGVjdGlvbl9jbG9uZSxcbiAgZGF0dW06IHNlbGVjdGlvbl9kYXR1bSxcbiAgb246IHNlbGVjdGlvbl9vbixcbiAgZGlzcGF0Y2g6IHNlbGVjdGlvbl9kaXNwYXRjaCxcbiAgW1N5bWJvbC5pdGVyYXRvcl06IHNlbGVjdGlvbl9pdGVyYXRvclxufTtcblxuZXhwb3J0IGRlZmF1bHQgc2VsZWN0aW9uO1xuIiwiaW1wb3J0IGNyZWF0b3IgZnJvbSBcIi4uL2NyZWF0b3IuanNcIjtcbmltcG9ydCBzZWxlY3RvciBmcm9tIFwiLi4vc2VsZWN0b3IuanNcIjtcblxuZnVuY3Rpb24gY29uc3RhbnROdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSksXG4gICAgICBzZWxlY3QgPSBiZWZvcmUgPT0gbnVsbCA/IGNvbnN0YW50TnVsbCA6IHR5cGVvZiBiZWZvcmUgPT09IFwiZnVuY3Rpb25cIiA/IGJlZm9yZSA6IHNlbGVjdG9yKGJlZm9yZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG51bGwpO1xuICB9KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKigpIHtcbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHlpZWxkIG5vZGU7XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvbmVudGVyLCBvbnVwZGF0ZSwgb25leGl0KSB7XG4gIHZhciBlbnRlciA9IHRoaXMuZW50ZXIoKSwgdXBkYXRlID0gdGhpcywgZXhpdCA9IHRoaXMuZXhpdCgpO1xuICBpZiAodHlwZW9mIG9uZW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGVudGVyID0gb25lbnRlcihlbnRlcik7XG4gICAgaWYgKGVudGVyKSBlbnRlciA9IGVudGVyLnNlbGVjdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIGVudGVyID0gZW50ZXIuYXBwZW5kKG9uZW50ZXIgKyBcIlwiKTtcbiAgfVxuICBpZiAob251cGRhdGUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZSA9IG9udXBkYXRlKHVwZGF0ZSk7XG4gICAgaWYgKHVwZGF0ZSkgdXBkYXRlID0gdXBkYXRlLnNlbGVjdGlvbigpO1xuICB9XG4gIGlmIChvbmV4aXQgPT0gbnVsbCkgZXhpdC5yZW1vdmUoKTsgZWxzZSBvbmV4aXQoZXhpdCk7XG4gIHJldHVybiBlbnRlciAmJiB1cGRhdGUgPyBlbnRlci5tZXJnZSh1cGRhdGUpLm9yZGVyKCkgOiB1cGRhdGU7XG59XG4iLCJmdW5jdGlvbiBsb3dlcigpIHtcbiAgaWYgKHRoaXMucHJldmlvdXNTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gobG93ZXIpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGNvbnRleHQuc2VsZWN0aW9uID8gY29udGV4dC5zZWxlY3Rpb24oKSA6IGNvbnRleHQ7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20odGhpcyk7XG59XG4iLCJmdW5jdGlvbiBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCwgdGhpcy5fX2RhdGFfXyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uUmVtb3ZlKHR5cGVuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb247XG4gICAgaWYgKCFvbikgcmV0dXJuO1xuICAgIGZvciAodmFyIGogPSAwLCBpID0gLTEsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGlmIChvID0gb25bal0sICghdHlwZW5hbWUudHlwZSB8fCBvLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUpICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLm9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25bKytpXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgrK2kpIG9uLmxlbmd0aCA9IGk7XG4gICAgZWxzZSBkZWxldGUgdGhpcy5fX29uO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkFkZCh0eXBlbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbiwgbywgbGlzdGVuZXIgPSBjb250ZXh0TGlzdGVuZXIodmFsdWUpO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgIGlmICgobyA9IG9uW2pdKS50eXBlID09PSB0eXBlbmFtZS50eXBlICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyID0gbGlzdGVuZXIsIG8ub3B0aW9ucyA9IG9wdGlvbnMpO1xuICAgICAgICBvLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGVuYW1lLnR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICBvID0ge3R5cGU6IHR5cGVuYW1lLnR5cGUsIG5hbWU6IHR5cGVuYW1lLm5hbWUsIHZhbHVlOiB2YWx1ZSwgbGlzdGVuZXI6IGxpc3RlbmVyLCBvcHRpb25zOiBvcHRpb25zfTtcbiAgICBpZiAoIW9uKSB0aGlzLl9fb24gPSBbb107XG4gICAgZWxzZSBvbi5wdXNoKG8pO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0eXBlbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHR5cGVuYW1lcyA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiksIGksIG4gPSB0eXBlbmFtZXMubGVuZ3RoLCB0O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBvbiA9IHRoaXMubm9kZSgpLl9fb247XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgZm9yIChpID0gMCwgbyA9IG9uW2pdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICgodCA9IHR5cGVuYW1lc1tpXSkudHlwZSA9PT0gby50eXBlICYmIHQubmFtZSA9PT0gby5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb24gPSB2YWx1ZSA/IG9uQWRkIDogb25SZW1vdmU7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBvcHRpb25zKSk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gLTEsIG0gPSBncm91cHMubGVuZ3RoOyArK2ogPCBtOykge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gZ3JvdXAubGVuZ3RoIC0gMSwgbmV4dCA9IGdyb3VwW2ldLCBub2RlOyAtLWkgPj0gMDspIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgaWYgKG5leHQgJiYgbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuZXh0KSBeIDQpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZnVuY3Rpb24gcHJvcGVydHlSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Q29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIGVsc2UgdGhpc1tuYW1lXSA9IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHByb3BlcnR5UmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHByb3BlcnR5RnVuY3Rpb25cbiAgICAgICAgICA6IHByb3BlcnR5Q29uc3RhbnQpKG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKClbbmFtZV07XG59XG4iLCJmdW5jdGlvbiByYWlzZSgpIHtcbiAgaWYgKHRoaXMubmV4dFNpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmFpc2UpO1xufVxuIiwiZnVuY3Rpb24gcmVtb3ZlKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJlbW92ZSk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzZWxlY3RvciBmcm9tIFwiLi4vc2VsZWN0b3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBhcnJheSBmcm9tIFwiLi4vYXJyYXkuanNcIjtcbmltcG9ydCBzZWxlY3RvckFsbCBmcm9tIFwiLi4vc2VsZWN0b3JBbGwuanNcIjtcblxuZnVuY3Rpb24gYXJyYXlBbGwoc2VsZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJyYXkoc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgPT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gYXJyYXlBbGwoc2VsZWN0KTtcbiAgZWxzZSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtjaGlsZE1hdGNoZXJ9IGZyb20gXCIuLi9tYXRjaGVyLmpzXCI7XG5cbnZhciBmaW5kID0gQXJyYXkucHJvdG90eXBlLmZpbmQ7XG5cbmZ1bmN0aW9uIGNoaWxkRmluZChtYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZpbmQuY2FsbCh0aGlzLmNoaWxkcmVuLCBtYXRjaCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoaWxkRmlyc3QoKSB7XG4gIHJldHVybiB0aGlzLmZpcnN0RWxlbWVudENoaWxkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3QobWF0Y2ggPT0gbnVsbCA/IGNoaWxkRmlyc3RcbiAgICAgIDogY2hpbGRGaW5kKHR5cGVvZiBtYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gbWF0Y2ggOiBjaGlsZE1hdGNoZXIobWF0Y2gpKSk7XG59XG4iLCJpbXBvcnQge2NoaWxkTWF0Y2hlcn0gZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxudmFyIGZpbHRlciA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXI7XG5cbmZ1bmN0aW9uIGNoaWxkcmVuKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gY2hpbGRyZW5GaWx0ZXIobWF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmaWx0ZXIuY2FsbCh0aGlzLmNoaWxkcmVuLCBtYXRjaCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdEFsbChtYXRjaCA9PSBudWxsID8gY2hpbGRyZW5cbiAgICAgIDogY2hpbGRyZW5GaWx0ZXIodHlwZW9mIG1hdGNoID09PSBcImZ1bmN0aW9uXCIgPyBtYXRjaCA6IGNoaWxkTWF0Y2hlcihtYXRjaCkpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICBsZXQgc2l6ZSA9IDA7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzKSArK3NpemU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuIHNpemU7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29tcGFyZSkge1xuICBpZiAoIWNvbXBhcmUpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgZnVuY3Rpb24gY29tcGFyZU5vZGUoYSwgYikge1xuICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJlKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHNvcnRncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHNvcnRncm91cCA9IHNvcnRncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHNvcnRncm91cFtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvcnRncm91cC5zb3J0KGNvbXBhcmVOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHNvcnRncm91cHMsIHRoaXMuX3BhcmVudHMpLm9yZGVyKCk7XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHVwZGF0ZSkge1xuICByZXR1cm4gbmV3IEFycmF5KHVwZGF0ZS5sZW5ndGgpO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3cuanNcIjtcblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVGdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2LCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IHN0eWxlUmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gc3R5bGVGdW5jdGlvblxuICAgICAgICAgICAgOiBzdHlsZUNvbnN0YW50KShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpXG4gICAgICA6IHN0eWxlVmFsdWUodGhpcy5ub2RlKCksIG5hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3R5bGVWYWx1ZShub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSlcbiAgICAgIHx8IGRlZmF1bHRWaWV3KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbn1cbiIsImZ1bmN0aW9uIHRleHRSZW1vdmUoKSB7XG4gIHRoaXMudGV4dENvbnRlbnQgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gdGV4dFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gdGV4dEZ1bmN0aW9uXG4gICAgICAgICAgOiB0ZXh0Q29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkudGV4dENvbnRlbnQ7XG59XG4iLCJmdW5jdGlvbiBub25lKCkge31cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBub25lIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG59XG4iLCJmdW5jdGlvbiBlbXB0eSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IGVtcHR5IDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCkge1xuICBsZXQgc291cmNlRXZlbnQ7XG4gIHdoaWxlIChzb3VyY2VFdmVudCA9IGV2ZW50LnNvdXJjZUV2ZW50KSBldmVudCA9IHNvdXJjZUV2ZW50O1xuICByZXR1cm4gZXZlbnQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlKSB7XG4gIHJldHVybiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgLy8gbm9kZSBpcyBhIE5vZGVcbiAgICAgIHx8IChub2RlLmRvY3VtZW50ICYmIG5vZGUpIC8vIG5vZGUgaXMgYSBXaW5kb3dcbiAgICAgIHx8IG5vZGUuZGVmYXVsdFZpZXc7IC8vIG5vZGUgaXMgYSBEb2N1bWVudFxufVxuIiwiaW1wb3J0IHtUaW1lcn0gZnJvbSBcIi4vdGltZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICBkZWxheSA9IGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5O1xuICB0LnJlc3RhcnQoZWxhcHNlZCA9PiB7XG4gICAgdC5zdG9wKCk7XG4gICAgY2FsbGJhY2soZWxhcHNlZCArIGRlbGF5KTtcbiAgfSwgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cbiIsInZhciBmcmFtZSA9IDAsIC8vIGlzIGFuIGFuaW1hdGlvbiBmcmFtZSBwZW5kaW5nP1xuICAgIHRpbWVvdXQgPSAwLCAvLyBpcyBhIHRpbWVvdXQgcGVuZGluZz9cbiAgICBpbnRlcnZhbCA9IDAsIC8vIGFyZSBhbnkgdGltZXJzIGFjdGl2ZT9cbiAgICBwb2tlRGVsYXkgPSAxMDAwLCAvLyBob3cgZnJlcXVlbnRseSB3ZSBjaGVjayBmb3IgY2xvY2sgc2tld1xuICAgIHRhc2tIZWFkLFxuICAgIHRhc2tUYWlsLFxuICAgIGNsb2NrTGFzdCA9IDAsXG4gICAgY2xvY2tOb3cgPSAwLFxuICAgIGNsb2NrU2tldyA9IDAsXG4gICAgY2xvY2sgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwib2JqZWN0XCIgJiYgcGVyZm9ybWFuY2Uubm93ID8gcGVyZm9ybWFuY2UgOiBEYXRlLFxuICAgIHNldEZyYW1lID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgOiBmdW5jdGlvbihmKSB7IHNldFRpbWVvdXQoZiwgMTcpOyB9O1xuXG5leHBvcnQgZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gY2xvY2tOb3cgfHwgKHNldEZyYW1lKGNsZWFyTm93KSwgY2xvY2tOb3cgPSBjbG9jay5ub3coKSArIGNsb2NrU2tldyk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyTm93KCkge1xuICBjbG9ja05vdyA9IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBUaW1lcigpIHtcbiAgdGhpcy5fY2FsbCA9XG4gIHRoaXMuX3RpbWUgPVxuICB0aGlzLl9uZXh0ID0gbnVsbDtcbn1cblxuVGltZXIucHJvdG90eXBlID0gdGltZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVGltZXIsXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIHRpbWUgPSAodGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZSkgKyAoZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXkpO1xuICAgIGlmICghdGhpcy5fbmV4dCAmJiB0YXNrVGFpbCAhPT0gdGhpcykge1xuICAgICAgaWYgKHRhc2tUYWlsKSB0YXNrVGFpbC5fbmV4dCA9IHRoaXM7XG4gICAgICBlbHNlIHRhc2tIZWFkID0gdGhpcztcbiAgICAgIHRhc2tUYWlsID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fY2FsbCA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHNsZWVwKCk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jYWxsKSB7XG4gICAgICB0aGlzLl9jYWxsID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWUgPSBJbmZpbml0eTtcbiAgICAgIHNsZWVwKCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGltZXIoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lckZsdXNoKCkge1xuICBub3coKTsgLy8gR2V0IHRoZSBjdXJyZW50IHRpbWUsIGlmIG5vdCBhbHJlYWR5IHNldC5cbiAgKytmcmFtZTsgLy8gUHJldGVuZCB3ZeKAmXZlIHNldCBhbiBhbGFybSwgaWYgd2UgaGF2ZW7igJl0IGFscmVhZHkuXG4gIHZhciB0ID0gdGFza0hlYWQsIGU7XG4gIHdoaWxlICh0KSB7XG4gICAgaWYgKChlID0gY2xvY2tOb3cgLSB0Ll90aW1lKSA+PSAwKSB0Ll9jYWxsLmNhbGwodW5kZWZpbmVkLCBlKTtcbiAgICB0ID0gdC5fbmV4dDtcbiAgfVxuICAtLWZyYW1lO1xufVxuXG5mdW5jdGlvbiB3YWtlKCkge1xuICBjbG9ja05vdyA9IChjbG9ja0xhc3QgPSBjbG9jay5ub3coKSkgKyBjbG9ja1NrZXc7XG4gIGZyYW1lID0gdGltZW91dCA9IDA7XG4gIHRyeSB7XG4gICAgdGltZXJGbHVzaCgpO1xuICB9IGZpbmFsbHkge1xuICAgIGZyYW1lID0gMDtcbiAgICBuYXAoKTtcbiAgICBjbG9ja05vdyA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9rZSgpIHtcbiAgdmFyIG5vdyA9IGNsb2NrLm5vdygpLCBkZWxheSA9IG5vdyAtIGNsb2NrTGFzdDtcbiAgaWYgKGRlbGF5ID4gcG9rZURlbGF5KSBjbG9ja1NrZXcgLT0gZGVsYXksIGNsb2NrTGFzdCA9IG5vdztcbn1cblxuZnVuY3Rpb24gbmFwKCkge1xuICB2YXIgdDAsIHQxID0gdGFza0hlYWQsIHQyLCB0aW1lID0gSW5maW5pdHk7XG4gIHdoaWxlICh0MSkge1xuICAgIGlmICh0MS5fY2FsbCkge1xuICAgICAgaWYgKHRpbWUgPiB0MS5fdGltZSkgdGltZSA9IHQxLl90aW1lO1xuICAgICAgdDAgPSB0MSwgdDEgPSB0MS5fbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDIgPSB0MS5fbmV4dCwgdDEuX25leHQgPSBudWxsO1xuICAgICAgdDEgPSB0MCA/IHQwLl9uZXh0ID0gdDIgOiB0YXNrSGVhZCA9IHQyO1xuICAgIH1cbiAgfVxuICB0YXNrVGFpbCA9IHQwO1xuICBzbGVlcCh0aW1lKTtcbn1cblxuZnVuY3Rpb24gc2xlZXAodGltZSkge1xuICBpZiAoZnJhbWUpIHJldHVybjsgLy8gU29vbmVzdCBhbGFybSBhbHJlYWR5IHNldCwgb3Igd2lsbCBiZS5cbiAgaWYgKHRpbWVvdXQpIHRpbWVvdXQgPSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gIHZhciBkZWxheSA9IHRpbWUgLSBjbG9ja05vdzsgLy8gU3RyaWN0bHkgbGVzcyB0aGFuIGlmIHdlIHJlY29tcHV0ZWQgY2xvY2tOb3cuXG4gIGlmIChkZWxheSA+IDI0KSB7XG4gICAgaWYgKHRpbWUgPCBJbmZpbml0eSkgdGltZW91dCA9IHNldFRpbWVvdXQod2FrZSwgdGltZSAtIGNsb2NrLm5vdygpIC0gY2xvY2tTa2V3KTtcbiAgICBpZiAoaW50ZXJ2YWwpIGludGVydmFsID0gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnRlcnZhbCkgY2xvY2tMYXN0ID0gY2xvY2subm93KCksIGludGVydmFsID0gc2V0SW50ZXJ2YWwocG9rZSwgcG9rZURlbGF5KTtcbiAgICBmcmFtZSA9IDEsIHNldEZyYW1lKHdha2UpO1xuICB9XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmltcG9ydCB7U0NIRURVTEVEfSBmcm9tIFwiLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5cbnZhciByb290ID0gW251bGxdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlLFxuICAgICAgaTtcblxuICBpZiAoc2NoZWR1bGVzKSB7XG4gICAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICBpZiAoKHNjaGVkdWxlID0gc2NoZWR1bGVzW2ldKS5zdGF0ZSA+IFNDSEVEVUxFRCAmJiBzY2hlZHVsZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNpdGlvbihbW25vZGVdXSwgcm9vdCwgbmFtZSwgK2kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IFwiLi9zZWxlY3Rpb24vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0cmFuc2l0aW9ufSBmcm9tIFwiLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYWN0aXZlfSBmcm9tIFwiLi9hY3RpdmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnJ1cHR9IGZyb20gXCIuL2ludGVycnVwdC5qc1wiO1xuIiwiaW1wb3J0IHtTVEFSVElORywgRU5ESU5HLCBFTkRFRH0gZnJvbSBcIi4vdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlLFxuICAgICAgYWN0aXZlLFxuICAgICAgZW1wdHkgPSB0cnVlLFxuICAgICAgaTtcblxuICBpZiAoIXNjaGVkdWxlcykgcmV0dXJuO1xuXG4gIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG5cbiAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgIGlmICgoc2NoZWR1bGUgPSBzY2hlZHVsZXNbaV0pLm5hbWUgIT09IG5hbWUpIHsgZW1wdHkgPSBmYWxzZTsgY29udGludWU7IH1cbiAgICBhY3RpdmUgPSBzY2hlZHVsZS5zdGF0ZSA+IFNUQVJUSU5HICYmIHNjaGVkdWxlLnN0YXRlIDwgRU5ESU5HO1xuICAgIHNjaGVkdWxlLnN0YXRlID0gRU5ERUQ7XG4gICAgc2NoZWR1bGUudGltZXIuc3RvcCgpO1xuICAgIHNjaGVkdWxlLm9uLmNhbGwoYWN0aXZlID8gXCJpbnRlcnJ1cHRcIiA6IFwiY2FuY2VsXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNjaGVkdWxlLmluZGV4LCBzY2hlZHVsZS5ncm91cCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgfVxuXG4gIGlmIChlbXB0eSkgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xufVxuIiwiaW1wb3J0IHtzZWxlY3Rpb259IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCBzZWxlY3Rpb25faW50ZXJydXB0IGZyb20gXCIuL2ludGVycnVwdC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl90cmFuc2l0aW9uIGZyb20gXCIuL3RyYW5zaXRpb24uanNcIjtcblxuc2VsZWN0aW9uLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBzZWxlY3Rpb25faW50ZXJydXB0O1xuc2VsZWN0aW9uLnByb3RvdHlwZS50cmFuc2l0aW9uID0gc2VsZWN0aW9uX3RyYW5zaXRpb247XG4iLCJpbXBvcnQgaW50ZXJydXB0IGZyb20gXCIuLi9pbnRlcnJ1cHQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIGludGVycnVwdCh0aGlzLCBuYW1lKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb24sIG5ld0lkfSBmcm9tIFwiLi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlIGZyb20gXCIuLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5pbXBvcnQge2Vhc2VDdWJpY0luT3V0fSBmcm9tIFwiZDMtZWFzZVwiO1xuaW1wb3J0IHtub3d9IGZyb20gXCJkMy10aW1lclwiO1xuXG52YXIgZGVmYXVsdFRpbWluZyA9IHtcbiAgdGltZTogbnVsbCwgLy8gU2V0IG9uIHVzZS5cbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiAyNTAsXG4gIGVhc2U6IGVhc2VDdWJpY0luT3V0XG59O1xuXG5mdW5jdGlvbiBpbmhlcml0KG5vZGUsIGlkKSB7XG4gIHZhciB0aW1pbmc7XG4gIHdoaWxlICghKHRpbWluZyA9IG5vZGUuX190cmFuc2l0aW9uKSB8fCAhKHRpbWluZyA9IHRpbWluZ1tpZF0pKSB7XG4gICAgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHJhbnNpdGlvbiAke2lkfSBub3QgZm91bmRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpbWluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgaWQsXG4gICAgICB0aW1pbmc7XG5cbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG4gICAgaWQgPSBuYW1lLl9pZCwgbmFtZSA9IG5hbWUuX25hbWU7XG4gIH0gZWxzZSB7XG4gICAgaWQgPSBuZXdJZCgpLCAodGltaW5nID0gZGVmYXVsdFRpbWluZykudGltZSA9IG5vdygpLCBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQsIGksIGdyb3VwLCB0aW1pbmcgfHwgaW5oZXJpdChub2RlLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkKTtcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgYXMgaW50ZXJwb2xhdGVUcmFuc2Zvcm19IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtuYW1lc3BhY2V9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcbmltcG9ydCBpbnRlcnBvbGF0ZSBmcm9tIFwiLi9pbnRlcnBvbGF0ZS5qc1wiO1xuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpLCBzdHJpbmcxO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSwgc3RyaW5nMTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpLCBpID0gZnVsbG5hbWUgPT09IFwidHJhbnNmb3JtXCIgPyBpbnRlcnBvbGF0ZVRyYW5zZm9ybSA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdGhpcy5hdHRyVHdlZW4obmFtZSwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pKGZ1bGxuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwiYXR0ci5cIiArIG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdmFsdWUgPT0gbnVsbCA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpKGZ1bGxuYW1lKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkoZnVsbG5hbWUsIGksIHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge25hbWVzcGFjZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuXG5mdW5jdGlvbiBhdHRySW50ZXJwb2xhdGUobmFtZSwgaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGkuY2FsbCh0aGlzLCB0KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJJbnRlcnBvbGF0ZU5TKGZ1bGxuYW1lLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIGkuY2FsbCh0aGlzLCB0KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIGF0dHJJbnRlcnBvbGF0ZU5TKGZ1bGxuYW1lLCBpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZnVuY3Rpb24gYXR0clR3ZWVuKG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgYXR0ckludGVycG9sYXRlKG5hbWUsIGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIga2V5ID0gXCJhdHRyLlwiICsgbmFtZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgKGZ1bGxuYW1lLmxvY2FsID8gYXR0clR3ZWVuTlMgOiBhdHRyVHdlZW4pKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtnZXQsIGluaXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIGRlbGF5RnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWxheUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGRlbGF5RnVuY3Rpb25cbiAgICAgICAgICA6IGRlbGF5Q29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmRlbGF5O1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZHVyYXRpb25GdW5jdGlvbihpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZHVyYXRpb24gPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Db25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmR1cmF0aW9uID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGR1cmF0aW9uRnVuY3Rpb25cbiAgICAgICAgICA6IGR1cmF0aW9uQ29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmR1cmF0aW9uO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZWFzZSA9IHZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmVhc2U7XG59XG4iLCJpbXBvcnQge3NldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZWFzZVZhcnlpbmcoaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHR5cGVvZiB2ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgICBzZXQodGhpcywgaWQpLmVhc2UgPSB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMuZWFjaChlYXNlVmFyeWluZyh0aGlzLl9pZCwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG9uMCwgb24xLCB0aGF0ID0gdGhpcywgaWQgPSB0aGF0Ll9pZCwgc2l6ZSA9IHRoYXQuc2l6ZSgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGNhbmNlbCA9IHt2YWx1ZTogcmVqZWN0fSxcbiAgICAgICAgZW5kID0ge3ZhbHVlOiBmdW5jdGlvbigpIHsgaWYgKC0tc2l6ZSA9PT0gMCkgcmVzb2x2ZSgpOyB9fTtcblxuICAgIHRoYXQuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgICAgb24gPSBzY2hlZHVsZS5vbjtcblxuICAgICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICAgIGlmIChvbiAhPT0gb24wKSB7XG4gICAgICAgIG9uMSA9IChvbjAgPSBvbikuY29weSgpO1xuICAgICAgICBvbjEuXy5jYW5jZWwucHVzaChjYW5jZWwpO1xuICAgICAgICBvbjEuXy5pbnRlcnJ1cHQucHVzaChjYW5jZWwpO1xuICAgICAgICBvbjEuXy5lbmQucHVzaChlbmQpO1xuICAgICAgfVxuXG4gICAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBzZWxlY3Rpb24gd2FzIGVtcHR5LCByZXNvbHZlIGVuZCBpbW1lZGlhdGVseVxuICAgIGlmIChzaXplID09PSAwKSByZXNvbHZlKCk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHttYXRjaGVyfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBtYXRjaGVyKG1hdGNoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCB0aGlzLl9uYW1lLCB0aGlzLl9pZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHRyYW5zaXRpb25fYXR0ciBmcm9tIFwiLi9hdHRyLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9hdHRyVHdlZW4gZnJvbSBcIi4vYXR0clR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9kZWxheSBmcm9tIFwiLi9kZWxheS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2Vhc2UgZnJvbSBcIi4vZWFzZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZWFzZVZhcnlpbmcgZnJvbSBcIi4vZWFzZVZhcnlpbmcuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2ZpbHRlciBmcm9tIFwiLi9maWx0ZXIuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX21lcmdlIGZyb20gXCIuL21lcmdlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9vbiBmcm9tIFwiLi9vbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0IGZyb20gXCIuL3NlbGVjdC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0QWxsIGZyb20gXCIuL3NlbGVjdEFsbC5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc2VsZWN0aW9uIGZyb20gXCIuL3NlbGVjdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc3R5bGUgZnJvbSBcIi4vc3R5bGUuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3N0eWxlVHdlZW4gZnJvbSBcIi4vc3R5bGVUd2Vlbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90ZXh0VHdlZW4gZnJvbSBcIi4vdGV4dFR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90cmFuc2l0aW9uIGZyb20gXCIuL3RyYW5zaXRpb24uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3R3ZWVuIGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lbmQgZnJvbSBcIi4vZW5kLmpzXCI7XG5cbnZhciBpZCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2l0aW9uKGdyb3VwcywgcGFyZW50cywgbmFtZSwgaWQpIHtcbiAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xuICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX2lkID0gaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zaXRpb24obmFtZSkge1xuICByZXR1cm4gc2VsZWN0aW9uKCkudHJhbnNpdGlvbihuYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0lkKCkge1xuICByZXR1cm4gKytpZDtcbn1cblxudmFyIHNlbGVjdGlvbl9wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlO1xuXG5UcmFuc2l0aW9uLnByb3RvdHlwZSA9IHRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNpdGlvbixcbiAgc2VsZWN0OiB0cmFuc2l0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiB0cmFuc2l0aW9uX3NlbGVjdEFsbCxcbiAgc2VsZWN0Q2hpbGQ6IHNlbGVjdGlvbl9wcm90b3R5cGUuc2VsZWN0Q2hpbGQsXG4gIHNlbGVjdENoaWxkcmVuOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNlbGVjdENoaWxkcmVuLFxuICBmaWx0ZXI6IHRyYW5zaXRpb25fZmlsdGVyLFxuICBtZXJnZTogdHJhbnNpdGlvbl9tZXJnZSxcbiAgc2VsZWN0aW9uOiB0cmFuc2l0aW9uX3NlbGVjdGlvbixcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbl90cmFuc2l0aW9uLFxuICBjYWxsOiBzZWxlY3Rpb25fcHJvdG90eXBlLmNhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fcHJvdG90eXBlLm5vZGVzLFxuICBub2RlOiBzZWxlY3Rpb25fcHJvdG90eXBlLm5vZGUsXG4gIHNpemU6IHNlbGVjdGlvbl9wcm90b3R5cGUuc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9wcm90b3R5cGUuZW1wdHksXG4gIGVhY2g6IHNlbGVjdGlvbl9wcm90b3R5cGUuZWFjaCxcbiAgb246IHRyYW5zaXRpb25fb24sXG4gIGF0dHI6IHRyYW5zaXRpb25fYXR0cixcbiAgYXR0clR3ZWVuOiB0cmFuc2l0aW9uX2F0dHJUd2VlbixcbiAgc3R5bGU6IHRyYW5zaXRpb25fc3R5bGUsXG4gIHN0eWxlVHdlZW46IHRyYW5zaXRpb25fc3R5bGVUd2VlbixcbiAgdGV4dDogdHJhbnNpdGlvbl90ZXh0LFxuICB0ZXh0VHdlZW46IHRyYW5zaXRpb25fdGV4dFR3ZWVuLFxuICByZW1vdmU6IHRyYW5zaXRpb25fcmVtb3ZlLFxuICB0d2VlbjogdHJhbnNpdGlvbl90d2VlbixcbiAgZGVsYXk6IHRyYW5zaXRpb25fZGVsYXksXG4gIGR1cmF0aW9uOiB0cmFuc2l0aW9uX2R1cmF0aW9uLFxuICBlYXNlOiB0cmFuc2l0aW9uX2Vhc2UsXG4gIGVhc2VWYXJ5aW5nOiB0cmFuc2l0aW9uX2Vhc2VWYXJ5aW5nLFxuICBlbmQ6IHRyYW5zaXRpb25fZW5kLFxuICBbU3ltYm9sLml0ZXJhdG9yXTogc2VsZWN0aW9uX3Byb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdXG59O1xuIiwiaW1wb3J0IHtjb2xvcn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQge2ludGVycG9sYXRlTnVtYmVyLCBpbnRlcnBvbGF0ZVJnYiwgaW50ZXJwb2xhdGVTdHJpbmd9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBjO1xuICByZXR1cm4gKHR5cGVvZiBiID09PSBcIm51bWJlclwiID8gaW50ZXJwb2xhdGVOdW1iZXJcbiAgICAgIDogYiBpbnN0YW5jZW9mIGNvbG9yID8gaW50ZXJwb2xhdGVSZ2JcbiAgICAgIDogKGMgPSBjb2xvcihiKSkgPyAoYiA9IGMsIGludGVycG9sYXRlUmdiKVxuICAgICAgOiBpbnRlcnBvbGF0ZVN0cmluZykoYSwgYik7XG59XG4iLCJpbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcbiAgaWYgKHRyYW5zaXRpb24uX2lkICE9PSB0aGlzLl9pZCkgdGhyb3cgbmV3IEVycm9yO1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSB0cmFuc2l0aW9uLl9ncm91cHMsIG0wID0gZ3JvdXBzMC5sZW5ndGgsIG0xID0gZ3JvdXBzMS5sZW5ndGgsIG0gPSBNYXRoLm1pbihtMCwgbTEpLCBtZXJnZXMgPSBuZXcgQXJyYXkobTApLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICBtZXJnZVtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cbiIsImltcG9ydCB7Z2V0LCBzZXQsIGluaXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmZ1bmN0aW9uIHN0YXJ0KG5hbWUpIHtcbiAgcmV0dXJuIChuYW1lICsgXCJcIikudHJpbSgpLnNwbGl0KC9efFxccysvKS5ldmVyeShmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiAhdCB8fCB0ID09PSBcInN0YXJ0XCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgb24wLCBvbjEsIHNpdCA9IHN0YXJ0KG5hbWUpID8gaW5pdCA6IHNldDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNpdCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub247XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjApIChvbjEgPSAob24wID0gb24pLmNvcHkoKSkub24obmFtZSwgbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMlxuICAgICAgPyBnZXQodGhpcy5ub2RlKCksIGlkKS5vbi5vbihuYW1lKVxuICAgICAgOiB0aGlzLmVhY2gob25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpKTtcbn1cbiIsImZ1bmN0aW9uIHJlbW92ZUZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5fX3RyYW5zaXRpb24pIGlmICgraSAhPT0gaWQpIHJldHVybjtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vbihcImVuZC5yZW1vdmVcIiwgcmVtb3ZlRnVuY3Rpb24odGhpcy5faWQpKTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHt0aW1lciwgdGltZW91dH0gZnJvbSBcImQzLXRpbWVyXCI7XG5cbnZhciBlbXB0eU9uID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcImVuZFwiLCBcImNhbmNlbFwiLCBcImludGVycnVwdFwiKTtcbnZhciBlbXB0eVR3ZWVuID0gW107XG5cbmV4cG9ydCB2YXIgQ1JFQVRFRCA9IDA7XG5leHBvcnQgdmFyIFNDSEVEVUxFRCA9IDE7XG5leHBvcnQgdmFyIFNUQVJUSU5HID0gMjtcbmV4cG9ydCB2YXIgU1RBUlRFRCA9IDM7XG5leHBvcnQgdmFyIFJVTk5JTkcgPSA0O1xuZXhwb3J0IHZhciBFTkRJTkcgPSA1O1xuZXhwb3J0IHZhciBFTkRFRCA9IDY7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUsIGlkLCBpbmRleCwgZ3JvdXAsIHRpbWluZykge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb247XG4gIGlmICghc2NoZWR1bGVzKSBub2RlLl9fdHJhbnNpdGlvbiA9IHt9O1xuICBlbHNlIGlmIChpZCBpbiBzY2hlZHVsZXMpIHJldHVybjtcbiAgY3JlYXRlKG5vZGUsIGlkLCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBpbmRleDogaW5kZXgsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBncm91cDogZ3JvdXAsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBvbjogZW1wdHlPbixcbiAgICB0d2VlbjogZW1wdHlUd2VlbixcbiAgICB0aW1lOiB0aW1pbmcudGltZSxcbiAgICBkZWxheTogdGltaW5nLmRlbGF5LFxuICAgIGR1cmF0aW9uOiB0aW1pbmcuZHVyYXRpb24sXG4gICAgZWFzZTogdGltaW5nLmVhc2UsXG4gICAgdGltZXI6IG51bGwsXG4gICAgc3RhdGU6IENSRUFURURcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IENSRUFURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHNjaGVkdWxlZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IFNUQVJURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZSB8fCAhKHNjaGVkdWxlID0gc2NoZWR1bGVbaWRdKSkgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNpdGlvbiBub3QgZm91bmRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG5vZGUsIGlkLCBzZWxmKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHR3ZWVuO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHNlbGYgdGltZXIgd2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLlxuICAvLyBOb3RlIHRoZSBhY3R1YWwgZGVsYXkgaXMgbm90IGtub3duIHVudGlsIHRoZSBmaXJzdCBjYWxsYmFjayFcbiAgc2NoZWR1bGVzW2lkXSA9IHNlbGY7XG4gIHNlbGYudGltZXIgPSB0aW1lcihzY2hlZHVsZSwgMCwgc2VsZi50aW1lKTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZShlbGFwc2VkKSB7XG4gICAgc2VsZi5zdGF0ZSA9IFNDSEVEVUxFRDtcbiAgICBzZWxmLnRpbWVyLnJlc3RhcnQoc3RhcnQsIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG5cbiAgICAvLyBJZiB0aGUgZWxhcHNlZCBkZWxheSBpcyBsZXNzIHRoYW4gb3VyIGZpcnN0IHNsZWVwLCBzdGFydCBpbW1lZGlhdGVseS5cbiAgICBpZiAoc2VsZi5kZWxheSA8PSBlbGFwc2VkKSBzdGFydChlbGFwc2VkIC0gc2VsZi5kZWxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydChlbGFwc2VkKSB7XG4gICAgdmFyIGksIGosIG4sIG87XG5cbiAgICAvLyBJZiB0aGUgc3RhdGUgaXMgbm90IFNDSEVEVUxFRCwgdGhlbiB3ZSBwcmV2aW91c2x5IGVycm9yZWQgb24gc3RhcnQuXG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNDSEVEVUxFRCkgcmV0dXJuIHN0b3AoKTtcblxuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIG8gPSBzY2hlZHVsZXNbaV07XG4gICAgICBpZiAoby5uYW1lICE9PSBzZWxmLm5hbWUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBXaGlsZSB0aGlzIGVsZW1lbnQgYWxyZWFkeSBoYXMgYSBzdGFydGluZyB0cmFuc2l0aW9uIGR1cmluZyB0aGlzIGZyYW1lLFxuICAgICAgLy8gZGVmZXIgc3RhcnRpbmcgYW4gaW50ZXJydXB0aW5nIHRyYW5zaXRpb24gdW50aWwgdGhhdCB0cmFuc2l0aW9uIGhhcyBhXG4gICAgICAvLyBjaGFuY2UgdG8gdGljayAoYW5kIHBvc3NpYmx5IGVuZCk7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzU0IVxuICAgICAgaWYgKG8uc3RhdGUgPT09IFNUQVJURUQpIHJldHVybiB0aW1lb3V0KHN0YXJ0KTtcblxuICAgICAgLy8gSW50ZXJydXB0IHRoZSBhY3RpdmUgdHJhbnNpdGlvbiwgaWYgYW55LlxuICAgICAgaWYgKG8uc3RhdGUgPT09IFJVTk5JTkcpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiaW50ZXJydXB0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBDYW5jZWwgYW55IHByZS1lbXB0ZWQgdHJhbnNpdGlvbnMuXG4gICAgICBlbHNlIGlmICgraSA8IGlkKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIG8ub24uY2FsbChcImNhbmNlbFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBvLmluZGV4LCBvLmdyb3VwKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZlciB0aGUgZmlyc3QgdGljayB0byBlbmQgb2YgdGhlIGN1cnJlbnQgZnJhbWU7IHNlZSBkMy9kMyMxNTc2LlxuICAgIC8vIE5vdGUgdGhlIHRyYW5zaXRpb24gbWF5IGJlIGNhbmNlbGVkIGFmdGVyIHN0YXJ0IGFuZCBiZWZvcmUgdGhlIGZpcnN0IHRpY2shXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgc2NoZWR1bGVkIGJlZm9yZSB0aGUgc3RhcnQgZXZlbnQ7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzE2IVxuICAgIC8vIEFzc3VtaW5nIHRoaXMgaXMgc3VjY2Vzc2Z1bCwgc3Vic2VxdWVudCBjYWxsYmFja3MgZ28gc3RyYWlnaHQgdG8gdGljay5cbiAgICB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFNUQVJURUQpIHtcbiAgICAgICAgc2VsZi5zdGF0ZSA9IFJVTk5JTkc7XG4gICAgICAgIHNlbGYudGltZXIucmVzdGFydCh0aWNrLCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xuICAgICAgICB0aWNrKGVsYXBzZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIHN0YXJ0IGV2ZW50LlxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHRoZSB0d2VlbiBhcmUgaW5pdGlhbGl6ZWQuXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJUSU5HO1xuICAgIHNlbGYub24uY2FsbChcInN0YXJ0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApO1xuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTVEFSVElORykgcmV0dXJuOyAvLyBpbnRlcnJ1cHRlZFxuICAgIHNlbGYuc3RhdGUgPSBTVEFSVEVEO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdHdlZW4sIGRlbGV0aW5nIG51bGwgdHdlZW4uXG4gICAgdHdlZW4gPSBuZXcgQXJyYXkobiA9IHNlbGYudHdlZW4ubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBqID0gLTE7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChvID0gc2VsZi50d2VlbltpXS52YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApKSB7XG4gICAgICAgIHR3ZWVuWysral0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICB0d2Vlbi5sZW5ndGggPSBqICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIHZhciB0ID0gZWxhcHNlZCA8IHNlbGYuZHVyYXRpb24gPyBzZWxmLmVhc2UuY2FsbChudWxsLCBlbGFwc2VkIC8gc2VsZi5kdXJhdGlvbikgOiAoc2VsZi50aW1lci5yZXN0YXJ0KHN0b3ApLCBzZWxmLnN0YXRlID0gRU5ESU5HLCAxKSxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gdHdlZW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHR3ZWVuW2ldLmNhbGwobm9kZSwgdCk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIGVuZCBldmVudC5cbiAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gRU5ESU5HKSB7XG4gICAgICBzZWxmLm9uLmNhbGwoXCJlbmRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBzZWxmLnN0YXRlID0gRU5ERUQ7XG4gICAgc2VsZi50aW1lci5zdG9wKCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpZF07XG4gICAgZm9yICh2YXIgaSBpbiBzY2hlZHVsZXMpIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgfVxufVxuIiwiaW1wb3J0IHtzZWxlY3Rvcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgICAgc2NoZWR1bGUoc3ViZ3JvdXBbaV0sIG5hbWUsIGlkLCBpLCBzdWJncm91cCwgZ2V0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtzZWxlY3RvckFsbH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtUcmFuc2l0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNjaGVkdWxlLCB7Z2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApLCBjaGlsZCwgaW5oZXJpdCA9IGdldChub2RlLCBpZCksIGsgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBrIDwgbDsgKytrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID0gY2hpbGRyZW5ba10pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGNoaWxkLCBuYW1lLCBpZCwgaywgY2hpbGRyZW4sIGluaGVyaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWJncm91cHMucHVzaChjaGlsZHJlbik7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuXG52YXIgU2VsZWN0aW9uID0gc2VsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2dyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtQ3NzIGFzIGludGVycG9sYXRlVHJhbnNmb3JtfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7c3R5bGV9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IGludGVycG9sYXRlIGZyb20gXCIuL2ludGVycG9sYXRlLmpzXCI7XG5cbmZ1bmN0aW9uIHN0eWxlTnVsbChuYW1lLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHN0cmluZzEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCBzdHJpbmcxMCA9IHN0cmluZzEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHN0eWxlKHRoaXMsIG5hbWUpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHZhbHVlMSA9IHZhbHVlKHRoaXMpLFxuICAgICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHN0cmluZzEgPSB2YWx1ZTEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVNYXliZVJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgb24wLCBvbjEsIGxpc3RlbmVyMCwga2V5ID0gXCJzdHlsZS5cIiArIG5hbWUsIGV2ZW50ID0gXCJlbmQuXCIgKyBrZXksIHJlbW92ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub24sXG4gICAgICAgIGxpc3RlbmVyID0gc2NoZWR1bGUudmFsdWVba2V5XSA9PSBudWxsID8gcmVtb3ZlIHx8IChyZW1vdmUgPSBzdHlsZVJlbW92ZShuYW1lKSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjAgfHwgbGlzdGVuZXIwICE9PSBsaXN0ZW5lcikgKG9uMSA9IChvbjAgPSBvbikuY29weSgpKS5vbihldmVudCwgbGlzdGVuZXIwID0gbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgaSA9IChuYW1lICs9IFwiXCIpID09PSBcInRyYW5zZm9ybVwiID8gaW50ZXJwb2xhdGVUcmFuc2Zvcm0gOiBpbnRlcnBvbGF0ZTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZU51bGwobmFtZSwgaSkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBzdHlsZVJlbW92ZShuYW1lKSlcbiAgICA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVGdW5jdGlvbihuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwic3R5bGUuXCIgKyBuYW1lLCB2YWx1ZSkpKVxuICAgICAgLmVhY2goc3R5bGVNYXliZVJlbW92ZSh0aGlzLl9pZCwgbmFtZSkpXG4gICAgOiB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZUNvbnN0YW50KG5hbWUsIGksIHZhbHVlKSwgcHJpb3JpdHkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBudWxsKTtcbn1cbiIsImZ1bmN0aW9uIHN0eWxlSW50ZXJwb2xhdGUobmFtZSwgaSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGkuY2FsbCh0aGlzLCB0KSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVR3ZWVuKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgdCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQgPSAoaTAgPSBpKSAmJiBzdHlsZUludGVycG9sYXRlKG5hbWUsIGksIHByaW9yaXR5KTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGtleSA9IFwic3R5bGUuXCIgKyAobmFtZSArPSBcIlwiKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKTtcbn1cbiIsImltcG9ydCB7dHdlZW5WYWx1ZX0gZnJvbSBcIi4vdHdlZW4uanNcIjtcblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTEgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLnR3ZWVuKFwidGV4dFwiLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyB0ZXh0RnVuY3Rpb24odHdlZW5WYWx1ZSh0aGlzLCBcInRleHRcIiwgdmFsdWUpKVxuICAgICAgOiB0ZXh0Q29uc3RhbnQodmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCIpKTtcbn1cbiIsImZ1bmN0aW9uIHRleHRJbnRlcnBvbGF0ZShpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IGkuY2FsbCh0aGlzLCB0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dFR3ZWVuKHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgdGV4dEludGVycG9sYXRlKGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIga2V5ID0gXCJ0ZXh0XCI7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCB0ZXh0VHdlZW4odmFsdWUpKTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbiwgbmV3SWR9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZDAgPSB0aGlzLl9pZCxcbiAgICAgIGlkMSA9IG5ld0lkKCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgdmFyIGluaGVyaXQgPSBnZXQobm9kZSwgaWQwKTtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQxLCBpLCBncm91cCwge1xuICAgICAgICAgIHRpbWU6IGluaGVyaXQudGltZSArIGluaGVyaXQuZGVsYXkgKyBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGRlbGF5OiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2U6IGluaGVyaXQuZWFzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZDEpO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gdHdlZW5SZW1vdmUoaWQsIG5hbWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgdHdlZW4gYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9IHR3ZWVuMCA9IHR3ZWVuO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMSA9IHR3ZWVuMS5zbGljZSgpO1xuICAgICAgICAgIHR3ZWVuMS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHdlZW5GdW5jdGlvbihpZCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSAodHdlZW4wID0gdHdlZW4pLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciB0ID0ge25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0sIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjFbaV0gPSB0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gbikgdHdlZW4xLnB1c2godCk7XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIG5hbWUgKz0gXCJcIjtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgdHdlZW4gPSBnZXQodGhpcy5ub2RlKCksIGlkKS50d2VlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuLmxlbmd0aCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh0ID0gdHdlZW5baV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbCA/IHR3ZWVuUmVtb3ZlIDogdHdlZW5GdW5jdGlvbikoaWQsIG5hbWUsIHZhbHVlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0d2VlblZhbHVlKHRyYW5zaXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRyYW5zaXRpb24uX2lkO1xuXG4gIHRyYW5zaXRpb24uZWFjaChmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpO1xuICAgIChzY2hlZHVsZS52YWx1ZSB8fCAoc2NoZWR1bGUudmFsdWUgPSB7fSkpW25hbWVdID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gZ2V0KG5vZGUsIGlkKS52YWx1ZVtuYW1lXTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHggPT4gKCkgPT4geDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFpvb21FdmVudCh0eXBlLCB7XG4gIHNvdXJjZUV2ZW50LFxuICB0YXJnZXQsXG4gIHRyYW5zZm9ybSxcbiAgZGlzcGF0Y2hcbn0pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIHR5cGU6IHt2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBzb3VyY2VFdmVudDoge3ZhbHVlOiBzb3VyY2VFdmVudCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICB0YXJnZXQ6IHt2YWx1ZTogdGFyZ2V0LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHRyYW5zZm9ybToge3ZhbHVlOiB0cmFuc2Zvcm0sIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgXzoge3ZhbHVlOiBkaXNwYXRjaH1cbiAgfSk7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgem9vbX0gZnJvbSBcIi4vem9vbS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHpvb21UcmFuc2Zvcm0sIGlkZW50aXR5IGFzIHpvb21JZGVudGl0eSwgVHJhbnNmb3JtIGFzIFpvb21UcmFuc2Zvcm19IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIFRyYW5zZm9ybShrLCB4LCB5KSB7XG4gIHRoaXMuayA9IGs7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm0sXG4gIHNjYWxlOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGsgPT09IDEgPyB0aGlzIDogbmV3IFRyYW5zZm9ybSh0aGlzLmsgKiBrLCB0aGlzLngsIHRoaXMueSk7XG4gIH0sXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB4ID09PSAwICYgeSA9PT0gMCA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuaywgdGhpcy54ICsgdGhpcy5rICogeCwgdGhpcy55ICsgdGhpcy5rICogeSk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiBbcG9pbnRbMF0gKiB0aGlzLmsgKyB0aGlzLngsIHBvaW50WzFdICogdGhpcy5rICsgdGhpcy55XTtcbiAgfSxcbiAgYXBwbHlYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggKiB0aGlzLmsgKyB0aGlzLng7XG4gIH0sXG4gIGFwcGx5WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5ICogdGhpcy5rICsgdGhpcy55O1xuICB9LFxuICBpbnZlcnQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIFsobG9jYXRpb25bMF0gLSB0aGlzLngpIC8gdGhpcy5rLCAobG9jYXRpb25bMV0gLSB0aGlzLnkpIC8gdGhpcy5rXTtcbiAgfSxcbiAgaW52ZXJ0WDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAoeCAtIHRoaXMueCkgLyB0aGlzLms7XG4gIH0sXG4gIGludmVydFk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gKHkgLSB0aGlzLnkpIC8gdGhpcy5rO1xuICB9LFxuICByZXNjYWxlWDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4LmNvcHkoKS5kb21haW4oeC5yYW5nZSgpLm1hcCh0aGlzLmludmVydFgsIHRoaXMpLm1hcCh4LmludmVydCwgeCkpO1xuICB9LFxuICByZXNjYWxlWTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5LmNvcHkoKS5kb21haW4oeS5yYW5nZSgpLm1hcCh0aGlzLmludmVydFksIHRoaXMpLm1hcCh5LmludmVydCwgeSkpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy54ICsgXCIsXCIgKyB0aGlzLnkgKyBcIikgc2NhbGUoXCIgKyB0aGlzLmsgKyBcIilcIjtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBpZGVudGl0eSA9IG5ldyBUcmFuc2Zvcm0oMSwgMCwgMCk7XG5cbnRyYW5zZm9ybS5wcm90b3R5cGUgPSBUcmFuc2Zvcm0ucHJvdG90eXBlO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSkge1xuICB3aGlsZSAoIW5vZGUuX196b29tKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuIGlkZW50aXR5O1xuICByZXR1cm4gbm9kZS5fX3pvb207XG59XG4iLCJpbXBvcnQge2Rpc3BhdGNofSBmcm9tIFwiZDMtZGlzcGF0Y2hcIjtcbmltcG9ydCB7ZHJhZ0Rpc2FibGUsIGRyYWdFbmFibGV9IGZyb20gXCJkMy1kcmFnXCI7XG5pbXBvcnQge2ludGVycG9sYXRlWm9vbX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge3NlbGVjdCwgcG9pbnRlcn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtpbnRlcnJ1cHR9IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBab29tRXZlbnQgZnJvbSBcIi4vZXZlbnQuanNcIjtcbmltcG9ydCB7VHJhbnNmb3JtLCBpZGVudGl0eX0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG5pbXBvcnQgbm9ldmVudCwge25vcHJvcGFnYXRpb259IGZyb20gXCIuL25vZXZlbnQuanNcIjtcblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG4vLyBleGNlcHQgZm9yIHBpbmNoLXRvLXpvb20sIHdoaWNoIGlzIHNlbnQgYXMgYSB3aGVlbCtjdHJsS2V5IGV2ZW50XG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKGV2ZW50KSB7XG4gIHJldHVybiAoIWV2ZW50LmN0cmxLZXkgfHwgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykgJiYgIWV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCgpIHtcbiAgdmFyIGUgPSB0aGlzO1xuICBpZiAoZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICBlID0gZS5vd25lclNWR0VsZW1lbnQgfHwgZTtcbiAgICBpZiAoZS5oYXNBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIpKSB7XG4gICAgICBlID0gZS52aWV3Qm94LmJhc2VWYWw7XG4gICAgICByZXR1cm4gW1tlLngsIGUueV0sIFtlLnggKyBlLndpZHRoLCBlLnkgKyBlLmhlaWdodF1dO1xuICAgIH1cbiAgICByZXR1cm4gW1swLCAwXSwgW2Uud2lkdGguYmFzZVZhbC52YWx1ZSwgZS5oZWlnaHQuYmFzZVZhbC52YWx1ZV1dO1xuICB9XG4gIHJldHVybiBbWzAsIDBdLCBbZS5jbGllbnRXaWR0aCwgZS5jbGllbnRIZWlnaHRdXTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybSgpIHtcbiAgcmV0dXJuIHRoaXMuX196b29tIHx8IGlkZW50aXR5O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V2hlZWxEZWx0YShldmVudCkge1xuICByZXR1cm4gLWV2ZW50LmRlbHRhWSAqIChldmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqIChldmVudC5jdHJsS2V5ID8gMTAgOiAxKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvdWNoYWJsZSgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiB0aGlzKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbnN0cmFpbih0cmFuc2Zvcm0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSB7XG4gIHZhciBkeDAgPSB0cmFuc2Zvcm0uaW52ZXJ0WChleHRlbnRbMF1bMF0pIC0gdHJhbnNsYXRlRXh0ZW50WzBdWzBdLFxuICAgICAgZHgxID0gdHJhbnNmb3JtLmludmVydFgoZXh0ZW50WzFdWzBdKSAtIHRyYW5zbGF0ZUV4dGVudFsxXVswXSxcbiAgICAgIGR5MCA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFswXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMV0sXG4gICAgICBkeTEgPSB0cmFuc2Zvcm0uaW52ZXJ0WShleHRlbnRbMV1bMV0pIC0gdHJhbnNsYXRlRXh0ZW50WzFdWzFdO1xuICByZXR1cm4gdHJhbnNmb3JtLnRyYW5zbGF0ZShcbiAgICBkeDEgPiBkeDAgPyAoZHgwICsgZHgxKSAvIDIgOiBNYXRoLm1pbigwLCBkeDApIHx8IE1hdGgubWF4KDAsIGR4MSksXG4gICAgZHkxID4gZHkwID8gKGR5MCArIGR5MSkgLyAyIDogTWF0aC5taW4oMCwgZHkwKSB8fCBNYXRoLm1heCgwLCBkeTEpXG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGV4dGVudCA9IGRlZmF1bHRFeHRlbnQsXG4gICAgICBjb25zdHJhaW4gPSBkZWZhdWx0Q29uc3RyYWluLFxuICAgICAgd2hlZWxEZWx0YSA9IGRlZmF1bHRXaGVlbERlbHRhLFxuICAgICAgdG91Y2hhYmxlID0gZGVmYXVsdFRvdWNoYWJsZSxcbiAgICAgIHNjYWxlRXh0ZW50ID0gWzAsIEluZmluaXR5XSxcbiAgICAgIHRyYW5zbGF0ZUV4dGVudCA9IFtbLUluZmluaXR5LCAtSW5maW5pdHldLCBbSW5maW5pdHksIEluZmluaXR5XV0sXG4gICAgICBkdXJhdGlvbiA9IDI1MCxcbiAgICAgIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVab29tLFxuICAgICAgbGlzdGVuZXJzID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcInpvb21cIiwgXCJlbmRcIiksXG4gICAgICB0b3VjaHN0YXJ0aW5nLFxuICAgICAgdG91Y2hmaXJzdCxcbiAgICAgIHRvdWNoZW5kaW5nLFxuICAgICAgdG91Y2hEZWxheSA9IDUwMCxcbiAgICAgIHdoZWVsRGVsYXkgPSAxNTAsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDAsXG4gICAgICB0YXBEaXN0YW5jZSA9IDEwO1xuXG4gIGZ1bmN0aW9uIHpvb20oc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uXG4gICAgICAgIC5wcm9wZXJ0eShcIl9fem9vbVwiLCBkZWZhdWx0VHJhbnNmb3JtKVxuICAgICAgICAub24oXCJ3aGVlbC56b29tXCIsIHdoZWVsZWQsIHtwYXNzaXZlOiBmYWxzZX0pXG4gICAgICAgIC5vbihcIm1vdXNlZG93bi56b29tXCIsIG1vdXNlZG93bmVkKVxuICAgICAgICAub24oXCJkYmxjbGljay56b29tXCIsIGRibGNsaWNrZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC56b29tXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLnpvb21cIiwgdG91Y2htb3ZlZClcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuem9vbSB0b3VjaGNhbmNlbC56b29tXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIik7XG4gIH1cblxuICB6b29tLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGNvbGxlY3Rpb24uc2VsZWN0aW9uID8gY29sbGVjdGlvbi5zZWxlY3Rpb24oKSA6IGNvbGxlY3Rpb247XG4gICAgc2VsZWN0aW9uLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pO1xuICAgIGlmIChjb2xsZWN0aW9uICE9PSBzZWxlY3Rpb24pIHtcbiAgICAgIHNjaGVkdWxlKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLmludGVycnVwdCgpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGdlc3R1cmUodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIC5ldmVudChldmVudClcbiAgICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgIC56b29tKG51bGwsIHR5cGVvZiB0cmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIiA/IHRyYW5zZm9ybS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdHJhbnNmb3JtKVxuICAgICAgICAgIC5lbmQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB6b29tLnNjYWxlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHAsIGV2ZW50KSB7XG4gICAgem9vbS5zY2FsZVRvKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgazAgPSB0aGlzLl9fem9vbS5rLFxuICAgICAgICAgIGsxID0gdHlwZW9mIGsgPT09IFwiZnVuY3Rpb25cIiA/IGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGs7XG4gICAgICByZXR1cm4gazAgKiBrMTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS5zY2FsZVRvID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBrLCBwLCBldmVudCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwLFxuICAgICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgICBrMSA9IHR5cGVvZiBrID09PSBcImZ1bmN0aW9uXCIgPyBrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodDAsIGsxKSwgcDAsIHAxKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVCeSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgeCwgeSwgZXZlbnQpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbih0aGlzLl9fem9vbS50cmFuc2xhdGUoXG4gICAgICAgIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB4LFxuICAgICAgICB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8geS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogeVxuICAgICAgKSwgZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgbnVsbCwgZXZlbnQpO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIHgsIHksIHAsIGV2ZW50KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICAgIHAwID0gcCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcDtcbiAgICAgIHJldHVybiBjb25zdHJhaW4oaWRlbnRpdHkudHJhbnNsYXRlKHAwWzBdLCBwMFsxXSkuc2NhbGUodC5rKS50cmFuc2xhdGUoXG4gICAgICAgIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyAteC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyAteS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXlcbiAgICAgICksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgcCwgZXZlbnQpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHRyYW5zZm9ybSwgaykge1xuICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIGspKTtcbiAgICByZXR1cm4gayA9PT0gdHJhbnNmb3JtLmsgPyB0cmFuc2Zvcm0gOiBuZXcgVHJhbnNmb3JtKGssIHRyYW5zZm9ybS54LCB0cmFuc2Zvcm0ueSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUodHJhbnNmb3JtLCBwMCwgcDEpIHtcbiAgICB2YXIgeCA9IHAwWzBdIC0gcDFbMF0gKiB0cmFuc2Zvcm0uaywgeSA9IHAwWzFdIC0gcDFbMV0gKiB0cmFuc2Zvcm0uaztcbiAgICByZXR1cm4geCA9PT0gdHJhbnNmb3JtLnggJiYgeSA9PT0gdHJhbnNmb3JtLnkgPyB0cmFuc2Zvcm0gOiBuZXcgVHJhbnNmb3JtKHRyYW5zZm9ybS5rLCB4LCB5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbnRyb2lkKGV4dGVudCkge1xuICAgIHJldHVybiBbKCtleHRlbnRbMF1bMF0gKyArZXh0ZW50WzFdWzBdKSAvIDIsICgrZXh0ZW50WzBdWzFdICsgK2V4dGVudFsxXVsxXSkgLyAyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKHRyYW5zaXRpb24sIHRyYW5zZm9ybSwgcG9pbnQsIGV2ZW50KSB7XG4gICAgdHJhbnNpdGlvblxuICAgICAgICAub24oXCJzdGFydC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuZXZlbnQoZXZlbnQpLnN0YXJ0KCk7IH0pXG4gICAgICAgIC5vbihcImludGVycnVwdC56b29tIGVuZC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuZXZlbnQoZXZlbnQpLmVuZCgpOyB9KVxuICAgICAgICAudHdlZW4oXCJ6b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgZyA9IGdlc3R1cmUodGhhdCwgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICAgICAgICBlID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpLFxuICAgICAgICAgICAgICBwID0gcG9pbnQgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHBvaW50ID09PSBcImZ1bmN0aW9uXCIgPyBwb2ludC5hcHBseSh0aGF0LCBhcmdzKSA6IHBvaW50LFxuICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgoZVsxXVswXSAtIGVbMF1bMF0sIGVbMV1bMV0gLSBlWzBdWzFdKSxcbiAgICAgICAgICAgICAgYSA9IHRoYXQuX196b29tLFxuICAgICAgICAgICAgICBiID0gdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoYXQsIGFyZ3MpIDogdHJhbnNmb3JtLFxuICAgICAgICAgICAgICBpID0gaW50ZXJwb2xhdGUoYS5pbnZlcnQocCkuY29uY2F0KHcgLyBhLmspLCBiLmludmVydChwKS5jb25jYXQodyAvIGIuaykpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gMSkgdCA9IGI7IC8vIEF2b2lkIHJvdW5kaW5nIGVycm9yIG9uIGVuZC5cbiAgICAgICAgICAgIGVsc2UgeyB2YXIgbCA9IGkodCksIGsgPSB3IC8gbFsyXTsgdCA9IG5ldyBUcmFuc2Zvcm0oaywgcFswXSAtIGxbMF0gKiBrLCBwWzFdIC0gbFsxXSAqIGspOyB9XG4gICAgICAgICAgICBnLnpvb20obnVsbCwgdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXN0dXJlKHRoYXQsIGFyZ3MsIGNsZWFuKSB7XG4gICAgcmV0dXJuICghY2xlYW4gJiYgdGhhdC5fX3pvb21pbmcpIHx8IG5ldyBHZXN0dXJlKHRoYXQsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gR2VzdHVyZSh0aGF0LCBhcmdzKSB7XG4gICAgdGhpcy50aGF0ID0gdGhhdDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICB0aGlzLnNvdXJjZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudC5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB0aGlzLnRhcHMgPSAwO1xuICB9XG5cbiAgR2VzdHVyZS5wcm90b3R5cGUgPSB7XG4gICAgZXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQpIHRoaXMuc291cmNlRXZlbnQgPSBldmVudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCsrdGhpcy5hY3RpdmUgPT09IDEpIHtcbiAgICAgICAgdGhpcy50aGF0Ll9fem9vbWluZyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdChcInN0YXJ0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB6b29tOiBmdW5jdGlvbihrZXksIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRoaXMubW91c2UgJiYga2V5ICE9PSBcIm1vdXNlXCIpIHRoaXMubW91c2VbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMubW91c2VbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gwICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMFsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDBbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gxICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMVsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDFbMF0pO1xuICAgICAgdGhpcy50aGF0Ll9fem9vbSA9IHRyYW5zZm9ybTtcbiAgICAgIHRoaXMuZW1pdChcInpvb21cIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy50aGF0Ll9fem9vbWluZztcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgZCA9IHNlbGVjdCh0aGlzLnRoYXQpLmRhdHVtKCk7XG4gICAgICBsaXN0ZW5lcnMuY2FsbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhpcy50aGF0LFxuICAgICAgICBuZXcgWm9vbUV2ZW50KHR5cGUsIHtcbiAgICAgICAgICBzb3VyY2VFdmVudDogdGhpcy5zb3VyY2VFdmVudCxcbiAgICAgICAgICB0YXJnZXQ6IHpvb20sXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMudGhhdC5fX3pvb20sXG4gICAgICAgICAgZGlzcGF0Y2g6IGxpc3RlbmVyc1xuICAgICAgICB9KSxcbiAgICAgICAgZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gd2hlZWxlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIHQuayAqIE1hdGgucG93KDIsIHdoZWVsRGVsdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSxcbiAgICAgICAgcCA9IHBvaW50ZXIoZXZlbnQpO1xuXG4gICAgLy8gSWYgdGhlIG1vdXNlIGlzIGluIHRoZSBzYW1lIGxvY2F0aW9uIGFzIGJlZm9yZSwgcmV1c2UgaXQuXG4gICAgLy8gSWYgdGhlcmUgd2VyZSByZWNlbnQgd2hlZWwgZXZlbnRzLCByZXNldCB0aGUgd2hlZWwgaWRsZSB0aW1lb3V0LlxuICAgIGlmIChnLndoZWVsKSB7XG4gICAgICBpZiAoZy5tb3VzZVswXVswXSAhPT0gcFswXSB8fCBnLm1vdXNlWzBdWzFdICE9PSBwWzFdKSB7XG4gICAgICAgIGcubW91c2VbMV0gPSB0LmludmVydChnLm1vdXNlWzBdID0gcCk7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQoZy53aGVlbCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyB3aGVlbCBldmVudCB3b27igJl0IHRyaWdnZXIgYSB0cmFuc2Zvcm0gY2hhbmdlLCBpZ25vcmUgaXQuXG4gICAgZWxzZSBpZiAodC5rID09PSBrKSByZXR1cm47XG5cbiAgICAvLyBPdGhlcndpc2UsIGNhcHR1cmUgdGhlIG1vdXNlIHBvaW50IGFuZCBsb2NhdGlvbiBhdCB0aGUgc3RhcnQuXG4gICAgZWxzZSB7XG4gICAgICBnLm1vdXNlID0gW3AsIHQuaW52ZXJ0KHApXTtcbiAgICAgIGludGVycnVwdCh0aGlzKTtcbiAgICAgIGcuc3RhcnQoKTtcbiAgICB9XG5cbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBnLndoZWVsID0gc2V0VGltZW91dCh3aGVlbGlkbGVkLCB3aGVlbERlbGF5KTtcbiAgICBnLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQsIGspLCBnLm1vdXNlWzBdLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuXG4gICAgZnVuY3Rpb24gd2hlZWxpZGxlZCgpIHtcbiAgICAgIGcud2hlZWwgPSBudWxsO1xuICAgICAgZy5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZWRvd25lZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MsIHRydWUpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdiA9IHNlbGVjdChldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS56b29tXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC56b29tXCIsIG1vdXNldXBwZWQsIHRydWUpLFxuICAgICAgICBwID0gcG9pbnRlcihldmVudCwgY3VycmVudFRhcmdldCksXG4gICAgICAgIHgwID0gZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTAgPSBldmVudC5jbGllbnRZO1xuXG4gICAgZHJhZ0Rpc2FibGUoZXZlbnQudmlldyk7XG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgZy5tb3VzZSA9IFtwLCB0aGlzLl9fem9vbS5pbnZlcnQocCldO1xuICAgIGludGVycnVwdCh0aGlzKTtcbiAgICBnLnN0YXJ0KCk7XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmVkKGV2ZW50KSB7XG4gICAgICBub2V2ZW50KGV2ZW50KTtcbiAgICAgIGlmICghZy5tb3ZlZCkge1xuICAgICAgICB2YXIgZHggPSBldmVudC5jbGllbnRYIC0geDAsIGR5ID0gZXZlbnQuY2xpZW50WSAtIHkwO1xuICAgICAgICBnLm1vdmVkID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICAgIH1cbiAgICAgIGcuZXZlbnQoZXZlbnQpXG4gICAgICAgLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKGcudGhhdC5fX3pvb20sIGcubW91c2VbMF0gPSBwb2ludGVyKGV2ZW50LCBjdXJyZW50VGFyZ2V0KSwgZy5tb3VzZVsxXSksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwcGVkKGV2ZW50KSB7XG4gICAgICB2Lm9uKFwibW91c2Vtb3ZlLnpvb20gbW91c2V1cC56b29tXCIsIG51bGwpO1xuICAgICAgZHJhZ0VuYWJsZShldmVudC52aWV3LCBnLm1vdmVkKTtcbiAgICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgICAgZy5ldmVudChldmVudCkuZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGJsY2xpY2tlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdDAgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgcDAgPSBwb2ludGVyKGV2ZW50LmNoYW5nZWRUb3VjaGVzID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudCwgdGhpcyksXG4gICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgazEgPSB0MC5rICogKGV2ZW50LnNoaWZ0S2V5ID8gMC41IDogMiksXG4gICAgICAgIHQxID0gY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0MCwgazEpLCBwMCwgcDEpLCBleHRlbnQuYXBwbHkodGhpcywgYXJncyksIHRyYW5zbGF0ZUV4dGVudCk7XG5cbiAgICBub2V2ZW50KGV2ZW50KTtcbiAgICBpZiAoZHVyYXRpb24gPiAwKSBzZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKHNjaGVkdWxlLCB0MSwgcDAsIGV2ZW50KTtcbiAgICBlbHNlIHNlbGVjdCh0aGlzKS5jYWxsKHpvb20udHJhbnNmb3JtLCB0MSwgcDAsIGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoc3RhcnRlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgZyA9IGdlc3R1cmUodGhpcywgYXJncywgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09PSBuKS5ldmVudChldmVudCksXG4gICAgICAgIHN0YXJ0ZWQsIGksIHQsIHA7XG5cbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXSwgcCA9IHBvaW50ZXIodCwgdGhpcyk7XG4gICAgICBwID0gW3AsIHRoaXMuX196b29tLmludmVydChwKSwgdC5pZGVudGlmaWVyXTtcbiAgICAgIGlmICghZy50b3VjaDApIGcudG91Y2gwID0gcCwgc3RhcnRlZCA9IHRydWUsIGcudGFwcyA9IDEgKyAhIXRvdWNoc3RhcnRpbmc7XG4gICAgICBlbHNlIGlmICghZy50b3VjaDEgJiYgZy50b3VjaDBbMl0gIT09IHBbMl0pIGcudG91Y2gxID0gcCwgZy50YXBzID0gMDtcbiAgICB9XG5cbiAgICBpZiAodG91Y2hzdGFydGluZykgdG91Y2hzdGFydGluZyA9IGNsZWFyVGltZW91dCh0b3VjaHN0YXJ0aW5nKTtcblxuICAgIGlmIChzdGFydGVkKSB7XG4gICAgICBpZiAoZy50YXBzIDwgMikgdG91Y2hmaXJzdCA9IHBbMF0sIHRvdWNoc3RhcnRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaHN0YXJ0aW5nID0gbnVsbDsgfSwgdG91Y2hEZWxheSk7XG4gICAgICBpbnRlcnJ1cHQodGhpcyk7XG4gICAgICBnLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2htb3ZlZChldmVudCwgLi4uYXJncykge1xuICAgIGlmICghdGhpcy5fX3pvb21pbmcpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJncykuZXZlbnQoZXZlbnQpLFxuICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgdCwgcCwgbDtcblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gcG9pbnRlcih0LCB0aGlzKTtcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBnLnRvdWNoMFswXSA9IHA7XG4gICAgICBlbHNlIGlmIChnLnRvdWNoMSAmJiBnLnRvdWNoMVsyXSA9PT0gdC5pZGVudGlmaWVyKSBnLnRvdWNoMVswXSA9IHA7XG4gICAgfVxuICAgIHQgPSBnLnRoYXQuX196b29tO1xuICAgIGlmIChnLnRvdWNoMSkge1xuICAgICAgdmFyIHAwID0gZy50b3VjaDBbMF0sIGwwID0gZy50b3VjaDBbMV0sXG4gICAgICAgICAgcDEgPSBnLnRvdWNoMVswXSwgbDEgPSBnLnRvdWNoMVsxXSxcbiAgICAgICAgICBkcCA9IChkcCA9IHAxWzBdIC0gcDBbMF0pICogZHAgKyAoZHAgPSBwMVsxXSAtIHAwWzFdKSAqIGRwLFxuICAgICAgICAgIGRsID0gKGRsID0gbDFbMF0gLSBsMFswXSkgKiBkbCArIChkbCA9IGwxWzFdIC0gbDBbMV0pICogZGw7XG4gICAgICB0ID0gc2NhbGUodCwgTWF0aC5zcXJ0KGRwIC8gZGwpKTtcbiAgICAgIHAgPSBbKHAwWzBdICsgcDFbMF0pIC8gMiwgKHAwWzFdICsgcDFbMV0pIC8gMl07XG4gICAgICBsID0gWyhsMFswXSArIGwxWzBdKSAvIDIsIChsMFsxXSArIGwxWzFdKSAvIDJdO1xuICAgIH1cbiAgICBlbHNlIGlmIChnLnRvdWNoMCkgcCA9IGcudG91Y2gwWzBdLCBsID0gZy50b3VjaDBbMV07XG4gICAgZWxzZSByZXR1cm47XG5cbiAgICBnLnpvb20oXCJ0b3VjaFwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHQsIHAsIGwpLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaGVuZGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLl9fem9vbWluZykgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0O1xuXG4gICAgbm9wcm9wYWdhdGlvbihldmVudCk7XG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXTtcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDA7XG4gICAgICBlbHNlIGlmIChnLnRvdWNoMSAmJiBnLnRvdWNoMVsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDE7XG4gICAgfVxuICAgIGlmIChnLnRvdWNoMSAmJiAhZy50b3VjaDApIGcudG91Y2gwID0gZy50b3VjaDEsIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICBpZiAoZy50b3VjaDApIGcudG91Y2gwWzFdID0gdGhpcy5fX3pvb20uaW52ZXJ0KGcudG91Y2gwWzBdKTtcbiAgICBlbHNlIHtcbiAgICAgIGcuZW5kKCk7XG4gICAgICAvLyBJZiB0aGlzIHdhcyBhIGRibHRhcCwgcmVyb3V0ZSB0byB0aGUgKG9wdGlvbmFsKSBkYmxjbGljay56b29tIGhhbmRsZXIuXG4gICAgICBpZiAoZy50YXBzID09PSAyKSB7XG4gICAgICAgIHQgPSBwb2ludGVyKHQsIHRoaXMpO1xuICAgICAgICBpZiAoTWF0aC5oeXBvdCh0b3VjaGZpcnN0WzBdIC0gdFswXSwgdG91Y2hmaXJzdFsxXSAtIHRbMV0pIDwgdGFwRGlzdGFuY2UpIHtcbiAgICAgICAgICB2YXIgcCA9IHNlbGVjdCh0aGlzKS5vbihcImRibGNsaWNrLnpvb21cIik7XG4gICAgICAgICAgaWYgKHApIHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHpvb20ud2hlZWxEZWx0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh3aGVlbERlbHRhID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHpvb20pIDogd2hlZWxEZWx0YTtcbiAgfTtcblxuICB6b29tLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIHpvb20pIDogZmlsdGVyO1xuICB9O1xuXG4gIHpvb20udG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgem9vbS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXh0ZW50ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbWytfWzBdWzBdLCArX1swXVsxXV0sIFsrX1sxXVswXSwgK19bMV1bMV1dXSksIHpvb20pIDogZXh0ZW50O1xuICB9O1xuXG4gIHpvb20uc2NhbGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGVFeHRlbnRbMF0gPSArX1swXSwgc2NhbGVFeHRlbnRbMV0gPSArX1sxXSwgem9vbSkgOiBbc2NhbGVFeHRlbnRbMF0sIHNjYWxlRXh0ZW50WzFdXTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2xhdGVFeHRlbnRbMF1bMF0gPSArX1swXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzBdID0gK19bMV1bMF0sIHRyYW5zbGF0ZUV4dGVudFswXVsxXSA9ICtfWzBdWzFdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV0gPSArX1sxXVsxXSwgem9vbSkgOiBbW3RyYW5zbGF0ZUV4dGVudFswXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdXSwgW3RyYW5zbGF0ZUV4dGVudFsxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzFdXV07XG4gIH07XG5cbiAgem9vbS5jb25zdHJhaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29uc3RyYWluID0gXywgem9vbSkgOiBjb25zdHJhaW47XG4gIH07XG5cbiAgem9vbS5kdXJhdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkdXJhdGlvbiA9ICtfLCB6b29tKSA6IGR1cmF0aW9uO1xuICB9O1xuXG4gIHpvb20uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCB6b29tKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHpvb20ub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gem9vbSA6IHZhbHVlO1xuICB9O1xuXG4gIHpvb20uY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgem9vbSkgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xuICB9O1xuXG4gIHpvb20udGFwRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGFwRGlzdGFuY2UgPSArXywgem9vbSkgOiB0YXBEaXN0YW5jZTtcbiAgfTtcblxuICByZXR1cm4gem9vbTtcbn1cbiIsImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuXHJcbi8qKlxyXG4gKiBQYXJlbnQgY2xhc3MgZm9yIGJ1dHRvbiBlbGVtZW50cyB1c2VkIHRvIGludGVyYWN0IHdpdGggdGhlIGdyaWR2aXogdmlld2VyLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGJ1dHRvblxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQnV0dG9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICAqIG9wdHMucGFyZW50Tm9kZVxyXG4gICAgICogb3B0cy5pZFxyXG4gICAgICogb3B0cy50aXRsZVxyXG4gICAgICogb3B0cy5jbGFzc1xyXG4gICAgICogb3B0cy5vbkNsaWNrRnVuY3Rpb25cclxuICAgICAqIG9wdHMueFxyXG4gICAgICogb3B0cy55XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xyXG4gICAgICAgIHRoaXMubWFwID0gb3B0cy5tYXBcclxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBvcHRzLnBhcmVudE5vZGUgfHwgb3B0cy5tYXAuY29udGFpbmVyXHJcblxyXG4gICAgICAgIC8vIHRoZSBkaXYgZWxlbWVudFxyXG4gICAgICAgIGlmIChvcHRzLmlkKSB0aGlzLmRpdiA9IHNlbGVjdCgnIycgKyBvcHRzLmlkKVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuZGl2IHx8IHRoaXMuZGl2LmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXYgPSBzZWxlY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXHJcbiAgICAgICAgICAgIGlmIChvcHRzLmlkKSB0aGlzLmRpdi5hdHRyKCdpZCcsIG9wdHMuaWQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0cy50aXRsZSkgdGhpcy5kaXYuYXR0cigndGl0bGUnLCBvcHRzLnRpdGxlKVxyXG4gICAgICAgIGlmIChvcHRzLmNsYXNzKSB0aGlzLmRpdi5hdHRyKCdjbGFzcycsIG9wdHMuY2xhc3MpXHJcblxyXG4gICAgICAgIC8vIGFkZCBldmVudHNcclxuICAgICAgICBpZiAob3B0cy5vbkNsaWNrRnVuY3Rpb24pIHRoaXMuZGl2Lm9uKCdjbGljaycsIG9wdHMub25DbGlja0Z1bmN0aW9uKVxyXG5cclxuICAgICAgICAvL3NldCBzdHlsZXNcclxuICAgICAgICB0aGlzLnN0eWxlKFxyXG4gICAgICAgICAgICAnYm94LXNoYWRvdycsXHJcbiAgICAgICAgICAgICcwIDdweCA4cHggcmdiYSgwLDQ3LDEwMywuMDgpLCAwIDAgMjJweCByZ2JhKDAsNDcsMTAzLC4wNCksIDAgMTJweCAxN3B4IHJnYmEoMCw0NywxMDMsLjA0KSwgMCAtNHB4IDRweCByZ2JhKDAsNDcsMTAzLC4wNCknXHJcbiAgICAgICAgKSAvLy5lY2wtdS1zaGFkb3ctM1xyXG4gICAgICAgIHRoaXMuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCAnI2ZmZmZmZicpXHJcbiAgICAgICAgdGhpcy5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKVxyXG4gICAgICAgIHRoaXMuc3R5bGUoJ2N1cnNvcicsICdwb2ludGVyJylcclxuICAgICAgICB0aGlzLnN0eWxlKCdkaXNwbGF5JywgJ2ZsZXgnKVxyXG4gICAgICAgIHRoaXMuc3R5bGUoJ2p1c3RpZnktY29udGVudCcsICdjZW50ZXInKVxyXG4gICAgICAgIHRoaXMuc3R5bGUoJ2FsaWduLWl0ZW1zJywgJ2NlbnRlcicpXHJcbiAgICAgICAgdGhpcy5zdHlsZSgnd2lkdGgnLCAnMzVweCcpXHJcbiAgICAgICAgdGhpcy5zdHlsZSgnaGVpZ2h0JywgJzMwcHgnKVxyXG4gICAgICAgIC8vIHRoaXMuc3R5bGUocGFkZGluZyAsICc0cHgnXHJcblxyXG4gICAgICAgIC8vIGFwcGVuZCB0byBwYXJlbnRcclxuICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5kaXYubm9kZSgpKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgYSBzdHlsZSB0byB0aGUgYnV0dG9uIGRpdi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdlxyXG4gICAgICogQHJldHVybnMge3RoaXN9XHJcbiAgICAgKi9cclxuICAgIHN0eWxlKGssIHYpIHtcclxuICAgICAgICB0aGlzLmRpdi5zdHlsZShrLCB2KVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAnLi9CdXR0b24uanMnXHJcblxyXG4vKipcclxuICogQnV0dG9uIGZvciB0b2dnbGluZyBmdWxsc2NyZWVuIG1vZGVcclxuICpcclxuICogQG1vZHVsZSBidXR0b25cclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZ1bGxzY3JlZW5CdXR0b24gZXh0ZW5kcyBCdXR0b24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICAgICogb3B0cy5wYXJlbnROb2RlIC0gdGhlIG5vZGUgdGhhdCB0aGUgYnV0dG9uIGlzIGFwcGVuZGVkIHRvXHJcbiAgICAgKiBvcHRzLmNhbnZhcyAtIHRoZSBncmlkdml6IGNhbnZhc1xyXG4gICAgICogb3B0cy5pZFxyXG4gICAgICogb3B0cy50aXRsZSAtIEhUTUwgdGl0bGUgYXR0cmlidXRlXHJcbiAgICAgKiBvcHRzLmNsYXNzIC0gY3NzIGNsYXNzXHJcbiAgICAgKiBvcHRzLm9uQ2xpY2tGdW5jdGlvblxyXG4gICAgICogb3B0cy54IC0geCBwb3NpdGlvbiBvZiB0aGUgYnV0dG9uXHJcbiAgICAgKiBvcHRzLnkgLSB5IHBvc2l0aW9uIG9mIHRoZSBidXR0b25cclxuICAgICAqL1xyXG5cclxuICAgIC8vIGRlZmF1bHQgc3RhdGVcclxuICAgIGlzRnVsbHNjcmVlbiA9IGZhbHNlXHJcblxyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcblxyXG4gICAgICAgIC8vIGFwcGVuZCBmdWxsc2NyZWVuIGljb24gdG8gYnV0dG9uIGNvbnRhaW5lclxyXG4gICAgICAgIHRoaXMuZGl2Lm5vZGUoKS5pbm5lckhUTUwgPSBgXHJcbiAgICAgICAgPHN2Z1xyXG4gICAgICAgICAgICBzdHlsZT1cImhlaWdodDogMS4ycmVtOyB3aWR0aDogMS4ycmVtOyBmaWxsOmJsYWNrOyBtYXJnaW46MDtcIlxyXG4gICAgICAgICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXHJcbiAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8c3ZnIGZpbGw9XCIjMDAwMDAwXCIgdmlld0JveD1cIjAgMCA5NiA5NlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cclxuICAgICAgICAgICAgPHRpdGxlLz5cclxuICAgICAgICAgICAgPGc+XHJcbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMzAsMEg2QTUuOTk2Niw1Ljk5NjYsMCwwLDAsMCw2VjMwYTYsNiwwLDAsMCwxMiwwVjEySDMwQTYsNiwwLDAsMCwzMCwwWlwiLz5cclxuICAgICAgICAgICAgPHBhdGggZD1cIk05MCwwSDY2YTYsNiwwLDAsMCwwLDEySDg0VjMwYTYsNiwwLDAsMCwxMiwwVjZBNS45OTY2LDUuOTk2NiwwLDAsMCw5MCwwWlwiLz5cclxuICAgICAgICAgICAgPHBhdGggZD1cIk0zMCw4NEgxMlY2NkE2LDYsMCwwLDAsMCw2NlY5MGE1Ljk5NjYsNS45OTY2LDAsMCwwLDYsNkgzMGE2LDYsMCwwLDAsMC0xMlpcIi8+XHJcbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNOTAsNjBhNS45OTY2LDUuOTk2NiwwLDAsMC02LDZWODRINjZhNiw2LDAsMCwwLDAsMTJIOTBhNS45OTY2LDUuOTk2NiwwLDAsMCw2LTZWNjZBNS45OTY2LDUuOTk2NiwwLDAsMCw5MCw2MFpcIi8+XHJcbiAgICAgICAgICAgIDwvZz5cclxuICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgYFxyXG5cclxuICAgICAgICAvL3NhdmUgaW5pdGlhbCBtYXAgZGltZW5zaW9uc1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdEhlaWdodCA9IHRoaXMubWFwLmhcclxuICAgICAgICB0aGlzLmRlZmF1bHRXaWR0aCA9IHRoaXMubWFwLndcclxuXHJcbiAgICAgICAgLy8gZXZlbnQgaGFuZGxlclxyXG4gICAgICAgIHRoaXMuZGl2Lm9uKCdjbGljaycsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub25DbGlja0Z1bmN0aW9uKGUpXHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLmRpdi5vbignbW91c2VvdmVyJywgKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsICdsaWdodGdyZXknKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5kaXYub24oJ21vdXNlb3V0JywgKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsICcjZmZmZmZmJylcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvL3NldCBwb3NpdGlvblxyXG4gICAgICAgIGlmIChvcHRzLngpIHtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZSgnbGVmdCcsIG9wdHMueCArICdweCcpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZSgncmlnaHQnLCAnMTBweCcpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRzLnkpIHtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZSgndG9wJywgb3B0cy55ICsgJ3B4JylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlKCd0b3AnLCAnOTBweCcpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uQ2xpY2tGdW5jdGlvbihlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGdWxsc2NyZWVuKHRoaXMubWFwLmNvbnRhaW5lcilcclxuICAgICAgICAgICAgLy9yZXNpemUgY2FudmFzIHRvIGRlZmF1bHRcclxuICAgICAgICAgICAgdGhpcy5tYXAuaCA9IHRoaXMuZGVmYXVsdEhlaWdodFxyXG4gICAgICAgICAgICB0aGlzLm1hcC53ID0gdGhpcy5kZWZhdWx0V2lkdGhcclxuICAgICAgICAgICAgdGhpcy5tYXAuZ2VvQ2FudmFzLmggPSB0aGlzLmRlZmF1bHRIZWlnaHRcclxuICAgICAgICAgICAgdGhpcy5tYXAuZ2VvQ2FudmFzLncgPSB0aGlzLmRlZmF1bHRXaWR0aFxyXG4gICAgICAgICAgICB0aGlzLm1hcC5nZW9DYW52YXMuY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnJyArIHRoaXMuZGVmYXVsdFdpZHRoKVxyXG4gICAgICAgICAgICB0aGlzLm1hcC5nZW9DYW52YXMuY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJycgKyB0aGlzLmRlZmF1bHRIZWlnaHQpXHJcbiAgICAgICAgICAgIHRoaXMubWFwLnJlZHJhdygpXHJcbiAgICAgICAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gZmFsc2VcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW5GdWxsc2NyZWVuKHRoaXMubWFwLmNvbnRhaW5lcilcclxuICAgICAgICAgICAgLy9yZXNpemUgY2FudmFzIHRvIGZ1bGxzY3JlZW5cclxuICAgICAgICAgICAgdGhpcy5tYXAuaCA9IHdpbmRvdy5zY3JlZW4uaGVpZ2h0XHJcbiAgICAgICAgICAgIHRoaXMubWFwLncgPSB3aW5kb3cuc2NyZWVuLndpZHRoXHJcbiAgICAgICAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiBPcGVuIGZ1bGxzY3JlZW4gKi9cclxuICAgIG9wZW5GdWxsc2NyZWVuKGVsZW0pIHtcclxuICAgICAgICBpZiAoZWxlbS5yZXF1ZXN0RnVsbHNjcmVlbikge1xyXG4gICAgICAgICAgICBlbGVtLnJlcXVlc3RGdWxsc2NyZWVuKClcclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW0ud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHtcclxuICAgICAgICAgICAgLyogU2FmYXJpICovXHJcbiAgICAgICAgICAgIGVsZW0ud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XHJcbiAgICAgICAgICAgIC8qIElFMTEgKi9cclxuICAgICAgICAgICAgZWxlbS5tc1JlcXVlc3RGdWxsc2NyZWVuKClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyogQ2xvc2UgZnVsbHNjcmVlbiAqL1xyXG4gICAgY2xvc2VGdWxsc2NyZWVuKCkge1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5leGl0RnVsbHNjcmVlbikge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpXHJcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbikge1xyXG4gICAgICAgICAgICAvKiBTYWZhcmkgKi9cclxuICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbikge1xyXG4gICAgICAgICAgICAvKiBJRTExICovXHJcbiAgICAgICAgICAgIGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4oKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBCdXR0b24gfSBmcm9tICcuL0J1dHRvbi5qcydcclxuXHJcbi8qKlxyXG4gKiBCdXR0b24gZm9yIHRvZ2dsaW5nIGZ1bGxzY3JlZW4gbW9kZVxyXG4gKlxyXG4gKiBAbW9kdWxlIGJ1dHRvblxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgWm9vbUJ1dHRvbnMgZXh0ZW5kcyBCdXR0b24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuXHJcbiAgICAgICAgdGhpcy5vblpvb20gPSBvcHRzLm9uWm9vbSAvLyBjdXN0b20gdXNlciBldmVudCBoYW5kbGVyXHJcbiAgICAgICAgdGhpcy5kZWx0YSA9IG9wdHMuZGVsdGEgfHwgMC4yXHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSB6b29tIGluIGJ1dHRvblxyXG4gICAgICAgIHRoaXMuem9vbUluQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXHJcbiAgICAgICAgdGhpcy56b29tSW5CdG4uaWQgPSAnem9vbS1pbidcclxuICAgICAgICB0aGlzLnpvb21JbkJ0bi5jbGFzc05hbWUgPSAnZ3JpZHZpei16b29tLWJ1dHRvbidcclxuICAgICAgICB0aGlzLnpvb21JbkJ0bi50aXRsZSA9ICdab29tIGluJ1xyXG4gICAgICAgIHRoaXMuem9vbUluQnRuLnRleHRDb250ZW50ID0gJysnXHJcbiAgICAgICAgdGhpcy56b29tSW5CdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnpvb21JbihlKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy56b29tSW5CdG4uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnpvb21JbkJ0bi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnbGlnaHRncmV5J1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy56b29tSW5CdG4uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuem9vbUluQnRuLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZmZmZmZmJ1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSB6b29tIG91dCBidXR0b25cclxuICAgICAgICB0aGlzLnpvb21PdXRCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcclxuICAgICAgICB0aGlzLnpvb21PdXRCdG4uaWQgPSAnem9vbS1vdXQnXHJcbiAgICAgICAgdGhpcy56b29tT3V0QnRuLmNsYXNzTmFtZSA9ICdncmlkdml6LXpvb20tYnV0dG9uJ1xyXG4gICAgICAgIHRoaXMuem9vbU91dEJ0bi50aXRsZSA9ICdab29tIG91dCdcclxuICAgICAgICB0aGlzLnpvb21PdXRCdG4udGV4dENvbnRlbnQgPSAnLSdcclxuICAgICAgICB0aGlzLnpvb21PdXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnpvb21PdXQoZSlcclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuem9vbU91dEJ0bi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuem9vbU91dEJ0bi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnbGlnaHRncmV5J1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy56b29tT3V0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnpvb21PdXRCdG4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNmZmZmZmYnXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gU2V0IGNvbW1vbiBzdHlsZXMgZm9yIGJ1dHRvbnNcclxuICAgICAgICBjb25zdCBidXR0b25zID0gW3RoaXMuem9vbUluQnRuLCB0aGlzLnpvb21PdXRCdG5dXHJcbiAgICAgICAgYnV0dG9ucy5mb3JFYWNoKChidG4sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGJ0bi5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcidcclxuICAgICAgICAgICAgYnRuLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2NlbnRlcidcclxuICAgICAgICAgICAgYnRuLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcclxuICAgICAgICAgICAgYnRuLnN0eWxlLmJvcmRlciA9ICdub25lJ1xyXG4gICAgICAgICAgICBidG4uc3R5bGUuY29sb3IgPSAnYmxhY2snXHJcbiAgICAgICAgICAgIGJ0bi5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJ1xyXG4gICAgICAgICAgICBidG4uc3R5bGUudGV4dERlY29yYXRpb24gPSAnbm9uZSdcclxuICAgICAgICAgICAgYnRuLnN0eWxlLnBhZGRpbmcgPSAnNHB4J1xyXG4gICAgICAgICAgICBidG4uc3R5bGUuZm9udFNpemUgPSAnMjRweCdcclxuICAgICAgICAgICAgYnRuLnN0eWxlLmZvbnRXZWlnaHQgPSAnYm9sZCdcclxuICAgICAgICAgICAgYnRuLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSdcclxuICAgICAgICAgICAgYnRuLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZmZmZmZmJ1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIGJ0bi5zdHlsZS5ib3JkZXJCb3R0b20gPSAnMXB4IHNvbGlkIGdyZXknIC8vIFpvb20gaW4gYnV0dG9uIG9ubHlcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBVbnNldCBwYXJlbnQgY2xhc3MgaGVpZ2h0IGFuZCBkaXNwbGF5IGZvciBkdWFsIGJ1dHRvbnNcclxuICAgICAgICB0aGlzLnN0eWxlKCdoZWlnaHQnLCAndW5zZXQnKVxyXG4gICAgICAgIHRoaXMuc3R5bGUoJ2Rpc3BsYXknLCAndW5zZXQnKVxyXG5cclxuICAgICAgICAvLyBTZXQgcG9zaXRpb25cclxuICAgICAgICBpZiAob3B0cy54KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGUoJ2xlZnQnLCBvcHRzLnggKyAncHgnKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGUoJ3JpZ2h0JywgJzEwcHgnKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0cy55KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGUoJ3RvcCcsIG9wdHMueSArICdweCcpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZSgndG9wJywgJzEwcHgnKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIGJ1dHRvbnMgdG8gdGhlIGNvbnRhaW5lclxyXG4gICAgICAgIHRoaXMuZGl2Lm5vZGUoKS5hcHBlbmRDaGlsZCh0aGlzLnpvb21JbkJ0bilcclxuICAgICAgICB0aGlzLmRpdi5ub2RlKCkuYXBwZW5kQ2hpbGQodGhpcy56b29tT3V0QnRuKVxyXG4gICAgfVxyXG5cclxuICAgIC8qIFpvb20gaW4gKi9cclxuICAgIHpvb21JbihlKSB7XHJcbiAgICAgICAgdGhpcy5tYXAuc2V0Wm9vbSh0aGlzLm1hcC5nZXRab29tKCkgKiAoMSAtIHRoaXMuZGVsdGEpKS5yZWRyYXcoKVxyXG4gICAgICAgIGlmICh0aGlzLm9uWm9vbSkgdGhpcy5vblpvb20oZSlcclxuICAgICAgICBpZiAodGhpcy5tYXAuZ2VvQ2FudmFzLm9uWm9vbUZ1bikgdGhpcy5tYXAuZ2VvQ2FudmFzLm9uWm9vbUZ1bihlKVxyXG4gICAgfVxyXG5cclxuICAgIC8qIFpvb20gb3V0ICovXHJcbiAgICB6b29tT3V0KGUpIHtcclxuICAgICAgICB0aGlzLm1hcC5zZXRab29tKHRoaXMubWFwLmdldFpvb20oKSAqICgxICsgdGhpcy5kZWx0YSkpLnJlZHJhdygpXHJcbiAgICAgICAgaWYgKHRoaXMub25ab29tKSB0aGlzLm9uWm9vbShlKVxyXG4gICAgICAgIGlmICh0aGlzLm1hcC5nZW9DYW52YXMub25ab29tRnVuKSB0aGlzLm1hcC5nZW9DYW52YXMub25ab29tRnVuKGUpXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG4vKipcclxuICogQSBncmlkIGNlbGwuXHJcbiAqIEB0eXBlZGVmIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBDZWxsICovXHJcblxyXG4vKipcclxuICogQSBkYXRhc2V0IGNvbXBvbmVudCwgb2YgZ3JpZCBjZWxscy5cclxuICogQGFic3RyYWN0XHJcbiAqXHJcbiAqIEBtb2R1bGUgY29yZVxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRGF0YXNldCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9NYXAuanNcIikuTWFwfSBtYXAgVGhlIG1hcC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgZGF0YXNldC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSBkYXRhc2V0IHJlc29sdXRpb24sIGluIHRoZSBDUlMgZ2VvZ3JhcGhpY2FsIHVuaXQuXHJcbiAgICAgKiBAcGFyYW0ge3twcmVwcm9jZXNzPzpmdW5jdGlvbihDZWxsKTpib29sZWFuLCBtaXhlZFJlc29sdXRpb24/OmZ1bmN0aW9uKENlbGwpOm51bWJlcn19IG9wdHNcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYXAsIHVybCwgcmVzb2x1dGlvbiwgb3B0cyA9IHt9KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1hcC5cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQHR5cGUge2ltcG9ydChcIi4vTWFwLmpzXCIpLk1hcH0gKi9cclxuICAgICAgICB0aGlzLm1hcCA9IG1hcFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdXJsIG9mIHRoZSBkYXRhc2V0LlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMudXJsID0gdXJsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkYXRhc2V0IHJlc29sdXRpb24gaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbiBjYXNlIHRoZSBkYXRhc2V0IGlzIGEgZGF0YXNldCB3aXRoIGNlbGxzIGhhdmluZyBkaWZmZXJlbnQgcmVzb2x1dGlvbixcclxuICAgICAgICAgKiB0aGlzIGlzIHRoZSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHJlc29sdXRpb24gb2YgZWFjaCBjZWxsLlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAdHlwZSB7KGZ1bmN0aW9uKENlbGwpOm51bWJlciApfCB1bmRlZmluZWQgfSAqL1xyXG4gICAgICAgIHRoaXMubWl4ZWRSZXNvbHV0aW9uID0gb3B0cy5taXhlZFJlc29sdXRpb25cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBwcmVwcm9jZXNzIHRvIHJ1biBvbiBlYWNoIGNlbGwgYWZ0ZXIgbG9hZGluZy4gSXQgY2FuIGJlIHVzZWQgdG8gYXBwbHkgc29tZSBzcGVjaWZpYyB0cmVhdG1lbnQgYmVmb3JlIG9yIGNvbXB1dGUgYSBuZXcgY29sdW1uLiBBbmQgYWxzbyB0byBkZXRlcm1pbmUgd2hpY2ggY2VsbHMgdG8ga2VlcCBhZnRlciBsb2FkaW5nLlxyXG4gICAgICAgICAqIEB0eXBlIHsoZnVuY3Rpb24oQ2VsbCk6Ym9vbGVhbiApfCB1bmRlZmluZWQgfSAqL1xyXG4gICAgICAgIHRoaXMucHJlcHJvY2VzcyA9IG9wdHMucHJlcHJvY2VzcyB8fCB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgLyoqIFRoZSBjZWxscyB3aXRoaW4gdGhlIHZpZXdcclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxDZWxsPn0gKi9cclxuICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlID0gW11cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3QgZGF0YSB3aXRoaW4gYSBnZW9ncmFwaGljIGVudmVsb3BlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb0NhbnZhc1wiKS5FbnZlbG9wZXx1bmRlZmluZWR9IGV4dEdlb1xyXG4gICAgICogQHJldHVybnMge3RoaXN9XHJcbiAgICAgKi9cclxuICAgIGdldERhdGEoZXh0R2VvID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgZ2V0RGF0YSBub3QgaW1wbGVtZW50ZWQuJylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGwgdGhlIHZpZXcgY2FjaGUgd2l0aCBhbGwgY2VsbHMgd2hpY2ggYXJlIHdpdGhpbiBhIGdlb2dyYXBoaWNhbCBlbnZlbG9wZS5cclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb0NhbnZhc1wiKS5FbnZlbG9wZX0gZXh0R2VvIFRoZSB2aWV3IGdlb2dyYXBoaWNhbCBlbnZlbG9wZS5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVWaWV3Q2FjaGUoZXh0R2VvKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgdXBkYXRlVmlld0NhY2hlIG5vdCBpbXBsZW1lbnRlZC4nKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgY2VsbCB1bmRlciBhIGdpdmVuIHBvc2l0aW9uLCBpZiBhbnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBwb3NHZW9cclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPENlbGw+fSBjZWxscyBTb21lIGNlbGxzIGZyb20gdGhlIGRhdGFzZXQgKGEgc3Vic2V0IGlmIG5lY2Vzc2FyeSwgdXN1YWxseSB0aGUgdmlldyBjYWNoZSkuXHJcbiAgICAgKiBAcmV0dXJucyB7Q2VsbHx1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIGdldENlbGxGcm9tUG9zaXRpb24ocG9zR2VvLCBjZWxscykge1xyXG4gICAgICAgIC8vY29tcHV0ZSBjYW5kaWRhdGUgY2VsbCBwb3NpdGlvblxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIC8vY29uc3QgciA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgLy9jb25zdCBjZWxsWCA9IHIgKiBNYXRoLmZsb29yKHBvc0dlby54IC8gcilcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICAvL2NvbnN0IGNlbGxZID0gciAqIE1hdGguZmxvb3IocG9zR2VvLnkgLyByKVxyXG5cclxuICAgICAgICAvKi9nZXQgY2VsbFxyXG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICBpZiAoY2VsbC54ICE9IGNlbGxYKSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoY2VsbC55ICE9IGNlbGxZKSBjb250aW51ZVxyXG4gICAgICAgICAgICByZXR1cm4gY2VsbFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkKi9cclxuXHJcbiAgICAgICAgLy9yYXJlIGNhc2Ugb2YgbWl4ZWQgcmVzb2x1dGlvbiBkYXRhc2V0XHJcbiAgICAgICAgaWYgKHRoaXMubWl4ZWRSZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBjZWxscykge1xyXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgICAgICAgICBjb25zdCByID0gK3RoaXMubWl4ZWRSZXNvbHV0aW9uKGMpXHJcbiAgICAgICAgICAgICAgICBpZiAocG9zR2VvLnggPCBjLngpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjLnggKyByIDwgcG9zR2VvLngpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwb3NHZW8ueSA8IGMueSkgY29udGludWVcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMueSArIHIgPCBwb3NHZW8ueSkgY29udGludWVcclxuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIGNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbW1vbiBjYXNlXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLmdldFJlc29sdXRpb24oKVxyXG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICBpZiAocG9zR2VvLnggPCBjZWxsLngpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNlbGwueCArIHIgPCBwb3NHZW8ueCkgY29udGludWVcclxuICAgICAgICAgICAgZWxzZSBpZiAocG9zR2VvLnkgPCBjZWxsLnkpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNlbGwueSArIHIgPCBwb3NHZW8ueSkgY29udGludWVcclxuICAgICAgICAgICAgZWxzZSByZXR1cm4gY2VsbFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICB9XHJcblxyXG4gICAgLy9nZXR0ZXJzIGFuZCBzZXR0ZXJzXHJcblxyXG4gICAgLyoqIEByZXR1cm5zIHtudW1iZXJ9ICovXHJcbiAgICBnZXRSZXNvbHV0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdXRpb25cclxuICAgIH1cclxuXHJcbiAgICAvKiogQHJldHVybnMge0FycmF5LjxDZWxsPn0gKi9cclxuICAgIGdldFZpZXdDYWNoZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jZWxsc1ZpZXdDYWNoZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSByZWxldmFudCBkYXRhc2V0IGZvciBhIHNwZWNpZmllZCB6b29tLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5QaXhlbHNQZXJDZWxsXHJcbiAgICAgKiBAcmV0dXJucyB7RGF0YXNldHx1bmRlZmluZWR9XHJcbiAgICAgKiAqL1xyXG4gICAgZ2V0RGF0YXNldCh6LCBtaW5QaXhlbHNQZXJDZWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIGFuIGFic3RyYWN0IGNsYXNzIHVzZWQgdG8gZ3JvdXAgZWxlbWVudHMgc2hhcmVkIGJldHdlZW4gTGF5ZXIgYW5kIFN0eWxlIGNsYXNzZXMuXHJcbiAqXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAbW9kdWxlIGNvcmVcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERyYXdhYmxlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHNwZWNpZnlpbmcgaWYgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIHZpc2libGUgb3Igbm90LlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBwYXJhbWV0ZXIgaXMgdGhlIHpvb20gbGV2ZWwuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcik6Ym9vbGVhbn0gKi9cclxuICAgICAgICB0aGlzLnZpc2libGUgPSBvcHRzLnZpc2libGVcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBhbHBoYSAodHJhbnNwYXJlbmN5L29wYWNpdHkpLCBiZXR3ZWVuIDAuMCAoZnVsbHkgdHJhbnNwYXJlbnQpIGFuZCAxLjAgKGZ1bGx5IG9wYXF1ZSkuXHJcbiAgICAgICAgICogIFRoZSBmdW5jdGlvbiBwYXJhbWV0ZXIgaXMgdGhlIHpvb20gbGV2ZWwuXHJcbiAgICAgICAgICogKHNlZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ6IGdsb2JhbEFscGhhIHByb3BlcnR5KVxyXG4gICAgICAgICAqIEB0eXBlIHsoZnVuY3Rpb24obnVtYmVyKTpudW1iZXIpfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICB0aGlzLmFscGhhID0gb3B0cy5hbHBoYVxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGJsZW5kIG9wZXJhdGlvbi5cclxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gcGFyYW1ldGVyIGlzIHRoZSB6b29tIGxldmVsLlxyXG4gICAgICAgICAqIChzZWUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gcHJvcGVydHkpXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcik6R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9ufSAqL1xyXG4gICAgICAgIHRoaXMuYmxlbmRPcGVyYXRpb24gPSBvcHRzLmJsZW5kT3BlcmF0aW9uIHx8ICgoeikgPT4gJ3NvdXJjZS1vdmVyJylcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHsoZnVuY3Rpb24obnVtYmVyKTpzdHJpbmcpfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICB0aGlzLmZpbHRlckNvbG9yID0gb3B0cy5maWx0ZXJDb2xvciAvLyAoeikgPT4gXCIjZWVlN1wiXHJcbiAgICAgICAgLyoqIEB0eXBlIHsoZnVuY3Rpb24obnVtYmVyKTpHbG9iYWxDb21wb3NpdGVPcGVyYXRpb258XCJub25lXCIpfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICB0aGlzLmZpbHRlckJsZW5kT3BlcmF0aW9uID0gb3B0cy5maWx0ZXJCbGVuZE9wZXJhdGlvbiAvLyAoeikgPT4gXCJtdWx0aXBseVwiXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGxheWVyIGZpbHRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvQ2FudmFzLmpzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzIFRoZSBjYW52YXMgd2hlcmUgdG8gZHJhdyB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICovXHJcbiAgICBkcmF3RmlsdGVyKGdlb0NhbnZhcykge1xyXG4gICAgICAgIC8vbm8gZmlsdGVyOiByZXR1cm5cclxuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyQ29sb3IpIHJldHVyblxyXG5cclxuICAgICAgICAvL2dldCBmaWx0ZXJcclxuICAgICAgICBjb25zdCBmYyA9IHRoaXMuZmlsdGVyQ29sb3IoZ2VvQ2FudmFzLnZpZXcueilcclxuXHJcbiAgICAgICAgLy9ubyBmaWx0ZXI6IHJldHVyblxyXG4gICAgICAgIGlmICghZmMgfHwgZmMgPT0gJ25vbmUnKSByZXR1cm5cclxuXHJcbiAgICAgICAgLy9kcmF3IGZpbHRlclxyXG5cclxuICAgICAgICAvL3NldCBjb2xvclxyXG4gICAgICAgIGdlb0NhbnZhcy5vZmZzY3JlZW5DdHguZmlsbFN0eWxlID0gZmNcclxuXHJcbiAgICAgICAgLy9zYXZlIGJsZW5kIG1vZGUgYW5kIHNldCBuZXcsIGlmIGFueVxyXG4gICAgICAgIGxldCBibyA9IHVuZGVmaW5lZCwgYm8yID0gdW5kZWZpbmVkXHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyQmxlbmRPcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgYm8gPSBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxyXG4gICAgICAgICAgICBibzIgPSB0aGlzLmZpbHRlckJsZW5kT3BlcmF0aW9uKGdlb0NhbnZhcy52aWV3LnopXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChibzIgJiYgYm8yICE9IFwibm9uZVwiKSBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJvMjtcclxuXHJcbiAgICAgICAgLy9kcmF3XHJcbiAgICAgICAgZ2VvQ2FudmFzLm9mZnNjcmVlbkN0eC5maWxsUmVjdCgwLCAwLCBnZW9DYW52YXMudywgZ2VvQ2FudmFzLmgpXHJcblxyXG4gICAgICAgIC8vcmVzdG9yZSBibGVuZCBtb2RlXHJcbiAgICAgICAgaWYgKGJvKSBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJvO1xyXG5cclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbi8qKiBAdHlwZWRlZiB7IHt4TWluOiBudW1iZXIsIHhNYXg6IG51bWJlciwgeU1pbjogbnVtYmVyLCB5TWF4OiBudW1iZXJ9IH0gRW52ZWxvcGUgKi9cclxuXHJcbi8qKlxyXG4gKiBBIHZpZXdzaGVkLlxyXG4gKiBAdHlwZWRlZiB7e3g6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXJ9fSBWaWV3ICovXHJcblxyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IHpvb20gYXMgZDN6b29tLCB6b29tSWRlbnRpdHkgfSBmcm9tICdkMy16b29tJ1xyXG5cclxuLyoqXHJcbiAqIEEgSFRNTCBjYW52YXMgZm9yIGdlbyBkYXRhIGRpc3BsYXksIGVuaGFuY2VkIHdpdGggem9vbSBhbmQgcGFuIGNhcGFiaWxpdGllcy5cclxuICpcclxuICogQG1vZHVsZSBjb3JlXHJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHZW9DYW52YXMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgdmlld1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgdmlld1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHogVGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXcgKHBpeGVsIHNpemUsIGluIGdyb3VuZCBtKVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY2FudmFzLCB4ID0gMCwgeSA9IDAsIHogPSAwLCBvcHRzID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSAqL1xyXG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMudyA9IHRoaXMuY2FudmFzLm9mZnNldFdpZHRoXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5oID0gdGhpcy5jYW52YXMub2Zmc2V0SGVpZ2h0XHJcblxyXG4gICAgICAgIC8vIEFkanVzdCBjYW52YXMgd2lkdGggYW5kIGhlaWdodCBiYXNlZCBvbiBkZXZpY2UgcGl4ZWwgcmF0aW9cclxuICAgICAgICAvL2NvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEgLy8gR2V0IHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW9cclxuICAgICAgICAvL3RoaXMuY2FudmFzLndpZHRoID0gdGhpcy53ICogZHByIC8vIFNldCBjYW52YXMgd2lkdGhcclxuICAgICAgICAvL1xcc3RoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuaCAqIGRwciAvLyBTZXQgY2FudmFzIGhlaWdodFxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgb2Zmc2NyZWVuIGNhbnZhcyBmb3IgZHJhd2luZyBvcGVyYXRpb25zXHJcbiAgICAgICAgdGhpcy5vZmZzY3JlZW5DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxyXG4gICAgICAgIHRoaXMub2Zmc2NyZWVuQ2FudmFzLndpZHRoID0gdGhpcy53XHJcbiAgICAgICAgdGhpcy5vZmZzY3JlZW5DYW52YXMuaGVpZ2h0ID0gdGhpcy5oXHJcblxyXG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJylcclxuICAgICAgICBjb25zdCBvZmZzY3JlZW5DdHggPSB0aGlzLm9mZnNjcmVlbkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXHJcbiAgICAgICAgaWYgKCFjdHgpIHRocm93ICdJbXBvc3NpYmxlIHRvIGNyZWF0ZSBjYW52YXMgMkQgY29udGV4dCdcclxuICAgICAgICBpZiAoIW9mZnNjcmVlbkN0eCkgdGhyb3cgJ0ltcG9zc2libGUgdG8gY3JlYXRlIGNhbnZhcyAyRCBjb250ZXh0J1xyXG4gICAgICAgIC8qKkB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovXHJcbiAgICAgICAgdGhpcy5jdHggPSBjdHhcclxuICAgICAgICB0aGlzLm9mZnNjcmVlbkN0eCA9IG9mZnNjcmVlbkN0eFxyXG4gICAgICAgIC8vdGhpcy5jdHguc2NhbGUoZHByLCBkcHIpIC8vIFNjYWxlIHRoZSBjb250ZXh0XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHo6IHBpeGVsIHNpemUsIGluIG0vcGl4XHJcbiAgICAgICAgICogQHR5cGUge1ZpZXd9ICAqL1xyXG4gICAgICAgIHRoaXMudmlldyA9IHsgeDogeCwgeTogeSwgejogeiB9XHJcblxyXG4gICAgICAgIC8qKiBCYWNrZ3JvdW5kIGNvbG9yLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRzLmJhY2tncm91bmRDb2xvciB8fCAnd2hpdGUnXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24ob2JqZWN0fHVuZGVmaW5lZCk6dm9pZH0gKi9cclxuICAgICAgICB0aGlzLm9uWm9vbVN0YXJ0RnVuID0gb3B0cy5vblpvb21TdGFydEZ1blxyXG5cclxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKG9iamVjdHx1bmRlZmluZWQpOnZvaWR9ICovXHJcbiAgICAgICAgdGhpcy5vblpvb21FbmRGdW4gPSBvcHRzLm9uWm9vbUVuZEZ1blxyXG5cclxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKG9iamVjdHx1bmRlZmluZWQpOnZvaWR9ICovXHJcbiAgICAgICAgdGhpcy5vblpvb21GdW4gPSBvcHRzLm9uWm9vbUZ1blxyXG5cclxuICAgICAgICAvL2N1cnJlbnQgZXh0ZW50XHJcbiAgICAgICAgLyoqIEB0eXBlIHtFbnZlbG9wZX0gKi9cclxuICAgICAgICB0aGlzLmV4dEdlbyA9IHsgeE1pbjogTmFOLCB4TWF4OiBOYU4sIHlNaW46IE5hTiwgeU1heDogTmFOIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXHJcblxyXG4gICAgICAgIC8vcmVseSBvbiBkMyBmb3Igem9vbVxyXG4gICAgICAgIGlmICghb3B0cy5kaXNhYmxlWm9vbSkge1xyXG4gICAgICAgICAgICBsZXQgdFAgPSB6b29tSWRlbnRpdHlcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBsZXQgZGVib3VuY2VUaW1lb3V0ID0gbnVsbCAvLyBBZGQgYSBkZWJvdW5jZSB0aW1lb3V0IHZhcmlhYmxlXHJcbiAgICAgICAgICAgIGNvbnN0IHogPSBkM3pvb20oKVxyXG4gICAgICAgICAgICAgICAgLy8gdG8gbWFrZSB0aGUgem9vbWluZyBhIGJpdCBmYXN0ZXJcclxuICAgICAgICAgICAgICAgIC53aGVlbERlbHRhKChlKSA9PiAtZS5kZWx0YVkgKiAoZS5kZWx0YU1vZGUgPT09IDEgPyAwLjA3IDogZS5kZWx0YU1vZGUgPyAxIDogMC4wMDQpKVxyXG4gICAgICAgICAgICAgICAgLm9uKCd6b29tJywgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZS50cmFuc2Zvcm1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB6b29tRmFjdG9yID0gdFAuayAvIHQua1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh6b29tRmFjdG9yID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9wYW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHggPSB0UC54IC0gdC54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5ID0gdFAueSAtIHQueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhbihkeCAqIHRoaXMudmlldy56LCAtZHkgKiB0aGlzLnZpZXcueilcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVab29tKGUsIHpvb21GYWN0b3IpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRQID0gdFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vblpvb21GdW4pIHRoaXMub25ab29tRnVuKGUpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdzdGFydCcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgb2Ygem9vbSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgdGhlIGN1cnJlbnQgY2FudmFzIHN0YXRlIHRvIGtlZXAgb25zY3JlZW4gZHVyaW5nIHBhbi96b29tIGJlZm9yZSByZWRyYXdpbmdcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmMuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcnICsgdGhpcy53KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5jLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJycgKyB0aGlzLmgpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmMuZ2V0Q29udGV4dCgnMmQnKT8uZHJhd0ltYWdlKHRoaXMuY2FudmFzLCAwLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5keCA9IDBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZHkgPSAwXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmYgPSAxXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub25ab29tU3RhcnRGdW4pIHRoaXMub25ab29tU3RhcnRGdW4oZSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIG9mIHBhbi96b29tIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRyYXcoKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZSA9IHsgYzogbnVsbCwgZHg6IDAsIGR5OiAwLCBmOiAxIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub25ab29tRW5kRnVuKSB0aGlzLm9uWm9vbUVuZEZ1bihlKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICB6KHNlbGVjdCh0aGlzLmNhbnZhcykpXHJcblxyXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVab29tID0gKGV2ZW50LCB6b29tRmFjdG9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBjYW5jZWwgb25nb2luZyBkYXRhIHJlcXVlc3RzXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbEN1cnJlbnRSZXF1ZXN0cygpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZSA9IGV2ZW50LnNvdXJjZUV2ZW50XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlIGluc3RhbmNlb2YgV2hlZWxFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vem9vbSBhdCB0aGUgbW91c2UgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb20oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb21GYWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5waXhUb0dlb1goc2Uub2Zmc2V0WCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5waXhUb0dlb1koc2Uub2Zmc2V0WSlcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlIGluc3RhbmNlb2YgVG91Y2hFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSB0b3VjaGVzXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR4ID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHkgPSAwXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHQgb2Ygc2UudGFyZ2V0VG91Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eCArPSB0dC5jbGllbnRYXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5ICs9IHR0LmNsaWVudFlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHggLz0gc2UudGFyZ2V0VG91Y2hlcy5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICB0eSAvPSBzZS50YXJnZXRUb3VjaGVzLmxlbmd0aFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGp1c3QgZm9yIGNvbnRhaW5lcidzIG9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHR4IC09IGNvbnRhaW5lclJlY3QubGVmdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHR5IC09IGNvbnRhaW5lclJlY3QudG9wXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vem9vbSBhdCB0aGlzIGF2ZXJhZ2UgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb20oem9vbUZhY3RvciwgdGhpcy5waXhUb0dlb1godHgpLCB0aGlzLnBpeFRvR2VvWSh0eSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2VudGVyIGV4dGVudFxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICB0aGlzLnhNaW4gPSBvcHRzLmNlbnRlckV4dGVudCA/IG9wdHMuY2VudGVyRXh0ZW50WzBdIDogdW5kZWZpbmVkXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgIHRoaXMueU1pbiA9IG9wdHMuY2VudGVyRXh0ZW50ID8gb3B0cy5jZW50ZXJFeHRlbnRbMV0gOiB1bmRlZmluZWRcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgdGhpcy54TWF4ID0gb3B0cy5jZW50ZXJFeHRlbnQgPyBvcHRzLmNlbnRlckV4dGVudFsyXSA6IHVuZGVmaW5lZFxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICB0aGlzLnlNYXggPSBvcHRzLmNlbnRlckV4dGVudCA/IG9wdHMuY2VudGVyRXh0ZW50WzNdIDogdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8qKiBab29tIGV4dGVudCwgdG8gbGltaXQgem9vbSBpbiBhbmQgb3V0XHJcbiAgICAgICAgICogIEB0eXBlIHtBcnJheS48bnVtYmVyPn0gKi9cclxuICAgICAgICB0aGlzLnpvb21FeHRlbnQgPSBvcHRzLnpvb21FeHRlbnQgfHwgWzAsIEluZmluaXR5XVxyXG5cclxuICAgICAgICAvKiogQ2FudmFzIHN0YXRlLCB0byBiZSB1c2VkIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJlZHJhd3Mgb24gem9vbS9wYW5cclxuICAgICAgICAgKiAgQHR5cGUge3tjOkhUTUxDYW52YXNFbGVtZW50fG51bGwsZHg6bnVtYmVyLGR5Om51bWJlcixmOm51bWJlcn19ICovXHJcbiAgICAgICAgdGhpcy5jYW52YXNTYXZlID0geyBjOiBudWxsLCBkeDogMCwgZHk6IDAsIGY6IDEgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcmV0dXJucyB7Vmlld30gKi9cclxuICAgIGdldFZpZXcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ICovXHJcbiAgICBzZXRDZW50ZXJFeHRlbnQodikge1xyXG4gICAgICAgIHRoaXMueE1pbiA9IHZbMF1cclxuICAgICAgICB0aGlzLnlNaW4gPSB2WzFdXHJcbiAgICAgICAgdGhpcy54TWF4ID0gdlsyXVxyXG4gICAgICAgIHRoaXMueU1heCA9IHZbM11cclxuICAgIH1cclxuICAgIC8qKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcnx1bmRlZmluZWQ+fSAqL1xyXG4gICAgZ2V0Q2VudGVyRXh0ZW50KCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy54TWluLCB0aGlzLnlNaW4sIHRoaXMueE1heCwgdGhpcy55TWF4XVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ICovXHJcbiAgICBzZXRab29tRXh0ZW50KHYpIHtcclxuICAgICAgICB0aGlzLnpvb21FeHRlbnQgPSB2XHJcbiAgICB9XHJcbiAgICAvKiogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSAqL1xyXG4gICAgZ2V0Wm9vbUV4dGVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy56b29tRXh0ZW50XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEluaXRpYWxpc2UgY2FudmFzIHRyYW5zZm9ybSB3aXRoIGlkZW50aXR5IHRyYW5zZm9ybWF0aW9uLiAqL1xyXG4gICAgaW5pdENhbnZhc1RyYW5zZm9ybSgpIHtcclxuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMClcclxuICAgICAgICB0aGlzLm9mZnNjcmVlbkN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMClcclxuICAgIH1cclxuXHJcbiAgICAvKiogSW5pdGlhbGlzZSBjYW52YXMgdHJhbnNmb3JtIHdpdGggZ2VvIHRvIHNjcmVlbiB0cmFuc2Zvcm1hdGlvbiwgc28gdGhhdCBnZW8gb2JqZWN0cyBjYW4gYmUgZHJhd24gZGlyZWN0bHkgaW4gZ2VvIGNvb3JkaW5hdGVzLiAqL1xyXG4gICAgc2V0Q2FudmFzVHJhbnNmb3JtKCkge1xyXG4gICAgICAgIGNvbnN0IGsgPSAxIC8gdGhpcy52aWV3LnpcclxuICAgICAgICBjb25zdCB0eCA9IC10aGlzLnZpZXcueCAvIHRoaXMudmlldy56ICsgdGhpcy53ICogMC41XHJcbiAgICAgICAgY29uc3QgdHkgPSB0aGlzLnZpZXcueSAvIHRoaXMudmlldy56ICsgdGhpcy5oICogMC41XHJcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKGssIDAsIDAsIC1rLCB0eCwgdHkpXHJcbiAgICAgICAgdGhpcy5vZmZzY3JlZW5DdHguc2V0VHJhbnNmb3JtKGssIDAsIDAsIC1rLCB0eCwgdHkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldCB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIHdlYkdMIHNjcmVlbiBjb29yZGluYXRlcywgd2l0aGluIFstMSwxXSpbLTEsMV0gKi9cclxuICAgIGdldFdlYkdMVHJhbnNmb3JtKCkge1xyXG4gICAgICAgIGNvbnN0IGt4ID0gMi4wIC8gKHRoaXMudyAqIHRoaXMudmlldy56KVxyXG4gICAgICAgIGNvbnN0IGt5ID0gMi4wIC8gKHRoaXMuaCAqIHRoaXMudmlldy56KVxyXG4gICAgICAgIHJldHVybiBba3gsIDAuMCwgMC4wLCAwLjAsIGt5LCAwLjAsIC1reCAqIHRoaXMudmlldy54LCAta3kgKiB0aGlzLnZpZXcueSwgMS4wXVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgZnVuY3Rpb24gc3BlY2lmeWluZyBob3cgdG8gZHJhdyB0aGUgbWFwLiAqL1xyXG4gICAgcmVkcmF3KCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIHJlZHJhdyBub3QgaW1wbGVtZW50ZWQuJylcclxuICAgIH1cclxuXHJcbiAgICAvKiogV2hlbiB0aGUgem9vbSBsZXZlbCBjaGFuZ2VzLCBlbnN1cmVzIHRoYXQgYW55IG9uZ29pbmcgcmVxdWVzdHMgYXJlIGFib3J0ZWQgYmVmb3JlIG5ldyBvbmVzIGFyZSBpbml0aWF0ZWQuICovXHJcbiAgICBjYW5jZWxDdXJyZW50UmVxdWVzdHMoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgY2FuY2VsQ3VycmVudFJlcXVlc3RzIG5vdCBpbXBsZW1lbnRlZC4nKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIuIFRvIGJlIHVzZWQgYmVmb3JlIGEgcmVkcmF3IGZvciBleGFtcGxlLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKGNvbG9yID0gJ3doaXRlJykge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdHMudHJhbnNwYXJlbnRCYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaClcclxuICAgICAgICAgICAgdGhpcy5vZmZzY3JlZW5DdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMudywgdGhpcy5oKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN0eCkgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3JcclxuICAgICAgICAgICAgaWYgKHRoaXMub2Zmc2NyZWVuQ3R4KSB0aGlzLm9mZnNjcmVlbkN0eC5maWxsU3R5bGUgPSBjb2xvclxyXG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLncsIHRoaXMuaClcclxuICAgICAgICAgICAgdGhpcy5vZmZzY3JlZW5DdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53LCB0aGlzLmgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR4R2VvXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHlHZW9cclxuICAgICAqL1xyXG4gICAgcGFuKGR4R2VvID0gMCwgZHlHZW8gPSAwKSB7XHJcbiAgICAgICAgLy9lbnN1cmVzIHgveSBleHRlbnRcclxuICAgICAgICBpZiAodGhpcy54TWluICE9IHVuZGVmaW5lZCAmJiB0aGlzLnZpZXcueCArIGR4R2VvIDwgdGhpcy54TWluKSBkeEdlbyA9IHRoaXMueE1pbiAtIHRoaXMudmlldy54XHJcbiAgICAgICAgaWYgKHRoaXMueU1pbiAhPSB1bmRlZmluZWQgJiYgdGhpcy52aWV3LnkgKyBkeUdlbyA8IHRoaXMueU1pbikgZHlHZW8gPSB0aGlzLnlNaW4gLSB0aGlzLnZpZXcueVxyXG4gICAgICAgIGlmICh0aGlzLnhNYXggIT0gdW5kZWZpbmVkICYmIHRoaXMudmlldy54ICsgZHhHZW8gPiB0aGlzLnhNYXgpIGR4R2VvID0gdGhpcy54TWF4IC0gdGhpcy52aWV3LnhcclxuICAgICAgICBpZiAodGhpcy55TWF4ICE9IHVuZGVmaW5lZCAmJiB0aGlzLnZpZXcueSArIGR5R2VvID4gdGhpcy55TWF4KSBkeUdlbyA9IHRoaXMueU1heCAtIHRoaXMudmlldy55XHJcblxyXG4gICAgICAgIC8vcGFuXHJcbiAgICAgICAgdGhpcy52aWV3LnggKz0gZHhHZW9cclxuICAgICAgICB0aGlzLnZpZXcueSArPSBkeUdlb1xyXG4gICAgICAgIHRoaXMudXBkYXRlRXh0ZW50R2VvKClcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzU2F2ZS5jKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gMSAvIHRoaXMudmlldy56XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgc2F2ZWQgY2FudmFzIG9mZnNldFxyXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZHggLT0gZHhHZW8gKiBzY2FsZVxyXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZHkgKz0gZHlHZW8gKiBzY2FsZVxyXG5cclxuICAgICAgICAgICAgLy8gY2xlYXIgY2FudmFzXHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXIodGhpcy5iYWNrZ3JvdW5kQ29sb3IpXHJcblxyXG4gICAgICAgICAgICAvLyB0aGlzIGRvZXNudCB3b3JrIG9uIG1vYmlsZSBodHRwczovL2dpdGh1Yi5jb20vZXVyb3N0YXQvZ3JpZHZpei9pc3N1ZXMvOThcclxuICAgICAgICAgICAgLy90aGlzLmN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXNTYXZlLmMsIHRoaXMuY2FudmFzU2F2ZS5keCwgdGhpcy5jYW52YXNTYXZlLmR5KVxyXG4gICAgICAgICAgICB0aGlzLm9mZnNjcmVlbkN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXNTYXZlLmMsIHRoaXMuY2FudmFzU2F2ZS5keCwgdGhpcy5jYW52YXNTYXZlLmR5KVxyXG5cclxuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBvZmZzY3JlZW4gY2FudmFzIHRvIHRoZSB2aXNpYmxlIGNvbnRleHRcclxuICAgICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMub2Zmc2NyZWVuQ3R4LmNhbnZhcywgMCwgMClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbm8gY2FudmFzIHNhdmUnKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFpvb20uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZiBUaGUgem9vbSBmYWN0b3IsIHdpdGhpbiBdMCwgSW5maW5pdHldLiAxIGlzIGZvciBubyBjaGFuZ2UuIDwxIHRvIHpvb20taW4sID4xIHRvIHpvb20tb3V0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhHZW8gVGhlIHggZ2VvIHBvc2l0aW9uIGZpeGVkIGluIHRoZSBzY3JlZW4uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geUdlbyBUaGUgeSBnZW8gcG9zaXRpb24gZml4ZWQgaW4gdGhlIHNjcmVlbi5cclxuICAgICAqL1xyXG4gICAgem9vbShmID0gMSwgeEdlbyA9IHRoaXMudmlldy54LCB5R2VvID0gdGhpcy52aWV3LnkpIHtcclxuICAgICAgICAvL1RPRE8gZm9yY2UgZ2VvIGV4dGVuZCB0byByZW1haW5cclxuXHJcbiAgICAgICAgLy90cnlpbmcgdG8gem9vbSBpbi9vdXQgYmV5b25kIGxpbWl0XHJcbiAgICAgICAgaWYgKHRoaXMuem9vbUV4dGVudFswXSA9PSB0aGlzLnZpZXcueiAmJiBmIDw9IDEpIHJldHVyblxyXG4gICAgICAgIGlmICh0aGlzLnpvb21FeHRlbnRbMV0gPT0gdGhpcy52aWV3LnogJiYgZiA+PSAxKSByZXR1cm5cclxuXHJcbiAgICAgICAgLy9lbnN1cmUgem9vbSBleHRlbnQgcHJlc2VydmVkXHJcbiAgICAgICAgY29uc3QgbmV3WmYgPSBmICogdGhpcy52aWV3LnpcclxuICAgICAgICBpZiAobmV3WmYgPCB0aGlzLnpvb21FeHRlbnRbMF0pIGYgPSB0aGlzLnpvb21FeHRlbnRbMF0gLyB0aGlzLnZpZXcuelxyXG4gICAgICAgIGlmIChuZXdaZiA+IHRoaXMuem9vbUV4dGVudFsxXSkgZiA9IHRoaXMuem9vbUV4dGVudFsxXSAvIHRoaXMudmlldy56XHJcblxyXG4gICAgICAgIHRoaXMudmlldy56ICo9IGZcclxuXHJcbiAgICAgICAgLy9jb21wdXRlIHBhblxyXG4gICAgICAgIGxldCBkeEdlbyA9ICh4R2VvIC0gdGhpcy52aWV3LngpICogKDEgLSBmKVxyXG4gICAgICAgIGxldCBkeUdlbyA9ICh5R2VvIC0gdGhpcy52aWV3LnkpICogKDEgLSBmKVxyXG5cclxuICAgICAgICAvL2Vuc3VyZXMgeC95IGV4dGVudFxyXG4gICAgICAgIGlmICh0aGlzLnhNaW4gIT0gdW5kZWZpbmVkICYmIHRoaXMudmlldy54ICsgZHhHZW8gPCB0aGlzLnhNaW4pIGR4R2VvID0gdGhpcy54TWluIC0gdGhpcy52aWV3LnhcclxuICAgICAgICBpZiAodGhpcy55TWluICE9IHVuZGVmaW5lZCAmJiB0aGlzLnZpZXcueSArIGR5R2VvIDwgdGhpcy55TWluKSBkeUdlbyA9IHRoaXMueU1pbiAtIHRoaXMudmlldy55XHJcbiAgICAgICAgaWYgKHRoaXMueE1heCAhPSB1bmRlZmluZWQgJiYgdGhpcy52aWV3LnggKyBkeEdlbyA+IHRoaXMueE1heCkgZHhHZW8gPSB0aGlzLnhNYXggLSB0aGlzLnZpZXcueFxyXG4gICAgICAgIGlmICh0aGlzLnlNYXggIT0gdW5kZWZpbmVkICYmIHRoaXMudmlldy55ICsgZHlHZW8gPiB0aGlzLnlNYXgpIGR5R2VvID0gdGhpcy55TWF4IC0gdGhpcy52aWV3LnlcclxuXHJcbiAgICAgICAgLy9wYW5cclxuICAgICAgICB0aGlzLnZpZXcueCArPSBkeEdlb1xyXG4gICAgICAgIHRoaXMudmlldy55ICs9IGR5R2VvXHJcbiAgICAgICAgdGhpcy51cGRhdGVFeHRlbnRHZW8oKVxyXG5cclxuICAgICAgICAvLyB6b29tIGluIG9uIHRoZSBjdXJyZW50IGNhbnZhcyBzdGF0ZVxyXG4gICAgICAgIGlmICh0aGlzLmNhbnZhc1NhdmUuYykge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyKHRoaXMuYmFja2dyb3VuZENvbG9yKVxyXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZiAvPSBmXHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5keCA9IHRoaXMuZ2VvVG9QaXhYKHhHZW8pICogKDEgLSB0aGlzLmNhbnZhc1NhdmUuZilcclxuICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmR5ID0gdGhpcy5nZW9Ub1BpeFkoeUdlbykgKiAoMSAtIHRoaXMuY2FudmFzU2F2ZS5mKVxyXG4gICAgICAgICAgICB0aGlzLmNsZWFyKHRoaXMuYmFja2dyb3VuZENvbG9yKVxyXG4gICAgICAgICAgICB0aGlzLm9mZnNjcmVlbkN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuYyxcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5keCxcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5keSxcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5mICogdGhpcy5jYW52YXNTYXZlLmMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZiAqIHRoaXMuY2FudmFzU2F2ZS5jLmhlaWdodFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2NyZWVuQ2FudmFzLCAvLyBVc2Ugb2Zmc2NyZWVuIGNhbnZhcyBhcyB0aGUgc291cmNlXHJcbiAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgMCwgLy8gUG9zaXRpb24gdGhlIG9mZnNjcmVlbiBjYW52YXMgYXQgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgbWFpbiBjYW52YXNcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoLCAvLyBUaGUgd2lkdGggb2YgdGhlIHZpc2libGUgY2FudmFzXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgLy8gVGhlIGhlaWdodCBvZiB0aGUgdmlzaWJsZSBjYW52YXNcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXJnaW5QeFxyXG4gICAgICogQHJldHVybnMge0VudmVsb3BlfSBUaGUgZW52ZWxvcGUgb2YgdGhlIHZpZXcsIGluIGdlbyBjb29yZGluYXRlcy5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlRXh0ZW50R2VvKG1hcmdpblB4ID0gMjApIHtcclxuICAgICAgICB0aGlzLmV4dEdlbyA9IHtcclxuICAgICAgICAgICAgeE1pbjogdGhpcy5waXhUb0dlb1goLW1hcmdpblB4KSxcclxuICAgICAgICAgICAgeE1heDogdGhpcy5waXhUb0dlb1godGhpcy53ICsgbWFyZ2luUHgpLFxyXG4gICAgICAgICAgICB5TWluOiB0aGlzLnBpeFRvR2VvWSh0aGlzLmggKyBtYXJnaW5QeCksXHJcbiAgICAgICAgICAgIHlNYXg6IHRoaXMucGl4VG9HZW9ZKC1tYXJnaW5QeCksXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmV4dEdlb1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlIG9iamVjdCBoYXMgdG8gYmUgZHJhd25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3t4Om51bWJlcix5Om51bWJlcn19IG9ialxyXG4gICAgICovXHJcbiAgICB0b0RyYXcob2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai54IDwgdGhpcy5leHRHZW8ueE1pbikgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgaWYgKG9iai54ID4gdGhpcy5leHRHZW8ueE1heCkgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgaWYgKG9iai55IDwgdGhpcy5leHRHZW8ueU1pbikgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgaWYgKG9iai55ID4gdGhpcy5leHRHZW8ueU1heCkgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuXHJcbiAgICAvL2NvbnZlcnNpb24gZnVuY3Rpb25zXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4R2VvIEdlbyB4IGNvb3JkaW5hdGUsIGluIG0uXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTY3JlZW4geCBjb29yZGluYXRlLCBpbiBwaXguXHJcbiAgICAgKi9cclxuICAgIGdlb1RvUGl4WCh4R2VvKSB7XHJcbiAgICAgICAgcmV0dXJuICh4R2VvIC0gdGhpcy52aWV3LngpIC8gdGhpcy52aWV3LnogKyB0aGlzLncgKiAwLjVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlHZW8gR2VvIHkgY29vcmRpbmF0ZSwgaW4gbS5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNjcmVlbiB5IGNvb3JkaW5hdGUsIGluIHBpeC5cclxuICAgICAqL1xyXG4gICAgZ2VvVG9QaXhZKHlHZW8pIHtcclxuICAgICAgICByZXR1cm4gLSh5R2VvIC0gdGhpcy52aWV3LnkpIC8gdGhpcy52aWV3LnogKyB0aGlzLmggKiAwLjVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggU2NyZWVuIHggY29vcmRpbmF0ZSwgaW4gcGl4LlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gR2VvIHggY29vcmRpbmF0ZSwgaW4gbS5cclxuICAgICAqL1xyXG4gICAgcGl4VG9HZW9YKHgpIHtcclxuICAgICAgICByZXR1cm4gKHggLSB0aGlzLncgKiAwLjUpICogdGhpcy52aWV3LnogKyB0aGlzLnZpZXcueFxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBTY3JlZW4geSBjb29yZGluYXRlLCBpbiBwaXguXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBHZW8geSBjb29yZGluYXRlLCBpbiBtLlxyXG4gICAgICovXHJcbiAgICBwaXhUb0dlb1koeSkge1xyXG4gICAgICAgIHJldHVybiAtKHkgLSB0aGlzLmggKiAwLjUpICogdGhpcy52aWV3LnogKyB0aGlzLnZpZXcueVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgeCx5LHogZWxlbWVudHMgZnJvbSBVUkwgYW5kIGFzc2lnbiB0aGVtIHRvIHRoZSB2aWV3LiAqL1xyXG4gICAgc2V0Vmlld0Zyb21VUkwoKSB7XHJcbiAgICAgICAgY29uc3QgeCA9IEdlb0NhbnZhcy5nZXRQYXJhbWV0ZXJCeU5hbWUoJ3gnKSxcclxuICAgICAgICAgICAgeSA9IEdlb0NhbnZhcy5nZXRQYXJhbWV0ZXJCeU5hbWUoJ3knKSxcclxuICAgICAgICAgICAgeiA9IEdlb0NhbnZhcy5nZXRQYXJhbWV0ZXJCeU5hbWUoJ3onKVxyXG4gICAgICAgIGlmICh4ICE9IG51bGwgJiYgeCAhPSB1bmRlZmluZWQgJiYgIWlzTmFOKCt4KSkgdGhpcy52aWV3LnggPSAreFxyXG4gICAgICAgIGlmICh5ICE9IG51bGwgJiYgeSAhPSB1bmRlZmluZWQgJiYgIWlzTmFOKCt5KSkgdGhpcy52aWV3LnkgPSAreVxyXG4gICAgICAgIGlmICh6ICE9IG51bGwgJiYgeiAhPSB1bmRlZmluZWQgJiYgIWlzTmFOKCt6KSkgdGhpcy52aWV3LnogPSArelxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgVVJMIHBhcmFtZXRlciBieSBuYW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFBhcmFtZXRlckJ5TmFtZShuYW1lKSB7XHJcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvW1xcW10vLCAnXFxcXFsnKS5yZXBsYWNlKC9bXFxdXS8sICdcXFxcXScpXHJcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnW1xcXFw/Jl0nICsgbmFtZSArICc9KFteJiNdKiknKSxcclxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlZ2V4LmV4ZWMobG9jYXRpb24uc2VhcmNoKVxyXG4gICAgICAgIHJldHVybiAhcmVzdWx0cyA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgJyAnKSlcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IERyYXdhYmxlIH0gZnJvbSAnLi9EcmF3YWJsZS5qcydcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGNvcmVcclxuICogQGFic3RyYWN0XHJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBMYXllciBleHRlbmRzIERyYXdhYmxlIHtcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzIFRoZSBjYW52YXMgd2hlcmUgdG8gZHJhdyB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbGVnZW5kXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICovXHJcbiAgICBkcmF3KGdlb0NhbnZhcywgbGVnZW5kID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgZHJhdyBub3QgaW1wbGVtZW50ZWQuJylcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBjb250YWluZXIuXHJcbiAqXHJcbiAqIEBtb2R1bGUgY29yZVxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGVnZW5kIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuaWQgPSBvcHRzLmlkXHJcblxyXG4gICAgICAgIC8vVE9ETyBzdG9wIHVzaW5nIGl0LiBVc2Ugc3R5bGUgbWV0aG9kIGJlbG93IGluc3RlYWQuXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBAZGVwcmVjYXRlZCAqL1xyXG4gICAgICAgIHRoaXMudG9wID0gb3B0cy50b3BcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gQGRlcHJlY2F0ZWQgKi9cclxuICAgICAgICB0aGlzLmJvdHRvbSA9IG9wdHMuYm90dG9tXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IEBkZXByZWNhdGVkICovXHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gb3B0cy5sZWZ0XHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IEBkZXByZWNhdGVkICovXHJcbiAgICAgICAgdGhpcy5yaWdodCA9IG9wdHMucmlnaHRcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gQGRlcHJlY2F0ZWQgKi9cclxuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBvcHRzLmJhY2tncm91bmQgfHwgJ25vbmUnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXHJcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gb3B0cy5wYWRkaW5nIHx8ICc1cHgnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXHJcbiAgICAgICAgdGhpcy5ib3JkZXIgPSBvcHRzLmJvcmRlciB8fCAnMHB4J1xyXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBAZGVwcmVjYXRlZCAqL1xyXG4gICAgICAgIHRoaXNbJ2JvcmRlci1yYWRpdXMnXSA9IG9wdHNbJ2JvcmRlci1yYWRpdXMnXSB8fCAnbm9uZSdcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gQGRlcHJlY2F0ZWQgKi9cclxuICAgICAgICB0aGlzWydib3gtc2hhZG93J10gPSBvcHRzWydib3gtc2hhZG93J10gfHwgJ25vbmUnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXHJcbiAgICAgICAgdGhpc1snZm9udC1mYW1pbHknXSA9IG9wdHNbJ2ZvbnQtZmFtaWx5J10gfHwgJ0hlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWYnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXHJcbiAgICAgICAgLy90aGlzLndpZHRoID0gb3B0cy53aWR0aFxyXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBAZGVwcmVjYXRlZCAqL1xyXG4gICAgICAgIC8vdGhpcy5oZWlnaHQgPSBvcHRzLmhlaWdodFxyXG5cclxuICAgICAgICAvL3RoZSBkaXYgZWxlbWVudFxyXG4gICAgICAgIGlmICh0aGlzLmlkKSB0aGlzLmRpdiA9IHNlbGVjdCgnIycgKyB0aGlzLmlkKVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuZGl2IHx8IHRoaXMuZGl2LmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXYgPSBzZWxlY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlkKSB0aGlzLmRpdi5hdHRyKCdpZCcsIHRoaXMuaWQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NldCBzdHlsZVxyXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlKCdiYWNrZ3JvdW5kJywgdGhpcy5iYWNrZ3JvdW5kKVxyXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlKCdwYWRkaW5nJywgdGhpcy5wYWRkaW5nKVxyXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlKCdib3JkZXInLCB0aGlzLmJvcmRlcilcclxuICAgICAgICB0aGlzLmRpdi5zdHlsZSgnYm9yZGVyLXJhZGl1cycsIHRoaXNbJ2JvcmRlci1yYWRpdXMnXSlcclxuICAgICAgICB0aGlzLmRpdi5zdHlsZSgnYm94LXNoYWRvdycsIHRoaXNbJ2JveC1zaGFkb3cnXSlcclxuICAgICAgICB0aGlzLmRpdi5zdHlsZSgnZm9udC1mYW1pbHknLCB0aGlzWydmb250LWZhbWlseSddKVxyXG5cclxuICAgICAgICAvL2lmICh0aGlzLndpZHRoKSB0aGlzLmRpdi5zdHlsZSgnd2lkdGgnLCB0aGlzLndpZHRoKVxyXG4gICAgICAgIC8vaWYgKHRoaXMuaGVpZ2h0KSB0aGlzLmRpdi5zdHlsZSgnaGVpZ2h0JywgdGhpcy5oZWlnaHQpXHJcblxyXG4gICAgICAgIC8vdGl0bGVcclxuICAgICAgICB0aGlzLnRpdGxlID0gb3B0cy50aXRsZVxyXG4gICAgICAgIHRoaXMudGl0bGVGb250U2l6ZSA9IG9wdHMudGl0bGVGb250U2l6ZSB8fCAnMC44ZW0nXHJcbiAgICAgICAgdGhpcy50aXRsZUZvbnRXZWlnaHQgPSBvcHRzLnRpdGxlRm9udFdlaWdodCB8fCAnYm9sZCdcclxuXHJcbiAgICAgICAgLy9sYWJlbFxyXG4gICAgICAgIHRoaXMubGFiZWxGb250U2l6ZSA9IG9wdHMubGFiZWxGb250U2l6ZSB8fCAnMC44ZW0nXHJcbiAgICAgICAgdGhpcy5sYWJlbFVuaXRUZXh0ID0gb3B0cy5sYWJlbFVuaXRUZXh0IHx8ICcnXHJcbiAgICAgICAgdGhpcy5sYWJlbEZvcm1hdCA9IG9wdHMubGFiZWxGb3JtYXRcclxuICAgIH1cclxuXHJcbiAgICBtYWtlVGl0bGUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRpdGxlKSByZXR1cm5cclxuICAgICAgICB0aGlzLmRpdlxyXG4gICAgICAgICAgICAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIHRoaXMudGl0bGVGb250U2l6ZSlcclxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsIHRoaXMudGl0bGVGb250V2VpZ2h0KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmdpbi1ib3R0b20nLCAnN3B4JylcclxuICAgICAgICAgICAgLnRleHQodGhpcy50aXRsZSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IGEgc3R5bGUgdG8gdGhlIGxlZ2VuZCBkaXYuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZcclxuICAgICAqIEByZXR1cm5zIHt0aGlzfHN0cmluZ31cclxuICAgICAqL1xyXG4gICAgc3R5bGUoaywgdikge1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLmRpdi5zdHlsZShrKVxyXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlKGssIHYpXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKG9wdHMgPSB7fSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0xlZ2VuZCB1cGRhdGUgbm90IGltcGxlbWVudGVkIHlldC4nKVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuLy8gaW50ZXJuYWwgaW1wb3J0c1xyXG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuL0dlb0NhbnZhcy5qcydcclxuaW1wb3J0IHsgVG9vbHRpcCB9IGZyb20gJy4vVG9vbHRpcC5qcydcclxuaW1wb3J0IHsgWm9vbUJ1dHRvbnMgfSBmcm9tICcuLi9idXR0b24vWm9vbUJ1dHRvbnMuanMnXHJcbmltcG9ydCB7IEZ1bGxzY3JlZW5CdXR0b24gfSBmcm9tICcuLi9idXR0b24vRnVsbHNjcmVlbkJ1dHRvbi5qcydcclxuXHJcbi8vIGV4dGVybmFsIGltcG9ydHNcclxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJ1xyXG5cclxuLyoqXHJcbiAqIEEgZ3JpZHZpeiBhcHBsaWNhdGlvbi5cclxuICpcclxuICogQG1vZHVsZSBjb3JlXHJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBNYXAge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSBjb250YWluZXJcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgb3B0cykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsYXllcnMuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLkxheWVyPn1cclxuICAgICAgICAgKiAqL1xyXG4gICAgICAgIHRoaXMubGF5ZXJzID0gb3B0cy5sYXllcnMgfHwgW11cclxuXHJcbiAgICAgICAgLy9nZXQgY29udGFpbmVyIGVsZW1lbnRcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ3JpZHZpeicpXHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgZmluZCBncmlkdml6IGNvbnRhaW5lciBlbGVtZW50LicpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9odHRwczovL2Nzcy10cmlja3MuY29tL2Fic29sdXRlLXBvc2l0aW9uaW5nLWluc2lkZS1yZWxhdGl2ZS1wb3NpdGlvbmluZy9cclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZScgLy8gY29udGFpbmVyIGVsZW1lbnQgbXVzdCBoYXZlIHJlbGF0aXZlIHBvc2l0aW9uaW5nXHJcblxyXG4gICAgICAgIC8vc2V0IGRpbWVuc2lvbnNcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLncgPSBvcHRzLncgfHwgdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGhcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLmggPSBvcHRzLmggfHwgdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbWFpbiBjYW52YXMgKGZvciByZW5kZXJpbmcgdG8gc2NyZWVuKVxyXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovXHJcbiAgICAgICAgdGhpcy5fY2FudmFzID0gb3B0cy5jYW52YXMgfHwgdGhpcy5pbml0aWFsaXNlQ2FudmFzKClcclxuXHJcbiAgICAgICAgLyoqICBJbml0aWFsaXplIEdlb0NhbnZhc1xyXG4gICAgICAgICAqIEB0eXBlIHtHZW9DYW52YXN9XHJcbiAgICAgICAgICogQHByaXZhdGUgKi9cclxuICAgICAgICB0aGlzLmdlb0NhbnZhcyA9IG5ldyBHZW9DYW52YXModGhpcy5fY2FudmFzLCBvcHRzLngsIG9wdHMueSwgb3B0cy56LCBvcHRzKVxyXG5cclxuICAgICAgICB0aGlzLmdlb0NhbnZhcy5yZWRyYXcgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVkcmF3KClcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5nZW9DYW52YXMuY2FuY2VsQ3VycmVudFJlcXVlc3RzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSB6b29tIGxldmVsIGNoYW5nZXMsIGF2b2lkIGRyYXdpbmcgb3V0ZGF0ZWQgdGlsZXMsIGFuZCBlbnN1cmUgdGhhdCByZXF1ZXN0cyBhcmUgcHJvcGVybHkgYWJvcnRlZCB3aGVuIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAvL211bHRpcmVzXHJcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuZGF0YXNldD8uZGF0YXNldHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGFzZXQgb2YgbGF5ZXIuZGF0YXNldD8uZGF0YXNldHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFzZXQ/LmNhbmNlbEN1cnJlbnRSZXF1ZXN0cykgZGF0YXNldC5jYW5jZWxDdXJyZW50UmVxdWVzdHMoKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vc2luZ2xlIHJlc1xyXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLmRhdGFzZXQ/LmNhbmNlbEN1cnJlbnRSZXF1ZXN0cykgbGF5ZXIuZGF0YXNldD8uY2FuY2VsQ3VycmVudFJlcXVlc3RzKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbGVnZW5kIGRpdlxyXG4gICAgICAgIHRoaXMubGVnZW5kID0gb3B0cy5sZWdlbmRDb250YWluZXJcclxuICAgICAgICAgICAgPyBzZWxlY3Qob3B0cy5sZWdlbmRDb250YWluZXIpIC8vIFdyYXAgdGhlIHByb3ZpZGVkIEhUTUwgbm9kZSBpbiBhIEQzIHNlbGVjdGlvblxyXG4gICAgICAgICAgICA6IG51bGxcclxuICAgICAgICBpZiAoIXRoaXMubGVnZW5kKSB0aGlzLmluaXRpYWxpc2VMZWdlbmQoKVxyXG5cclxuICAgICAgICAvL3Rvb2x0aXBcclxuXHJcbiAgICAgICAgLy8gc2V0IEFwcCBjb250YWluZXIgYXMgZGVmYXVsdCBwYXJlbnQgZWxlbWVudCBmb3IgdG9vbHRpcFxyXG4gICAgICAgIGlmICghb3B0cy50b29sdGlwKSBvcHRzLnRvb2x0aXAgPSB7fVxyXG4gICAgICAgIGlmICghb3B0cy50b29sdGlwLnBhcmVudEVsZW1lbnQpIG9wdHMudG9vbHRpcC5wYXJlbnRFbGVtZW50ID0gdGhpcy5jb250YWluZXJcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7VG9vbHRpcH0gKi9cclxuICAgICAgICB0aGlzLnRvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRzLnRvb2x0aXApXHJcblxyXG4gICAgICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lcnMgdG8gY29udGFpbmVyXHJcbiAgICAgICAgdGhpcy5tb3VzZU92ZXJIYW5kbGVyID0gKGUpID0+IHRoaXMuZm9jdXNDZWxsKGUpXHJcbiAgICAgICAgdGhpcy5tb3VzZU1vdmVIYW5kbGVyID0gKGUpID0+IHRoaXMuZm9jdXNDZWxsKGUpXHJcbiAgICAgICAgdGhpcy5tb3VzZU91dEhhbmRsZXIgPSAoZSkgPT4gdGhpcy50b29sdGlwLmhpZGUoKVxyXG4gICAgICAgIHRoaXMuZ2VvQ2FudmFzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm1vdXNlT3ZlckhhbmRsZXIpXHJcbiAgICAgICAgdGhpcy5nZW9DYW52YXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcilcclxuICAgICAgICB0aGlzLmdlb0NhbnZhcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLm1vdXNlT3V0SGFuZGxlcilcclxuXHJcbiAgICAgICAgLy8gbGlzdGVuIGZvciByZXNpemUgZXZlbnRzIG9uIHRoZSBBcHAncyBjb250YWluZXIgYW5kIGhhbmRsZSB0aGVtXHJcbiAgICAgICAgdGhpcy5kZWZpbmVSZXNpemVPYnNlcnZlcigpXHJcblxyXG4gICAgICAgIC8vIGFkZCBleHRyYSBsb2dpYyB0byBvblpvb21TdGFydEZ1blxyXG4gICAgICAgIHRoaXMuZ2VvQ2FudmFzLm9uWm9vbVN0YXJ0RnVuID0gKGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9wdHMub25ab29tU3RhcnRGdW4pIG9wdHMub25ab29tU3RhcnRGdW4oZSlcclxuICAgICAgICAgICAgdGhpcy50b29sdGlwLmhpZGUoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9mb3IgbW91c2Ugb3ZlclxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fG51bGx9ICovXHJcbiAgICAgICAgdGhpcy5jYW52YXNTYXZlID0gbnVsbFxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGlvblJlY3RhbmdsZUNvbG9yID0gb3B0cy5zZWxlY3Rpb25SZWN0YW5nbGVDb2xvciB8fCAnI0ZGNjM0NydcclxuICAgICAgICB0aGlzLnNlbGVjdGlvblJlY3RhbmdsZVdpZHRoUGl4ID0gb3B0cy5zZWxlY3Rpb25SZWN0YW5nbGVXaWR0aFBpeCB8fCAoKCkgPT4gNCkgLy8ocix6KSA9PiB7fVxyXG5cclxuICAgICAgICAvLyB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kIChlLmcuIGxlYWZsZXQpICdyZWQgcGFpbnRpbmcnIGZpeFxyXG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnRCYWNrZ3JvdW5kID0gb3B0cy50cmFuc3BhcmVudEJhY2tncm91bmRcclxuXHJcbiAgICAgICAgLy9zZXQgZGVmYXVsdCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cclxuICAgICAgICB0aGlzLmRlZmF1bHRHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPVxyXG4gICAgICAgICAgICBvcHRzLmRlZmF1bHRHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gfHwgdGhpcy5nZW9DYW52YXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICBpbml0aWFsaXNlQ2FudmFzKCkge1xyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXHJcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnJyArIHRoaXMudylcclxuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnJyArIHRoaXMuaClcclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpXHJcbiAgICAgICAgcmV0dXJuIGNhbnZhc1xyXG4gICAgfVxyXG5cclxuICAgIGluaXRpYWxpc2VMZWdlbmQoKSB7XHJcbiAgICAgICAgdGhpcy5sZWdlbmQgPSBzZWxlY3QodGhpcy5jb250YWluZXIpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2RpdicpIC8vIENyZWF0ZSBhIG5ldyBjb250YWluZXJcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2dyaWR2aXotbGVnZW5kJylcclxuICAgICAgICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnd2lkdGgnLCAnYXV0bycpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnaGVpZ2h0JywgJ2F1dG8nKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQnLCAnI0ZGRkZGRicpXHJcbiAgICAgICAgICAgIC8vLnN0eWxlKFwicGFkZGluZ1wiLCB0aGlzLnBhZGRpbmcpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnYm9yZGVyJywgJzBweCcpXHJcbiAgICAgICAgICAgIC8vLnN0eWxlKCdib3JkZXItcmFkaXVzJywgJzVweCcpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnYm94LXNoYWRvdycsICczcHggM3B4IDNweCBncmV5LCAtM3B4IC0zcHggM3B4ICNkZGQnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtZmFtaWx5JywgJ0hlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWYnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2JvdHRvbScsICcxNXB4JylcclxuICAgICAgICAgICAgLnN0eWxlKCdyaWdodCcsICcxNXB4JylcclxuICAgICAgICAvL2hpZGVcclxuICAgICAgICAvLy5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIilcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldC9nZXQgbGF5ZXIgc3RhY2suXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHt1bmRlZmluZWR8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5MYXllcnxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLkxheWVyW119IGxheWVyc1xyXG4gICAgICogQHJldHVybnMgeyB0aGlzIHwgaW1wb3J0KFwiLi9MYXllci5qc1wiKS5MYXllcltdIH1cclxuICAgICAqL1xyXG4gICAgbGF5ZXJzXyhsYXllcnMpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMubGF5ZXJzXHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxheWVycykpIHRoaXMubGF5ZXJzID0gbGF5ZXJzXHJcbiAgICAgICAgICAgIGVsc2UgdGhpcy5sYXllcnMgPSBbbGF5ZXJzXVxyXG4gICAgICAgIGVsc2UgdGhpcy5sYXllcnMgPSBhcmd1bWVudHNcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcmV0dXJucyB7dGhpc30gKi9cclxuICAgIHJlZHJhdygpIHtcclxuICAgICAgICAvL3JlbW92ZSBsZWdlbmQgZWxlbWVudHNcclxuICAgICAgICBpZiAodGhpcy5sZWdlbmQpIHRoaXMubGVnZW5kLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vY2xlYXJcclxuICAgICAgICB0aGlzLmdlb0NhbnZhcy5pbml0Q2FudmFzVHJhbnNmb3JtKClcclxuICAgICAgICB0aGlzLmdlb0NhbnZhcy5jbGVhcih0aGlzLmdlb0NhbnZhcy5iYWNrZ3JvdW5kQ29sb3IpXHJcblxyXG4gICAgICAgIGNvbnN0IHogPSB0aGlzLmdlb0NhbnZhcy52aWV3LnpcclxuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXHJcblxyXG4gICAgICAgIC8vZ28gdGhyb3VnaCB0aGUgbGF5ZXJzXHJcbiAgICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xyXG4gICAgICAgICAgICAvL2NoZWNrIGlmIGxheWVyIGlzIHZpc2libGVcclxuICAgICAgICAgICAgaWYgKGxheWVyLnZpc2libGUgJiYgIWxheWVyLnZpc2libGUoeikpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL3NldCBsYXllciBhbHBoYSBhbmQgYmxlbmQgbW9kZVxyXG4gICAgICAgICAgICB0aGlzLmdlb0NhbnZhcy5vZmZzY3JlZW5DdHguZ2xvYmFsQWxwaGEgPSBsYXllci5hbHBoYSA/IGxheWVyLmFscGhhKHopIDogMS4wXHJcbiAgICAgICAgICAgIGlmIChsYXllci5ibGVuZE9wZXJhdGlvbikgdGhpcy5nZW9DYW52YXMub2Zmc2NyZWVuQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGxheWVyLmJsZW5kT3BlcmF0aW9uKHopXHJcblxyXG4gICAgICAgICAgICAvL3NldCBhZmZpbiB0cmFuc2Zvcm0gdG8gZHJhdyB3aXRoIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICB0aGlzLmdlb0NhbnZhcy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IGxheWVyXHJcbiAgICAgICAgICAgIGxheWVyLmRyYXcodGhpcy5nZW9DYW52YXMsIHRoaXMubGVnZW5kKVxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IGxheWVyIGZpbHRlclxyXG4gICAgICAgICAgICBpZiAobGF5ZXIuZmlsdGVyQ29sb3IpIGxheWVyLmRyYXdGaWx0ZXIodGhpcy5nZW9DYW52YXMpXHJcblxyXG4gICAgICAgICAgICAvL3Jlc3RvcmUgZGVmYXVsdCBhbHBoYSBhbmQgYmxlbmQgb3BlcmF0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuZ2VvQ2FudmFzLm9mZnNjcmVlbkN0eC5nbG9iYWxBbHBoYSA9IDEuMFxyXG4gICAgICAgICAgICB0aGlzLmdlb0NhbnZhcy5vZmZzY3JlZW5DdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5kZWZhdWx0R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBvbmUgZHJhd0ltYWdlIGNhbGw6IGRyYXcgdGhlIG9mZnNjcmVlbiBjYW52YXMgdG8gdGhlIG1haW4gY2FudmFzXHJcbiAgICAgICAgdGhpcy5nZW9DYW52YXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXHJcbiAgICAgICAgdGhpcy5nZW9DYW52YXMuY3R4LmRyYXdJbWFnZSh0aGlzLmdlb0NhbnZhcy5vZmZzY3JlZW5DYW52YXMsIDAsIDApXHJcblxyXG4gICAgICAgIHRoaXMuY2FudmFzU2F2ZSA9IG51bGxcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXJnaW5QeFxyXG4gICAgICogQHJldHVybnMge2ltcG9ydCgnLi9HZW9DYW52YXMuanMnKS5FbnZlbG9wZX1cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlRXh0ZW50R2VvKG1hcmdpblB4ID0gMjApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZW9DYW52YXMudXBkYXRlRXh0ZW50R2VvKG1hcmdpblB4KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgKi9cclxuICAgIGZvY3VzQ2VsbChlKSB7XHJcbiAgICAgICAgLy9jb21wdXRlIG1vdXNlIGdlbyBwb3NpdGlvblxyXG4gICAgICAgIGNvbnN0IG1vdXNlUG9zaXRpb25HZW8gPSB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMuZ2VvQ2FudmFzLnBpeFRvR2VvWChlLm9mZnNldFggKyB0aGlzLnRvb2x0aXAueE1vdXNlT2Zmc2V0KSxcclxuICAgICAgICAgICAgeTogdGhpcy5nZW9DYW52YXMucGl4VG9HZW9ZKGUub2Zmc2V0WSArIHRoaXMudG9vbHRpcC55TW91c2VPZmZzZXQpLFxyXG4gICAgICAgIH1cclxuICAgICAgICAvKiogQHR5cGUge3tjZWxsOmltcG9ydCgnLi9EYXRhc2V0LmpzJykuQ2VsbCxodG1sOnN0cmluZyxyZXNvbHV0aW9uOm51bWJlcn0gfCB1bmRlZmluZWR9ICovXHJcbiAgICAgICAgY29uc3QgZm9jdXMgPSB0aGlzLmdldENlbGxGb2N1c0luZm8obW91c2VQb3NpdGlvbkdlbylcclxuXHJcbiAgICAgICAgLy8gVHJhbnNwYXJlbnQgYmFja2dyb3VuZCAoTGVhZmxldCk6IHJlZHJhdyBiYXNlLCB0aGVuIGRyYXcgZm9jdXMgcmVjdCBkaXJlY3RseSBvbiB0aGUgdmlzaWJsZSBjYW52YXNcclxuICAgICAgICBpZiAodGhpcy50cmFuc3BhcmVudEJhY2tncm91bmQpIHtcclxuICAgICAgICAgICAgLy8gQWx3YXlzIHJlc3RvcmUgdGhlIGJhc2UgKG9mZnNjcmVlbikgaW50byB0aGUgdmlzaWJsZSBjYW52YXNcclxuICAgICAgICAgICAgdGhpcy5nZW9DYW52YXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB0aGlzLmdlb0NhbnZhcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMudywgdGhpcy5oKTtcclxuICAgICAgICAgICAgdGhpcy5nZW9DYW52YXMuY3R4LmRyYXdJbWFnZSh0aGlzLmdlb0NhbnZhcy5vZmZzY3JlZW5DYW52YXMsIDAsIDApO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAuaHRtbChmb2N1cy5odG1sKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zZXRQb3NpdGlvbihlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zaG93KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdFdQaXggPSB0aGlzLnNlbGVjdGlvblJlY3RhbmdsZVdpZHRoUGl4XHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnNlbGVjdGlvblJlY3RhbmdsZVdpZHRoUGl4KGZvY3VzLnJlc29sdXRpb24sIHRoaXMuZ2VvQ2FudmFzLnZpZXcueilcclxuICAgICAgICAgICAgICAgICAgICA6IDQ7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5nZW9DYW52YXMuY3R4OyAvLyBkcmF3IGRpcmVjdGx5IG9uIHZpc2libGUgY2FudmFzXHJcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zZWxlY3Rpb25SZWN0YW5nbGVDb2xvcjtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSByZWN0V1BpeDtcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgaW4gcGl4ZWwgc3BhY2UgKG5vIGdlbyB0cmFuc2Zvcm0gb24gY3R4KVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeFBpeCA9IHRoaXMuZ2VvQ2FudmFzLmdlb1RvUGl4WChmb2N1cy5jZWxsLngpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeVBpeCA9IHRoaXMuZ2VvQ2FudmFzLmdlb1RvUGl4WShmb2N1cy5jZWxsLnkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd1BpeCA9IGZvY3VzLnJlc29sdXRpb24gLyB0aGlzLmdlb0NhbnZhcy52aWV3Lno7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoUGl4ID0gLXdQaXg7IC8vIHkgYXhpcyBpbnZlcnRlZCBpbiBnZW9Ub1BpeFxyXG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgeFBpeCAtIHJlY3RXUGl4IC8gMixcclxuICAgICAgICAgICAgICAgICAgICB5UGl4ICsgcmVjdFdQaXggLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHdQaXggKyByZWN0V1BpeCxcclxuICAgICAgICAgICAgICAgICAgICBoUGl4IC0gcmVjdFdQaXhcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47IC8vIGhhbmRsZWRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmb2N1cykge1xyXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuaHRtbChmb2N1cy5odG1sKVxyXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuc2V0UG9zaXRpb24oZSlcclxuICAgICAgICAgICAgdGhpcy50b29sdGlwLnNob3coKVxyXG5cclxuICAgICAgICAgICAgLy9zaG93IGNlbGwgcG9zaXRpb24gYXMgYSByZWN0YW5nbGVcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbnZhc1NhdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcnICsgdGhpcy53KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJycgKyB0aGlzLmgpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZ2V0Q29udGV4dCgnMmQnKT8uZHJhd0ltYWdlKHRoaXMuZ2VvQ2FudmFzLm9mZnNjcmVlbkNhbnZhcywgMCwgMClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2VvQ2FudmFzLm9mZnNjcmVlbkN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXNTYXZlLCAwLCAwKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgaW1hZ2Ugc2F2ZWQgKyBkcmF3IHJlY3RhbmdsZVxyXG4gICAgICAgICAgICBjb25zdCByZWN0V1BpeCA9IHRoaXMuc2VsZWN0aW9uUmVjdGFuZ2xlV2lkdGhQaXhcclxuICAgICAgICAgICAgICAgID8gdGhpcy5zZWxlY3Rpb25SZWN0YW5nbGVXaWR0aFBpeChmb2N1cy5yZXNvbHV0aW9uLCB0aGlzLmdlb0NhbnZhcy52aWV3LnopXHJcbiAgICAgICAgICAgICAgICA6IDRcclxuICAgICAgICAgICAgdGhpcy5nZW9DYW52YXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuZ2VvQ2FudmFzLm9mZnNjcmVlbkN0eFxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnNlbGVjdGlvblJlY3RhbmdsZUNvbG9yXHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSByZWN0V1BpeFxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuXHJcbiAgICAgICAgICAgIGN0eC5yZWN0KFxyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW9DYW52YXMuZ2VvVG9QaXhYKGZvY3VzLmNlbGwueCkgLSByZWN0V1BpeCAvIDIsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdlb0NhbnZhcy5nZW9Ub1BpeFkoZm9jdXMuY2VsbC55KSArIHJlY3RXUGl4IC8gMixcclxuICAgICAgICAgICAgICAgIGZvY3VzLnJlc29sdXRpb24gLyB0aGlzLmdlb0NhbnZhcy52aWV3LnogKyByZWN0V1BpeCxcclxuICAgICAgICAgICAgICAgIC1mb2N1cy5yZXNvbHV0aW9uIC8gdGhpcy5nZW9DYW52YXMudmlldy56IC0gcmVjdFdQaXhcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcclxuICAgICAgICAgICAgdGhpcy5nZW9DYW52YXMuY3R4LmRyYXdJbWFnZSh0aGlzLmdlb0NhbnZhcy5vZmZzY3JlZW5DYW52YXMsIDAsIDApXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50b29sdGlwLmhpZGUoKVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXNTYXZlKSB0aGlzLmdlb0NhbnZhcy5jdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzU2F2ZSwgMCwgMClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGNlbGwgSFRNTCBpbmZvIGF0IGEgZ2l2ZW4gZ2VvIHBvc2l0aW9uLlxyXG4gICAgICogVGhpcyBpcyB1c2VmdWxsIGZvciB1c2VyIGludGVyYWN0aW9ucywgdG8gc2hvdyB0aGlzIGluZm8gd2hlcmUgdGhlIHVzZXIgY2xpY2tzIGZvciBleGFtcGxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gcG9zR2VvXHJcbiAgICAgKiBAcmV0dXJucyB7e2NlbGw6aW1wb3J0KCcuL0RhdGFzZXQuanMnKS5DZWxsLGh0bWw6c3RyaW5nLHJlc29sdXRpb246bnVtYmVyfSB8IHVuZGVmaW5lZH1cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgZ2V0Q2VsbEZvY3VzSW5mbyhwb3NHZW8pIHtcclxuICAgICAgICAvL2dvIHRocm91Z2ggdGhlIGxheWVycywgc3RhcnRpbmcgZnJvbSB0b3BcclxuICAgICAgICBjb25zdCB6ID0gdGhpcy5nZW9DYW52YXMudmlldy56XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9MYXllci5qc1wiKS5MYXllcn0gKi9cclxuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVyc1tpXVxyXG4gICAgICAgICAgICBpZiAobGF5ZXIudmlzaWJsZSAmJiAhbGF5ZXIudmlzaWJsZSh6KSkgY29udGludWVcclxuICAgICAgICAgICAgaWYgKGxheWVyLmNlbGxJbmZvSFRNTCA9PT0gJ25vbmUnKSBjb250aW51ZSAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byBub3Qgc2hvdyB0b29sdGlwcyBmb3IgbGF5ZXJzICdvbiB0b3AnIChlLmcuIHBvcHVsYXRpb24gY2lyY2xlcyBvbiB0b3Agb2Ygc3F1YXJlcylcclxuICAgICAgICAgICAgaWYgKCFsYXllci5jZWxsSW5mb0hUTUwpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGlmICghbGF5ZXIuZ2V0RGF0YXNldCkgY29udGludWVcclxuICAgICAgICAgICAgY29uc3QgZHNjID0gbGF5ZXIuZ2V0RGF0YXNldCh6KVxyXG4gICAgICAgICAgICBpZiAoIWRzYykgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8vZ2V0IGNlbGwgYXQgbW91c2UgcG9zaXRpb25cclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vRGF0YXNldC5qcycpLkNlbGx8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZHNjLmdldENlbGxGcm9tUG9zaXRpb24ocG9zR2VvLCBkc2MuZ2V0Vmlld0NhY2hlKCkpXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coY2VsbCwgZHNjLnJlc29sdXRpb24pXHJcbiAgICAgICAgICAgIGlmICghY2VsbCkgcmV0dXJuIHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAgICAgLy9yYXJlIGNhc2UgZm9yIGEgZGF0YXNldCB3aXRoIG1peGVkIHJlc29sdXRpb25zXHJcbiAgICAgICAgICAgIGlmIChkc2MubWl4ZWRSZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByID0gK2RzYy5taXhlZFJlc29sdXRpb24oY2VsbClcclxuICAgICAgICAgICAgICAgIGNvbnN0IGh0bWwgPSBsYXllci5jZWxsSW5mb0hUTUwoY2VsbCwgcilcclxuICAgICAgICAgICAgICAgIGlmICghaHRtbCkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2VsbDogY2VsbCwgaHRtbDogaHRtbCwgcmVzb2x1dGlvbjogciB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSBsYXllci5jZWxsSW5mb0hUTUwoY2VsbCwgZHNjLmdldFJlc29sdXRpb24oKSlcclxuICAgICAgICAgICAgaWYgKCFodG1sKSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIHJldHVybiB7IGNlbGw6IGNlbGwsIGh0bWw6IGh0bWwsIHJlc29sdXRpb246IGRzYy5nZXRSZXNvbHV0aW9uKCkgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSB6XHJcbiAgICAgKi9cclxuICAgIHNldFZpZXcoeCwgeSwgeiA9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMuZ2VvQ2FudmFzLnZpZXcueCA9IHhcclxuICAgICAgICB0aGlzLmdlb0NhbnZhcy52aWV3LnkgPSB5XHJcbiAgICAgICAgaWYgKHogIT0gdW5kZWZpbmVkKSB0aGlzLmdlb0NhbnZhcy52aWV3LnogPSB6XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKiogQHJldHVybnMge2ltcG9ydCgnLi9HZW9DYW52YXMuanMnKS5WaWV3fSAqL1xyXG4gICAgZ2V0VmlldygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZW9DYW52YXMudmlld1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcmV0dXJucyB7bnVtYmVyfSAqL1xyXG4gICAgZ2V0Wm9vbSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZW9DYW52YXMudmlldy56XHJcbiAgICB9XHJcbiAgICAvKiogQHBhcmFtIHtudW1iZXJ9IHogQHJldHVybnMge3RoaXN9ICovXHJcbiAgICBzZXRab29tKHopIHtcclxuICAgICAgICB0aGlzLmdlb0NhbnZhcy52aWV3LnogPSB6XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKiogQHJldHVybnMge0FycmF5LjxudW1iZXJ8dW5kZWZpbmVkPn0gKi9cclxuICAgIGdldENlbnRlckV4dGVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZW9DYW52YXMuZ2V0Q2VudGVyRXh0ZW50KClcclxuICAgIH1cclxuICAgIC8qKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWwgQHJldHVybnMge3RoaXN9ICovXHJcbiAgICBzZXRDZW50ZXJFeHRlbnQodmFsKSB7XHJcbiAgICAgICAgdGhpcy5nZW9DYW52YXMuc2V0Q2VudGVyRXh0ZW50KHZhbClcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59ICovXHJcbiAgICBnZXRab29tRXh0ZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdlb0NhbnZhcy5nZXRab29tRXh0ZW50KClcclxuICAgIH1cclxuICAgIC8qKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWwgQHJldHVybnMge3RoaXN9ICovXHJcbiAgICBzZXRab29tRXh0ZW50KHZhbCkge1xyXG4gICAgICAgIHRoaXMuZ2VvQ2FudmFzLnNldFpvb21FeHRlbnQodmFsKVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEByZXR1cm5zIHtzdHJpbmd9ICovXHJcbiAgICBnZXRCYWNrZ3JvdW5kQ29sb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvQ2FudmFzLmJhY2tncm91bmRDb2xvclxyXG4gICAgfVxyXG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSB2YWwgQHJldHVybnMge3RoaXN9ICovXHJcbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3IodmFsKSB7XHJcbiAgICAgICAgdGhpcy5nZW9DYW52YXMuYmFja2dyb3VuZENvbG9yID0gdmFsXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzZXQgb2Ygem9vbSBidXR0b25zIHRvIHRoZSBtYXBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xyXG4gICAgICogQHJldHVybnMge3RoaXN9XHJcbiAgICAgKi9cclxuICAgIGFkZFpvb21CdXR0b25zKG9wdHMpIHtcclxuICAgICAgICAvLyAqIG9wdHMuaWRcclxuICAgICAgICAvLyAqIG9wdHMub25ab29tIC0gY3VzdG9tIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cclxuICAgICAgICAvLyAqIG9wdHMueFxyXG4gICAgICAgIC8vICogb3B0cy55XHJcbiAgICAgICAgLy8gKiBvcHRzLmRlbHRhIC0gem9vbSBkZWx0YSBhcHBsaWVkIG9uIGVhY2ggY2xpY2tcclxuXHJcbiAgICAgICAgdGhpcy56b29tQnV0dG9ucyA9IG5ldyBab29tQnV0dG9ucyh7XHJcbiAgICAgICAgICAgIG1hcDogdGhpcyxcclxuICAgICAgICAgICAgaWQ6IG9wdHM/LmlkIHx8ICdncmlkdml6LXpvb20tYnV0dG9ucy0nICsgdGhpcy5jb250YWluZXIuaWQsXHJcbiAgICAgICAgICAgIGNsYXNzOiBvcHRzPy5jbGFzcyxcclxuICAgICAgICAgICAgeDogb3B0cz8ueCxcclxuICAgICAgICAgICAgeTogb3B0cz8ueSxcclxuICAgICAgICAgICAgb25ab29tOiBvcHRzPy5vblpvb20sXHJcbiAgICAgICAgICAgIGRlbHRhOiBvcHRzPy5kZWx0YSB8fCAwLjIsXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBmdWxsc2NyZWVuIHRvZ2dsZSBidXR0b24gdG8gdGhlIGFwcFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cclxuICAgICAqL1xyXG4gICAgYWRkRnVsbHNjcmVlbkJ1dHRvbihvcHRzKSB7XHJcbiAgICAgICAgLy8gKiBvcHRzLm1hcCAtIHRoZSBncmlkdml6IG1hcFxyXG4gICAgICAgIC8vICogb3B0cy5pZFxyXG4gICAgICAgIC8vICogb3B0cy54XHJcbiAgICAgICAgLy8gKiBvcHRzLnlcclxuXHJcbiAgICAgICAgdGhpcy5mdWxsc2NyZWVuQnV0dG9uID0gbmV3IEZ1bGxzY3JlZW5CdXR0b24oe1xyXG4gICAgICAgICAgICBtYXA6IHRoaXMsXHJcbiAgICAgICAgICAgIGlkOiBvcHRzPy5pZCB8fCAnZ3JpZHZpei1mdWxsc2NyZWVuLWJ1dHRvbicsXHJcbiAgICAgICAgICAgIGNsYXNzOiBvcHRzPy5jbGFzcyxcclxuICAgICAgICAgICAgeDogb3B0cz8ueCxcclxuICAgICAgICAgICAgeTogb3B0cz8ueSxcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcmV0dXJucyB7dGhpc30gKi9cclxuICAgIHNldFZpZXdGcm9tVVJMKCkge1xyXG4gICAgICAgIHRoaXMuZ2VvQ2FudmFzLnNldFZpZXdGcm9tVVJMKClcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIEFkZCBhIHJlc2l6ZSBldmVudCBvYnNlcnZlciB0byB0aGUgQXBwcyBjb250YWluZXIgYW5kIHVwZGF0ZSB0aGUgY2FudmFzIGFjY29yZGluZ2x5XHJcbiAgICAgKiBAbWVtYmVyb2YgQXBwXHJcbiAgICAgKi9cclxuICAgIGRlZmluZVJlc2l6ZU9ic2VydmVyKCkge1xyXG4gICAgICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhlIG9ic2VydmVyIGlzIGN1cnJlbnRseSBwcm9jZXNzaW5nIGEgcmVzaXplIGV2ZW50XHJcbiAgICAgICAgbGV0IHJlc2l6ZVBlbmRpbmcgPSBmYWxzZVxyXG5cclxuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW50cmllcykgfHwgIWVudHJpZXMubGVuZ3RoKSByZXR1cm5cclxuXHJcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lclxyXG5cclxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBjb250YWluZXIgaGFzIHZhbGlkIGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5jbGllbnRXaWR0aCA+IDAgJiYgY29udGFpbmVyLmNsaWVudEhlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICghcmVzaXplUGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZVBlbmRpbmcgPSB0cnVlIC8vIFByZXZlbnQgb3ZlcmxhcHBpbmcgcmVzaXplIHRyaWdnZXJzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNpemVQZW5kaW5nID0gZmFsc2UgLy8gUmVzZXQgdGhlIGZsYWcgYWZ0ZXIgcHJvY2Vzc2luZ1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHNpemUgY2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oICE9PSBjb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IHRoaXMudyAhPT0gY29udGFpbmVyLmNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmggPSBjb250YWluZXIuY2xpZW50SGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLncgPSBjb250YWluZXIuY2xpZW50V2lkdGhcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZ2VvQ2FudmFzIHNpemVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlb0NhbnZhcy5oID0gdGhpcy5oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlb0NhbnZhcy53ID0gdGhpcy53XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlb0NhbnZhcy5jYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIFN0cmluZyh0aGlzLncpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW9DYW52YXMuY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgU3RyaW5nKHRoaXMuaCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlb0NhbnZhcy5vZmZzY3JlZW5DYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIFN0cmluZyh0aGlzLncpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW9DYW52YXMub2Zmc2NyZWVuQ2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgU3RyaW5nKHRoaXMuaCkpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRyYXcoKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsbHkgcmVwb3NpdGlvbiBVSSBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuem9vbUJ1dHRvbnMpIHRoaXMuem9vbUJ1dHRvbnMubm9kZS5zdHlsZS5sZWZ0ID0gdGhpcy53IC0gNTAgKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuZnVsbHNjcmVlbkJ1dHRvbikgdGhpcy5mdWxsc2NyZWVuQnV0dG9uLm5vZGUuc3R5bGUubGVmdCA9IHRoaXMudyAtIDUwICsgJ3B4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuY29udGFpbmVyKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uIERlc3Ryb3kgdGhlIG1hcCBhbmQgaXQncyBldmVudCBsaXN0ZW5lcnNcclxuICAgICAqIFRoaXMgc2hvdWxkIHNpZ25pZmljYW50bHkgcmVkdWNlIHRoZSBtZW1vcnkgdXNlZCB3aGVuIGNyZWF0aW5nIGFuZCBkZXN0cm95aW5nIGdyaWR2aXogbWFwIGluc3RhbmNlcyAoZm9yIGV4YW1wbGUgaW4gbGVhZmxldC1ncmlkdml6KVxyXG4gICAgICogQG1lbWJlcm9mIEFwcFxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIC8vIGNsZWFyIGxheWVyc1xyXG4gICAgICAgIHRoaXMubGF5ZXJzID0gW11cclxuICAgICAgICB0aGlzLmJnTGF5ZXJzID0gW11cclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmcm9tIGNvbnRhaW5lclxyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMubW91c2VPdmVySGFuZGxlcilcclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZUhhbmRsZXIpXHJcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLm1vdXNlT3V0SGFuZGxlcilcclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIGNhbnZhc1xyXG4gICAgICAgIHRoaXMuZ2VvQ2FudmFzLmNhbnZhcy5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvLyByZW1vdmUgbGVnZW5kXHJcbiAgICAgICAgdGhpcy5sZWdlbmQ/LnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSB0b29sdGlwXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnRvb2x0aXA/LnJlbW92ZSgpXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG4vKipcclxuICogQSBtdWx0aSByZXNvbHV0aW9uIGRhdGFzZXQgb2YgZ3JpZCBjZWxscy5cclxuICogSXQgY29uc2lzdHMgb2YgZGlmZmVyZW50IHtAbGluayBEYXRhc2V0fXMgZm9yIGVhY2ggcmVzb2x1dGlvbi5cclxuICpcclxuICogQGFic3RyYWN0XHJcbiAqXHJcbiAqIEBtb2R1bGUgY29yZVxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTXVsdGlSZXNvbHV0aW9uRGF0YXNldCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJlc29sdXRpb25zIFRoZSByZXNvbHV0aW9ucyBvZiB0aGUgZGF0YXNldHMsIGluIENSUyBnZW9ncmFwaGljYWwgdW5pdC5cclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4vRGF0YXNldFwiKS5EYXRhc2V0PnxmdW5jdGlvbihudW1iZXIpOmltcG9ydChcIi4vRGF0YXNldFwiKS5EYXRhc2V0fSBkYXRhc2V0cyBUaGUgZGF0YXNldHMgbGlzdCwgb25lIHBlciByZXNvbHV0aW9uLiBPciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGRhdGFzZXQgZnJvbSBhIHJlc29sdXRpb24gdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0geyB7cHJlcHJvY2Vzcz86ZnVuY3Rpb24oaW1wb3J0KFwiLi9EYXRhc2V0XCIpLkNlbGwpOmJvb2xlYW59IH0gb3B0cyBPcHRpb25zLiBwcmVwcm9jZXNzOiBBIGZ1bmN0aW9uIHRvIGFwcGx5IG9uIGVhY2ggZGF0YXNldCBjZWxsIHRvIHByZXBhcmUgaXRzIHZhbHVlcy4gQ2FuIGJlIHVzZWQgYWxzbyB0byBzZWxlY3QgY2VsbHMgdG8ga2VlcC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocmVzb2x1dGlvbnMsIGRhdGFzZXRzLCBvcHRzID0ge30pIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogVGhlIHJlc29sdXRpb25zIG9mIHRoZSBkYXRhc2V0cywgaW4gQ1JTIGdlb2dyYXBoaWNhbCB1bml0LlxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn0gKi9cclxuICAgICAgICB0aGlzLnJlc29sdXRpb25zID0gcmVzb2x1dGlvbnNcclxuXHJcbiAgICAgICAgLyoqIFRoZSBkYXRhc2V0cy4gSWYgdGhlIGxpc3QgaXMgbm90IGV4cGxpY3RlbHkgZGVmaW5lZCwgYnVpbGQgaXQgZnJvbSB0aGUgcmVzb2x1dGlvbiBsaXN0IHdpdGggdGhlIGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxpbXBvcnQoXCIuL0RhdGFzZXRcIikuRGF0YXNldD59ICovXHJcbiAgICAgICAgdGhpcy5kYXRhc2V0cyA9IHR5cGVvZiBkYXRhc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMucmVzb2x1dGlvbnMubWFwKGRhdGFzZXRzKSA6IGRhdGFzZXRzXHJcblxyXG4gICAgICAgIC8vdGhlcmUgbXVzdCBiZSBhcyBtYW55IGRhdGFzZXRzIGFzIHJlc29sdXRpb25zXHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldHMubGVuZ3RoID4gMSAmJiB0aGlzLmRhdGFzZXRzLmxlbmd0aCAhPSB0aGlzLnJlc29sdXRpb25zLmxlbmd0aClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgJ1VuY29tcGF0aWJsZSBudW1iZXIgb2YgZGF0YXNldHMgYW5kIHJlc29sdXRpb25zOiAnICtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFzZXRzLmxlbmd0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgJyAnICtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdXRpb25zLmxlbmd0aFxyXG4gICAgICAgICAgICApXHJcblxyXG4gICAgICAgIC8vc2V0IGRhdGFzZXQgcHJlcHJvY2Vzc2VzIGlmIHNwZWNpZmllZFxyXG4gICAgICAgIGlmIChvcHRzLnByZXByb2Nlc3MpIHRoaXMuc2V0UHJlcG9jZXNzZXMob3B0cy5wcmVwcm9jZXNzKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSByZWxldmFudCBkYXRhc2V0IGZvciBhIHNwZWNpZmllZCB6b29tLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5QaXhlbHNQZXJDZWxsXHJcbiAgICAgKiBAcmV0dXJucyB7aW1wb3J0KFwiLi9EYXRhc2V0XCIpLkRhdGFzZXR8dW5kZWZpbmVkfVxyXG4gICAgICogKi9cclxuICAgIGdldERhdGFzZXQoeiwgbWluUGl4ZWxzUGVyQ2VsbCkge1xyXG4gICAgICAgIC8vc3BlY2lhbCBjYXNlIHdoaXRoIHNpbmdsZSBkYXRhc2V0XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldHMubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLmRhdGFzZXRzWzBdXHJcblxyXG4gICAgICAgIGNvbnN0IHJzID0gdGhpcy5yZXNvbHV0aW9uc1xyXG4gICAgICAgIGxldCBpID0gMFxyXG4gICAgICAgIGxldCB6XyA9IHJzW2ldIC8gbWluUGl4ZWxzUGVyQ2VsbFxyXG4gICAgICAgIHdoaWxlICh6XyA8IHogJiYgaSA8IHJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpKytcclxuICAgICAgICAgICAgel8gPSByc1tpXSAvIG1pblBpeGVsc1BlckNlbGxcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9pZiAoaSA9PSAwKSByZXR1cm4gdGhpcy5kYXRhc2V0LmRhdGFzZXRzWzBdO1xyXG4gICAgICAgIC8vcmV0dXJuIHRoaXMuZGF0YXNldC5kYXRhc2V0c1tpIC0gMV07XHJcbiAgICAgICAgaWYgKGkgPT0gcnMubGVuZ3RoKSByZXR1cm4gdGhpcy5kYXRhc2V0c1tycy5sZW5ndGggLSAxXVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFzZXRzW2ldXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBwcmVwcm9jZXNzIGZ1bmN0aW9uIGZvciBhbGwgZGF0YXNldHMuXHJcbiAgICAgKiBUaGlzIGlzIGEgZnVuY3Rpb24gYXBwbGllZCBvbiBlYWNoIGNlbGwgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9EYXRhc2V0XCIpLkNlbGwpOmJvb2xlYW59IHByZXByb2Nlc3NcclxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxyXG4gICAgICovXHJcbiAgICBzZXRQcmVwb2Nlc3NlcyhwcmVwcm9jZXNzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgZHMgb2YgdGhpcy5kYXRhc2V0cykgZHMucHJlcHJvY2VzcyA9IHByZXByb2Nlc3NcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmdW5jdGlvbiB0byBlYXNlIHRoZSBjcmVhdGlvbiBvZiBtdWx0aSByZXNvbHV0aW9uIGRhdGFzZXRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJlc29sdXRpb25zIFRoZSByZXNvbHV0aW9ucyBvZiB0aGUgZGF0YXNldHMsIGluIENSUyBnZW9ncmFwaGljYWwgdW5pdFxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOmltcG9ydChcIi4vRGF0YXNldFwiKS5EYXRhc2V0fSByZXNUb0RhdGFzZXQgRnVuY3Rpb24gcmV0dXJuaW5nIGEgZGF0YXNldCBmcm9tIGEgcmVzb2x1dGlvblxyXG4gICAgICogQHBhcmFtIHsge3ByZXByb2Nlc3M/OmZ1bmN0aW9uKGltcG9ydChcIi4vRGF0YXNldFwiKS5DZWxsKTpib29sZWFufSB9IG9wdHMgT3B0aW9ucy4gcHJlcHJvY2VzczogQSBmdW5jdGlvbiB0byBhcHBseSBvbiBlYWNoIGRhdGFzZXQgY2VsbCB0byBwcmVwYXJlIGl0cyB2YWx1ZXNcclxuICAgICAqIEByZXR1cm5zIHtNdWx0aVJlc29sdXRpb25EYXRhc2V0fVxyXG4gICAgICovXHJcbiAgICAvKnN0YXRpYyBtYWtlKHJlc29sdXRpb25zLCByZXNUb0RhdGFzZXQsIG9wdHMpIHtcclxuICAgICAgICAvL21ha2UgZGF0YXNldHNcclxuICAgICAgICBjb25zdCBkc2MgPSBbXVxyXG4gICAgICAgIGZvciAoY29uc3QgcmVzIG9mIHJlc29sdXRpb25zKSBkc2MucHVzaChyZXNUb0RhdGFzZXQocmVzKSlcclxuICAgICAgICAvL21ha2UgbXVsdGkgcmVzb2x1dGlvbiBkYXRhc2V0XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aVJlc29sdXRpb25EYXRhc2V0KGRzYywgcmVzb2x1dGlvbnMsIG9wdHMpXHJcbiAgICB9Ki9cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IERyYXdhYmxlIH0gZnJvbSAnLi9EcmF3YWJsZS5qcydcclxuXHJcbi8qKiBAdHlwZWRlZiB7XCJzcXVhcmVcInxcImNpcmNsZVwifFwiZGlhbW9uZFwifFwiZG9udXRcInxcInRyaWFuZ2xlX3VwXCJ8XCJ0cmlhbmdsZV9kb3duXCJ8XCJ0cmlhbmdsZV9sZWZ0XCJ8XCJ0cmlhbmdsZV9yaWdodFwifFwibm9uZVwifSBTaGFwZSAqL1xyXG5cclxuLyoqXHJcbiAqIHZpZXdTY2FsZSB0eXBlXHJcbiAqIFJldHVybnMgYW4gb2JqZWN0IGZyb20gYSBsaXN0IG9mIGNlbGxzLFxyXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oQXJyYXkuPGltcG9ydCgnLi9EYXRhc2V0LmpzJykuQ2VsbD4sbnVtYmVyLCBudW1iZXIpOip9IFZpZXdTY2FsZSAqL1xyXG5cclxuLyoqXHJcbiAqIEEgc3R5bGUsIHRvIHNob3cgYSBncmlkIGRhdGFzZXQuXHJcbiAqXHJcbiAqIEBtb2R1bGUgY29yZVxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU3R5bGUgZXh0ZW5kcyBEcmF3YWJsZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHt7ZmlsdGVyPzpmdW5jdGlvbihpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGwpOmJvb2xlYW4sIG9mZnNldD86ZnVuY3Rpb24oaW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsLCBudW1iZXIsIG51bWJlcik6e2R4Om51bWJlcixkeTpudW1iZXJ9LCB2aXNpYmxlPzpmdW5jdGlvbihudW1iZXIpOmJvb2xlYW4sYWxwaGE/OmZ1bmN0aW9uKG51bWJlcik6bnVtYmVyLGJsZW5kT3BlcmF0aW9uPzpmdW5jdGlvbihudW1iZXIpOkdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbixkcmF3RnVuPzpmdW5jdGlvbix2aWV3U2NhbGU/OlZpZXdTY2FsZX19IG9wdHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge1ZpZXdTY2FsZXx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgdGhpcy52aWV3U2NhbGUgPSBvcHRzLnZpZXdTY2FsZVxyXG5cclxuICAgICAgICAvKiogQSBmaWx0ZXIgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIGNlbGwgbGlzdCwgdG8gZmlsdGVyIG91dCBzb21lIGNlbGxzIG5vdCB0byBiZSBkcmF3biAoc3VjaCBhcyBmb3IgZXhhbXBsZSB0aGUgY2VsbHMgd2l0aCB2YWx1ZT0wKS5cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQHR5cGUgeyhmdW5jdGlvbihpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGwpOmJvb2xlYW4pIHwgdW5kZWZpbmVkfSAqL1xyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gb3B0cy5maWx0ZXIgfHwgdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8qKiBBbiBvZmZzZXQuIFRoaXMgaXMgdG8gYWx0ZXIgdGhlIHBvc2l0aW9uIG9mIGFsbCBzeW1ib2xzIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLiBJbiBnZW9ncmFwaGljYWwgdW5pdC5cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCxudW1iZXIsbnVtYmVyKTp7ZHg6bnVtYmVyLGR5Om51bWJlcn19ICovXHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvcHRzLm9mZnNldCB8fCAoKGMsIHIsIHopID0+ICh7IGR4OiAwLCBkeTogMCB9KSlcclxuXHJcbiAgICAgICAgLyoqIEEgZHJhdyBmdW5jdGlvbiBmb3IgdGhlIHN0eWxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgdGhpcy5kcmF3RnVuID0gb3B0cy5kcmF3RnVuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwdWJsaWNcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPGltcG9ydChcIi4vTGVnZW5kXCIpLkxlZ2VuZD59ICovXHJcbiAgICAgICAgdGhpcy5sZWdlbmRzID0gW11cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgY2VsbHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsPn0gY2VsbHMgVGhlIGNlbGxzIHRvIGRyYXcuXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzIFRoZSBjYW52YXMgd2hlcmUgdG8gZHJhdyB0aGVtLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGhlaXIgcmVzb2x1dGlvbiAoaW4gZ2VvZ3JhcGhpYyB1bml0KVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKi9cclxuICAgIGRyYXcoY2VsbHMsIGdlb0NhbnZhcywgcmVzb2x1dGlvbikge1xyXG4gICAgICAgIGlmICh0aGlzLmRyYXdGdW4pIHRoaXMuZHJhd0Z1bihjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKVxyXG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgZHJhdyBub3QgaW1wbGVtZW50ZWQuJylcclxuICAgIH1cclxuXHJcbiAgICAvL2dldHRlcnMgYW5kIHNldHRlcnNcclxuXHJcbiAgICAvKiogQHJldHVybnMge2Z1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCxudW1iZXIsbnVtYmVyKTp7ZHg6bnVtYmVyLGR5Om51bWJlcn19ICovXHJcbiAgICBnZXRPZmZzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0XHJcbiAgICB9XHJcbiAgICAvKiogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGwsbnVtYmVyLG51bWJlcik6e2R4Om51bWJlcixkeTpudW1iZXJ9fSB2YWwgQHJldHVybnMge3RoaXN9ICovXHJcbiAgICBzZXRPZmZzZXQodmFsKSB7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB2YWxcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBVcGRhdGUgbGVnZW5kcyBvZiB0aGUgc3R5bGUsIGlmIGFueVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcclxuICAgICAqIEByZXR1cm5zIHt0aGlzfSAqL1xyXG4gICAgdXBkYXRlTGVnZW5kcyhvcHRzKSB7XHJcbiAgICAgICAgU3R5bGUudXBkYXRlTGVnZW5kc1JlY3Vyc2l2ZSh0aGlzLmxlZ2VuZHMsIG9wdHMpXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKiogQHByaXZhdGUgKi9cclxuICAgIHN0YXRpYyB1cGRhdGVMZWdlbmRzUmVjdXJzaXZlKGxnLCBvcHRzKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGcpKSBmb3IgKGNvbnN0IGxnXyBvZiBsZykgdGhpcy51cGRhdGVMZWdlbmRzUmVjdXJzaXZlKGxnXywgb3B0cylcclxuICAgICAgICBlbHNlIGxnLnVwZGF0ZShvcHRzKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi9MZWdlbmRcIikuTGVnZW5kPn0gbGVnZW5kc1xyXG4gICAgICogQHJldHVybnMge3RoaXN9ICovXHJcbiAgICBhZGRMZWdlbmRzKGxlZ2VuZHMpIHtcclxuICAgICAgICBmb3IgKGxldCBsZWdlbmQgb2YgbGVnZW5kcykgdGhpcy5sZWdlbmRzLnB1c2gobGVnZW5kKVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbi8vaW1wb3J0IHsgdHJhbnNpdGlvbiB9IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XHJcblxyXG4vKipcclxuICogQSBnZW5lcmljIGNsYXNzIHRvIG1ha2UgYSB0b29sdGlwLlxyXG4gKiBJdCBpcyBhIGRpdiBlbGVtZW50LCB3aGljaCBjYW4gYmUgbW92ZWQgdW5kZXIgdGhlIG1vdXNlIHBvaW50ZXIgYW5kIGZpbGxlZCB3aXRoIHNvbWUgaW5mb3JtYXRpb24gaW4gaHRtbC5cclxuICogQG1vZHVsZSBjb3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVG9vbHRpcCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLm1heFdpZHRoID0gb3B0cy5tYXhXaWR0aCB8fCAnMjBlbSdcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmZvbnRTaXplID0gb3B0cy5mb250U2l6ZSB8fCAnMS4yZW0nXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gb3B0cy5iYWNrZ3JvdW5kIHx8ICd3aGl0ZSdcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnBhZGRpbmcgPSBvcHRzLnBhZGRpbmcgfHwgJzVweCdcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmJvcmRlciA9IG9wdHMuYm9yZGVyIHx8ICcwcHgnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpc1snYm9yZGVyLXJhZGl1cyddID0gb3B0c1snYm9yZGVyLXJhZGl1cyddIHx8ICcwcHgnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpc1snYm94LXNoYWRvdyddID0gb3B0c1snYm94LXNoYWRvdyddIHx8ICc1cHggNXB4IDVweCBncmV5J1xyXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXNbJ2ZvbnQtZmFtaWx5J10gPSBvcHRzWydmb250LWZhbWlseSddIHx8ICdIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmJ1xyXG5cclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbiA9IG9wdHMudHJhbnNpdGlvbkR1cmF0aW9uIHx8IDEwMFxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMueE9mZnNldCA9IG9wdHMueE9mZnNldCB8fCAzMFxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMueU9mZnNldCA9IG9wdHMueU9mZnNldCB8fCAyMFxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAvLyBlLmcuIHRvIHByZXZlbnQgbW91c2UgY3Vyc29yIGNvdmVyaW5nIGNlbGwgYmVpbmcgaGlnaGxpZ2h0ZWRcclxuICAgICAgICB0aGlzLnlNb3VzZU9mZnNldCA9IG9wdHMueU1vdXNlT2Zmc2V0IHx8IDBcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnhNb3VzZU9mZnNldCA9IG9wdHMueE1vdXNlT2Zmc2V0IHx8IDBcclxuICAgICAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xyXG4gICAgICAgIHRoaXMucGFyZW50RWxlbWVudCA9IG9wdHMucGFyZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5XHJcbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cclxuICAgICAgICB0aGlzLnRvb2x0aXBFbGVtZW50ID0gb3B0cy50b29sdGlwRWxlbWVudCB8fCBudWxsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwdWJsaWNcclxuICAgICAgICAgKiBAdHlwZSB7aW1wb3J0KFwiZDMtc2VsZWN0aW9uXCIpLlNlbGVjdGlvbn0gKi9cclxuICAgICAgICB0aGlzLnRvb2x0aXAgPSBvcHRzLnRvb2x0aXBFbGVtZW50XHJcbiAgICAgICAgICAgID8gc2VsZWN0KG9wdHMudG9vbHRpcEVsZW1lbnQpIC8vIFdyYXAgdGhlIHByb3ZpZGVkIEhUTUwgbm9kZSBpbiBhIEQzIHNlbGVjdGlvblxyXG4gICAgICAgICAgICA6IHNlbGVjdCh0aGlzLnBhcmVudEVsZW1lbnQpLmFwcGVuZCgnZGl2JykuYXR0cignaWQnLCAnZ3JpZHZpei10b29sdGlwJykuYXR0cignY2xhc3MnLCAnZ3JpZHZpei10b29sdGlwJykgLy8gY3JlYXRlIGRlZmF1bHQgZWxlbWVudFxyXG5cclxuICAgICAgICAvL2luaXRpYWxpc2VcclxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ21heC13aWR0aCcsIHRoaXMubWF4V2lkdGgpXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdvdmVyZmxvdycsICdoaWRkZW4nKVxyXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgnZm9udC1zaXplJywgdGhpcy5mb250U2l6ZSlcclxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ2JhY2tncm91bmQnLCB0aGlzLmJhY2tncm91bmQpXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdwYWRkaW5nJywgdGhpcy5wYWRkaW5nKVxyXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgnYm9yZGVyJywgdGhpcy5ib3JkZXIpXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdib3JkZXItcmFkaXVzJywgdGhpc1snYm9yZGVyLXJhZGl1cyddKVxyXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgnYm94LXNoYWRvdycsIHRoaXNbJ2JveC1zaGFkb3cnXSlcclxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ2ZvbnQtZmFtaWx5JywgdGhpc1snZm9udC1mYW1pbHknXSlcclxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJylcclxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKVxyXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgnb3BhY2l0eScsICcwJylcclxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ3RleHQtd3JhcCcsICdub3dyYXAnKVxyXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgnei1pbmRleCcsIDk5OTk5OTk5KSAvLyBpbXBvcnRhbnQgZm9yIGxlYWZsZXQtZ3JpZHZpeiBldGNcclxuXHJcbiAgICAgICAgLy8gdGhlc2UgcGxhY2Vob2xkZXJzIGFyZSBuZWVkZWQgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBET00gcmVzaXplT2JzZXJ2ZXIgbG9vcDpcclxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ2xlZnQnLCAnMCcpXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCd0b3AnLCAnMCcpXHJcblxyXG4gICAgICAgIC8vIGFyaWEtbGFiZWxzICh0aGFua3MgdG8gd2FobGF0bGFzKVxyXG4gICAgICAgIHRoaXMudG9vbHRpcC5hdHRyKCdyb2xlJywgJ3Rvb2x0aXAnKS5hdHRyKCdhcmlhLWxpdmUnLCAncG9saXRlJylcclxuICAgIH1cclxuXHJcbiAgICAvKiogU2hvdyB0aGUgdG9vbHRpcCAqL1xyXG4gICAgc2hvdygpIHtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLnRyYW5zaXRpb25EdXJhdGlvbikuc3R5bGUoJ29wYWNpdHknLCAxKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBIaWRlIHRoZSB0b29sdGlwICovXHJcbiAgICBoaWRlKCkge1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICB0aGlzLnRvb2x0aXAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uKS5zdHlsZSgnb3BhY2l0eScsIDApXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxyXG4gICAgICovXHJcbiAgICBodG1sKGh0bWwpIHtcclxuICAgICAgICB0aGlzLnRvb2x0aXAuaHRtbChodG1sKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcCBhdCB0aGUgbW91c2UgZXZlbnQgcG9zaXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHNldFBvc2l0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBib3VuZGluZyByZWN0IG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIChtYXAyKVxyXG4gICAgICAgIGxldCBwYXJlbnRSZWN0ID0gdGhpcy5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgbW91c2UgcG9zaXRpb24gKHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQgY29udGFpbmVyKVxyXG4gICAgICAgIGxldCB4ID0gZXZlbnQuY2xpZW50WCAtIHBhcmVudFJlY3QubGVmdCArIHRoaXMueE9mZnNldCAvLyBSZWxhdGl2ZSB0byBwYXJlbnRcclxuICAgICAgICBsZXQgeSA9IGV2ZW50LmNsaWVudFkgLSBwYXJlbnRSZWN0LnRvcCAtIHRoaXMueU9mZnNldCAvLyBSZWxhdGl2ZSB0byBwYXJlbnRcclxuXHJcbiAgICAgICAgLy8gTm93LCBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHRvb2x0aXBcclxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ2xlZnQnLCB4ICsgJ3B4Jykuc3R5bGUoJ3RvcCcsIHkgKyAncHgnKVxyXG5cclxuICAgICAgICAvLyBFbnN1cmUgdGhlIHRvb2x0aXAgc3RheXMgaW5zaWRlIHRoZSBwYXJlbnQgY29udGFpbmVyXHJcbiAgICAgICAgdGhpcy5lbnN1cmVUb29sdGlwSW5zaWRlQ29udGFpbmVyKGV2ZW50LCBwYXJlbnRSZWN0LCB0aGlzLnRvb2x0aXAubm9kZSgpKVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gZW5zdXJlVG9vbHRpcEluc2lkZUNvbnRhaW5lclxyXG4gICAgICogQGRlc2NyaXB0aW9uIFByZXZlbnRzIHRoZSB0b29sdGlwIGZyb20gb3ZlcmZsb3dpbmcgb3V0IG9mIHRoZSBBcHAgY29udGFpbmVyIChlbnN1cmVzIHRoYXQgdGhlIHRvb2x0aXAgaXMgaW5zaWRlIHRoZSBncmlkdml6IGNvbnRhaW5lcilcclxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcclxuICAgICAqIEBwYXJhbSB7RE9NUmVjdH0gcGFyZW50UmVjdFxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9vbHRpcE5vZGVcclxuICAgICAqL1xyXG4gICAgZW5zdXJlVG9vbHRpcEluc2lkZUNvbnRhaW5lcihldmVudCwgcGFyZW50UmVjdCwgdG9vbHRpcE5vZGUpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRvb2x0aXBOb2RlXHJcbiAgICAgICAgbGV0IHBhcmVudFdpZHRoID0gcGFyZW50UmVjdC53aWR0aFxyXG4gICAgICAgIGxldCBwYXJlbnRIZWlnaHQgPSBwYXJlbnRSZWN0LmhlaWdodFxyXG5cclxuICAgICAgICAvLyBFbnN1cmUgdG9vbHRpcCBkb2Vzbid0IGdvIGJleW9uZCB0aGUgcmlnaHQgZWRnZVxyXG4gICAgICAgIGlmIChub2RlLm9mZnNldExlZnQgKyBub2RlLmNsaWVudFdpZHRoID4gcGFyZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgbGV0IGxlZnQgPSBldmVudC5jbGllbnRYIC0gbm9kZS5jbGllbnRXaWR0aCAtIHRoaXMueE9mZnNldFxyXG4gICAgICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4J1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIHRvb2x0aXAgZG9lc24ndCBnbyBiZXlvbmQgdGhlIGJvdHRvbSBlZGdlXHJcbiAgICAgICAgaWYgKG5vZGUub2Zmc2V0VG9wICsgbm9kZS5jbGllbnRIZWlnaHQgPiBwYXJlbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgbm9kZS5zdHlsZS50b3AgPSBwYXJlbnRIZWlnaHQgLSBub2RlLmNsaWVudEhlaWdodCArICdweCdcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSB0b29sdGlwIGRvZXNuJ3QgZ28gYWJvdmUgdGhlIHRvcCBlZGdlXHJcbiAgICAgICAgaWYgKG5vZGUub2Zmc2V0VG9wIDwgMCkge1xyXG4gICAgICAgICAgICBub2RlLnN0eWxlLnRvcCA9IDAgKyAncHgnXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFbnN1cmUgdG9vbHRpcCBkb2Vzbid0IGdvIGJleW9uZCB0aGUgbGVmdCBlZGdlXHJcbiAgICAgICAgaWYgKG5vZGUub2Zmc2V0TGVmdCA8IDApIHtcclxuICAgICAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gMCArICdweCdcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuXHRteS5tb3VzZW92ZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGh0bWwpIHtcclxuXHRcdGlmIChodG1sKSBteS5odG1sKGh0bWwpO1xyXG5cdFx0bXkuc2V0UG9zaXRpb24oZXZlbnQpO1xyXG5cdFx0bXkuc2hvdygpXHJcblx0XHQvL3RoaXMuZW5zdXJlVG9vbHRpcEluc2lkZUNvbnRhaW5lcigpO1xyXG5cdH07XHJcblx0XHJcblx0bXkubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRteS5zZXRQb3NpdGlvbihldmVudCk7XHJcblx0XHQvL3RoaXMuZW5zdXJlVG9vbHRpcEluc2lkZUNvbnRhaW5lcigpO1xyXG5cdH07XHJcblx0XHJcblx0bXkubW91c2VvdXQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRteS5oaWRlKCk7XHJcblx0fTsqL1xyXG5cclxuICAgIHN0eWxlKGssIHYpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSByZXR1cm4gdGhpcy50b29sdGlwLnN0eWxlKGspXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKGssIHYpXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICBhdHRyKGssIHYpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSByZXR1cm4gdGhpcy50b29sdGlwLmF0dHIoaylcclxuICAgICAgICB0aGlzLnRvb2x0aXAuYXR0cihrLCB2KVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG4vKiogQHR5cGVkZWYge3sgZGltczogb2JqZWN0LCBjcnM6IHN0cmluZywgdGlsZVNpemVDZWxsOiBudW1iZXIsIG9yaWdpblBvaW50OiB7eDpudW1iZXIseTpudW1iZXJ9LCByZXNvbHV0aW9uR2VvOiBudW1iZXIsIHRpbGluZ0JvdW5kczppbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhcy5qc1wiKS5FbnZlbG9wZSB9fSBHcmlkSW5mbyAqL1xyXG5cclxuaW1wb3J0IHsgZHN2IH0gZnJvbSAnZDMtZmV0Y2gnXHJcbmltcG9ydCB7IERhdGFzZXQgfSBmcm9tICcuLi9jb3JlL0RhdGFzZXQuanMnXHJcblxyXG4vKipcclxuICogQSBkYXRhc2V0IGNvbXBvc2VkIG9mIGEgc2luZ2xlIENTViBmaWxlIChub3QgdGlsZWQpLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGRhdGFzZXRcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENTVkdyaWQgZXh0ZW5kcyBEYXRhc2V0IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL01hcC5qc1wiKS5NYXB9IG1hcCBUaGUgbWFwLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIG9mIHRoZSBkYXRhc2V0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGhlIGRhdGFzZXQgcmVzb2x1dGlvbiBpbiBnZW9ncmFwaGljYWwgdW5pdC5cclxuICAgICAqIEBwYXJhbSB7e3ByZXByb2Nlc3M/OihmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbCk6Ym9vbGVhbiksZGVsaW1pdGVyPzpzdHJpbmd9fSBvcHRzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG1hcCwgdXJsLCByZXNvbHV0aW9uLCBvcHRzID0ge30pIHtcclxuICAgICAgICBzdXBlcihtYXAsIHVybCwgcmVzb2x1dGlvbiwgb3B0cylcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsPn0gKi9cclxuICAgICAgICB0aGlzLmNlbGxzID0gW11cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuZGVsaW1pdGVyID0gb3B0cy5kZWxpbWl0ZXIgfHwgJywnXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICogQHByaXZhdGUgICovXHJcbiAgICAgICAgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9ICdub3RMb2FkZWQnXHJcblxyXG4gICAgICAgIC8vZ2V0IGRhdGFcclxuICAgICAgICB0aGlzLmdldERhdGEodW5kZWZpbmVkKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdCBkYXRhIHdpdGhpbiBhIGdlb2dyYXBoaWMgZW52ZWxvcGUuXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkVudmVsb3BlfHVuZGVmaW5lZH0gZVxyXG4gICAgICovXHJcbiAgICBnZXREYXRhKGUpIHtcclxuICAgICAgICAvL2NoZWNrIGlmIGRhdGEgYWxyZWFkeSBsb2FkZWRcclxuICAgICAgICBpZiAodGhpcy5pbmZvTG9hZGluZ1N0YXR1cyAhPSAnbm90TG9hZGVkJykgcmV0dXJuIHRoaXNcclxuXHJcbiAgICAgICAgLy9sb2FkIGRhdGFcclxuICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ2xvYWRpbmcnXHJcbiAgICAgICAgOyhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZHN2KHRoaXMuZGVsaW1pdGVyLCB0aGlzLnVybClcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgY29vcmRpbmF0ZXMgaW4gbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjLnggPSArYy54XHJcbiAgICAgICAgICAgICAgICAgICAgYy55ID0gK2MueVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vcHJlcHJvY2Vzcy9maWx0ZXJcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXByb2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxzID0gW11cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gdGhpcy5wcmVwcm9jZXNzKGMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiID09IGZhbHNlKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxzLnB1c2goYylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2VsbHMgPSBkYXRhXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPIGNoZWNrIGlmIHJlZHJhdyBpcyBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgIC8vdGhhdCBpcyBpZiB0aGUgZGF0YXNldCBiZWxvbmdzIHRvIGEgbGF5ZXIgd2hpY2ggaXMgdmlzaWJsZSBhdCB0aGUgY3VycmVudCB6b29tIGxldmVsXHJcblxyXG4gICAgICAgICAgICAgICAgLy9yZWRyYXcgbWFwXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXApIHRoaXMubWFwLnJlZHJhdygpXHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9ICdsb2FkZWQnXHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAvL21hcmsgYXMgZmFpbGVkXHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ2ZhaWxlZCdcclxuICAgICAgICAgICAgICAgIHRoaXMuY2VsbHMgPSBbXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsbCB0aGUgdmlldyBjYWNoZSB3aXRoIGFsbCBjZWxscyB3aGljaCBhcmUgd2l0aGluIGEgZ2VvZ3JhcGhpY2FsIGVudmVsb3BlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuRW52ZWxvcGV9IGV4dEdlb1xyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVZpZXdDYWNoZShleHRHZW8pIHtcclxuICAgICAgICAvL2RhdGEgbm90IGxvYWRlZCB5ZXRcclxuICAgICAgICBpZiAoIXRoaXMuY2VsbHMpIHJldHVyblxyXG5cclxuICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlID0gW11cclxuICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGhpcy5jZWxscykge1xyXG4gICAgICAgICAgICBpZiAoK2NlbGwueCArIHRoaXMucmVzb2x1dGlvbiA8IGV4dEdlby54TWluKSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoK2NlbGwueCAtIHRoaXMucmVzb2x1dGlvbiA+IGV4dEdlby54TWF4KSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoK2NlbGwueSArIHRoaXMucmVzb2x1dGlvbiA8IGV4dEdlby55TWluKSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoK2NlbGwueSAtIHRoaXMucmVzb2x1dGlvbiA+IGV4dEdlby55TWF4KSBjb250aW51ZVxyXG4gICAgICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlLnB1c2goY2VsbClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBEYXRhc2V0IH0gZnJvbSAnLi4vY29yZS9EYXRhc2V0LmpzJ1xyXG5cclxuLyoqXHJcbiAqIEEgZGF0YXNldCBjb21wb3NlZCBvZiBjZWxscyBkZWZpbmVkIGluIGphdmFzY3JpcHQsIG9yIGxvYWRlZCBvdXRzaWRlIG9mIGdyaWR2aXogbWFwLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGRhdGFzZXRcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEpTR3JpZCBleHRlbmRzIERhdGFzZXQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBUaGUgZGF0YXNldCByZXNvbHV0aW9uIGluIGdlb2dyYXBoaWNhbCB1bml0LlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gY2VsbHMgVGhlIGNlbGxzLlxyXG4gICAgICogQHBhcmFtIHt9IG9wdHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocmVzb2x1dGlvbiwgY2VsbHMsIG9wdHMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHVuZGVmaW5lZCwgJycsIHJlc29sdXRpb24sIG9wdHMpXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGw+fSAqL1xyXG4gICAgICAgIHRoaXMuY2VsbHMgPSBjZWxscyB8fCBbXVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdCBkYXRhIHdpdGhpbiBhIGdlb2dyYXBoaWMgZW52ZWxvcGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhcy5qc1wiKS5FbnZlbG9wZXx1bmRlZmluZWR9IGVcclxuICAgICAqL1xyXG4gICAgZ2V0RGF0YShlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGwgdGhlIHZpZXcgY2FjaGUgd2l0aCBhbGwgY2VsbHMgd2hpY2ggYXJlIHdpdGhpbiBhIGdlb2dyYXBoaWNhbCBlbnZlbG9wZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkVudmVsb3BlfSBleHRHZW9cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVWaWV3Q2FjaGUoZXh0R2VvKSB7XHJcbiAgICAgICAgLy9kYXRhIG5vdCBsb2FkZWQgeWV0XHJcbiAgICAgICAgaWYgKCF0aGlzLmNlbGxzKSByZXR1cm5cclxuXHJcbiAgICAgICAgdGhpcy5jZWxsc1ZpZXdDYWNoZSA9IFtdXHJcbiAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHRoaXMuY2VsbHMpIHtcclxuICAgICAgICAgICAgaWYgKCtjZWxsLnggKyB0aGlzLnJlc29sdXRpb24gPCBleHRHZW8ueE1pbikgY29udGludWVcclxuICAgICAgICAgICAgaWYgKCtjZWxsLnggLSB0aGlzLnJlc29sdXRpb24gPiBleHRHZW8ueE1heCkgY29udGludWVcclxuICAgICAgICAgICAgaWYgKCtjZWxsLnkgKyB0aGlzLnJlc29sdXRpb24gPCBleHRHZW8ueU1pbikgY29udGludWVcclxuICAgICAgICAgICAgaWYgKCtjZWxsLnkgLSB0aGlzLnJlc29sdXRpb24gPiBleHRHZW8ueU1heCkgY29udGludWVcclxuICAgICAgICAgICAgdGhpcy5jZWxsc1ZpZXdDYWNoZS5wdXNoKGNlbGwpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuLyoqIEB0eXBlZGVmIHt7IGRpbXM6IG9iamVjdCwgY3JzOiBzdHJpbmcsIHRpbGVTaXplQ2VsbDogbnVtYmVyLCBvcmlnaW5Qb2ludDoge3g6bnVtYmVyLHk6bnVtYmVyfSwgcmVzb2x1dGlvbkdlbzogbnVtYmVyLCB0aWxpbmdCb3VuZHM6aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuRW52ZWxvcGUgfX0gR3JpZEluZm8gKi9cclxuXHJcbi8vIGludGVybmFsXHJcbmltcG9ydCB7IERhdGFzZXQgfSBmcm9tICcuLi9jb3JlL0RhdGFzZXQuanMnXHJcbi8vaW1wb3J0IHsgbW9uaXRvciwgbW9uaXRvckR1cmF0aW9uIH0gZnJvbSAnLi4vdXRpbHMvVXRpbHMuanMnXHJcblxyXG4vLyBleHRlcm5hbFxyXG5pbXBvcnQgeyBqc29uLCBjc3YgfSBmcm9tICdkMy1mZXRjaCdcclxuXHJcbi8qKlxyXG4gKiBBIHRpbGVkIGRhdGFzZXQsIGNvbXBvc2VkIG9mIENTViB0aWxlcy5cclxuICpcclxuICogQG1vZHVsZSBkYXRhc2V0XHJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBUaWxlZEdyaWQgZXh0ZW5kcyBEYXRhc2V0IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL01hcC5qc1wiKS5NYXB9IG1hcCBUaGUgbWFwLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIG9mIHRoZSBkYXRhc2V0LlxyXG4gICAgICogQHBhcmFtIHt7cHJlcHJvY2Vzcz86KGZ1bmN0aW9uKGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsKTpib29sZWFuKSwgb25seURyYXdXaGVuQWxsVGlsZXNSZWFkeTpib29sZWFufX0gb3B0c1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYXAsIHVybCwgb3B0cyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIobWFwLCB1cmwsIDAsIG9wdHMpXHJcbiAgICAgICAgdGhpcy5vbmx5RHJhd1doZW5BbGxUaWxlc1JlYWR5ID0gb3B0cy5vbmx5RHJhd1doZW5BbGxUaWxlc1JlYWR5IHx8IGZhbHNlXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGdyaWQgaW5mbyBvYmplY3QsIGZyb20gdGhlIGluZm8uanNvbiBmaWxlLlxyXG4gICAgICAgICAqICBAdHlwZSB7R3JpZEluZm8gfCB1bmRlZmluZWR9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiAgKi9cclxuICAgICAgICB0aGlzLmluZm8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKiBAcHJpdmF0ZSAgKi9cclxuICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ25vdExvYWRlZCdcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNhY2hlIG9mIHRoZSBsb2FkZWQgdGlsZXMuIEl0IGlzIGRvdWJsZSBpbmRleGVkOiBieSB4VCBhbmQgdGhlbiB5VC5cclxuICAgICAgICAgKiBFeGFtcGxlOiB0aGlzLmNhY2hlW3hUXVt5VF0gcmV0dXJucyB0aGUgdGlsZSBhdCBbeFRdW3lUXSBsb2NhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAgICAgICogKi9cclxuICAgICAgICB0aGlzLmNhY2hlID0ge31cclxuXHJcbiAgICAgICAgLy9sYXVuY2ggbG9hZGluZ1xyXG4gICAgICAgIHRoaXMubG9hZEluZm8oKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCB0aGUgaW5mby5qc29uIGZyb20gdGhlIHVybC5cclxuICAgICAqIEByZXR1cm5zIHRoaXNcclxuICAgICAqL1xyXG4gICAgbG9hZEluZm8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluZm8gJiYgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9PT0gJ25vdExvYWRlZCcpIHtcclxuICAgICAgICAgICAgOyhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBqc29uKHRoaXMudXJsICsgJ2luZm8uanNvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmZvID0gZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IGRhdGEucmVzb2x1dGlvbkdlb1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPSAnbG9hZGVkJ1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwLnJlZHJhdygpXHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbWFyayBhcyBmYWlsZWRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ2ZhaWxlZCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkoKVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9PT0gJ2xvYWRlZCcgfHwgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9PT0gJ2ZhaWxlZCcpIHRoaXMubWFwLnJlZHJhdygpXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgYSB0aWxpbmcgZW52ZWxvcGUgZnJvbSBhIGdlb2dyYXBoaWNhbCBlbnZlbG9wZS5cclxuICAgICAqIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRvIHVzZSB0byBrbm93IHdoaWNoIHRpbGVzIHRvIGRvd25sb2FkIGZvciBhIGdlb2dyYXBoaWNhbCB2aWV3LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuRW52ZWxvcGV9IGVcclxuICAgICAqIEByZXR1cm5zIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhcy5qc1wiKS5FbnZlbG9wZXx1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIGdldFRpbGluZ0VudmVsb3BlKGUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5mbykge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRJbmZvKClcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwbyA9IHRoaXMuaW5mby5vcmlnaW5Qb2ludCxcclxuICAgICAgICAgICAgciA9IHRoaXMuaW5mby5yZXNvbHV0aW9uR2VvLFxyXG4gICAgICAgICAgICBzID0gdGhpcy5pbmZvLnRpbGVTaXplQ2VsbFxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4TWluOiBNYXRoLmZsb29yKChlLnhNaW4gLSBwby54KSAvIChyICogcykpLFxyXG4gICAgICAgICAgICB4TWF4OiBNYXRoLmZsb29yKChlLnhNYXggLSBwby54KSAvIChyICogcykpLFxyXG4gICAgICAgICAgICB5TWluOiBNYXRoLmZsb29yKChlLnlNaW4gLSBwby55KSAvIChyICogcykpLFxyXG4gICAgICAgICAgICB5TWF4OiBNYXRoLmZsb29yKChlLnlNYXggLSBwby55KSAvIChyICogcykpLFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3QgZGF0YSB3aXRoaW4gYSBnZW9ncmFwaGljIGVudmVsb3BlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9jb3JlL0dlb0NhbnZhcy5qcycpLkVudmVsb3BlfSBleHRHZW9cclxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXREYXRhKGV4dEdlbykge1xyXG4gICAgICAgIGlmICghdGhpcy5pbmZvKSByZXR1cm4gdGhpc1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYW4gQWJvcnRDb250cm9sbGVyIGZvciB0aGUgY3VycmVudCBkYXRhIHJlcXVlc3RcclxuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxyXG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbFxyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHRpbGluZyBlbnZlbG9wZSBhbmQgY2hlY2sgYm91bmRzXHJcbiAgICAgICAgY29uc3QgdGIgPSB0aGlzLmdldFRpbGluZ0VudmVsb3BlKGV4dEdlbylcclxuICAgICAgICBpZiAoIXRiKSByZXR1cm4gdGhpc1xyXG5cclxuICAgICAgICBjb25zdCB7IHhNaW46IGdiWE1pbiwgeE1heDogZ2JYTWF4LCB5TWluOiBnYllNaW4sIHlNYXg6IGdiWU1heCB9ID0gdGhpcy5pbmZvLnRpbGluZ0JvdW5kc1xyXG5cclxuICAgICAgICBjb25zdCB4TWluID0gTWF0aC5tYXgodGIueE1pbiwgZ2JYTWluKVxyXG4gICAgICAgIGNvbnN0IHhNYXggPSBNYXRoLm1pbih0Yi54TWF4LCBnYlhNYXgpXHJcbiAgICAgICAgY29uc3QgeU1pbiA9IE1hdGgubWF4KHRiLnlNaW4sIGdiWU1pbilcclxuICAgICAgICBjb25zdCB5TWF4ID0gTWF0aC5taW4odGIueU1heCwgZ2JZTWF4KVxyXG5cclxuICAgICAgICBjb25zdCB0b3RhbFRpbGVzID0gKHhNYXggLSB4TWluICsgMSkgKiAoeU1heCAtIHlNaW4gKyAxKVxyXG4gICAgICAgIGxldCBwcm9jZXNzZWRUaWxlcyA9IDBcclxuICAgICAgICBjb25zdCB0aWxlUHJvbWlzZXMgPSBbXVxyXG5cclxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGlsZXMgd2l0aGluIGJvdW5kc1xyXG4gICAgICAgIGZvciAobGV0IHhUID0geE1pbjsgeFQgPD0geE1heDsgeFQrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5VCA9IHlNaW47IHlUIDw9IHlNYXg7IHlUKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZVt4VF0pIHRoaXMuY2FjaGVbeFRdID0ge31cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGFscmVhZHkgbG9hZGVkIHRpbGVzIG9yIHJldHJ5IGZhaWxlZCBvbmVzXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWNoZVt4VF1beVRdICYmIHRoaXMuY2FjaGVbeFRdW3lUXSAhPT0gJ2ZhaWxlZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICArK3Byb2Nlc3NlZFRpbGVzXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYXJrIHRpbGUgYXMgbG9hZGluZ1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZVt4VF1beVRdID0gJ2xvYWRpbmcnXHJcblxyXG4gICAgICAgICAgICAgICAgdGlsZVByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkVGlsZSh4VCwgeVQsIHNpZ25hbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHRpbGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVbeFRdW3lUXSA9IHRpbGVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBsYXN0IHRpbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTGFzdFRpbGUgPSArK3Byb2Nlc3NlZFRpbGVzID09PSB0b3RhbFRpbGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQW5kUmVkcmF3KHRpbGUsIGlzTGFzdFRpbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlW3hUXVt5VF0gPSAnZmFpbGVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytwcm9jZXNzZWRUaWxlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQodGlsZVByb21pc2VzKVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIGEgdGlsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5VFxyXG4gICAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gc2lnbmFsXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxyXG4gICAgICovXHJcbiAgICBhc3luYyBsb2FkVGlsZSh4VCwgeVQsIHNpZ25hbCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjc3YoYCR7dGhpcy51cmx9JHt4VH0vJHt5VH0uY3N2YCwgeyBzaWduYWwgfSlcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGxzID0gdGhpcy5wcmVwcm9jZXNzID8gZGF0YS5maWx0ZXIoKGNlbGwpID0+IHRoaXMucHJlcHJvY2VzcyhjZWxsKSAhPT0gZmFsc2UpIDogZGF0YVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmluZm8pIHRocm93IG5ldyBFcnJvcignVGlsZSBpbmZvIHVua25vd24nKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGdldEdyaWRUaWxlKGNlbGxzLCB4VCwgeVQsIHRoaXMuaW5mbylcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFRpbGUgcmVxdWVzdCBmb3IgJHt4VH0sICR7eVR9IHdhcyBhYm9ydGVkLmApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW5jZWwgb25nb2luZyBkYXRhIHJlcXVlc3RzIHdoZW4gem9vbSBsZXZlbCBjaGFuZ2VzLlxyXG4gICAgICovXHJcbiAgICBjYW5jZWxDdXJyZW50UmVxdWVzdHMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWJvcnRDb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tBbmRSZWRyYXcodGlsZSwgaXNMYXN0VGlsZSkge1xyXG4gICAgICAgIGlmICh0aGlzLm1hcC5nZW9DYW52YXMuY2FudmFzU2F2ZS5jKSByZXR1cm47IC8vIHNraXAgcmVkcmF3cyBkdXJpbmcgem9vbVxyXG4gICAgICAgIC8vIENoZWNrIGlmIGFueSB2aXNpYmxlIGxheWVyIGRlcGVuZHMgb24gdGhpcyBkYXRhc2V0XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgcmVkcmF3IGlzIHJlYWxseSBuZWVkZWQsIHRoYXQgaXMgaWY6XHJcbiAgICAgICAgLy8gMS4gdGhlIGRhdGFzZXQgYmVsb25ncyB0byBhIGxheWVyIHdoaWNoIGlzIHZpc2libGUgYXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxyXG4gICAgICAgIGxldCBuZWVkc1JlZHJhdyA9IGZhbHNlXHJcbiAgICAgICAgLy9nbyB0aHJvdWdoIHRoZSBsYXllcnNcclxuICAgICAgICBjb25zdCB6ID0gdGhpcy5tYXAuZ2V0Wm9vbSgpXHJcbiAgICAgICAgZm9yIChjb25zdCBsYXkgb2YgdGhpcy5tYXAubGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXkudmlzaWJsZSAmJiAhbGF5LnZpc2libGUoeikpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGlmICghbGF5LmdldERhdGFzZXQpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGlmIChsYXkuZ2V0RGF0YXNldCh6KSAhPSB0aGlzKSBjb250aW51ZVxyXG4gICAgICAgICAgICAvL2ZvdW5kIG9uZSBsYXllci4gTm8gbmVlZCB0byBzZWVrIG1vcmUuXHJcbiAgICAgICAgICAgIG5lZWRzUmVkcmF3ID0gdHJ1ZVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFuZWVkc1JlZHJhdykgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRpbGUgaW50ZXJzZWN0cyB0aGUgY3VycmVudCB2aWV3XHJcbiAgICAgICAgY29uc3QgZW52ID0gdGhpcy5tYXAudXBkYXRlRXh0ZW50R2VvKClcclxuICAgICAgICBjb25zdCB7IHhNaW4sIHhNYXgsIHlNaW4sIHlNYXggfSA9IHRpbGUuZXh0R2VvXHJcbiAgICAgICAgaWYgKGVudi54TWF4IDw9IHhNaW4gfHwgZW52LnhNaW4gPj0geE1heCB8fCBlbnYueU1heCA8PSB5TWluIHx8IGVudi55TWluID49IHlNYXgpIHJldHVyblxyXG5cclxuICAgICAgICAvLyBUcmlnZ2VyIHJlZHJhd1xyXG4gICAgICAgIGlmICh0aGlzLm9ubHlEcmF3V2hlbkFsbFRpbGVzUmVhZHkpIHtcclxuICAgICAgICAgICAgaWYgKGlzTGFzdFRpbGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwLnJlZHJhdygpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5yZWRyYXcoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGwgdGhlIHZpZXcgY2FjaGUgd2l0aCBhbGwgY2VsbHMgd2hpY2ggYXJlIHdpdGhpbiBhIGdlb2dyYXBoaWNhbCBlbnZlbG9wZS5cclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhcy5qc1wiKS5FbnZlbG9wZX0gZXh0R2VvXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgdXBkYXRlVmlld0NhY2hlKGV4dEdlbykge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgdGhpcy5jZWxsc1ZpZXdDYWNoZSA9IFtdXHJcblxyXG4gICAgICAgIC8vY2hlY2sgaWYgaW5mbyBoYXMgYmVlbiBsb2FkZWRcclxuICAgICAgICBpZiAoIXRoaXMuaW5mbykgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vdGlsZXMgd2l0aGluIHRoZSBzY29wZVxyXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuRW52ZWxvcGV8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgIGNvbnN0IHRiID0gdGhpcy5nZXRUaWxpbmdFbnZlbG9wZShleHRHZW8pXHJcbiAgICAgICAgaWYgKCF0YikgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vZ3JpZCBib3VuZHNcclxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkVudmVsb3BlfSAqL1xyXG4gICAgICAgIGNvbnN0IGdiID0gdGhpcy5pbmZvLnRpbGluZ0JvdW5kc1xyXG5cclxuICAgICAgICBmb3IgKGxldCB4VCA9IE1hdGgubWF4KHRiLnhNaW4sIGdiLnhNaW4pOyB4VCA8PSBNYXRoLm1pbih0Yi54TWF4LCBnYi54TWF4KTsgeFQrKykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FjaGVbeFRdKSBjb250aW51ZVxyXG4gICAgICAgICAgICBmb3IgKGxldCB5VCA9IE1hdGgubWF4KHRiLnlNaW4sIGdiLnlNaW4pOyB5VCA8PSBNYXRoLm1pbih0Yi55TWF4LCBnYi55TWF4KTsgeVQrKykge1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgdGlsZVxyXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtvYmplY3R9ICovXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aWxlID0gdGhpcy5jYWNoZVt4VF1beVRdXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRpbGUgfHwgdHlwZW9mIHRpbGUgPT09ICdzdHJpbmcnKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZ2V0IGNlbGxzXHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuY2VsbHNWaWV3Q2FjaGUgPSB0aGlzLmNlbGxzVmlld0NhY2hlLmNvbmNhdCh0aWxlLmNlbGxzKVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiB0aWxlLmNlbGxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCtjZWxsLnggKyB0aGlzLnJlc29sdXRpb24gPCBleHRHZW8ueE1pbikgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoK2NlbGwueCAtIHRoaXMucmVzb2x1dGlvbiA+IGV4dEdlby54TWF4KSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgrY2VsbC55ICsgdGhpcy5yZXNvbHV0aW9uIDwgZXh0R2VvLnlNaW4pIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCtjZWxsLnkgLSB0aGlzLnJlc29sdXRpb24gPiBleHRHZW8ueU1heCkgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlLnB1c2goY2VsbClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0R3JpZFRpbGUoY2VsbHMsIHhULCB5VCwgZ3JpZEluZm8pIHtcclxuICAgIGNvbnN0IHRpbGUgPSB7fVxyXG5cclxuICAgIC8qKiBAdHlwZSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldFwiKS5DZWxsPn0gKi9cclxuICAgIHRpbGUuY2VsbHMgPSBjZWxsc1xyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aWxlLnggPSB4VFxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aWxlLnkgPSB5VFxyXG5cclxuICAgIGNvbnN0IHIgPSBncmlkSW5mby5yZXNvbHV0aW9uR2VvXHJcbiAgICBjb25zdCBzID0gZ3JpZEluZm8udGlsZVNpemVDZWxsXHJcblxyXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhc1wiKS5FbnZlbG9wZX0gKi9cclxuICAgIHRpbGUuZXh0R2VvID0ge1xyXG4gICAgICAgIHhNaW46IGdyaWRJbmZvLm9yaWdpblBvaW50LnggKyByICogcyAqIHRpbGUueCxcclxuICAgICAgICB4TWF4OiBncmlkSW5mby5vcmlnaW5Qb2ludC54ICsgciAqIHMgKiAodGlsZS54ICsgMSksXHJcbiAgICAgICAgeU1pbjogZ3JpZEluZm8ub3JpZ2luUG9pbnQueSArIHIgKiBzICogdGlsZS55LFxyXG4gICAgICAgIHlNYXg6IGdyaWRJbmZvLm9yaWdpblBvaW50LnkgKyByICogcyAqICh0aWxlLnkgKyAxKSxcclxuICAgIH1cclxuXHJcbiAgICAvL2NvbnZlcnQgY2VsbCBjb29yZGluYXRlcyBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlc1xyXG4gICAgZm9yIChsZXQgY2VsbCBvZiB0aWxlLmNlbGxzKSB7XHJcbiAgICAgICAgY2VsbC54ID0gdGlsZS5leHRHZW8ueE1pbiArIGNlbGwueCAqIHJcclxuICAgICAgICBjZWxsLnkgPSB0aWxlLmV4dEdlby55TWluICsgY2VsbC55ICogclxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aWxlXHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2NvcmUvTGF5ZXIuanMnXHJcblxyXG4vKipcclxuICpcclxuICogQSBtYXAgYmFja2dyb3VuZCBsYXllciBpbiBcIlNsaXBweSBtYXBcIiBYWVogc3RhbmRhcmQuXHJcbiAqIFNlZSBodHRwczovL3dpa2kub3BlbnN0cmVldG1hcC5vcmcvd2lraS9TbGlwcHlfbWFwX3RpbGVuYW1lc1xyXG4gKiBodHRwczovL3d3dy5tYXB0aWxlci5jb20vZ29vZ2xlLW1hcHMtY29vcmRpbmF0ZXMtdGlsZS1ib3VuZHMtcHJvamVjdGlvbi8jNi8yNy44OC80NC40OFxyXG4gKlxyXG4gKiBAbW9kdWxlIGxheWVyXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCYWNrZ3JvdW5kTGF5ZXIgZXh0ZW5kcyBMYXllciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBUaGUgaW1hZ2UgY2FjaGUsIGluZGV4ZWQgYnkgei95L3hcclxuICAgICAgICAgKiBAcHJpdmF0ZSAqL1xyXG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMudXJsID0gb3B0cy51cmxcclxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsbnVtYmVyKTpzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy51cmxGdW4gPSBvcHRzLnVybEZ1biB8fCAoKHgsIHksIHopID0+IHRoaXMudXJsICsgeiArICcvJyArIHggKyAnLycgKyB5ICsgJy5wbmcnKVxyXG5cclxuICAgICAgICAvKiogVGhlIGdyb3VuZCByZXNvbHV0aW9ucyBvZiB0aGUgem9vbSBsZXZlbHMsIHN0YXJ0aW5nIGZyb20gdGhlIHNtYWxsZXN0IChtb3N0IHpvb21lZC1vdXQsIHVzdWFsbHkgMCkgdG8gdGhlIGxhcmdlc3QgKG1vc3Qgem9vbWVkLWluKS5cclxuICAgICAgICAgKiBVc3VhbGx5IGRpdmlkZWQgYnkgMiBmb3IgZWFjaCB6b29tIGxldmVsIGluY3JlbWVudC5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9ucyA9IG9wdHMucmVzb2x1dGlvbnNcclxuICAgICAgICBpZiAoIXRoaXMucmVzb2x1dGlvbnMgfHwgdGhpcy5yZXNvbHV0aW9ucy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNvbHV0aW9ucyBwcm92aWRlZCBmb3IgYmFja2dyb3VuZCBsYXllcicpXHJcblxyXG4gICAgICAgIC8qKiBUaGUgdGlsZSBzaXplLCBpbiBudW1iZXIgb2YgcGl4ZWxzXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLm5iUGl4ID0gb3B0cy5uYlBpeCB8fCAyNTZcclxuXHJcbiAgICAgICAgLyoqIENSUyBjb29yZGluYXRlcyBvZiB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHRvcCBsZWZ0IHRpbGUsIHRoZSBvbmUgd2l0aCBjb2RlIC8wLzAucG5nLlxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn0gKi9cclxuICAgICAgICB0aGlzLm9yaWdpbiA9IG9wdHMub3JpZ2luIHx8IFswLCAwXVxyXG5cclxuICAgICAgICAvKiogVGhlIGNvZGUgb2YgdGhlIHNtYWxsZXN0IChtb3N0IHpvb21lZC1vdXQpIHpvb20gbGV2ZWwsIGluIGNhc2UgaXQgaXMgbm90IDAuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnowID0gb3B0cy56MCB8fCAwXHJcblxyXG4gICAgICAgIC8qKiBBIGNvZWZmaWNpZW50IHRvIGFkanVzdCB0aGUgYmFja2dyb3VuIHJlc29sdXRpb24gd2l0aCB0aGUgc2NyZWVuIHJlc29sdXRpb24uXHJcbiAgICAgICAgICogIElmIHRoZSBiYWNrZ3JvdW5kIGltYWdlcyBhcmUgdG9vIHBpeGVsaXNlZCwgcmVkdWNlIHRoZSB2YWx1ZS5cclxuICAgICAgICAgKiAgSWYgdGhlcmUgYXJlIHRvbyBtYW55IGltYWdlcyB0byBkb3dubG9hZCwgaW5jcmVhc2UgdGhlIHZhbHVlLlxyXG4gICAgICAgICAqICBEZWZhdWx0IHZhbHVlIGlzIDEuMFxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5waXhlbGF0aW9uQ29lZmZpY2llbnQgPSBvcHRzLnBpeGVsYXRpb25Db2VmZmljaWVudCB8fCAxLjBcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB6L3gveSBjYWNoZSBkYXRhLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICogQHJldHVybnMge0hUTUxJbWFnZUVsZW1lbnR8c3RyaW5nfHVuZGVmaW5lZH1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldCh6LCB4LCB5KSB7XHJcbiAgICAgICAgbGV0IGQgPSB0aGlzLmNhY2hlW3pdXHJcbiAgICAgICAgaWYgKCFkKSByZXR1cm5cclxuICAgICAgICBkID0gZFt4XVxyXG4gICAgICAgIGlmICghZCkgcmV0dXJuXHJcbiAgICAgICAgcmV0dXJuIGRbeV1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFB1dCBpbWFnZSBpbiBjYWNoZS5cclxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxzdHJpbmd9IGltZ1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHB1dChpbWcsIHosIHgsIHkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2FjaGVbel0pIHRoaXMuY2FjaGVbel0gPSB7fVxyXG4gICAgICAgIGlmICghdGhpcy5jYWNoZVt6XVt4XSkgdGhpcy5jYWNoZVt6XVt4XSA9IHt9XHJcbiAgICAgICAgdGhpcy5jYWNoZVt6XVt4XVt5XSA9IGltZ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhcyBUaGUgY2FudmFzIHdoZXJlIHRvIGRyYXcgdGhlIGxheWVyLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGRyYXcoZ2VvQ2FudmFzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlc29sdXRpb25zIHx8IHRoaXMucmVzb2x1dGlvbnMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gcmVzb2x1dGlvbnMgcHJvdmlkZWQgZm9yIGJhY2tncm91bmQgbGF5ZXInKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcclxuICAgICAgICBjb25zdCB4MCA9IHRoaXMub3JpZ2luWzBdLCB5MCA9IHRoaXMub3JpZ2luWzFdXHJcblxyXG4gICAgICAgIC8vZ2V0IHpvb20gbGV2ZWwgYW5kIHJlc29sdXRpb25cclxuICAgICAgICBsZXQgel8gPSAwXHJcbiAgICAgICAgZm9yICh6XyA9IDA7IHpfIDwgdGhpcy5yZXNvbHV0aW9ucy5sZW5ndGg7IHpfKyspIGlmICh0aGlzLnJlc29sdXRpb25zW3pfXSA8IHogKiB0aGlzLnBpeGVsYXRpb25Db2VmZmljaWVudCkgYnJlYWtcclxuICAgICAgICB6XyAtPSAxXHJcbiAgICAgICAgel8gPSBNYXRoLm1heCgwLCB6XylcclxuICAgICAgICB6XyA9IE1hdGgubWluKHpfLCB0aGlzLnJlc29sdXRpb25zLmxlbmd0aCAtIDEpXHJcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5yZXNvbHV0aW9uc1t6X11cclxuICAgICAgICB6XyArPSB0aGlzLnowXHJcblxyXG4gICAgICAgIGNvbnN0IHNpemVHID0gdGhpcy5uYlBpeCAqIHJlc1xyXG4gICAgICAgIGNvbnN0IHNpemUgPSBzaXplRyAvIHpcclxuXHJcbiAgICAgICAgLy9nZXQgdGlsZSBudW1iZXJzXHJcbiAgICAgICAgY29uc3QgeEdlb1RvVE1TID0gKHgpID0+IE1hdGguY2VpbCgoeCAtIHgwKSAvIHNpemVHKVxyXG4gICAgICAgIGNvbnN0IHlHZW9Ub1RNUyA9ICh5KSA9PiBNYXRoLmNlaWwoLSh5IC0geTApIC8gc2l6ZUcpXHJcbiAgICAgICAgY29uc3QgeE1pbiA9IHhHZW9Ub1RNUyhnZW9DYW52YXMuZXh0R2VvLnhNaW4pIC0gMVxyXG4gICAgICAgIGNvbnN0IHhNYXggPSB4R2VvVG9UTVMoZ2VvQ2FudmFzLmV4dEdlby54TWF4KVxyXG4gICAgICAgIGNvbnN0IHlNYXggPSB5R2VvVG9UTVMoZ2VvQ2FudmFzLmV4dEdlby55TWluKVxyXG4gICAgICAgIGNvbnN0IHlNaW4gPSB5R2VvVG9UTVMoZ2VvQ2FudmFzLmV4dEdlby55TWF4KSAtIDFcclxuXHJcbiAgICAgICAgLy9oYW5kbGUgaW1hZ2VzXHJcbiAgICAgICAgZm9yIChsZXQgeCA9IHhNaW47IHggPCB4TWF4OyB4KyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHlNaW47IHkgPCB5TWF4OyB5KyspIHtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IGltYWdlXHJcbiAgICAgICAgICAgICAgICBsZXQgaW1nID0gdGhpcy5nZXQoel8sIHgsIHkpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9ubyBpbWFnZTogbG9hZCBpbWFnZSBmcm9tIFVSTFxyXG4gICAgICAgICAgICAgICAgaWYgKCFpbWcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHV0KGltZywgel8sIHgsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLnJlZHJhdygpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGltZy5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Nhc2Ugd2hlbiBubyBpbWFnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1dCgnZmFpbGVkJywgel8sIHgsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSB0aGlzLnVybEZ1bih4LCB5LCB6XylcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vY2FzZSB3aGVuIG5vIGltYWdlIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgICAgaWYgKGltZyA9PT0gJ2ZhaWxlZCcpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICBpZiAoIShpbWcgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGltZylcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGltZy53aWR0aCA9PSAwIHx8IGltZy5oZWlnaHQgPT0gMCkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgaW1hZ2VcclxuICAgICAgICAgICAgICAgIGNvbnN0IHhHZW8gPSB4MCArIHggKiBzaXplR1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeUdlbyA9IHkwIC0geSAqIHNpemVHXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5pbml0Q2FudmFzVHJhbnNmb3JtKClcclxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuZ2VvVG9QaXhYKHhHZW8pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMuZ2VvVG9QaXhZKHlHZW8pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2cuY3R4LmRyYXdJbWFnZShpbWcsIHhHZW8sIHlHZW8sIHNpemVHLCAtc2l6ZUcpXHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2NvcmUvTGF5ZXIuanMnXHJcblxyXG4vKipcclxuICpcclxuICogQSBtYXAgYmFja2dyb3VuZCBsYXllciBjb21wb3NlZCBvZiBhIHNpbmdsZSBpbWFnZSBmaWxlLCBnZW9sb2NhdGVkLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGxheWVyXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCYWNrZ3JvdW5kTGF5ZXJJbWFnZSBleHRlbmRzIExheWVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqIFRoZSBpbWFnZSBmaWxlIFVSTFxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy51cmwgPSBvcHRzLnVybFxyXG5cclxuICAgICAgICAvKiogVGhlIGltYWdlIGxlZnQgY29vcmRpbmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy54TWluID0gb3B0cy54TWluIHx8IDBcclxuICAgICAgICAvKiogVGhlIGltYWdlIHRvcCBjb29yZGluYXRlXHJcbiAgICAgICAgICogIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy55TWF4ID0gb3B0cy55TWF4IHx8IDBcclxuXHJcbiAgICAgICAgLyoqIFRoZSBpbWFnZSB3aWR0aCwgaW4gZ2VvIHVuaXRcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8IDIwMDAwXHJcbiAgICAgICAgLyoqIFRoZSBpbWFnZSBoZWlnaHQsIGluIGdlbyB1bml0XHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0IHx8IDIwMDAwXHJcblxyXG4gICAgICAgIC8qKiBUaGUgaW1hZ2Ugb2JqZWN0XHJcbiAgICAgICAgICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgIHRoaXMuaW1nID0gdW5kZWZpbmVkXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzIFRoZSBjYW52YXMgd2hlcmUgdG8gZHJhdyB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZHJhdyhnZW9DYW52YXMpIHtcclxuICAgICAgICAvL3VwZGF0ZSBtYXAgZXh0ZW50XHJcbiAgICAgICAgLy9nZW9DYW52YXMudXBkYXRlRXh0ZW50R2VvKDApXHJcblxyXG4gICAgICAgIGlmICh0aGlzLmltZykge1xyXG4gICAgICAgICAgICAvL3RoZSBpbWFnZSB3YXMgYWxyZWFkeSBkb3dubG9hZGVkOiBkcmF3IGl0XHJcblxyXG4gICAgICAgICAgICAvL2NvbXB1dGUgc2NyZWVuIGNvb3JkaW5hdGVzIGFuZCBzaXplIHJhdGlvXHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBnZW9DYW52YXMuZ2VvVG9QaXhYKHRoaXMueE1pbilcclxuICAgICAgICAgICAgY29uc3QgeSA9IGdlb0NhbnZhcy5nZW9Ub1BpeFkodGhpcy55TWF4KVxyXG4gICAgICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLmdldFZpZXcoKS56XHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgaW1hZ2VcclxuICAgICAgICAgICAgZ2VvQ2FudmFzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxyXG4gICAgICAgICAgICBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4LmRyYXdJbWFnZSh0aGlzLmltZywgeCwgeSwgdGhpcy53aWR0aCAvIHosIHRoaXMuaGVpZ2h0IC8geilcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL3JldHJpZXZlIGltYWdlXHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaW1nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmltZyA9IG5ldyBJbWFnZSgpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmltZy5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvQ2FudmFzLnJlZHJhdygpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmltZy5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY2FzZSB3aGVuIG5vIGltYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgcmV0cmlldmUgYmFja2dyb3VuZCBpbWFnZSBmcm9tJywgdGhpcy51cmwpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vc2V0IFVSTCB0byBsYXVuY2ggdGhlIGRvd25sb2FkXHJcbiAgICAgICAgICAgIHRoaXMuaW1nLnNyYyA9IHRoaXMudXJsXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9jb3JlL0xheWVyLmpzJ1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEEgbWFwIFdNUyBiYWNrZ3JvdW5kIGxheWVyLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGxheWVyXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCYWNrZ3JvdW5kTGF5ZXJXTVMgZXh0ZW5kcyBMYXllciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy51cmwgPSBvcHRzLnVybFxyXG5cclxuICAgICAgICAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgIHRoaXMuaW1nID0gdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICB0aGlzLnhNaW4gPSB1bmRlZmluZWRcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgdGhpcy54TWF4ID0gdW5kZWZpbmVkXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgIHRoaXMueU1pbiA9IHVuZGVmaW5lZFxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICB0aGlzLnlNYXggPSB1bmRlZmluZWRcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2hlY2sgaWYgdGhlIHZpZXcgaGFzIG1vdmVkIGFuZCBhIG5ldyBpbWFnZSBuZWVkcyB0byBiZSByZXRyaWV2ZWQuXHJcbiAgICAgKiBAcHJpdmF0ZSAqL1xyXG4gICAgaGFzTW92ZWQoZXh0R2VvKSB7XHJcbiAgICAgICAgaWYgKGV4dEdlby54TWluICE9IHRoaXMueE1pbikgcmV0dXJuIHRydWVcclxuICAgICAgICBlbHNlIGlmIChleHRHZW8ueE1heCAhPSB0aGlzLnhNYXgpIHJldHVybiB0cnVlXHJcbiAgICAgICAgZWxzZSBpZiAoZXh0R2VvLnlNaW4gIT0gdGhpcy55TWluKSByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIGVsc2UgaWYgKGV4dEdlby55TWF4ICE9IHRoaXMueU1heCkgcmV0dXJuIHRydWVcclxuICAgICAgICBlbHNlIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhcyBUaGUgY2FudmFzIHdoZXJlIHRvIGRyYXcgdGhlIGxheWVyLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGRyYXcoZ2VvQ2FudmFzKSB7XHJcbiAgICAgICAgLy91cGRhdGUgbWFwIGV4dGVudFxyXG4gICAgICAgIGdlb0NhbnZhcy51cGRhdGVFeHRlbnRHZW8oMClcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmhhc01vdmVkKGdlb0NhbnZhcy5leHRHZW8pICYmIHRoaXMuaW1nKSB7XHJcbiAgICAgICAgICAgIC8vdGhlIG1hcCBkaWQgbm90IG1vdmUgYW5kIHRoZSBpbWFnZSB3YXMgYWxyZWFkeSBkb3dubG9hZGVkOiBkcmF3IHRoZSBpbWFnZVxyXG4gICAgICAgICAgICBnZW9DYW52YXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXHJcbiAgICAgICAgICAgIGdlb0NhbnZhcy5vZmZzY3JlZW5DdHguZHJhd0ltYWdlKHRoaXMuaW1nLCAwLCAwLCBnZW9DYW52YXMudywgZ2VvQ2FudmFzLmgpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy90aGUgbWFwIG1vdmVkOiByZXRyaWV2ZSBuZXcgaW1hZ2VcclxuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIHRoaXMueE1pbiA9IGdlb0NhbnZhcy5leHRHZW8ueE1pblxyXG4gICAgICAgICAgICB0aGlzLnhNYXggPSBnZW9DYW52YXMuZXh0R2VvLnhNYXhcclxuICAgICAgICAgICAgdGhpcy55TWluID0gZ2VvQ2FudmFzLmV4dEdlby55TWluXHJcbiAgICAgICAgICAgIHRoaXMueU1heCA9IGdlb0NhbnZhcy5leHRHZW8ueU1heFxyXG5cclxuICAgICAgICAgICAgLy9idWlsZCBXTVMgVVJMXHJcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IFtdXHJcbiAgICAgICAgICAgIHVybC5wdXNoKHRoaXMudXJsKVxyXG4gICAgICAgICAgICB1cmwucHVzaCgnJndpZHRoPScpXHJcbiAgICAgICAgICAgIHVybC5wdXNoKGdlb0NhbnZhcy53KVxyXG4gICAgICAgICAgICB1cmwucHVzaCgnJmhlaWdodD0nKVxyXG4gICAgICAgICAgICB1cmwucHVzaChnZW9DYW52YXMuaClcclxuICAgICAgICAgICAgLy9iYm94OiB4bWluIHltaW4geG1heCB5bWF4XHJcbiAgICAgICAgICAgIHVybC5wdXNoKCcmYmJveD0nKVxyXG4gICAgICAgICAgICB1cmwucHVzaChnZW9DYW52YXMuZXh0R2VvLnhNaW4pXHJcbiAgICAgICAgICAgIHVybC5wdXNoKCcsJylcclxuICAgICAgICAgICAgdXJsLnB1c2goZ2VvQ2FudmFzLmV4dEdlby55TWluKVxyXG4gICAgICAgICAgICB1cmwucHVzaCgnLCcpXHJcbiAgICAgICAgICAgIHVybC5wdXNoKGdlb0NhbnZhcy5leHRHZW8ueE1heClcclxuICAgICAgICAgICAgdXJsLnB1c2goJywnKVxyXG4gICAgICAgICAgICB1cmwucHVzaChnZW9DYW52YXMuZXh0R2VvLnlNYXgpXHJcblxyXG4gICAgICAgICAgICBjb25zdCB1cmxTID0gdXJsLmpvaW4oJycpXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codXJsUylcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pbWcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1nID0gbmV3IEltYWdlKClcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1nLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMucmVkcmF3KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuaW1nLm9uZXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jYXNlIHdoZW4gbm8gaW1hZ2VcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCByZXRyaWV2ZSBXTVMgYmFja2dyb3VuZCBpbWFnZSBmcm9tJywgdXJsUylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9zZXQgVVJMIHRvIGxhdW5jaCB0aGUgZG93bmxvYWRcclxuICAgICAgICAgICAgdGhpcy5pbWcuc3JjID0gdXJsU1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vY29yZS9MYXllci5qcydcclxuaW1wb3J0IHsganNvbiB9IGZyb20gJ2QzLWZldGNoJ1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgbGF5ZXJcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdlb0pTT05MYXllciBleHRlbmRzIExheWVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMudXJsID0gb3B0cy51cmxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBwcmVwcm9jZXNzIHRvIHJ1biBvbiBlYWNoIGZlYXR1cmUgYWZ0ZXIgbG9hZGluZy5cclxuICAgICAgICAgKiBJdCBjYW4gYmUgdXNlZCB0byBhcHBseSBzb21lIHNwZWNpZmljIHRyZWF0bWVudCBiZWZvcmUsIGZvcm1hdCB0aGUgbGFiZWwgZGF0YSwgcHJvamVjdCBjb29yZGluYXRlcywgZXRjLlxyXG4gICAgICAgICAqIFJldHVybiBmYWxzZSBpZiB0aGUgbGFiZWwgc2hvdWxkIG5vdCBiZSBrZXB0LlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG9iamVjdCk6Ym9vbGVhbn0gKi9cclxuICAgICAgICB0aGlzLnByZXByb2Nlc3MgPSBvcHRzLnByZXByb2Nlc3NcclxuXHJcbiAgICAgICAgLy9mb3IgcG9pbnRzXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24ob2JqZWN0LG51bWJlcik6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuc2hhcGUgPSBvcHRzLnNoYXBlIHx8ICgoZiwgeikgPT4gJ2NpcmNsZScpXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW4gcGl4ZWxcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihvYmplY3QsbnVtYmVyKTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5zaXplID0gb3B0cy5zaXplIHx8ICgoZiwgeikgPT4gMTApXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24ob2JqZWN0LG51bWJlcik6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUgPSBvcHRzLnN0cm9rZVN0eWxlIHx8ICgoZiwgeikgPT4gJ3JlZCcpXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24ob2JqZWN0LG51bWJlcik6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuZmlsbFN0eWxlID0gb3B0cy5maWxsU3R5bGUgfHwgKChmLCB6KSA9PiAnYmxhY2snKVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluIHBpeGVsXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24ob2JqZWN0LG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gb3B0cy5saW5lV2lkdGggfHwgKChmLCB6KSA9PiAyKVxyXG5cclxuICAgICAgICAvL2ZvciBsaW5lc1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihvYmplY3QsbnVtYmVyKTpzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKChmLCB6KSA9PiAnZ3JheScpXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW4gcGl4ZWxcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihvYmplY3QsbnVtYmVyKTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdHMud2lkdGggfHwgKChmLCB6KSA9PiAyKVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG9iamVjdCxudW1iZXIpOkFycmF5LjxudW1iZXI+fHVuZGVmaW5lZH0gKi9cclxuICAgICAgICB0aGlzLmxpbmVEYXNoID0gb3B0cy5saW5lRGFzaCB8fCAoKGYsIHopID0+IHVuZGVmaW5lZClcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG9iamVjdD4gfCB1bmRlZmluZWR9ICovXHJcbiAgICAgICAgdGhpcy5mcyA9IHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gJ25vdExvYWRlZCdcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhlIGxheWVyLlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhcy5qc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhcyBUaGUgY2FudmFzIHdoZXJlIHRvIGRyYXcgdGhlIGxheWVyLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGRyYXcoZ2VvQ2FudmFzKSB7XHJcbiAgICAgICAgLy9sb2FkIGRhdGEsIGlmIG5vdCBkb25lIHlldC5cclxuICAgICAgICBpZiAoIXRoaXMuZnMpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkKGdlb0NhbnZhcy5yZWRyYXcpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcuelxyXG4gICAgICAgIGNvbnN0IGN0eCA9IGdlb0NhbnZhcy5vZmZzY3JlZW5DdHhcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMuZnMpIHtcclxuICAgICAgICAgICAgY29uc3QgZ3QgPSBmLmdlb21ldHJ5LnR5cGVcclxuXHJcbiAgICAgICAgICAgIGlmIChndCA9PSAnUG9pbnQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gZi5nZW9tZXRyeS5jb29yZGluYXRlc1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZ2V0IHN0eWxlIHBhcmFtZXRlcnMgZm9yIHRoZSBwb2ludCBmZWF0dXJlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuc2hhcGUoZiwgeilcclxuICAgICAgICAgICAgICAgIGlmICghc2hhcGUgfHwgc2hhcGUgPT0gJ25vbmUnKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZShmLCB6KSAqIHpcclxuICAgICAgICAgICAgICAgIGlmICghc2l6ZSkgY29udGludWVcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2VTdHlsZShmLCB6KVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbFN0eWxlID0gdGhpcy5maWxsU3R5bGUoZiwgeilcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoKGYsIHopICogelxyXG5cclxuICAgICAgICAgICAgICAgIC8vc2V0IGNhbnZhcyBkcmF3aW5nIHBhcmFtZXRlcnNcclxuICAgICAgICAgICAgICAgIGlmIChzdHJva2VTdHlsZSkgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGVcclxuICAgICAgICAgICAgICAgIGlmIChmaWxsU3R5bGUpIGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGVcclxuICAgICAgICAgICAgICAgIGlmIChsaW5lV2lkdGgpIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGhcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUgPT0gJ2NpcmNsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2RyYXcgY2lyY2xlIC0gZmlsbCBhbmQgc3Ryb2tlXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhjWzBdLCBjWzFdLCBzaXplIC8gMiwgMCwgMiAqIE1hdGguUEksIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxsU3R5bGUpIGN0eC5maWxsKClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3Ryb2tlU3R5bGUgJiYgbGluZVdpZHRoKSBjdHguc3Ryb2tlKClcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT0gJ3NxdWFyZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2RyYXcgc3F1YXJlIC0gZmlsbCBhbmQgc3Ryb2tlXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoY1swXSAtIHNpemUgLyAyLCBjWzFdIC0gc2l6ZSAvIDIsIHNpemUsIHNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGxTdHlsZSkgY3R4LmZpbGwoKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJva2VTdHlsZSAmJiBsaW5lV2lkdGgpIGN0eC5zdHJva2UoKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIHNoYXBlIGZvciBwb2ludCBnZW9qc29uOiAnICsgc2hhcGUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3QgPT0gJ0xpbmVTdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgICAgIGlmIChjcy5sZW5ndGggPCAyKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vc2V0IGNvbG9yXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yKGYsIHopXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbCB8fCBjb2wgPT0gJ25vbmUnKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sXHJcblxyXG4gICAgICAgICAgICAgICAgLy9zZXQgbGluZXdpZHRoXHJcbiAgICAgICAgICAgICAgICBjb25zdCB3UCA9IHRoaXMud2lkdGgoZiwgeilcclxuICAgICAgICAgICAgICAgIGlmICghd1AgfHwgd1AgPCAwKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHdQICogelxyXG5cclxuICAgICAgICAgICAgICAgIC8vc2V0IGxpbmUgZGFzaFxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGRQID0gdGhpcy5saW5lRGFzaChmLCB6KVxyXG4gICAgICAgICAgICAgICAgaWYgKGxkUCkgY3R4LnNldExpbmVEYXNoKGxkUClcclxuXHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgbGluZVxyXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGNzWzBdWzBdLCBjc1swXVsxXSlcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY3MubGVuZ3RoOyBpKyspIGN0eC5saW5lVG8oY3NbaV1bMF0sIGNzW2ldWzFdKVxyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZSBpbiBHZW9KU09OTGF5ZXI6ICcgKyBndClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8uLi5cclxuICAgICAgICBjdHguc2V0TGluZURhc2goW10pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIGRhdGEgZm9yIGxhYmVscywgZnJvbSBVUkwgdGhpcy51cmxcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTp2b2lkfSBjYWxsYmFja1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgYXN5bmMgbG9hZChjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghdGhpcy51cmwpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBsb2FkaW5nIGJvdW5kYXJpZXM6IE5vIFVSTCBzcGVjaWZpZWQuICcgKyB0aGlzLnVybClcclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gJ2ZhaWxlZCdcclxuICAgICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2hlY2sgaWYgZGF0YSBhbHJlYWR5IGxvYWRlZFxyXG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmdTdGF0dXMgIT0gJ25vdExvYWRlZCcpIHJldHVyblxyXG5cclxuICAgICAgICAvL2xvYWQgZGF0YVxyXG4gICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdsb2FkaW5nJ1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhXyA9IGF3YWl0IGpzb24odGhpcy51cmwpXHJcblxyXG4gICAgICAgICAgICAvKiogQHR5cGUgeyBBcnJheS48b2JqZWN0PiB9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBkYXRhXy5mZWF0dXJlc1xyXG5cclxuICAgICAgICAgICAgLy9wcmVwcm9jZXNzL2ZpbHRlclxyXG4gICAgICAgICAgICBpZiAodGhpcy5wcmVwcm9jZXNzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZzID0gW11cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IHRoaXMucHJlcHJvY2VzcyhjKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiID09IGZhbHNlKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnMucHVzaChjKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9zdG9yZSBsYWJlbHNcclxuICAgICAgICAgICAgICAgIHRoaXMuZnMgPSBkYXRhXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdsb2FkZWQnXHJcblxyXG4gICAgICAgICAgICAvL3JlZHJhd1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKClcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIGxvYWRpbmcgYm91bmRhcmllcyBmcm9tICcgKyB0aGlzLnVybClcclxuICAgICAgICAgICAgdGhpcy5mcyA9IFtdXHJcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdmYWlsZWQnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9jb3JlL0xheWVyLmpzJ1xyXG5cclxuLyoqXHJcbiAqIEEgbGF5ZXIsIHdoaWNoIHNwZWNpZmllcyBhIGRhdGFzZXQgdG8gYmUgc2hvd24gd2l0aCBzcGVjaWZpZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGxheWVyXHJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHcmlkTGF5ZXIgZXh0ZW5kcyBMYXllciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkRhdGFzZXR8aW1wb3J0KFwiLi4vY29yZS9NdWx0aVJlc29sdXRpb25EYXRhc2V0XCIpLk11bHRpUmVzb2x1dGlvbkRhdGFzZXR9IGRhdGFzZXQgVGhlIGRhdGFzZXQgdG8gc2hvdy5cclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvU3R5bGVcIikuU3R5bGU+fSBzdHlsZXMgVGhlIHN0eWxlcywgb3JkZXJlZCBpbiBkcmF3aW5nIG9yZGVyLlxyXG4gICAgICogQHBhcmFtIHt7dmlzaWJsZT86ZnVuY3Rpb24obnVtYmVyKTpib29sZWFuLGFscGhhPzpmdW5jdGlvbihudW1iZXIpOm51bWJlcixibGVuZE9wZXJhdGlvbj86ZnVuY3Rpb24obnVtYmVyKTpHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24sbWluUGl4ZWxzUGVyQ2VsbD86bnVtYmVyLGNlbGxJbmZvSFRNTD86ZnVuY3Rpb24oaW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkNlbGwpOnN0cmluZ319IG9wdHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZGF0YXNldCwgc3R5bGVzLCBvcHRzID0ge30pIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkRhdGFzZXR8aW1wb3J0KFwiLi4vY29yZS9NdWx0aVJlc29sdXRpb25EYXRhc2V0XCIpLk11bHRpUmVzb2x1dGlvbkRhdGFzZXR9ICovXHJcbiAgICAgICAgdGhpcy5kYXRhc2V0ID0gZGF0YXNldFxyXG5cclxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL1N0eWxlXCIpLlN0eWxlPn0gKi9cclxuICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlc1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIHBhcmFtZXRlciBpcyB1c2VkIHdoZW4gdGhlIGRhdGFzZXQgaXMgYSBNdWx0aVJlc29sdXRpb25EYXRhc2V0LlxyXG4gICAgICAgICAqIEl0IGRlZmluZXMgdGhlIG1pbmltdW0gbnVtYmVyIG9mIHBpeGVscyBhIGdyaWQgY2VsbCBzaG91bGQgaGF2ZSB0byBzZWxlY3QgdGhlIGRhdGFzZXQgdG8gZGlzcGxheSBiYXNlZCBvbiBpdHMgcmVzb2x1dGlvbi5cclxuICAgICAgICAgKiBBIGxvdyB2YWx1ZSwgbWVhbnMgdGhhdCB0aGUgbWFwIHdpbGwgYmUgbW9yZSBkZXRhaWxsZWQgKHNtYWxsZXIgY2VsbHMpLlxyXG4gICAgICAgICAqIEEgaGlnaCB2YWx1ZSwgbWVhbnMgdGhhdCB0aGUgbWFwIHdpbGwgYmUgbGVzcyBkZXRhaWxsZWQgKGxhcmdlciBjZWxscykuXHJcbiAgICAgICAgICogVGhpcyB2YWx1ZSBzaG91bGQgYmUgaGlnaGVyIHRoYW4gMSwgb3RoZXJ3aXNlIGl0IG1lYW5zIGEgZ3JpZCBjZWxsIGlzIHNtYWxsZXIgdGhhbiB0aGUgc2NyZWVuIHJlc29sdXRpb24uXHJcbiAgICAgICAgICogRm9yIG1vcmUgY29tcGxleCBjZWxsIHJlcHJlc2VudGF0aW9ucyB0aGF0IHJlcXVpcmUgc29tZSBtb3JlIG1hcCBzcGFjZSwgdGhpcyB2YWx1ZSBzaG91bGQgYmUgaGlnaGVyLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5taW5QaXhlbHNQZXJDZWxsID0gb3B0cy5taW5QaXhlbHNQZXJDZWxsIHx8IDNcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGZ1bmN0aW9uIHJldHVybmluZyBjZWxsIGluZm9ybWF0aW9uIGFzIEhUTUwuXHJcbiAgICAgICAgICogVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCBmb3IgdG9vbHRpcCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkNlbGwsIG51bWJlcik6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuY2VsbEluZm9IVE1MID0gb3B0cy5jZWxsSW5mb0hUTUwgfHwgR3JpZExheWVyLmRlZmF1bHRDZWxsSW5mb0hUTUxcclxuICAgIH1cclxuXHJcbiAgICAvKiogKi9cclxuICAgIGRyYXcoZ2VvQ2FudmFzLCBsZWdlbmQpIHtcclxuICAgICAgICAvL2dldCB6b29tIGxldmVsXHJcbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcclxuICAgICAgICBjb25zdCBjdHggPSBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4XHJcblxyXG4gICAgICAgIC8vZ2V0IGxheWVyIGRhdGFzZXQgY29tcG9uZW50XHJcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkRhdGFzZXR8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgIGNvbnN0IGRzYyA9IHRoaXMuZ2V0RGF0YXNldCh6KVxyXG4gICAgICAgIGlmICghZHNjKSByZXR1cm5cclxuXHJcbiAgICAgICAgLy9sYXVuY2ggZGF0YSBkb3dubG9hZCwgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgZHNjLmdldERhdGEoZ2VvQ2FudmFzLmV4dEdlbylcclxuXHJcbiAgICAgICAgLy91cGRhdGUgZGF0YXNldCB2aWV3IGNhY2hlXHJcbiAgICAgICAgZHNjLnVwZGF0ZVZpZXdDYWNoZShnZW9DYW52YXMuZXh0R2VvKVxyXG5cclxuICAgICAgICAvL2RyYXcgY2VsbHMsIHN0eWxlIGJ5IHN0eWxlXHJcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuc3R5bGVzKSB7XHJcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgc3R5bGUgaXMgdmlzaWJsZVxyXG4gICAgICAgICAgICBpZiAocy52aXNpYmxlICYmICFzLnZpc2libGUoeikpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL3NldCBzdHlsZSBhbHBoYSBhbmQgYmxlbmQgbW9kZVxyXG4gICAgICAgICAgICAvL1RPRE86IG11bHRpcGx5IGJ5IGxheWVyIGFscGhhID9cclxuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gcy5hbHBoYSA/IHMuYWxwaGEoeikgOiAxLjBcclxuICAgICAgICAgICAgaWYgKHMuYmxlbmRPcGVyYXRpb24pIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBzLmJsZW5kT3BlcmF0aW9uKHopXHJcblxyXG4gICAgICAgICAgICAvL3NldCBhZmZpbiB0cmFuc2Zvcm0gdG8gZHJhdyB3aXRoIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICBnZW9DYW52YXMuc2V0Q2FudmFzVHJhbnNmb3JtKClcclxuXHJcbiAgICAgICAgICAgIC8vZHJhdyB3aXRoIHN0eWxlXHJcbiAgICAgICAgICAgIHMuZHJhdyhkc2MuZ2V0Vmlld0NhY2hlKCksIGdlb0NhbnZhcywgZHNjLmdldFJlc29sdXRpb24oKSlcclxuXHJcbiAgICAgICAgICAgIC8vZHJhdyBzdHlsZSBmaWx0ZXJcclxuICAgICAgICAgICAgaWYgKHMuZmlsdGVyQ29sb3IpIHMuZHJhd0ZpbHRlcihnZW9DYW52YXMpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2FkZCBsZWdlbmQgZWxlbWVudFxyXG4gICAgICAgIGlmIChsZWdlbmQpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuc3R5bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHN0eWxlIGlzIHZpc2libGVcclxuICAgICAgICAgICAgICAgIGlmIChzLnZpc2libGUgJiYgIXMudmlzaWJsZSh6KSkgY29udGludWVcclxuICAgICAgICAgICAgICAgIEdyaWRMYXllci5hZGRMZWdlbmRzKGxlZ2VuZCwgcy5sZWdlbmRzKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vY2FzZSBmb3Igc3R5bGVzIG9mIHN0eWxlcywgbGlrZSBrZXJuZWwgc21vb3RoaW5nXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gZG8gYmV0dGVyXHJcbiAgICAgICAgICAgICAgICBpZiAoc1snc3R5bGVzJ10pIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHMyIG9mIHNbJ3N0eWxlcyddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMi52aXNpYmxlICYmICFzMi52aXNpYmxlKHopKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmlkTGF5ZXIuYWRkTGVnZW5kcyhsZWdlbmQsIHMyLmxlZ2VuZHMpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcHJpdmF0ZSAqL1xyXG4gICAgc3RhdGljIGFkZExlZ2VuZHMobGVnZW5kQ29tcCwgbGcpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsZykpIGZvciAoY29uc3QgbGdfIG9mIGxnKSB0aGlzLmFkZExlZ2VuZHMobGVnZW5kQ29tcCwgbGdfKVxyXG4gICAgICAgIGVsc2UgbGVnZW5kQ29tcC5ub2RlKCkuYXBwZW5kKGxnLmRpdi5ub2RlKCkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHJlbGV2YW50IGRhdGFzZXQgY29tcG9uZW50IGZvciBhIHNwZWNpZmllZCB6b29tLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6XHJcbiAgICAgKiBAcmV0dXJucyB7aW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkRhdGFzZXR8dW5kZWZpbmVkfVxyXG4gICAgICogKi9cclxuICAgIGdldERhdGFzZXQoeikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFzZXQuZ2V0RGF0YXNldCh6LCB0aGlzLm1pblBpeGVsc1BlckNlbGwpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQvZ2V0IHN0eWxlIHN0YWNrLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfGltcG9ydChcIi4uL2NvcmUvU3R5bGVcIikuU3R5bGV8QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvU3R5bGVcIikuU3R5bGU+fSBzdHlsZXNcclxuICAgICAqIEByZXR1cm5zIHsgdGhpcyB8IEFycmF5LjxpbXBvcnQoXCIuLi9jb3JlL1N0eWxlXCIpLlN0eWxlPiB9XHJcbiAgICAgKi9cclxuICAgIHN0eWxlc18oc3R5bGVzKSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLnN0eWxlc1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKVxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZXMpKSB0aGlzLnN0eWxlcyA9IHN0eWxlc1xyXG4gICAgICAgICAgICBlbHNlIHRoaXMuc3R5bGVzID0gW3N0eWxlc11cclxuICAgICAgICBlbHNlIHRoaXMuc3R5bGVzID0gYXJndW1lbnRzXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHJldHVybmluZyBjZWxsIGluZm9ybWF0aW9uIGFzIEhUTUwuXHJcbiAgICAgKiBUaGlzIGlzIHR5cGljYWxseSB1c2VkIGZvciB0b29sdGlwIGluZm9ybWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkNlbGx9IGNlbGxcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZWZhdWx0Q2VsbEluZm9IVE1MKGNlbGwpIHtcclxuICAgICAgICBjb25zdCBidWYgPSBbXVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNlbGwpKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICd4JykgY29udGludWVcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3knKSBjb250aW51ZVxyXG4gICAgICAgICAgICBidWYucHVzaCgnPGI+Jywga2V5LCAnPC9iPicsICcgOiAnLCBjZWxsW2tleV0sICc8YnI+JylcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ1Zi5qb2luKCcnKVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9jb3JlL0xheWVyLmpzJ1xyXG5pbXBvcnQgeyBjc3YgfSBmcm9tICdkMy1mZXRjaCdcclxuXHJcbi8qKiBBIGxhYmVsLiBUaGUgbmFtZSBpcyB0aGUgdGV4dCB0byBzaG93LiAoeCx5KSBhcmUgdGhlIGNvb3JkaW5hdGVzIGluIHRoZSBzYW1lIENSUyBhcyB0aGUgZ3JpZC5cclxuICogQHR5cGVkZWYge3tuYW1lOiBzdHJpbmcsIHg6bnVtYmVyLCB5Om51bWJlciB9fSBMYWJlbCAqL1xyXG5cclxuLyoqXHJcbiAqIEEgKGdlbmVyaWMpIGxheWVyIGZvciBwbGFjZW5hbWUgbGFiZWxzLCB0byBiZSBzaG93biBvbiB0b3Agb2YgdGhlIGdyaWQgbGF5ZXJzLlxyXG4gKiBUaGUgaW5wdXQgaXMgYSBDU1YgZmlsZSB3aXRoIHRoZSBwb3NpdGlvbiAoeCwgeSkgb2YgdGhlIGxhYmVscyBhbmQgbmFtZSArIHNvbWUgb3RoZXIgaW5mbyBvbiB0aGUgbGFiZWwgaW1wb3J0YW5jZS5cclxuICogSWYgdGhlIGxhYmVsIGRhdGEgaXMgbm90IGluIHRoZSBleHBlY3RlZCBmb3JtYXQgb3IgaW4gdGhlIHNhbWUgQ1JTIGFzIHRoZSBncmlkLCBpdCBjYW4gYmUgY29ycmVjdGVkIHdpdGggdGhlIFwicHJlcHJvY2Vzc1wiIGZ1bmN0aW9uLlxyXG4gKiBUaGUgc2VsZWN0aW9uIG9mIHRoZSBsYWJlbCwgdGhlaXIgc3R5bGUgKGZvbnQsIHdlaWdodCwgZXRjLikgYW5kIGNvbG9yIGNhbiBiZSBzcGVjaWZpZWQgZGVwZW5kaW5nIG9uIHRoZWlyIGltcG9ydGFuY2UgYW5kIHRoZSB6b29tIGxldmVsLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGxheWVyXHJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBMYWJlbExheWVyIGV4dGVuZHMgTGF5ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgVVJMIG9mIHRoZSBsYWJlbCBkYXRhLCBhcyBDU1YgZmlsZS5cclxuICAgICAgICAgKiBUaGUgZmlsZSBzaG91bGQgY29udGFpbiB0aGUgaW5mb3JtYXRpb24gZm9yIGVhY2ggbGFiZWwgc3VjaCBhcyB0aGUgdGV4dCwgdGhlIHBvc2l0aW9uIGFuZCBvdGhlciBpbmZvcm1hdGlvbiBmb3IgdGhlIGRpc3BsYXkgb2YgdGhlIGxhYmVsIGFjY29yZGluZyB0byB0aGUgem9vbSBsZXZlbC5cclxuICAgICAgICAgKiBJZiBuZWNlc3NhcnksIHRoaXMgZGF0YSBjYW4gYmUgcmVmb3JtYXRlZCB3aXRoIHRoZSAncHJlcHJvY2VzcycgcGFyYW1ldGVyLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnVybCA9IG9wdHMudXJsXHJcblxyXG4gICAgICAgIC8qKiBTcGVjaWZ5IGlmIGFuZCBob3cgYSBsYWJlbCBzaG91bGQgYmUgZHJhd24sIGRlcGVuZGluZyBvbiBpdHMgaW1wb3J0YW5jZSBhbmQgdGhlIHpvb20gbGV2ZWwuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oTGFiZWwsbnVtYmVyKTpzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5zdHlsZSA9IG9wdHMuc3R5bGUgfHwgKCgpID0+ICcxLjJlbSBBcmlhbCcpXHJcblxyXG4gICAgICAgIC8qKiBTcGVjaWZ5IHRoZSBsYWJlbCBjb2xvciwgZGVwZW5kaW5nIG9uIGl0cyBpbXBvcnRhbmNlIGFuZCB0aGUgem9vbSBsZXZlbC5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihMYWJlbCxudW1iZXIpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAob3B0cy5kYXJrID8gKCkgPT4gJ3doaXRlJyA6ICgpID0+ICdibGFjaycpXHJcblxyXG4gICAgICAgIC8qKiBTcGVjaWZ5IHRoZSBsYWJlbCBoYWxvIGNvbG9yLCBkZXBlbmRpbmcgb24gaXRzIGltcG9ydGFuY2UgYW5kIHRoZSB6b29tIGxldmVsLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKExhYmVsLG51bWJlcik6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuaGFsb0NvbG9yID0gb3B0cy5oYWxvQ29sb3IgfHwgKG9wdHMuZGFyayA/ICgpID0+ICdibGFjaycgOiAoKSA9PiAnd2hpdGUnKVxyXG5cclxuICAgICAgICAvKiogU3BlY2lmeSB0aGUgbGFiZWwgaGFsbyB3aWR0aCwgZGVwZW5kaW5nIG9uIGl0cyBpbXBvcnRhbmNlIGFuZCB0aGUgem9vbSBsZXZlbC5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihMYWJlbCxudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLmhhbG9XaWR0aCA9IG9wdHMuaGFsb1dpZHRoIHx8ICgoKSA9PiAyLjUpXHJcblxyXG4gICAgICAgIC8qKiBUaGUgYW5jaG9yIHdoZXJlIHRvIGRyYXcgdGhlIHRleHQsIGZyb20gbGFiZWwgcG9zaXRpb24uIFNlZSBIVE1MLWNhbnZhcyB0ZXh0QWxpZ24gcHJvcGVydHkuXHJcbiAgICAgICAgICogXCJsZWZ0XCIgfHwgXCJyaWdodFwiIHx8IFwiY2VudGVyXCIgfHwgXCJzdGFydFwiIHx8IFwiZW5kXCJcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtDYW52YXNUZXh0QWxpZ259ICovXHJcbiAgICAgICAgdGhpcy50ZXh0QWxpZ24gPSBvcHRzLnRleHRBbGlnbiB8fCAnc3RhcnQnXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xyXG4gICAgICAgIHRoaXMub2Zmc2V0UGl4ID0gb3B0cy5vZmZzZXRQaXggfHwgWzUsIDVdXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgcHJlcHJvY2VzcyB0byBydW4gb24gZWFjaCBsYWJlbCBhZnRlciBsb2FkaW5nLlxyXG4gICAgICAgICAqIEl0IGNhbiBiZSB1c2VkIHRvIGFwcGx5IHNvbWUgc3BlY2lmaWMgdHJlYXRtZW50IGJlZm9yZSwgZm9ybWF0IHRoZSBsYWJlbCBkYXRhLCBwcm9qZWN0IGNvb3JkaW5hdGVzLCBldGMuXHJcbiAgICAgICAgICogUmV0dXJuIGZhbHNlIGlmIHRoZSBsYWJlbCBzaG91bGQgbm90IGJlIGtlcHQuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oTGFiZWwpOmJvb2xlYW59ICovXHJcbiAgICAgICAgdGhpcy5wcmVwcm9jZXNzID0gb3B0cy5wcmVwcm9jZXNzXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxMYWJlbD4gfCB1bmRlZmluZWR9ICovXHJcbiAgICAgICAgdGhpcy5sYWJlbHMgPSB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdub3RMb2FkZWQnXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoZSBsYWJlbCBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzIFRoZSBjYW52YXMgd2hlcmUgdG8gZHJhdyB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZHJhdyhnZW9DYW52YXMpIHtcclxuICAgICAgICAvL2xvYWQgbGFiZWxzLCBpZiBub3QgZG9uZSB5ZXQuXHJcbiAgICAgICAgaWYgKCF0aGlzLmxhYmVscykge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWQoZ2VvQ2FudmFzLnJlZHJhdylcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGNvbnN0IHogPSBnZW9DYW52YXMudmlldy56XHJcbiAgICAgICAgY29uc3QgY3R4ID0gZ2VvQ2FudmFzLm9mZnNjcmVlbkN0eFxyXG5cclxuICAgICAgICAvL3RleHQgYWxpZ25cclxuICAgICAgICBjdHgudGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ24gfHwgJ3N0YXJ0J1xyXG5cclxuICAgICAgICAvL2xpbmUgam9pbiBhbmQgY2FwXHJcbiAgICAgICAgY3R4LmxpbmVKb2luID0gJ2JldmVsJyAvL3x8IFwicm91bmRcIiB8fCBcIm1pdGVyXCI7XHJcbiAgICAgICAgY3R4LmxpbmVDYXAgPSAnYnV0dCcgLy98fCBcInJvdW5kXCIgfHwgXCJzcXVhcmVcIjtcclxuXHJcbiAgICAgICAgLy9kcmF3IGluIHBpeCBjb29yZGluYXRlc1xyXG4gICAgICAgIGdlb0NhbnZhcy5pbml0Q2FudmFzVHJhbnNmb3JtKClcclxuXHJcbiAgICAgICAgLy9kcmF3IGxhYmVscywgb25lIGJ5IG9uZVxyXG4gICAgICAgIGZvciAoY29uc3QgbGIgb2YgdGhpcy5sYWJlbHMpIHtcclxuICAgICAgICAgICAgLy9nZXQgbGFiZWwgc3R5bGVcclxuICAgICAgICAgICAgY29uc3Qgc3QgPSB0aGlzLnN0eWxlKGxiLCB6KVxyXG4gICAgICAgICAgICBpZiAoIXN0KSBjb250aW51ZVxyXG4gICAgICAgICAgICBjdHguZm9udCA9IHN0XHJcblxyXG4gICAgICAgICAgICAvL2NoZWNrIGxhYmVsIHdpdGhpbiB0aGUgdmlldywgdG8gYmUgZHJhd25cclxuICAgICAgICAgICAgaWYgKCFnZW9DYW52YXMudG9EcmF3KGxiKSkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8vcG9zaXRpb25cclxuICAgICAgICAgICAgY29uc3QgeFAgPSBnZW9DYW52YXMuZ2VvVG9QaXhYKGxiLngpICsgdGhpcy5vZmZzZXRQaXhbMF1cclxuICAgICAgICAgICAgY29uc3QgeVAgPSBnZW9DYW52YXMuZ2VvVG9QaXhZKGxiLnkpIC0gdGhpcy5vZmZzZXRQaXhbMV1cclxuXHJcbiAgICAgICAgICAgIC8vbGFiZWwgc3Ryb2tlLCBmb3IgdGhlIGhhbG9cclxuICAgICAgICAgICAgaWYgKHRoaXMuaGFsb0NvbG9yICYmIHRoaXMuaGFsb1dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYyA9IHRoaXMuaGFsb0NvbG9yKGxiLCB6KVxyXG4gICAgICAgICAgICAgICAgY29uc3QgaHcgPSB0aGlzLmhhbG9XaWR0aChsYiwgeilcclxuICAgICAgICAgICAgICAgIGlmIChoYyAmJiBodyAmJiBodyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBoY1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBod1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KGxiLm5hbWUsIHhQLCB5UClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9sYWJlbCBmaWxsXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yKGxiLCB6KVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobGIubmFtZSwgeFAsIHlQKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBkYXRhIGZvciBsYWJlbHMsIGZyb20gVVJMIHRoaXMudXJsXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gY2FsbGJhY2tcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGxvYWQoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoIXRoaXMudXJsKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgbG9hZGluZyBsYWJlbHM6IE5vIFVSTCBzcGVjaWZpZWQuICcgKyB0aGlzLnVybClcclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gJ2ZhaWxlZCdcclxuICAgICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2hlY2sgaWYgZGF0YSBhbHJlYWR5IGxvYWRlZFxyXG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmdTdGF0dXMgIT0gJ25vdExvYWRlZCcpIHJldHVyblxyXG5cclxuICAgICAgICAvL2xvYWQgZGF0YVxyXG4gICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdsb2FkaW5nJ1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgeyBBcnJheS48TGFiZWw+IH0gKi9cclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNzdih0aGlzLnVybClcclxuXHJcbiAgICAgICAgICAgIC8vcHJlcHJvY2Vzcy9maWx0ZXJcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJlcHJvY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXVxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gdGhpcy5wcmVwcm9jZXNzKGMpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT0gZmFsc2UpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMucHVzaChjKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9zdG9yZSBsYWJlbHNcclxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxzID0gZGF0YVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSAnbG9hZGVkJ1xyXG5cclxuICAgICAgICAgICAgLy9yZWRyYXdcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBsb2FkaW5nIGxhYmVscyBmcm9tICcgKyB0aGlzLnVybClcclxuICAgICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXVxyXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSAnZmFpbGVkJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IExlZ2VuZCB9IGZyb20gJy4uL2NvcmUvTGVnZW5kLmpzJ1xyXG5cclxuLyoqXHJcbiAqIEEgbGVnZW5kIGVsZW1lbnQgZm9yIGNvbG9yIGNhdGVncm9yaWVzLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGxlZ2VuZFxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ29sb3JDYXRlZ29yeUxlZ2VuZCBleHRlbmRzIExlZ2VuZCB7XHJcbiAgICAvKiogQHBhcmFtIHtPYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8vY29sL2NhdGVnb3JpZXMgYXJyYXksIGluIGRpc3BsYXkgb3JkZXJcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48W3N0cmluZyxzdHJpbmddPn0gKi9cclxuICAgICAgICB0aGlzLmNvbG9yTGFiZWwgPSBvcHRzLmNvbG9yTGFiZWwgfHwgW1snZ3JheScsICctJ11dXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NvcmUvU3R5bGUuanNcIikuU2hhcGV9ICovXHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IG9wdHMuc2hhcGUgfHwgJ2NpcmNsZSdcclxuICAgICAgICB0aGlzLmRpbWVuc2lvbiA9IG9wdHMuZGltZW5zaW9uIHx8IHsgcjogOCB9XHJcbiAgICAgICAgdGhpcy5zdHJva2VDb2xvciA9IG9wdHMuc3Ryb2tlQ29sb3IgfHwgJ2dyYXknXHJcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGggfHwgMVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgLy9jbGVhclxyXG4gICAgICAgIHRoaXMuZGl2LnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vdGl0bGVcclxuICAgICAgICB0aGlzLm1ha2VUaXRsZSgpXHJcblxyXG4gICAgICAgIC8vY2F0ZWdvcmllc1xyXG4gICAgICAgIGNvbnN0IG5iID0gdGhpcy5jb2xvckxhYmVsLmxlbmd0aFxyXG4gICAgICAgIGlmIChuYiA9PSAwKSByZXR1cm5cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHRoaXMuY29sb3JMYWJlbFtpXVxyXG5cclxuICAgICAgICAgICAgLy9tYWtlIGRpdiBmb3IgY2F0ZWdvcnlcclxuICAgICAgICAgICAgY29uc3QgZCA9IHRoaXMuZGl2LmFwcGVuZCgnZGl2JylcclxuICAgICAgICAgICAgLy90byBlbmFibGUgdmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgICAgIC8vLnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKVxyXG5cclxuICAgICAgICAgICAgY29uc3Qgc3cgPSB0aGlzLnN0cm9rZVdpZHRoXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgZ3JhcGhpYyBlbGVtZW50OiBib3ggLyBjaXJjbGVcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hhcGUgPT09ICdzcXVhcmUnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gdGhpcy5kaW1lbnNpb24uaCB8fCAxNVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdyA9IHRoaXMuZGltZW5zaW9uLncgfHwgMjBcclxuICAgICAgICAgICAgICAgIGQuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsICdpbmxpbmUnKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHcgKyAyICogc3cpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGggKyAyICogc3cpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgc3cpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBzdylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB3KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGNhdFswXSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRoaXMuc3Ryb2tlQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB0aGlzLnN0cm9rZVdpZHRoKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2hhcGUgPT09ICdjaXJjbGUnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5kaW1lbnNpb24uciB8fCA4XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gMiAqIHIgKyAyICogc3dcclxuICAgICAgICAgICAgICAgIGQuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsICdpbmxpbmUnKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGgpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgciArIHN3KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIHIgKyBzdylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigncicsIHIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgY2F0WzBdKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgdGhpcy5zdHJva2VDb2xvcilcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHRoaXMuc3Ryb2tlV2lkdGgpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2hhcGU6JyArIHRoaXMuc2hhcGUpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vd3JpdGUgbGFiZWwgdGV4dFxyXG4gICAgICAgICAgICBkLmFwcGVuZCgnZGl2JylcclxuICAgICAgICAgICAgICAgIC8vc2hvdyBvbiByaWdodCBvZiBncmFwaGljXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnaW5saW5lJylcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NlbnRlciB2ZXJ0aWNhbGx5XHJcbiAgICAgICAgICAgICAgICAvLy5zdHlsZShcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIikuc3R5bGUoXCJ0b3BcIiwgXCIwXCIpLnN0eWxlKFwiYm90dG9tXCIsIFwiMFwiKVxyXG5cclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncGFkZGluZy1sZWZ0JywgJzVweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIHRoaXMubGFiZWxGb250U2l6ZSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KGNhdFsxXSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9jb3JlL0xlZ2VuZC5qcydcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBlbGVtZW50IGZvciBkaXNjcmV0ZSBjb2xvciBzdHlsZS5cclxuICogSW5zcGlyYXRpb246IGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AZDMvY29sb3ItbGVnZW5kXHJcbiAqXHJcbiAqIEBtb2R1bGUgbGVnZW5kXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb2xvckRpc2NyZXRlTGVnZW5kIGV4dGVuZHMgTGVnZW5kIHtcclxuICAgIC8qKiBAcGFyYW0ge09iamVjdH0gb3B0cyAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqIEBwcml2YXRlIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvU3R5bGUnKS5WaWV3U2NhbGUpOkFycmF5LjxzdHJpbmc+fSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3JzID0gb3B0cy5jb2xvcnNcclxuICAgICAgICAvKiogQHByaXZhdGUgQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9TdHlsZScpLlZpZXdTY2FsZSk6QXJyYXkuPG51bWJlcj59ICovXHJcbiAgICAgICAgdGhpcy5icmVha3MgPSBvcHRzLmJyZWFrc1xyXG5cclxuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAzMDBcclxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0IHx8IDE1XHJcblxyXG4gICAgICAgIHRoaXMudGlja1NpemUgPSBvcHRzLnRpY2tTaXplIHx8IDNcclxuXHJcbiAgICAgICAgLy9sYWJlbFxyXG4gICAgICAgIHRoaXMuaW52ZXJ0ID0gb3B0cy5pbnZlcnRcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7e3ZpZXdTY2FsZTppbXBvcnQoJy4uL2NvcmUvU3R5bGUnKS5WaWV3U2NhbGV9IH0gb3B0c1xyXG4gICAgICovXHJcbiAgICB1cGRhdGUob3B0cykge1xyXG4gICAgICAgIC8vY2xlYXJcclxuICAgICAgICB0aGlzLmRpdi5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvL3RpdGxlXHJcbiAgICAgICAgdGhpcy5tYWtlVGl0bGUoKVxyXG5cclxuICAgICAgICAvL2dldCBjb2xvcnMgYW5kIGJyZWFrc1xyXG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuY29sb3JzKG9wdHMudmlld1NjYWxlKVxyXG4gICAgICAgIGNvbnN0IGJyZWFrcyA9IHRoaXMuYnJlYWtzKG9wdHMudmlld1NjYWxlKVxyXG4gICAgICAgIGlmICghYnJlYWtzKSByZXR1cm5cclxuXHJcbiAgICAgICAgLy9jbGFzc2VzXHJcbiAgICAgICAgY29uc3QgbmIgPSBjb2xvcnMubGVuZ3RoXHJcbiAgICAgICAgaWYgKG5iID09IDApIHJldHVyblxyXG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoIC8gbmJcclxuXHJcbiAgICAgICAgLy9tYWtlIHN2ZyBlbGVtZW50XHJcbiAgICAgICAgY29uc3Qgc3ZnID0gdGhpcy5kaXZcclxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy53aWR0aClcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0ICsgdGhpcy50aWNrU2l6ZSArIDIgKyAxMClcclxuXHJcbiAgICAgICAgLy9kcmF3IGdyYXBoaWMgZWxlbWVudHNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspIHtcclxuICAgICAgICAgICAgc3ZnLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGkgKiB3KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmhlaWdodClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGNvbG9yc1tpXSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdGljayBsaW5lXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuYjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgdyAqIGkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgdyAqIGkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCB0aGlzLmhlaWdodCArIHRoaXMudGlja1NpemUpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2xhYmVsc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmI7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBicmVha3NbaSAtIDFdXHJcbiAgICAgICAgICAgIGlmIChpc05hTihsYWJlbCkgfHwgbGFiZWwgPT0gdW5kZWZpbmVkKSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbEZvcm1hdCkgbGFiZWwgPSB0aGlzLmxhYmVsRm9ybWF0KGxhYmVsLCBpKVxyXG5cclxuICAgICAgICAgICAgLy9sYWJlbFxyXG4gICAgICAgICAgICBzdmcuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICd0aWNrbGFiZWxfJyArIGkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHcgKiBpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB0aGlzLmhlaWdodCArIHRoaXMudGlja1NpemUgKyAyKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLmxhYmVsRm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICAvLy5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxyXG4gICAgICAgICAgICAgICAgLy8uc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIkFyaWFsXCIpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2FsaWdubWVudC1iYXNlbGluZScsICd0b3AnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdkb21pbmFudC1iYXNlbGluZScsICdoYW5naW5nJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAudGV4dChsYWJlbClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9jb3JlL0xlZ2VuZC5qcydcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBlbGVtZW50IGZvciBjb250aW51b3VzIGNvbG9yIHN0eWxlLlxyXG4gKiBJbnNwaXJhdGlvbjogaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BkMy9jb2xvci1sZWdlbmRcclxuICpcclxuICogQG1vZHVsZSBsZWdlbmRcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbG9yTGVnZW5kIGV4dGVuZHMgTGVnZW5kIHtcclxuICAgIC8qKiBAcGFyYW0ge09iamVjdH0gb3B0cyAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLy9hIGZ1bmN0aW9uIFswLDFdLT5jb2xvciBmb3IgY29udGludW91cyBjb2xvcnMuXHJcbiAgICAgICAgLy9pdCBjYW4gdGFrZSBhcyBzZWNvbmQgYXJndW1lbnQgdGhlIHZpZXdzY2FsZS5cclxuICAgICAgICB0aGlzLmNvbG9yU2NhbGUgPSBvcHRzLmNvbG9yU2NhbGVcclxuXHJcbiAgICAgICAgLy9mdW5jdGlvbiAodFswLDFdKSAtPiB2YWx1ZSAoZm9yIGxhYmVsIHRleHQpXHJcbiAgICAgICAgLy9pdCBjYW4gdGFrZSBhcyBzZWNvbmQgYXJndW1lbnQgdGhlIHZpZXdzY2FsZS5cclxuICAgICAgICB0aGlzLnRleHRTY2FsZSA9IG9wdHMudGV4dFNjYWxlIHx8ICgodCkgPT4gdClcclxuXHJcbiAgICAgICAgdGhpcy5tYXJnaW4gPSBvcHRzLm1hcmdpbiB8fCA1XHJcblxyXG4gICAgICAgIC8vcmVwbGFjZSB3aXRoIGxhYmVscyA/XHJcbiAgICAgICAgdGhpcy50aWNrU2l6ZSA9IG9wdHMudGlja1NpemUgfHwgNlxyXG4gICAgICAgIHRoaXMudGlja3MgPSBvcHRzLnRpY2tzIHx8IE1hdGguZmxvb3IodGhpcy53aWR0aCAvIDUwKVxyXG4gICAgICAgIHRoaXMudGlja0Zvcm1hdCA9IG9wdHMudGlja0Zvcm1hdFxyXG4gICAgICAgIHRoaXMudGlja1VuaXQgPSBvcHRzLnRpY2tVbml0XHJcblxyXG4gICAgICAgIHRoaXMuZm9udFNpemUgPSBvcHRzLmZvbnRTaXplIHx8ICcwLjhlbSdcclxuICAgICAgICB0aGlzLmludmVydCA9IG9wdHMuaW52ZXJ0XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8IDMwMFxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0cy5oZWlnaHQgfHwgMTVcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7e3ZpZXdTY2FsZTppbXBvcnQoJy4uL2NvcmUvU3R5bGUnKS5WaWV3U2NhbGV9IH0gb3B0c1xyXG4gICAgICovXHJcbiAgICB1cGRhdGUob3B0cykge1xyXG4gICAgICAgIC8vY2xlYXJcclxuICAgICAgICB0aGlzLmRpdi5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvL3RpdGxlXHJcbiAgICAgICAgdGhpcy5tYWtlVGl0bGUoKVxyXG5cclxuICAgICAgICBjb25zdCBzdmdXID0gdGhpcy53aWR0aCArIDIgKiB0aGlzLm1hcmdpblxyXG4gICAgICAgIGNvbnN0IHN2Z0ggPSB0aGlzLmhlaWdodCArIHRoaXMubWFyZ2luICsgdGhpcy50aWNrU2l6ZSArIDEwXHJcbiAgICAgICAgY29uc3Qgc3ZnID0gdGhpcy5kaXYuYXBwZW5kKCdzdmcnKS5hdHRyKCd3aWR0aCcsIHN2Z1cpLmF0dHIoJ2hlaWdodCcsIHN2Z0gpXHJcbiAgICAgICAgLy8gIDxyZWN0IHdpZHRoPVwiMzAwXCIgaGVpZ2h0PVwiMTAwXCIgc3R5bGU9XCJmaWxsOnJnYigwLDAsMjU1KTtzdHJva2Utd2lkdGg6MztzdHJva2U6cmdiKDAsMCwwKVwiIC8+XHJcblxyXG4gICAgICAgIGNvbnN0IGcgPSBzdmcuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgdGhpcy5tYXJnaW4gKyAnICcgKyAwICsgJyknKVxyXG5cclxuICAgICAgICAvL2RyYXcgY29sb3IgYmFyXHJcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGggPSB0aGlzLmhlaWdodFxyXG4gICAgICAgIGNvbnN0IHN0ZXAgPSA1XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3OyBpICs9IHN0ZXApIHtcclxuICAgICAgICAgICAgbGV0IHQgPSBpIC8gKHcgLSAxKVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnZlcnQpIHQgPSAxIC0gdFxyXG4gICAgICAgICAgICBnLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBzdGVwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGgpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCB0aGlzLmNvbG9yU2NhbGUodCwgb3B0cy52aWV3U2NhbGUpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRpY2tzOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHQgPSBpIC8gKHRoaXMudGlja3MgLSAxKVxyXG5cclxuICAgICAgICAgICAgLy90aWNrIGxpbmVcclxuICAgICAgICAgICAgZy5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgdyAqIHQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgdyAqIHQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBoICsgdGhpcy50aWNrU2l6ZSlcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJylcclxuXHJcbiAgICAgICAgICAgIC8vcHJlcGFyZSB0aWNrIGxhYmVsXHJcbiAgICAgICAgICAgIGcuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICd0aWNrbGFiZWxfJyArIGkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHcgKiB0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBoICsgdGhpcy50aWNrU2l6ZSArIDIpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIHRoaXMuZm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICAvLy5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxyXG4gICAgICAgICAgICAgICAgLy8uc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIkFyaWFsXCIpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgaSA9PSAwID8gJ3N0YXJ0JyA6IGkgPT0gdGhpcy50aWNrcyAtIDEgPyAnZW5kJyA6ICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAndG9wJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZG9taW5hbnQtYmFzZWxpbmUnLCAnaGFuZ2luZycpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAvLy50ZXh0KFwiLVwiKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy91cGRhdGUgdGljayBsYWJlbHNcclxuXHJcbiAgICAgICAgLy9sYWJlbCB0ZXh0IGZvcm1hdFxyXG4gICAgICAgIGNvbnN0IGYgPSB0aGlzLnRpY2tGb3JtYXQgJiYgdGhpcy50aWNrRm9ybWF0ICE9ICd0ZXh0JyA/IHRoaXMudGlja0Zvcm1hdCA6ICh2KSA9PiB2XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRpY2tzOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHQgPSBpIC8gKHRoaXMudGlja3MgLSAxKVxyXG5cclxuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMudGV4dFNjYWxlKHQsIG9wdHMudmlld1NjYWxlKVxyXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gKHYgPyBmKHYpIDogJzAnKSArICh0aGlzLnRpY2tVbml0ID8gdGhpcy50aWNrVW5pdCA6ICcnKVxyXG4gICAgICAgICAgICBpZiAodGV4dCA9PSB1bmRlZmluZWQpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL3RpY2sgbGFiZWxcclxuICAgICAgICAgICAgdGhpcy5kaXYuc2VsZWN0KCcjJyArICd0aWNrbGFiZWxfJyArIGkpLnRleHQodGV4dClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9jb3JlL0xlZ2VuZC5qcydcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBlbGVtZW50IGZvciBzZWdtZW50IG9yaWVudGF0aW9uLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGxlZ2VuZFxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgT3JpZW50YXRpb25MZWdlbmQgZXh0ZW5kcyBMZWdlbmQge1xyXG4gICAgLyoqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvL29yaWVudGF0aW9uXHJcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IG9wdHMub3JpZW50YXRpb24gfHwgMFxyXG4gICAgICAgIC8vY29sb3JcclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgPT4gJ2dyYXknKVxyXG4gICAgICAgIC8vd2lkdGhcclxuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAoKHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgPT4gMyAqIHopXHJcbiAgICAgICAgLy9sZW5ndGhcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IG9wdHMubGVuZ3RoIHx8ICgocmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA9PiByZXNvbHV0aW9uKVxyXG5cclxuICAgICAgICAvL2xhYmVsXHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IG9wdHMubGFiZWwgfHwgJy0nXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3sgc3R5bGU6IGltcG9ydChcIi4uL3N0eWxlL1NlZ21lbnRTdHlsZS5qc1wiKS5TZWdtZW50U3R5bGUsIHJlc29sdXRpb246IG51bWJlciwgejogbnVtYmVyLCB2aWV3U2NhbGU6b2JqZWN0IH19IG9wdHNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKG9wdHMpIHtcclxuICAgICAgICAvL2NsZWFyXHJcbiAgICAgICAgdGhpcy5kaXYuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy90aXRsZVxyXG4gICAgICAgIHRoaXMubWFrZVRpdGxlKClcclxuXHJcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZGl2LmFwcGVuZCgnZGl2JylcclxuXHJcbiAgICAgICAgLy9jb21wdXRlIHNlZ21lbnQgY29sb3IsIHdpZHRoIGFuZCBsZW5ndGhcclxuICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuY29sb3Iob3B0cy5yZXNvbHV0aW9uLCBvcHRzLnosIG9wdHMudmlld1NjYWxlKVxyXG4gICAgICAgIGNvbnN0IHdpZHRoUGl4ID0gdGhpcy53aWR0aChvcHRzLnJlc29sdXRpb24sIG9wdHMueiwgb3B0cy52aWV3U2NhbGUpIC8gb3B0cy56XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoUGl4ID0gdGhpcy5sZW5ndGgob3B0cy5yZXNvbHV0aW9uLCBvcHRzLnosIG9wdHMudmlld1NjYWxlKSAvIG9wdHMuelxyXG5cclxuICAgICAgICAvL2RyYXcgU1ZHIHNlZ21lbnRcclxuICAgICAgICBjb25zdCBzdmdTID0gTWF0aC5tYXgobGVuZ3RoUGl4LCB3aWR0aFBpeClcclxuICAgICAgICBjb25zdCBzdmcgPSBkLmFwcGVuZCgnc3ZnJykuYXR0cignd2lkdGgnLCBzdmdTKS5hdHRyKCdoZWlnaHQnLCBzdmdTKS5zdHlsZSgnJywgJ2lubGluZS1ibG9jaycpXHJcblxyXG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKCgtdGhpcy5vcmllbnRhdGlvbiAqIE1hdGguUEkpIC8gMTgwKVxyXG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKCgtdGhpcy5vcmllbnRhdGlvbiAqIE1hdGguUEkpIC8gMTgwKVxyXG4gICAgICAgIGNvbnN0IGRjID0gc3ZnUyAqIDAuNSxcclxuICAgICAgICAgICAgbDIgPSBsZW5ndGhQaXggKiAwLjVcclxuICAgICAgICBzdmcuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgZGMgLSBjb3MgKiBsMilcclxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgZGMgLSBzaW4gKiBsMilcclxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgZGMgKyBjb3MgKiBsMilcclxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgZGMgKyBzaW4gKiBsMilcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBjb2xvcilcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB3aWR0aFBpeClcclxuXHJcbiAgICAgICAgLy9sYWJlbFxyXG4gICAgICAgIGQuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnaW5saW5lJylcclxuICAgICAgICAgICAgLnN0eWxlKCdwYWRkaW5nLWxlZnQnLCAnNXB4JylcclxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLmxhYmVsRm9udFNpemUpXHJcbiAgICAgICAgICAgIC50ZXh0KHRoaXMubGFiZWwgKyAodGhpcy5sYWJlbFVuaXRUZXh0ID8gJyAnIDogJycpICsgdGhpcy5sYWJlbFVuaXRUZXh0KVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3JpZW50YXRpb25zXHJcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVsc1xyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0c1xyXG4gKiBAcmV0dXJucyAgeyBBcnJheS48T3JpZW50YXRpb25MZWdlbmQ+IH1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvcmllbnRhdGlvbkxlZ2VuZChvcmllbnRhdGlvbnMsIGxhYmVscywgb3B0cyA9IHt9KSB7XHJcbiAgICBjb25zdCBsZWdlbmRzID0gW11cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZW50YXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgb3B0cy50aXRsZSA9IGkgPT0gMCA/IG9wdHMudGl0bGUgOiB1bmRlZmluZWRcclxuICAgICAgICBvcHRzLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb25zW2ldXHJcbiAgICAgICAgb3B0cy5sYWJlbCA9IGxhYmVsc1tpXVxyXG4gICAgICAgIGxlZ2VuZHMucHVzaChuZXcgT3JpZW50YXRpb25MZWdlbmQob3B0cykpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVnZW5kc1xyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vY29yZS9MZWdlbmQuanMnXHJcbmltcG9ydCB7IG5pY2UgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IHsgbWF4IH0gZnJvbSAnZDMtYXJyYXknXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgZWxlbWVudCBmb3IgcHJvcG9ydGlvbmFsIHN5bWJvbHMuXHJcbiAqXHJcbiAqIEBtb2R1bGUgbGVnZW5kXHJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTaXplTGVnZW5kIGV4dGVuZHMgTGVnZW5kIHtcclxuICAgIC8qKiBAcGFyYW0ge09iamVjdH0gb3B0cyAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB0ZXh0IGxhYmVsLCBmcm9tIHRoZSB2aWV3IHNjYWxlIGFuZCBsaXN0IG9mIGNlbGxzLCByZXNvbHV0aW9uIGFuZCB6b29tXHJcbiAgICAgICAgICogIEB0eXBlIHsgZnVuY3Rpb24ob2JqZWN0LCBBcnJheS48aW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsPiwgbnVtYmVyLCBudW1iZXIpOihudW1iZXJ8c3RyaW5nKSB9ICovXHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IG9wdHMubGFiZWwgfHwgdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgc2l6ZSBvZiB0aGUgbGVnZW5kIHN5bWJvbCwgaW4gZ2VvIFVvTSwgZnJvbSB0aGUgdmlld3NjYWxlLCByZXNvbHV0aW9uIGFuZCB6b29tXHJcbiAgICAgICAgICogIEB0eXBlIHsgZnVuY3Rpb24ob2JqZWN0LCBudW1iZXIsIG51bWJlcik6bnVtYmVyIH0gKi9cclxuICAgICAgICB0aGlzLnNpemUgPSBvcHRzLnNpemUgfHwgdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8vc3ltYm9sXHJcbiAgICAgICAgLyoqICBAdHlwZSB7KGltcG9ydChcIi4uL2NvcmUvU3R5bGVcIikuU2hhcGUpfFwibGluZVwifSAqL1xyXG4gICAgICAgIHRoaXMuc2hhcGUgPSBvcHRzLnNoYXBlIHx8ICdjaXJjbGUnXHJcblxyXG4gICAgICAgIC8vZ2VuZXJhbCBjYXNlXHJcbiAgICAgICAgdGhpcy5maWxsQ29sb3IgPSBvcHRzLmZpbGxDb2xvciB8fCAnbm9uZSdcclxuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gb3B0cy5zdHJva2VDb2xvciB8fCAnZ3JheSdcclxuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aCB8fCAxXHJcblxyXG4gICAgICAgIC8vZm9yIGxpbmUgc2hhcGVcclxuICAgICAgICAvL1RPRE8gdGhpcy5vcmllbnRhdGlvbiA9IG9wdHMub3JpZW50YXRpb24gfHwgMFxyXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICdncmF5J1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gb3B0cy5sZW5ndGggfHwgKChyZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpID0+IHJlc29sdXRpb24pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3sgdmlld1NjYWxlOm9iamVjdCwgcmVzb2x1dGlvbjogbnVtYmVyLCB6Om51bWJlciwgY2VsbHM6QXJyYXkuPGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbD4gfX0gb3B0c1xyXG4gICAgICovXHJcbiAgICB1cGRhdGUob3B0cykge1xyXG4gICAgICAgIC8vY2xlYXJcclxuICAgICAgICB0aGlzLmRpdi5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvL3RpdGxlXHJcbiAgICAgICAgdGhpcy5tYWtlVGl0bGUoKVxyXG5cclxuICAgICAgICAvL2dldCBsYWJlbC4gTWF5IG5vdCBiZSBhIG51bWJlciAoISlcclxuICAgICAgICBsZXQgbGFiZWwgPSB0aGlzLmxhYmVsKG9wdHMudmlld1NjYWxlLCBvcHRzLmNlbGxzLCBvcHRzLnJlc29sdXRpb24sIG9wdHMueilcclxuXHJcbiAgICAgICAgLy9jb21wdXRlIHNpemUgb2Ygc3ltYm9sLCBpbiBwaXhcclxuICAgICAgICBsZXQgc2l6ZVBpeFxyXG4gICAgICAgIGlmICh0aGlzLnNpemUpIHNpemVQaXggPSB0aGlzLnNpemUob3B0cy52aWV3U2NhbGUsIG9wdHMucmVzb2x1dGlvbiwgb3B0cy56KSAvIG9wdHMuelxyXG4gICAgICAgIGVsc2Ugc2l6ZVBpeCA9IG9wdHMudmlld1NjYWxlKCtsYWJlbCkgLyBvcHRzLnpcclxuICAgICAgICBpZiAoIXNpemVQaXgpIHJldHVyblxyXG5cclxuICAgICAgICAvL2Zvcm1hdCBsYWJlbCwgaWYgc3BlY2lmaWVkIGFuZCBwb3NzaWJsZVxyXG4gICAgICAgIGlmICh0aGlzLmxhYmVsRm9ybWF0ICYmICFpc05hTigrbGFiZWwpKSBsYWJlbCA9IHRoaXMubGFiZWxGb3JtYXQobGFiZWwpXHJcblxyXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmRpdi5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgLy90byBlbmFibGUgdmVydGljYWwgY2VudGVyaW5nXHJcbiAgICAgICAgLy8uc3R5bGUoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpXHJcblxyXG4gICAgICAgIC8vZGVmYXVsdCBzdmcgY29uc3RydWN0aW9uLCBmb3Igc3F1YXJlIGFuZCBjaXJjbGVcclxuICAgICAgICBjb25zdCBzdmcgPSAoKSA9PlxyXG4gICAgICAgICAgICBkXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgc2l6ZVBpeCArIHRoaXMuc3Ryb2tlV2lkdGggKyAyKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHNpemVQaXggKyB0aGlzLnN0cm9rZVdpZHRoICsgMilcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnJywgJ2lubGluZS1ibG9jaycpXHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNoYXBlID09PSAnc3F1YXJlJykge1xyXG4gICAgICAgICAgICBzdmcoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBzaXplUGl4KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHNpemVQaXgpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCB0aGlzLmZpbGxDb2xvcilcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgdGhpcy5zdHJva2VDb2xvcilcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5zdHJva2VXaWR0aClcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2hhcGUgPT09ICdjaXJjbGUnKSB7XHJcbiAgICAgICAgICAgIC8vIDxjaXJjbGUgY3g9XCI1MFwiIGN5PVwiNTBcIiByPVwiNDBcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjNcIiBmaWxsPVwicmVkXCIgLz5cclxuICAgICAgICAgICAgY29uc3QgciA9IChzaXplUGl4ICsgdGhpcy5zdHJva2VXaWR0aCkgKiAwLjVcclxuICAgICAgICAgICAgc3ZnKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCByICsgMSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIHIgKyAxKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCByKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgdGhpcy5maWxsQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRoaXMuc3Ryb2tlQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHRoaXMuc3Ryb2tlV2lkdGgpXHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNoYXBlID09PSAnZG9udXQnKSB7XHJcbiAgICAgICAgICAgIC8vVE9ET1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaGFwZSA9PT0gJ2RpYW1vbmQnKSB7XHJcbiAgICAgICAgICAgIC8vVE9ET1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaGFwZSA9PT0gJ2xpbmUnKSB7XHJcbiAgICAgICAgICAgIC8vZ2V0IHNlZ21lbnQgbGVuZ3RoXHJcbiAgICAgICAgICAgIGxldCBsZW5ndGhQaXggPSB0aGlzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLmxlbmd0aChvcHRzLnJlc29sdXRpb24sIG9wdHMueiwgb3B0cy52aWV3U2NhbGUpXHJcbiAgICAgICAgICAgICAgICA6IG9wdHMucmVzb2x1dGlvblxyXG4gICAgICAgICAgICBsZW5ndGhQaXggLz0gb3B0cy56XHJcblxyXG4gICAgICAgICAgICBjb25zdCBzdmcgPSBkXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgbGVuZ3RoUGl4KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHNpemVQaXgpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJycsICdpbmxpbmUtYmxvY2snKVxyXG5cclxuICAgICAgICAgICAgLy9UT0RPIG9yaWVudGF0aW9uXHJcbiAgICAgICAgICAgIC8vPGxpbmUgeDE9XCIwXCIgeTE9XCIwXCIgeDI9XCIyMDBcIiB5Mj1cIjIwMFwiIHN0eWxlPVwic3Ryb2tlOnJnYigyNTUsMCwwKTtzdHJva2Utd2lkdGg6MlwiIC8+XHJcbiAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHNpemVQaXggLyAyKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgbGVuZ3RoUGl4KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgc2l6ZVBpeCAvIDIpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRoaXMuY29sb3IpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHNpemVQaXgpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNoYXBlOicgKyB0aGlzLnNoYXBlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9sYWJlbFxyXG4gICAgICAgIGQuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnaW5saW5lJylcclxuICAgICAgICAgICAgLnN0eWxlKCdwYWRkaW5nLWxlZnQnLCAnNXB4JylcclxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLmxhYmVsRm9udFNpemUpXHJcbiAgICAgICAgICAgIC50ZXh0KGxhYmVsICsgKHRoaXMubGFiZWxVbml0VGV4dCA/ICcgJyA6ICcnKSArIHRoaXMubGFiZWxVbml0VGV4dClcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlc1xyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfSBzaXplXHJcbiAqIEBwYXJhbSB7IG9iamVjdCB9IG9wdHNcclxuICogQHJldHVybnMge0FycmF5LjxTaXplTGVnZW5kPn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzaXplTGVnZW5kKHZhbHVlcywgc2l6ZSwgb3B0cyA9IHt9KSB7XHJcbiAgICBjb25zdCBsZWdlbmRzID0gW11cclxuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xyXG4gICAgICAgIG9wdHMudGl0bGUgPSB2YWx1ZSA9PSB2YWx1ZXNbMF0gPyBvcHRzLnRpdGxlIDogdW5kZWZpbmVkXHJcbiAgICAgICAgb3B0cy5zaXplID0gKCkgPT4gc2l6ZSh2YWx1ZSlcclxuICAgICAgICBvcHRzLmxhYmVsID0gKCkgPT4gdmFsdWVcclxuICAgICAgICBsZWdlbmRzLnB1c2gobmV3IFNpemVMZWdlbmQob3B0cykpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVnZW5kc1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHsgZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsKTpudW1iZXIgfSB2YWx1ZVxyXG4gKiBAcGFyYW0geyp9IG9wdHNcclxuICogQHJldHVybnMge0FycmF5LjxTaXplTGVnZW5kPn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzaXplTGVnZW5kVmlld1NjYWxlKHZhbHVlLCBvcHRzID0ge30pIHtcclxuICAgIGNvbnN0IGsgPSBvcHRzLmsgfHwgWzAuOSwgMC41LCAwLjIsIDAuMDVdXHJcbiAgICBjb25zdCBsZWdlbmRzID0gW11cclxuICAgIGZvciAobGV0IGtfIG9mIGspIHtcclxuICAgICAgICBvcHRzLnRpdGxlID0ga18gPT0ga1swXSA/IG9wdHMudGl0bGUgOiB1bmRlZmluZWRcclxuICAgICAgICBvcHRzLmxhYmVsID0gKHZpZXdTY2FsZSwgY2VsbHMpID0+IG5pY2Uoa18gKiBtYXgoY2VsbHMsIHZhbHVlKSlcclxuICAgICAgICBsZWdlbmRzLnB1c2gobmV3IFNpemVMZWdlbmQob3B0cykpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVnZW5kc1xyXG59XHJcblxyXG4vKipcclxuICogQSBmdW5jdGlvbiB3aGljaCByZXR1cm4gYSBzdGFjayBvZiBzaXplIGxlZ2VuZHMgZm9yIGEgZGlzY3JldGUgY2xhc3NpZmljYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7IEFycmF5LjxudW1iZXI+IH0gYnJlYWtzXHJcbiAqIEBwYXJhbSB7IEFycmF5LjxudW1iZXI+IH0gc2l6ZXNcclxuICogQHBhcmFtIHsgb2JqZWN0IH0gb3B0c1xyXG4gKiBAcmV0dXJucyB7QXJyYXkuPFNpemVMZWdlbmQ+fVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNpemVEaXNjcmV0ZUxlZ2VuZChicmVha3MsIHNpemVzLCBvcHRzID0ge30pIHtcclxuICAgIGNvbnN0IGYgPSBvcHRzLmxhYmVsRm9ybWF0IHx8ICgoeCkgPT4geClcclxuICAgIGNvbnN0IGxhYmVsVGV4dCA9IG9wdHMubGFiZWxUZXh0IHx8IGRlZmF1bHRMYWJlbFRleHQoZilcclxuICAgIGNvbnN0IGxlZ2VuZHMgPSBbXVxyXG4gICAgZm9yIChsZXQgaSA9IHNpemVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgb3B0cy50aXRsZSA9IGkgPT0gc2l6ZXMubGVuZ3RoIC0gMSA/IG9wdHMudGl0bGUgOiB1bmRlZmluZWRcclxuICAgICAgICBvcHRzLnNpemUgPSAoKSA9PiBzaXplc1tpXVxyXG4gICAgICAgIG9wdHMubGFiZWwgPSAoKSA9PiBsYWJlbFRleHQoYnJlYWtzW2kgLSAxXSwgYnJlYWtzW2ldKVxyXG4gICAgICAgIGxlZ2VuZHMucHVzaChuZXcgU2l6ZUxlZ2VuZChvcHRzKSlcclxuICAgIH1cclxuICAgIHJldHVybiBsZWdlbmRzXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybiBhIHN0YWNrIG9mIHNpemUgbGVnZW5kcyBmb3IgYSBkaXNjcmV0ZSBjbGFzc2lmaWNhdGlvbiB1c2luZyBhIHZpZXdzY2FsZS5cclxuICogQHBhcmFtIHsgbnVtYmVyIH0gY2xhc3NOdW1iZXJcclxuICogQHBhcmFtIHsgb2JqZWN0IH0gb3B0c1xyXG4gKiBAcmV0dXJucyB7QXJyYXkuPFNpemVMZWdlbmQ+fVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNpemVEaXNjcmV0ZVZpZXdTY2FsZUxlZ2VuZChjbGFzc051bWJlciwgb3B0cyA9IHt9KSB7XHJcbiAgICBjb25zdCBmID0gb3B0cy5sYWJlbEZvcm1hdCB8fCAoKHgpID0+IHgpXHJcbiAgICBjb25zdCBsYWJlbFRleHQgPSBvcHRzLmxhYmVsVGV4dCB8fCBkZWZhdWx0TGFiZWxUZXh0KGYpXHJcbiAgICBjb25zdCBsZWdlbmRzID0gW11cclxuICAgIGNvbnN0IHZpZXdTY2FsZUZ1biA9IG9wdHMudmlld1NjYWxlRnVuIHx8ICgodCkgPT4gdCkgLy9UT0RPIGRvIGl0IGRpZmZlcmVudGx5PyBBdCBzaXplbGVnZW5kIGxldmVsICFcclxuICAgIGZvciAobGV0IGkgPSBjbGFzc051bWJlciAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgb3B0cy50aXRsZSA9IGkgPT0gY2xhc3NOdW1iZXIgLSAxID8gb3B0cy50aXRsZSA6IHVuZGVmaW5lZFxyXG4gICAgICAgIG9wdHMuc2l6ZSA9ICh2aWV3U2NhbGUpID0+IHZpZXdTY2FsZUZ1bih2aWV3U2NhbGUpLnZhbHVlc1tpXVxyXG4gICAgICAgIG9wdHMubGFiZWwgPSAodmlld1NjYWxlKSA9PlxyXG4gICAgICAgICAgICBsYWJlbFRleHQodmlld1NjYWxlRnVuKHZpZXdTY2FsZSkuYnJlYWtzW2kgLSAxXSwgdmlld1NjYWxlRnVuKHZpZXdTY2FsZSkuYnJlYWtzW2ldKVxyXG4gICAgICAgIGxlZ2VuZHMucHVzaChuZXcgU2l6ZUxlZ2VuZChvcHRzKSlcclxuICAgIH1cclxuICAgIHJldHVybiBsZWdlbmRzXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGZvcm1hdCBsYWJlcmxzIGZvciBkaXNjcmV0ZSBzY2FsZSBsZWdlbmRzLlxyXG4gKiBAcGFyYW0geyBmdW5jdGlvbihudW1iZXIpOnN0cmluZyB9IGZvcm1hdFxyXG4gKiBAcmV0dXJucyB7IGZ1bmN0aW9uKG51bWJlcnx1bmRlZmluZWQsIG51bWJlcnx1bmRlZmluZWQpOiBzdHJpbmcgfVxyXG4gKi9cclxuZnVuY3Rpb24gZGVmYXVsdExhYmVsVGV4dChmb3JtYXQpIHtcclxuICAgIHJldHVybiAodjAsIHYxKSA9PiB7XHJcbiAgICAgICAgaWYgKHYwID09IHVuZGVmaW5lZCAmJiB2MSA9PSB1bmRlZmluZWQpIHJldHVybiAnJ1xyXG4gICAgICAgIGlmICh2MSA9PSB1bmRlZmluZWQpIHJldHVybiAnPiAnICsgZm9ybWF0KHYwKVxyXG4gICAgICAgIGlmICh2MCA9PSB1bmRlZmluZWQpIHJldHVybiAnPCAnICsgZm9ybWF0KHYxKVxyXG4gICAgICAgIHJldHVybiBmb3JtYXQodjApICsgJyAtICcgKyBmb3JtYXQodjEpXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcbmltcG9ydCB7IExlZ2VuZCB9IGZyb20gJy4uL2NvcmUvTGVnZW5kLmpzJ1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBtb2R1bGUgbGVnZW5kXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBUZXJuYXJ5TGVnZW5kIGV4dGVuZHMgTGVnZW5kIHtcclxuICAgIC8qKiBAcGFyYW0ge09iamVjdH0gb3B0cyAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLy9jbGFzc2lmaWVyXHJcbiAgICAgICAgdGhpcy5jbGFzc2lmaWVyID0gb3B0cy5jbGFzc2lmaWVyXHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8IDE1MFxyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ29sb3IgPSB0aGlzLnNlbGVjdGlvbkNvbG9yIHx8ICdyZWQnXHJcbiAgICAgICAgdGhpcy50b29sdGlwID0gb3B0cy50b29sdGlwXHJcbiAgICAgICAgdGhpcy50ZXh0cyA9IG9wdHMudGV4dHNcclxuXHJcbiAgICAgICAgdGhpcy5sZWZ0VGV4dCA9IG9wdHMubGVmdFRleHQgfHwgJ0NhdGVnb3J5IDAnXHJcbiAgICAgICAgdGhpcy50b3BUZXh0ID0gb3B0cy50b3BUZXh0IHx8ICdDYXRlZ29yeSAxJ1xyXG4gICAgICAgIHRoaXMucmlnaHRUZXh0ID0gb3B0cy5yaWdodFRleHQgfHwgJ0NhdGVnb3J5IDInXHJcblxyXG4gICAgICAgIHRoaXMuY2VudGVyQ29lZmZpY2llbnQgPSBvcHRzLmNlbnRlckNvZWZmaWNpZW50IHx8IHRoaXMuY2xhc3NpZmllci5jZW50ZXJDb2VmZmljaWVudFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHt7fSB9IG9wdHNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKG9wdHMpIHtcclxuICAgICAgICAvL2NsZWFyXHJcbiAgICAgICAgdGhpcy5kaXYuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy90aXRsZVxyXG4gICAgICAgIHRoaXMubWFrZVRpdGxlKClcclxuXHJcbiAgICAgICAgY29uc3Qgc3FydDNvdmVyMiA9IDAuODY2MDI1XHJcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGggPSB3ICogc3FydDNvdmVyMlxyXG4gICAgICAgIGNvbnN0IGNsYXNzaWZpZXIgPSB0aGlzLmNsYXNzaWZpZXJcclxuICAgICAgICBjb25zdCBzZWxlY3Rpb25Db2xvciA9IHRoaXMuc2VsZWN0aW9uQ29sb3JcclxuICAgICAgICBjb25zdCBzZWxlY3Rpb25TdHJva2VXaWR0aCA9IDBcclxuICAgICAgICBjb25zdCB0dCA9IHRoaXMudG9vbHRpcFxyXG4gICAgICAgIGNvbnN0IHRleHRzID0gdGhpcy50ZXh0cyB8fCB7fVxyXG5cclxuICAgICAgICBjb25zdCBwYWRkaW5nID0gMlxyXG4gICAgICAgIGNvbnN0IGZvbnRTaXplID0gMTJcclxuXHJcbiAgICAgICAgLy9tYWtlIHN2ZyBlbGVtZW50XHJcbiAgICAgICAgY29uc3Qgc3ZnID0gdGhpcy5kaXZcclxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdyArIHNlbGVjdGlvblN0cm9rZVdpZHRoKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaCArIDQgKiBwYWRkaW5nICsgMiAqIGZvbnRTaXplKVxyXG5cclxuICAgICAgICAvL3RvcCBsYWJlbFxyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHcgLyAyKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIHBhZGRpbmcgKyBmb250U2l6ZSlcclxuICAgICAgICAgICAgLnRleHQodGhpcy50b3BUZXh0KVxyXG4gICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgZm9udFNpemUpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgIC8vbGVmdCBsYWJlbFxyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMyAqIHBhZGRpbmcgKyAyICogZm9udFNpemUgKyBoKVxyXG4gICAgICAgICAgICAudGV4dCh0aGlzLmxlZnRUZXh0KVxyXG4gICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgZm9udFNpemUpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpXHJcbiAgICAgICAgLy9yaWdodCBsYWJlbFxyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMyAqIHBhZGRpbmcgKyAyICogZm9udFNpemUgKyBoKVxyXG4gICAgICAgICAgICAudGV4dCh0aGlzLnJpZ2h0VGV4dClcclxuICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGZvbnRTaXplKVxyXG4gICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnZW5kJylcclxuXHJcbiAgICAgICAgLy90cmlhbmdsZSBncm91cFxyXG4gICAgICAgIGNvbnN0IGcgPSBzdmdcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKFxyXG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybScsXHJcbiAgICAgICAgICAgICAgICAndHJhbnNsYXRlKCcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0cm9rZVdpZHRoIC8gMiArXHJcbiAgICAgICAgICAgICAgICAgICAgJyAnICtcclxuICAgICAgICAgICAgICAgICAgICAoc2VsZWN0aW9uU3Ryb2tlV2lkdGggLyAyICsgKDIgKiBwYWRkaW5nICsgZm9udFNpemUpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJyknXHJcbiAgICAgICAgICAgIClcclxuXHJcbiAgICAgICAgLy9jb21tb24gZnVuY3Rpb24gZm9yIHRyaWFuZ2xlIHBhdGNoZXNcclxuICAgICAgICBjb25zdCBzZXRBdHRyaWJ1dGVzID0gKGVsdCwgY29sb3IsIHRleHQpID0+IHtcclxuICAgICAgICAgICAgLy9lbHQucmFpc2UoKTtcclxuICAgICAgICAgICAgZWx0LmF0dHIoJ2ZpbGwnLCBjb2xvcilcclxuICAgICAgICAgICAgICAgIC8vLmF0dHIoXCJzdHJva2VcIiwgY29sb3JPdmVyKVxyXG4gICAgICAgICAgICAgICAgLy8uYXR0cihcInN0cm9rZS13aWR0aFwiLCAwKVxyXG4gICAgICAgICAgICAgICAgLy8uYXR0cihcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyp0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7IHNlbGVjdCh0aGlzKS5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIHNlbGVjdGlvblN0cm9rZVdpZHRoKTsqL1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsJywgc2VsZWN0aW9uQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0dCB8fCAhdGV4dCkgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgdHQuaHRtbCh0ZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgIHR0LnNldFBvc2l0aW9uKGUpXHJcbiAgICAgICAgICAgICAgICAgICAgdHQuc2hvdygpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKnNlbGVjdCh0aGlzKS5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDApOyovXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmF0dHIoJ2ZpbGwnLCBjb2xvcilcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHQpIHR0LmhpZGUoKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgaWYgKHR0ICYmIHRleHQpXHJcbiAgICAgICAgICAgICAgICBlbHQub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHQuc2V0UG9zaXRpb24oZSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbnN0IFtjMCwgYzEsIGMyXSA9IGNsYXNzaWZpZXIuY2VudGVyXHJcblxyXG4gICAgICAgIC8vdHJhcGV6aXVtIHMwXHJcbiAgICAgICAgY29uc3QgdDAgPSBnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgICAgICAuYXR0cihcclxuICAgICAgICAgICAgICAgICdwb2ludHMnLFxyXG4gICAgICAgICAgICAgICAgJzAsJyArXHJcbiAgICAgICAgICAgICAgICAgICAgaCArXHJcbiAgICAgICAgICAgICAgICAgICAgJyAnICtcclxuICAgICAgICAgICAgICAgICAgICB3IC8gMyArXHJcbiAgICAgICAgICAgICAgICAgICAgJywnICtcclxuICAgICAgICAgICAgICAgICAgICBoICtcclxuICAgICAgICAgICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHcgLyAyICtcclxuICAgICAgICAgICAgICAgICAgICAnLCcgK1xyXG4gICAgICAgICAgICAgICAgICAgIChoICogMikgLyAzICtcclxuICAgICAgICAgICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHcgLyA2ICtcclxuICAgICAgICAgICAgICAgICAgICAnLCcgK1xyXG4gICAgICAgICAgICAgICAgICAgIChoICogMikgLyAzXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICBzZXRBdHRyaWJ1dGVzKHQwLCBjbGFzc2lmaWVyLmNvbG9yc1swXSwgdGV4dHNbJzAnXSlcclxuICAgICAgICAvL3RyYXBleml1bSBzMVxyXG4gICAgICAgIGNvbnN0IHQxID0gZ1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdwb2x5Z29uJylcclxuICAgICAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAgICAgICAncG9pbnRzJyxcclxuICAgICAgICAgICAgICAgIHcgLyAyICtcclxuICAgICAgICAgICAgICAgICAgICAnLDAgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKHcgKiAyKSAvIDMgK1xyXG4gICAgICAgICAgICAgICAgICAgICcsJyArXHJcbiAgICAgICAgICAgICAgICAgICAgaCAvIDMgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgdyAvIDIgK1xyXG4gICAgICAgICAgICAgICAgICAgICcsJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKGggKiAyKSAvIDMgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgdyAvIDMgK1xyXG4gICAgICAgICAgICAgICAgICAgICcsJyArXHJcbiAgICAgICAgICAgICAgICAgICAgaCAvIDNcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIHNldEF0dHJpYnV0ZXModDEsIGNsYXNzaWZpZXIuY29sb3JzWzFdLCB0ZXh0c1snMSddKVxyXG4gICAgICAgIC8vdHJhcGV6aXVtIHMyXHJcbiAgICAgICAgY29uc3QgdDIgPSBnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgICAgICAuYXR0cihcclxuICAgICAgICAgICAgICAgICdwb2ludHMnLFxyXG4gICAgICAgICAgICAgICAgdyArXHJcbiAgICAgICAgICAgICAgICAgICAgJywnICtcclxuICAgICAgICAgICAgICAgICAgICBoICtcclxuICAgICAgICAgICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICh3ICogNSkgLyA2ICtcclxuICAgICAgICAgICAgICAgICAgICAnLCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICgyICogaCkgLyAzICtcclxuICAgICAgICAgICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHcgLyAyICtcclxuICAgICAgICAgICAgICAgICAgICAnLCcgK1xyXG4gICAgICAgICAgICAgICAgICAgIChoICogMikgLyAzICtcclxuICAgICAgICAgICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICh3ICogMikgLyAzICtcclxuICAgICAgICAgICAgICAgICAgICAnLCcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGhcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIHNldEF0dHJpYnV0ZXModDIsIGNsYXNzaWZpZXIuY29sb3JzWzJdLCB0ZXh0c1snMiddKVxyXG4gICAgICAgIC8vdHJpYW5nbGUgczBcclxuICAgICAgICBjb25zdCB0MF8gPSBnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgICAgICAuYXR0cihcclxuICAgICAgICAgICAgICAgICdwb2ludHMnLFxyXG4gICAgICAgICAgICAgICAgdyAvIDIgK1xyXG4gICAgICAgICAgICAgICAgICAgICcsJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKGggKiAyKSAvIDMgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKHcgKiA1KSAvIDYgK1xyXG4gICAgICAgICAgICAgICAgICAgICcsJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKGggKiAyKSAvIDMgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKHcgKiAyKSAvIDMgK1xyXG4gICAgICAgICAgICAgICAgICAgICcsJyArXHJcbiAgICAgICAgICAgICAgICAgICAgaCAvIDNcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIHNldEF0dHJpYnV0ZXModDBfLCBjbGFzc2lmaWVyLm1peENvbG9yc1swXSwgdGV4dHNbJ20xMiddKVxyXG4gICAgICAgIC8vdHJpYW5nbGUgczFcclxuICAgICAgICBjb25zdCB0MV8gPSBnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgICAgICAuYXR0cigncG9pbnRzJywgdyAvIDIgKyAnLCcgKyAoaCAqIDIpIC8gMyArICcgJyArIHcgLyAzICsgJywnICsgaCArICcgJyArICh3ICogMikgLyAzICsgJywnICsgaClcclxuICAgICAgICBzZXRBdHRyaWJ1dGVzKHQxXywgY2xhc3NpZmllci5taXhDb2xvcnNbMV0sIHRleHRzWydtMDInXSlcclxuICAgICAgICAvL3RyaWFuZ2xlIHMyXHJcbiAgICAgICAgY29uc3QgdDJfID0gZ1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdwb2x5Z29uJylcclxuICAgICAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAgICAgICAncG9pbnRzJyxcclxuICAgICAgICAgICAgICAgIHcgLyAyICsgJywnICsgKGggKiAyKSAvIDMgKyAnICcgKyB3IC8gNiArICcsJyArIChoICogMikgLyAzICsgJyAnICsgdyAvIDMgKyAnLCcgKyBoIC8gM1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgc2V0QXR0cmlidXRlcyh0Ml8sIGNsYXNzaWZpZXIubWl4Q29sb3JzWzJdLCB0ZXh0c1snbTAxJ10pXHJcblxyXG4gICAgICAgIC8vY2VudGVyXHJcbiAgICAgICAgaWYgKHRoaXMuY2VudGVyQ29lZmZpY2llbnQpIHtcclxuICAgICAgICAgICAgLy9UT0RPIG1ha2UgaXQgYW4gaGV4YWdvbiAhXHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IGdcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCB3IC8gMilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIChoICogMikgLyAzKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCAodGhpcy5jZW50ZXJDb2VmZmljaWVudCAqIGgpIC8gMylcclxuICAgICAgICAgICAgc2V0QXR0cmlidXRlcyhjZW50ZXIsIGNsYXNzaWZpZXIuY2VudGVyQ29sb3IsIHRleHRzWydjZW50ZXInXSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgbGV0IG1pZGRsZSwgbGVmdCwgdG9wLCByaWdodCwgbGVmdF8sIGJvdHRvbV8sIHJpZ2h0X1xyXG4gICAgICAgIGlmICghdGhpcy5yZWFsKSB7XHJcblxyXG4gICAgICAgICAgICAvLzAgbGVmdCB0cmlhbmdsZVxyXG4gICAgICAgICAgICBsZWZ0ID0gZy5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsIFwiMCxcIiArIGggKyBcIiBcIiArICh3IC8gMykgKyBcIixcIiArIGggKyBcIiBcIiArICh3IC8gNikgKyBcIixcIiArICgyICogaCAvIDMpKVxyXG4gICAgICAgICAgICAvLzEgdG9wIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgIHRvcCA9IGcuYXBwZW5kKCdwb2x5Z29uJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdwb2ludHMnLCAodyAvIDMpICsgXCIsXCIgKyAoaCAvIDMpICsgXCIgXCIgKyAodyAqIDIgLyAzKSArIFwiLFwiICsgKGggLyAzKSArIFwiIFwiICsgKHcgLyAyKSArIFwiLDBcIilcclxuICAgICAgICAgICAgLy8yIHJpZ2h0IHRyaWFuZ2xlXHJcbiAgICAgICAgICAgIHJpZ2h0ID0gZy5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsICh3ICogMiAvIDMpICsgXCIsXCIgKyBoICsgXCIgXCIgKyB3ICsgXCIsXCIgKyBoICsgXCIgXCIgKyAodyAqIDUgLyA2KSArIFwiLFwiICsgKDIgKiBoIC8gMykpXHJcbiAgICAgICAgICAgIC8vbWlkZGxlIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgIG1pZGRsZSA9IGcuYXBwZW5kKCdwb2x5Z29uJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdwb2ludHMnLCAodyAvIDIpICsgXCIsXCIgKyAoaCAvIDMpICsgXCIgXCIgKyAodyAvIDQpICsgXCIsXCIgKyAoaCAqIDUgLyA2KSArIFwiIFwiICsgKDMgKiB3IC8gNCkgKyBcIixcIiArIChoICogNSAvIDYpKVxyXG4gICAgICAgICAgICAvLzAxIGxlZnQgdHJhcGV6aXVtXHJcbiAgICAgICAgICAgIGxlZnRfID0gZy5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsICh3IC8gNikgKyBcIixcIiArIChoICogMiAvIDMpICsgXCIgXCIgKyAodyAvIDQpICsgXCIsXCIgKyAoaCAqIDUgLyA2KSArIFwiIFwiICsgKHcgLyAyKSArIFwiLFwiICsgKGggLyAzKSArIFwiIFwiICsgKHcgLyAzKSArIFwiLFwiICsgKGggLyAzKSlcclxuICAgICAgICAgICAgLy8wMiBib3R0b20gdHJhcGV6aXVtXHJcbiAgICAgICAgICAgIGJvdHRvbV8gPSBnLmFwcGVuZCgncG9seWdvbicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRzJywgKHcgLyAzKSArIFwiLFwiICsgKGgpICsgXCIgXCIgKyAoMiAqIHcgLyAzKSArIFwiLFwiICsgKGgpICsgXCIgXCIgKyAodyAqIDMgLyA0KSArIFwiLFwiICsgKGggKiA1IC8gNikgKyBcIiBcIiArICh3IC8gNCkgKyBcIixcIiArIChoICogNSAvIDYpKVxyXG4gICAgICAgICAgICAvLzEyIHJpZ2h0IHRyYXBleml1bVxyXG4gICAgICAgICAgICByaWdodF8gPSBnLmFwcGVuZCgncG9seWdvbicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRzJywgKHcgLyAyKSArIFwiLFwiICsgKGggLyAzKSArIFwiIFwiICsgKHcgKiAzIC8gNCkgKyBcIixcIiArIChoICogNSAvIDYpICsgXCIgXCIgKyAodyAqIDUgLyA2KSArIFwiLFwiICsgKGggKiAyIC8gMykgKyBcIiBcIiArICh3ICogMiAvIDMpICsgXCIsXCIgKyAoaCAvIDMpKVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy9taWRkbGUgdHJpYW5nbGVcclxuICAgICAgICAgICAgbWlkZGxlID0gZy5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsICh3IC8gMikgKyBcIiwwIDAsXCIgKyBoICsgXCIgXCIgKyB3ICsgXCIsXCIgKyBoKVxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IHRyYXBleml1bVxyXG4gICAgICAgICAgICAvL2RyYXcgbGFyZ2UgdHJhcGV6aXVtIGZpcnN0XHJcbiAgICAgICAgICAgIGZvciAobGV0IGlfID0gMjsgaV8gPj0gMDsgaV8tLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IHRoaXMuY2xhc3NpZmllci5sb3dJbmRleFtpX11cclxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmNsYXNzaWZpZXIubG93VGhyZXNob2xkW2ldXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vMDEgbGVmdCB0cmFwZXppdW1cclxuICAgICAgICAgICAgICAgICAgICBsZWZ0XyA9IGcuYXBwZW5kKCdwb2x5Z29uJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsIHcgLyAyICsgXCIsMCAwLFwiICsgaCArIFwiIFwiICsgdyAqIHIgKyBcIixcIiArIGggKyBcIiBcIiArIHcgKiAoMSArIHIpIC8gMiArIFwiLFwiICsgciAqIGgpXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8wMiBib3R0b20gdHJhcGV6aXVtXHJcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tXyA9IGcuYXBwZW5kKCdwb2x5Z29uJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsIFwiMCxcIiArIGggKyBcIiBcIiArIHcgKyBcIixcIiArIGggKyBcIiBcIiArIHcgKiAoMSAtIHIgLyAyKSArIFwiLFwiICsgaCAqICgxIC0gcikgKyBcIiBcIiArIHIgKiB3IC8gMiArIFwiLFwiICsgaCAqICgxIC0gcikpXHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8xMiByaWdodCB0cmFwZXppdW1cclxuICAgICAgICAgICAgICAgICAgICByaWdodF8gPSBnLmFwcGVuZCgncG9seWdvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdwb2ludHMnLCB3ICsgXCIsXCIgKyBoICsgXCIgXCIgKyB3IC8gMiArIFwiLDAgXCIgKyB3ICogKDEgLSByKSAvIDIgKyBcIixcIiArIGggKiByICsgXCIgXCIgKyB3ICogKDEgLSByKSArIFwiLFwiICsgaClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IHRyaWFuZ2xlc1xyXG4gICAgICAgICAgICAvL2RyYXcgbGFyZ2UgdHJpYW5nbGVzIGZpcnN0XHJcbiAgICAgICAgICAgIGZvciAobGV0IGlfID0gMjsgaV8gPj0gMDsgaV8tLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IHRoaXMuY2xhc3NpZmllci5oaWdoSW5kZXhbaV9dXHJcbiAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5jbGFzc2lmaWVyLmhpZ2hUaHJlc2hvbGRbaV1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vMiByaWdodCB0cmlhbmdsZVxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gZy5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRzJywgdyArIFwiLFwiICsgaCArIFwiIFwiICsgdyAqIHIgKyBcIixcIiArIGggKyBcIiBcIiArIHcgKiAoMSArIHIpIC8gMiArIFwiLFwiICsgaCAqIHIpXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8xIHRvcCB0cmlhbmdsZVxyXG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IGcuYXBwZW5kKCdwb2x5Z29uJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsICh3IC8gMikgKyBcIiwwIFwiICsgdyAqIHIgLyAyICsgXCIsXCIgKyBoICogKDEgLSByKSArIFwiIFwiICsgdyAqICgxIC0gciAvIDIpICsgXCIsXCIgKyBoICogKDEgLSByKSlcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAvLzAgbGVmdCB0cmlhbmdsZVxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBnLmFwcGVuZCgncG9seWdvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdwb2ludHMnLCBcIjAsXCIgKyBoICsgXCIgXCIgKyB3ICogKDEgLSByKSArIFwiLFwiICsgaCArIFwiIFwiICsgdyAqICgxIC0gcikgLyAyICsgXCIsXCIgKyBoICogcilcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9Ki9cclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vY29yZS9TdHlsZS5qcydcclxuXHJcbi8qKiBAdHlwZWRlZiB7XCJmbGFnXCJ8XCJwaWVjaGFydFwifFwicmluZ1wifFwic2VnbWVudFwifFwicmFkYXJcInxcImFnZXB5cmFtaWRcInxcImhhbGZ0b25lXCJ9IENvbXBvc2l0aW9uVHlwZSAqL1xyXG5cclxuLyoqXHJcbiAqIEEgc3R5bGUgc2hvd2luZyB0aGUgY29tcG9zaXRpb24gb2YgYSB0b3RhbCBpbiBkaWZmZXJlbnQgY2F0ZWdvcmllcywgd2l0aCBkaWZmZXJlbnQgY29sb3IgaHVlcy5cclxuICogSXQgY29uc2lzdHMgb2YgYSBzeW1ib2wgd2l0aCBkaWZmZXJlbnQgcGFydHMsIHdob3NlIHNpemUgcmVmbGVjdCB0aGUgcHJvcG9ydGlvbiBvZiB0aGUgY29ycmVzcG9uZGluZyBjYXRlZ29yeS5cclxuICogRm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgc3ltYm9scywgQHNlZSBDb21wb3NpdGlvblR5cGVcclxuICogVGhlIHN5bWJvbCBjYW4gYmUgc2NhbGVkIGRlcGVuZGluZyBvbiB0aGUgY2VsbCBpbXBvcnRhbmNlLlxyXG4gKlxyXG4gKiBAbW9kdWxlIHN0eWxlXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb21wb3NpdGlvblN0eWxlIGV4dGVuZHMgU3R5bGUge1xyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGljdGlvbmFyeSAoc3RyaW5nIC0+IGNvbG9yKSB3aGljaCBnaXZlIHRoZSBjb2xvciBvZiBlYWNoIGNhdGVnb3J5LlxyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9ICovXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3JcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHR5cGUgb2YgZGVjb21wb3NpdGlvbiBzeW1ib2wgb2YgYSBjZWxsLCBAc2VlIENvbXBvc2l0aW9uVHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbCxudW1iZXIsIG51bWJlcixvYmplY3QpOkNvbXBvc2l0aW9uVHlwZX0gKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBvcHRzLnR5cGUgfHwgKCgpID0+ICdmbGFnJykgLy8oYyxyLHosdnMpID0+IHt9XHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgc2l6ZSBvZiBhIGNlbGwgaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZSB8fCAoKGMsIHIpID0+IHIpIC8vKGMscix6LHZzKSA9PiB7fVxyXG5cclxuICAgICAgICAvKiogRm9yIHN0eWxlIHR5cGVzIHdpdGggc3RyaXBlcyAoZmxhZywgc2VnbWVudCksIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgc3RyaXBlcyAoMCBmb3IgaG9yaXpvbnRhbCwgb3RoZXIgZm9yIHZlcnRpY2FsKS5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0LmpzXCIpLkNlbGwsbnVtYmVyLG51bWJlcixvYmplY3QpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnN0cmlwZXNPcmllbnRhdGlvbiA9IG9wdHMuc3RyaXBlc09yaWVudGF0aW9uIHx8ICgoKSA9PiAwKSAvLyhjLHIseix2cykgPT4gLi4uXHJcblxyXG4gICAgICAgIC8qKiBUaGUgZnVuY3Rpb24gc3BlY2lmeWluZyBhbiBvZmZzZXQgYW5nbGUgZm9yIGEgcmFkYXIsIGhhbGZ0b25lIG9yIHBpZSBjaGFydCBzdHlsZS5cclxuICAgICAgICAgKiBUaGUgYW5nbGUgaXMgc3BlY2lmaWVkIGluIGRlZ3JlZS4gVGhlIHJvdGF0aW9uIGlzIGFudGktY2xvY2t3aXNlLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbCxudW1iZXIsbnVtYmVyLG9iamVjdCk6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMub2Zmc2V0QW5nbGUgPSBvcHRzLm9mZnNldEFuZ2xlIHx8ICgoKSA9PiAwKSAvLyhjLHIseix2cykgPT4gLi4uXHJcblxyXG4gICAgICAgIC8qKiBUaGUgZnVuY3Rpb24gc3BlY2lmeWluZyB0aGUgaGVpZ2h0IG9mIHRoZSBhZ2UgcHlyYW1pZCwgaW4gZ2VvIHVuaXQuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlcixudW1iZXIsb2JqZWN0KTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5hZ2VQeXJhbWlkSGVpZ2h0ID0gb3B0cy5hZ2VQeXJhbWlkSGVpZ2h0IHx8ICgoYywgcikgPT4gcikgLy8oYyxyLHosdnMpID0+IC4uLlxyXG5cclxuICAgICAgICAvKiogRm9yIHBpZSBjaGFydCwgdGhpcyBpcyBwYXJhbWV0ZXIgZm9yIGludGVybmFsIHJhZGl1cywgc28gdGhhdCB0aGUgcGllIGNoYXJ0IGxvb2tzIGxpa2UgYSBkb251dC5cclxuICAgICAgICAgKiAwIGZvciBub3JtYWwgcGllIGNoYXJ0cywgMC41IHRvIGVtcHR5IGhhbGYgb2YgdGhlIHJhZGl1cy5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMucGllQ2hhcnRJbnRlcm5hbFJhZGl1c0ZhY3RvciA9IG9wdHMucGllQ2hhcnRJbnRlcm5hbFJhZGl1c0ZhY3RvciB8fCAwXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGNlbGxzIGFzIHNxdWFyZXMgZGVwZW5kaW5nIG9uIHRoZWlyIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsPn0gY2VsbHNcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuR2VvQ2FudmFzfSBnZW9DYW52YXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uXHJcbiAgICAgKi9cclxuICAgIGRyYXcoY2VsbHMsIGdlb0NhbnZhcywgcmVzb2x1dGlvbikge1xyXG4gICAgICAgIC8vZmlsdGVyXHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcuelxyXG4gICAgICAgIGNvbnN0IGN0eCA9IGdlb0NhbnZhcy5vZmZzY3JlZW5DdHhcclxuXHJcbiAgICAgICAgLy9nZXQgdmlldyBzY2FsZVxyXG4gICAgICAgIGNvbnN0IHZpZXdTY2FsZSA9IHRoaXMudmlld1NjYWxlID8gdGhpcy52aWV3U2NhbGUoY2VsbHMsIHJlc29sdXRpb24sIHopIDogdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8vbmIgY2F0ZWdvcmllcyAtIHVzZWQgZm9yIHJhZGFyIGFuZCBhZ2VweXJhbWlkXHJcbiAgICAgICAgY29uc3QgbmJDYXQgPSBPYmplY3QuZW50cmllcyh0aGlzLmNvbG9yKS5sZW5ndGhcclxuXHJcbiAgICAgICAgLy9kcmF3IGNhbGxzXHJcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICAvL3NpemVcclxuICAgICAgICAgICAgY29uc3Qgc0cgPSB0aGlzLnNpemUgPyB0aGlzLnNpemUoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHJlc29sdXRpb25cclxuICAgICAgICAgICAgaWYgKCFzRykgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjZWxsLCByZXNvbHV0aW9uLCB6KVxyXG5cclxuICAgICAgICAgICAgLy9nZXQgc3ltYm9sIHR5cGVcclxuICAgICAgICAgICAgY29uc3QgdHlwZV8gPSB0aGlzLnR5cGUgPyB0aGlzLnR5cGUoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6ICdmbGFnJ1xyXG5cclxuICAgICAgICAgICAgLy9jb21wdXRlIGNlbnRlciBwb3NpdGlvblxyXG4gICAgICAgICAgICBjb25zdCB4YyA9IGNlbGwueCArIG9mZnNldC5keCArICh0eXBlXyA9PT0gJ2FnZXB5cmFtaWQnID8gMCA6IHJlc29sdXRpb24gKiAwLjUpXHJcbiAgICAgICAgICAgIGNvbnN0IHljID0gY2VsbC55ICsgb2Zmc2V0LmR5ICsgKHR5cGVfID09PSAnYWdlcHlyYW1pZCcgPyAwIDogcmVzb2x1dGlvbiAqIDAuNSlcclxuXHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSBvZmZzZXQgYW5nbGUsIHdoZW4gcmVsZXZhbnRcclxuICAgICAgICAgICAgY29uc3Qgb2ZmQW5nID0gdGhpcy5vZmZzZXRBbmdsZVxyXG4gICAgICAgICAgICAgICAgPyAodGhpcy5vZmZzZXRBbmdsZShjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpICogTWF0aC5QSSkgLyAxODBcclxuICAgICAgICAgICAgICAgIDogMFxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVfID09PSAnYWdlcHlyYW1pZCcgfHwgdHlwZV8gPT09ICdyYWRhcicgfHwgdHlwZV8gPT09ICdoYWxmdG9uZScpIHtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IGNlbGwgY2F0ZWdvcnkgbWF4IHZhbHVlXHJcbiAgICAgICAgICAgICAgICBsZXQgbWF4VmFsID0gLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5jb2xvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gK2NlbGxba2V5XVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ID4gbWF4VmFsKSBtYXhWYWwgPSB2XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jdW11bFxyXG4gICAgICAgICAgICAgICAgbGV0IGN1bXVsID0gMFxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVfID09PSAnYWdlcHlyYW1pZCcgJiYgdGhpcy5hZ2VQeXJhbWlkSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgIGN1bXVsID0gKHJlc29sdXRpb24gLSB0aGlzLmFnZVB5cmFtaWRIZWlnaHQoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSkgLyAyXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZV8gPT09ICdyYWRhcicgfHwgdHlwZV8gPT09ICdoYWxmdG9uZScpIGN1bXVsID0gTWF0aC5QSSAvIDIgKyBvZmZBbmdcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbXB1dGUgdGhlIGluY3JlbWVudCwgd2hpY2ggaXMgdGhlIHZhbHVlIHRvIGluY3JlbWVudCB0aGUgY3VtdWwgZm9yIGVhY2ggY2F0ZWdvcnlcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluY3IgPVxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVfID09PSAnYWdlcHlyYW1pZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAodGhpcy5hZ2VQeXJhbWlkSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5hZ2VQeXJhbWlkSGVpZ2h0KGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXNvbHV0aW9uKSAvIG5iQ2F0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZV8gPT09ICdyYWRhcicgfHwgdHlwZV8gPT09ICdoYWxmdG9uZSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoMiAqIE1hdGguUEkpIC8gbmJDYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIGlmIChpbmNyID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzeW1ib2wgdHlwZTonICsgdHlwZV8pXHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2NvbHVtbiwgY29sb3JdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuY29sb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVfID09PSAnYWdlcHlyYW1pZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZXQgY2F0ZWdvcnkgY29sb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dldCBjYXRlZ29yeSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBjZWxsW2NvbHVtbl1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBjYXRlZ29yeSBsZW5ndGggLSBpbiBnZW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdHID0gKHNHICogdmFsKSAvIG1heFZhbFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kcmF3IGJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoeGMgKyAocmVzb2x1dGlvbiAtIHdHKSAvIDIsIHljICsgY3VtdWwsIHdHLCBpbmNyKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9uZXh0IGhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdW11bCArPSBpbmNyXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlXyA9PT0gJ3JhZGFyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NldCBjYXRlZ29yeSBjb2xvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3JcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IGNhdGVncm95IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNlbGxbY29sdW1uXVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21wdXRlIGNhdGVnb3J5IHJhZGl1cyAtIGluIGdlb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zdCByRyA9IHRoaXMucmFkaXVzKHZhbCwgciwgc3RhdCwgY2VsbFN0YXQsIHopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJHID0gKHNHIC8gMikgKiBNYXRoLnNxcnQodmFsIC8gbWF4VmFsKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kcmF3IGFuZ3VsYXIgc2VjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHhjLCB5YylcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyh4YywgeWMsIHJHLCBjdW11bCAtIGluY3IsIGN1bXVsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHhjLCB5YylcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9uZXh0IGFuZ3VsYXIgc2VjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1bXVsICs9IGluY3JcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVfID09PSAnaGFsZnRvbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IGNhdGVnb3J5IGNvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvclxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgY2F0ZWdyb3kgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gY2VsbFtjb2x1bW5dXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgY2F0ZWdvcnkgcmFkaXVzIC0gaW4gZ2VvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByRyA9IHNHICogMC4zMzMgKiBNYXRoLnNxcnQodmFsIC8gbWF4VmFsKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kcmF3IGNpcmNsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhjICsgcmVzb2x1dGlvbiAqIDAuMjUgKiBNYXRoLmNvcyhjdW11bCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5YyArIHJlc29sdXRpb24gKiAwLjI1ICogTWF0aC5zaW4oY3VtdWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgckcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAqIE1hdGguUElcclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25leHQgYW5ndWxhciBzZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VtdWwgKz0gaW5jclxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzeW1ib2wgdHlwZTonICsgdHlwZV8pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9jb21wdXRlIHRvdGFsXHJcbiAgICAgICAgICAgICAgICBsZXQgdG90YWwgPSAwXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gb2YgT2JqZWN0LmtleXModGhpcy5jb2xvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gK2NlbGxbY29sdW1uXVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdikgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSB2XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRvdGFsIHx8IGlzTmFOKHRvdGFsKSkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgZGVjb21wb3NpdGlvbiBzeW1ib2xcclxuICAgICAgICAgICAgICAgIGxldCBjdW11bCA9IDBcclxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSByZXNvbHV0aW9uICogKDEgLSBzRyAvIHJlc29sdXRpb24pICogMC41XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmkgPSB0aGlzLnN0cmlwZXNPcmllbnRhdGlvbihjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpXHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2NvbHVtbiwgY29sb3JdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuY29sb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgc2hhcmVcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFyZSA9IGNlbGxbY29sdW1uXSAvIHRvdGFsXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaGFyZSB8fCBpc05hTihzaGFyZSkpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2V0IGNvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZHJhdyBzeW1ib2wgcGFydFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlXyA9PT0gJ2ZsYWcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhdyBmbGFnIHN0cmlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwueCArIGQgKyBvZmZzZXQuZHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC55ICsgZCArIGN1bXVsICogc0cgKyBvZmZzZXQuZHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc0csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmUgKiBzR1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwueCArIGQgKyBjdW11bCAqIHNHICsgb2Zmc2V0LmR4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwueSArIGQgKyBvZmZzZXQuZHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmUgKiBzRyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzR1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlXyA9PT0gJ3BpZWNoYXJ0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RyYXcgcGllIGNoYXJ0IGFuZ3VsYXIgc2VjdG9yXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgYW5nbGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGExID0gY3VtdWwgKiAyICogTWF0aC5QSVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhMiA9IChjdW11bCArIHNoYXJlKSAqIDIgKiBNYXRoLlBJXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RyYXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeGMsIHljKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKHhjLCB5Yywgc0cgKiAwLjUsIGExICsgb2ZmQW5nLCBhMiArIG9mZkFuZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGllQ2hhcnRJbnRlcm5hbFJhZGl1c0ZhY3RvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc0cgKiAwLjUgKiB0aGlzLnBpZUNoYXJ0SW50ZXJuYWxSYWRpdXNGYWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYTEgKyBvZmZBbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYTIgKyBvZmZBbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZV8gPT09ICdyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RyYXcgcmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyh4YywgeWMsIE1hdGguc3FydCgxIC0gY3VtdWwpICogc0cgKiAwLjUsIDAsIDIgKiBNYXRoLlBJKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlXyA9PT0gJ3NlZ21lbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhdyBzZWdtZW50IHNlY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdHID0gKHNHICogc0cpIC8gcmVzb2x1dGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwueCArIG9mZnNldC5keCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnkgKyAocmVzb2x1dGlvbiAtIHdHKSAvIDIgKyBjdW11bCAqIHdHICsgb2Zmc2V0LmR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmUgKiB3R1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwueCArIGN1bXVsICogcmVzb2x1dGlvbiArIG9mZnNldC5keCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnkgKyAocmVzb2x1dGlvbiAtIHdHKSAvIDIgKyBvZmZzZXQuZHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmUgKiByZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdHXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc3ltYm9sIHR5cGU6JyArIHR5cGVfKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY3VtdWwgKz0gc2hhcmVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByZXNvbHV0aW9uOiByZXNvbHV0aW9uLCB6OiB6LCB2aWV3U2NhbGU6IHZpZXdTY2FsZSB9KVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9jb3JlL1N0eWxlLmpzJ1xyXG5pbXBvcnQgeyByYW5kb21Ob3JtYWwgfSBmcm9tICdkMy1yYW5kb20nXHJcbmltcG9ydCB7IGNoZWNrV2ViR0xTdXBwb3J0LCBtYWtlV2ViR0xDYW52YXMgfSBmcm9tICcuLi91dGlscy93ZWJHTFV0aWxzLmpzJ1xyXG5pbXBvcnQgeyBXZWJHTFNxdWFyZUNvbG9yaW5nIH0gZnJvbSAnLi4vdXRpbHMvV2ViR0xTcXVhcmVDb2xvcmluZy5qcydcclxuaW1wb3J0IHsgY29sb3IgfSBmcm9tICdkMy1jb2xvcidcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAbW9kdWxlIHN0eWxlXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBEb3REZW5zaXR5U3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIGRvdHMgZm9yIGEgY2VsbCB2YWx1ZS5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLCBudW1iZXIsIG51bWJlciwgb2JqZWN0KTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5kb3ROdW1iZXIgPSBvcHRzLmRvdE51bWJlciB8fCAoKGNlbGwsIHJlc29sdXRpb24pID0+IHJlc29sdXRpb24gLyAxMDApIC8vKGMscix6LHZzKSA9PiB7fVxyXG5cclxuICAgICAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBkb3RzLiBTYW1lIGNvbG9yIGZvciBhbGwgZG90cyB3aXRoaW4gYSBjZWxsLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKCkgPT4gJyNGRjU3MzMnKSAvLyhjLHIseix2cykgPT4ge31cclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaXplIG9mIHRoZSBkb3RzLCBpbiBnZW8gdW5pdC4gU2FtZSBzaXplIGZvciBhbGwgY2VsbHMuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyLG9iamVjdCk6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuZG90U2l6ZSA9IG9wdHMuZG90U2l6ZSB8fCAoKHJlc29sdXRpb24sIHopID0+IDEuNSAqIHopIC8vKGMscix6LHZzKSA9PiB7fVxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpZ21hIG9mIHRoZSBkb3RzIGRpc3RyaWJ1dGlvbi4gU2FtZSB2YWx1ZSBmb3IgYWxsIGNlbGxzLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsIG51bWJlcixvYmplY3QpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnNpZ21hID0gb3B0cy5zaWdtYSB8fCAoKHJlc29sdXRpb24sIHopID0+IHJlc29sdXRpb24gLyAyKSAvLyhjLHIseix2cykgPT4ge31cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgY2VsbHMgYXMgdGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvblxyXG4gICAgICovXHJcbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcclxuXHJcbiAgICAgICAgLy9nZXQgdmlldyBzY2FsZVxyXG4gICAgICAgIGNvbnN0IHZpZXdTY2FsZSA9IHRoaXMudmlld1NjYWxlID8gdGhpcy52aWV3U2NhbGUoY2VsbHMsIHJlc29sdXRpb24sIHopIDogdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8vZ2V0IHNpemVcclxuICAgICAgICBjb25zdCBzR2VvID0gdGhpcy5kb3RTaXplID8gdGhpcy5kb3RTaXplKHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB6XHJcblxyXG4gICAgICAgIC8vbWFrZSByYW5kb20gZnVuY3Rpb25cclxuICAgICAgICBjb25zdCBzaWcgPSB0aGlzLnNpZ21hID8gdGhpcy5zaWdtYShyZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogcmVzb2x1dGlvbiAqIDAuNFxyXG4gICAgICAgIGNvbnN0IHJhbmQgPSByYW5kb21Ob3JtYWwoMCwgc2lnKVxyXG5cclxuICAgICAgICBjb25zdCBjdHggPSBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4XHJcblxyXG4gICAgICAgIGlmIChjaGVja1dlYkdMU3VwcG9ydCgpKSB7XHJcbiAgICAgICAgICAgIC8vY3JlYXRlIGNhbnZhcyBhbmQgd2ViZ2wgcmVuZGVyZXJcclxuICAgICAgICAgICAgY29uc3QgY3ZXR0wgPSBtYWtlV2ViR0xDYW52YXMoZ2VvQ2FudmFzLncgKyAnJywgZ2VvQ2FudmFzLmggKyAnJylcclxuICAgICAgICAgICAgaWYgKCFjdldHTCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gd2ViR0wnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vY3JlYXRlIHdlYkdMIHByb2dyYW1cclxuICAgICAgICAgICAgY29uc3QgcHJvZyA9IG5ldyBXZWJHTFNxdWFyZUNvbG9yaW5nKGN2V0dMLmdsLCBzR2VvIC8geilcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHIyID0gcmVzb2x1dGlvbiAvIDJcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGNlbGwgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IGNvbG9yXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yKGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSlcclxuICAgICAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PT0gJ25vbmUnKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vbnVtYmVyIG9mIGRvdHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvdE51bWJlciA9IHRoaXMuZG90TnVtYmVyKGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSlcclxuXHJcbiAgICAgICAgICAgICAgICAvL2dldCBvZmZzZXRcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGNlbGwsIHJlc29sdXRpb24sIHopXHJcblxyXG4gICAgICAgICAgICAgICAgLy9jZWxsIGNlbnRlclxyXG4gICAgICAgICAgICAgICAgY29uc3QgY3ggPSBjZWxsLnggKyBvZmZzZXQuZHggKyByMlxyXG4gICAgICAgICAgICAgICAgY29uc3QgY3kgPSBjZWxsLnkgKyBvZmZzZXQuZHkgKyByMlxyXG5cclxuICAgICAgICAgICAgICAgIC8vY29udmVydCBjb2xvclxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2MgPSBjb2xvcihjb2wpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNjKSByZXR1cm5cclxuXHJcbiAgICAgICAgICAgICAgICAvL3JhbmRvbSBwb2ludHNcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRvdE51bWJlcjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHByb2cuYWRkUG9pbnREYXRhMihjeCArIHJhbmQoKSwgY3kgKyByYW5kKCksIGNjLnIsIGNjLmcsIGNjLmIsIGNjLm9wYWNpdHkpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZHJhd1xyXG4gICAgICAgICAgICBwcm9nLmRyYXcoZ2VvQ2FudmFzLmdldFdlYkdMVHJhbnNmb3JtKCkpXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgaW4gY2FudmFzIGdlb1xyXG4gICAgICAgICAgICBnZW9DYW52YXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXHJcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoY3ZXR0wuY2FudmFzLCAwLCAwKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGNlbGwgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IGNvbG9yXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yKGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSlcclxuICAgICAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PT0gJ25vbmUnKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgLy9zZXQgY29sb3JcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xcclxuXHJcbiAgICAgICAgICAgICAgICAvL251bWJlciBvZiBkb3RzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb3ROdW1iZXIgPSB0aGlzLmRvdE51bWJlcihjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9nZXQgb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjZWxsLCByZXNvbHV0aW9uLCB6KVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZHJhdyByYW5kb20gZG90c1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3ggPSBjZWxsLnggKyBvZmZzZXQuZHggKyByZXNvbHV0aW9uIC8gMixcclxuICAgICAgICAgICAgICAgICAgICBjeSA9IGNlbGwueSArIG9mZnNldC5keSArIHJlc29sdXRpb24gLyAyXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBkb3ROdW1iZXI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChjeCArIHJhbmQoKSwgY3kgKyByYW5kKCksIHNHZW8sIHNHZW8pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiwgdmlld1NjYWxlOiB2aWV3U2NhbGUgfSlcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vY29yZS9TdHlsZS5qcydcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHN0eWxlXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbWFnZVN0eWxlIGV4dGVuZHMgU3R5bGUge1xyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGltYWdlIFVSTCBvZiBhIGNlbGwuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBvcHRzLmltYWdlIHx8ICgoKSA9PiAnJykgLy8oYyxyLHosdnMpID0+IHt9XHJcblxyXG4gICAgICAgIC8qKiBUaGUgaW1hZ2Ugc2l6ZSBpbiBncm91bmQgbWV0ZXJzXHJcbiAgICAgICAgICogIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOm51bWJlcn0gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaXplID0gb3B0cy5zaXplIHx8ICgoY2VsbCwgcmVzb2x1dGlvbikgPT4gcmVzb2x1dGlvbilcclxuXHJcbiAgICAgICAgLyoqIERpY3Rpb25uYXJ5IG9mIHByZWxvYWRlZCBpbWFnZXMuIHVybCAtPiBpbWFnZVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge29iamVjdH0gKi9cclxuICAgICAgICB0aGlzLmNhY2hlID0ge31cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsPn0gY2VsbHNcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuR2VvQ2FudmFzfSBnZW9DYW52YXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcueixcclxuICAgICAgICAgICAgcmVzb2x1dGlvblBpeCA9IHJlc29sdXRpb24gLyB6XHJcblxyXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcclxuICAgICAgICBjb25zdCB2aWV3U2NhbGUgPSB0aGlzLnZpZXdTY2FsZSA/IHRoaXMudmlld1NjYWxlKGNlbGxzLCByZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAvL2RyYXcgaW4gc2NyZWVuIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgZ2VvQ2FudmFzLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgLy9nZXQgY2VsbCBpbWFnZSB1cmxcclxuICAgICAgICAgICAgY29uc3QgdXJsID0gdGhpcy5pbWFnZShjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpXHJcbiAgICAgICAgICAgIGlmICghdXJsKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9zaXplIGFuZCBwb3NpdGlvbiB2YWx1ZXNcclxuICAgICAgICAgICAgbGV0IHNpemVQaXggPSB0aGlzLnNpemUoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSAvIHpcclxuICAgICAgICAgICAgaWYgKCFzaXplUGl4KSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9nZXQgaW1hZ2UgZnJvbSBjYWNoZVxyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuY2FjaGVbdXJsXVxyXG5cclxuICAgICAgICAgICAgLy9sb2FkaW5nLCBrZWVwIHdhaXRpbmdcclxuICAgICAgICAgICAgaWYgKGltYWdlID09ICdsb2FkaW5nJykgcmV0dXJuXHJcbiAgICAgICAgICAgIC8vbm8gaW1hZ2U6IGxvYWQgaXRcclxuICAgICAgICAgICAgZWxzZSBpZiAoIWltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAvL3RhZyBhcyBsb2FkaW5nXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlW3VybF0gPSAnbG9hZGluZydcclxuXHJcbiAgICAgICAgICAgICAgICAvL2RlZmluZSBpbWFnZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKClcclxuICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zdG9yZSBpbWFnZSBkYXRhIGluIGNhY2hlIGFuZCByZWRyYXdcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlW3VybF0gPSBpbWdcclxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMucmVkcmF3KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGltZy5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY2FzZSB3aGVuIG5vIGltYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgcmV0cmlldmUgaW1hZ2UgZnJvbScsIHVybClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vc2V0IFVSTCB0byBsYXVuY2ggdGhlIGRvd25sb2FkXHJcbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gdXJsXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgaW1hZ2VcclxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSAocmVzb2x1dGlvblBpeCAtIHNpemVQaXgpIC8gMlxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5nZW9Ub1BpeFgoY2VsbC54KSArIGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb0NhbnZhcy5nZW9Ub1BpeFkoY2VsbC55KSArIGQgLSByZXNvbHV0aW9uUGl4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplUGl4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplUGl4XHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXHJcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHJlc29sdXRpb246IHJlc29sdXRpb24sIHo6IHosIHZpZXdTY2FsZTogdmlld1NjYWxlIH0pXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL2NvcmUvU3R5bGUuanMnXHJcbmltcG9ydCB7IFNpZGVTdHlsZSB9IGZyb20gJy4vU2lkZVN0eWxlLmpzJ1xyXG5cclxuLyoqIEB0eXBlZGVmIHt7eDpudW1iZXIseTpudW1iZXIsb3I6XCJ2XCJ8XCJoXCIsYzE6aW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsfHVuZGVmaW5lZCxjMjppbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGx8dW5kZWZpbmVkfX0gU2lkZSAqL1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgc3R5bGVcclxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIElzb0ZlbmNlU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkaWN0aW9uYXJ5IChzdHJpbmcgLT4gY29sb3IpIHdoaWNoIGdpdmUgdGhlIGNvbG9yIG9mIGVhY2ggY2F0ZWdvcnkuXHJcbiAgICAgICAgICogQHR5cGUge29iamVjdH0gKi9cclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvclxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGhlaWdodCBvZiBhIGNlbGwgaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0cy5oZWlnaHQgfHwgKChjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpID0+IHJlc29sdXRpb24gKiAwLjQpXHJcblxyXG4gICAgICAgIC8qKiBUaGUgcGVyc3BlY3RpdmUgYW5nbGUsIGluIGRlZ3JlZSwgd2l0aGluIFstMTgwLDE4MF0sIGZyb20gW08seF0gYXhpcy5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuYW5nbGUgPSBvcHRzLmFuZ2xlICE9IHVuZGVmaW5lZCA/IG9wdHMuYW5nbGUgOiA1MFxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvcm5lciBsaW5lIHN0cm9rZSBzdHlsZS5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLG51bWJlcixudW1iZXIsbnVtYmVyKTpzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5jb3JuZXJMaW5lU3Ryb2tlQ29sb3IgPSBvcHRzLmNvcm5lckxpbmVTdHJva2VDb2xvciB8fCAoKGMsIHIsIHosIGFuZ2xlKSA9PiAnIzk5OScpXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29ybmVyIGxpbmUgd2lkdGguXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCxudW1iZXIsbnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuY29ybmVyTGluZVdpZHRoID0gb3B0cy5jb3JuZXJMaW5lV2lkdGggfHwgKChjLCByLCB6LCBhbmdsZSkgPT4gKGFuZ2xlICUgOTAgPT0gMCA/IDAgOiAwLjggKiB6KSlcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2hvdyB2ZXJ0aWNhbCBjcm9zcy1zZWN0aW9ucy5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gKi9cclxuICAgICAgICB0aGlzLnNWZXJ0ID0gb3B0cy5zVmVydCAhPSB1bmRlZmluZWQgPyBvcHRzLnNWZXJ0IDogdHJ1ZVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaG93IGhvcml6b250YWwgY3Jvc3Mtc2VjdGlvbnMuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59ICovXHJcbiAgICAgICAgdGhpcy5zSG9yID0gb3B0cy5zSG9yICE9IHVuZGVmaW5lZCA/IG9wdHMuc0hvciA6IHRydWVcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsPn0gY2VsbHNcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuR2VvQ2FudmFzfSBnZW9DYW52YXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgLy9maWx0ZXJcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGNvbnN0IHogPSBnZW9DYW52YXMudmlldy56XHJcbiAgICAgICAgY29uc3QgY3R4ID0gZ2VvQ2FudmFzLm9mZnNjcmVlbkN0eFxyXG5cclxuICAgICAgICAvL2dldCB2aWV3IHNjYWxlXHJcbiAgICAgICAgY29uc3Qgdmlld1NjYWxlID0gdGhpcy52aWV3U2NhbGUgPyB0aGlzLnZpZXdTY2FsZShjZWxscywgcmVzb2x1dGlvbiwgeikgOiB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgLy9uYiBjYXRlZ29yaWVzIC0gdXNlZCBmb3IgcmFkYXIgYW5kIGFnZXB5cmFtaWRcclxuICAgICAgICBjb25zdCBjYXRzID0gT2JqZWN0LmtleXModGhpcy5jb2xvcilcclxuXHJcbiAgICAgICAgLy9oYWxmIHJlc29sdXRpb25cclxuICAgICAgICBjb25zdCByMiA9IHJlc29sdXRpb24gLyAyXHJcblxyXG4gICAgICAgIC8vZ2V0IG9mZnNldFxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldCh1bmRlZmluZWQsIHJlc29sdXRpb24sIHopLFxyXG4gICAgICAgICAgICBkeCA9IG9mZnNldC5keCxcclxuICAgICAgICAgICAgZHkgPSBvZmZzZXQuZHlcclxuXHJcbiAgICAgICAgLy9tYWtlIHNpZGVzXHJcbiAgICAgICAgLyoqICBAdHlwZSB7QXJyYXkuPFNpZGU+fSAqL1xyXG4gICAgICAgIGNvbnN0IHNpZGVzID0gU2lkZVN0eWxlLmJ1aWxkU2lkZXMoXHJcbiAgICAgICAgICAgIGNlbGxzLFxyXG4gICAgICAgICAgICByZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICB0aGlzLmFuZ2xlICUgMTgwICE9IDkwICYmIHRoaXMuc1ZlcnQsXHJcbiAgICAgICAgICAgIHRoaXMuYW5nbGUgJSAxODAgIT0gMCAmJiB0aGlzLnNIb3JcclxuICAgICAgICApXHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgaWYgKHNpZGVzLmxlbmd0aCA9PSAwKSByZXR1cm5cclxuXHJcbiAgICAgICAgLy9hbmdsZSBpbiByYWRpYW5zXHJcbiAgICAgICAgY29uc3QgYVJhZCA9ICh0aGlzLmFuZ2xlICogTWF0aC5QSSkgLyAxODAsXHJcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFSYWQpLFxyXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihhUmFkKVxyXG5cclxuICAgICAgICAvL3NvcnQgc2lkZXMgc28gdGhhdCB0aGUgYmFjayBvbmVzIGFyZSBkcmF3biBmaXJzdC4gVGhpcyBkZXBlbmRzIG9uIHRoZSBhbmdsZS5cclxuICAgICAgICAvL2RlcGVuZGluZyBvbiBkaXN0YW5jZSB0byB0aGUgcmVmZXJlbmNlIGNvcm5lciBwb2ludFxyXG4gICAgICAgIGNvbnN0IHhDb3JuZXIgPSBNYXRoLmFicyh0aGlzLmFuZ2xlKSA8IDkwID8gZ2VvQ2FudmFzLmV4dEdlby54TWluIDogZ2VvQ2FudmFzLmV4dEdlby54TWF4XHJcbiAgICAgICAgY29uc3QgeUNvcm5lciA9IHRoaXMuYW5nbGUgPCAwID8gZ2VvQ2FudmFzLmV4dEdlby55TWF4IDogZ2VvQ2FudmFzLmV4dEdlby55TWluXHJcbiAgICAgICAgc2lkZXMuc29ydChcclxuICAgICAgICAgICAgKHMxLCBzMikgPT5cclxuICAgICAgICAgICAgICAgIE1hdGguaHlwb3QoczIueCAtIHhDb3JuZXIsIHMyLnkgLSB5Q29ybmVyKSAtIE1hdGguaHlwb3QoczEueCAtIHhDb3JuZXIsIHMxLnkgLSB5Q29ybmVyKVxyXG4gICAgICAgIClcclxuXHJcbiAgICAgICAgLy9wcmVwYXJlIGZ1bmN0aW9uIHRvIGRyYXcgY29ybmVyIGxpbmUgZm9yIGEgY2VsbCAqYypcclxuICAgICAgICBjb25zdCBkcmF3Q29ybmVyTGluZSA9IChjZWxsKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghY2VsbCkgcmV0dXJuXHJcbiAgICAgICAgICAgIC8vbGluZSBzdHlsZVxyXG4gICAgICAgICAgICBjb25zdCBsdyA9IHRoaXMuY29ybmVyTGluZVdpZHRoID8gdGhpcy5jb3JuZXJMaW5lV2lkdGgoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdGhpcy5hbmdsZSkgOiAwLjggKiB6XHJcbiAgICAgICAgICAgIGlmIChsdyA9PSAwKSByZXR1cm5cclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb3JuZXJMaW5lU3Ryb2tlQ29sb3JcclxuICAgICAgICAgICAgICAgID8gdGhpcy5jb3JuZXJMaW5lU3Ryb2tlQ29sb3IoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdGhpcy5hbmdsZSlcclxuICAgICAgICAgICAgICAgIDogJyMzMzMnXHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsd1xyXG5cclxuICAgICAgICAgICAgLy9oZWlnaHQgLSBpbiBnZW9cclxuICAgICAgICAgICAgY29uc3QgaEcgPSB0aGlzLmhlaWdodChjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgbGluZVxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhjZWxsLnggKyByMiArIGR4LCBjZWxsLnkgKyByMiArIGR5KVxyXG4gICAgICAgICAgICBjdHgubGluZVRvKGNlbGwueCArIHIyICsgaEcgKiBjb3MgKyBkeCwgY2VsbC55ICsgcjIgKyBoRyAqIHNpbiArIGR5KVxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBzaWRlc1xyXG4gICAgICAgIGN0eC5saW5lQ2FwID0gJ3JvdW5kJ1xyXG4gICAgICAgIGZvciAobGV0IHNpZGUgb2Ygc2lkZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgYzEgPSBzaWRlLmMxLFxyXG4gICAgICAgICAgICAgICAgYzIgPSBzaWRlLmMyLFxyXG4gICAgICAgICAgICAgICAgeCA9IHNpZGUueCxcclxuICAgICAgICAgICAgICAgIHkgPSBzaWRlLnlcclxuXHJcbiAgICAgICAgICAgIC8vaGVpZ2h0cyAtIGluIGdlb1xyXG4gICAgICAgICAgICBjb25zdCBoRzEgPSBjMSA/IHRoaXMuaGVpZ2h0KGMxLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogMCxcclxuICAgICAgICAgICAgICAgIGhHMiA9IGMyID8gdGhpcy5oZWlnaHQoYzIsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiAwXHJcblxyXG4gICAgICAgICAgICAvL2NvbXB1dGUgdG90YWxzIGZvciBib3RoIGNlbGxzXHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsMSA9IGNvbXB1dGVUb3RhbChjMSwgY2F0cyksXHJcbiAgICAgICAgICAgICAgICB0b3RhbDIgPSBjb21wdXRlVG90YWwoYzIsIGNhdHMpXHJcbiAgICAgICAgICAgIGlmICh0b3RhbDEgPT0gMCAmJiB0b3RhbDIgPT0gMCkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIGxldCBjdW11bDEgPSAwLFxyXG4gICAgICAgICAgICAgICAgY3VtdWwyID0gMFxyXG4gICAgICAgICAgICBmb3IgKGxldCBbY29sdW1uLCBjb2xvcl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5jb2xvcikpIHtcclxuICAgICAgICAgICAgICAgIC8vZHJhdyBzdHJpcGUgb2Ygc2lkZSBzIGFuZCBjYXRlZ29yeSBjb2x1bW5cclxuXHJcbiAgICAgICAgICAgICAgICAvL2dldCB2YWx1ZXMgZm9yIGJvdGggY2VsbHNcclxuICAgICAgICAgICAgICAgIGxldCB2MSA9IGMxID8gK2MxW2NvbHVtbl0gOiAwXHJcbiAgICAgICAgICAgICAgICBsZXQgdjIgPSBjMiA/ICtjMltjb2x1bW5dIDogMFxyXG4gICAgICAgICAgICAgICAgaWYgKHYxID09IDAgJiYgdjIgPT0gMCkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbXB1dGUgaGVpZ2h0c1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaDEgPSAoaEcxICogY3VtdWwxKSAvIHRvdGFsMSB8fCAwXHJcbiAgICAgICAgICAgICAgICBjb25zdCBoMW4gPSAoaEcxICogKGN1bXVsMSArIHYxKSkgLyB0b3RhbDEgfHwgMFxyXG4gICAgICAgICAgICAgICAgY29uc3QgaDIgPSAoaEcyICogY3VtdWwyKSAvIHRvdGFsMiB8fCAwXHJcbiAgICAgICAgICAgICAgICBjb25zdCBoMm4gPSAoaEcyICogKGN1bXVsMiArIHYyKSkgLyB0b3RhbDIgfHwgMFxyXG5cclxuICAgICAgICAgICAgICAgIC8vbWFrZSBwYXRoXHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGlmIChzaWRlLm9yID09ICdoJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaG9yaXpvbnRhbCBzaWRlIC0gdmVydGljYWwgc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYm90dG9tIGxlZnRcclxuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyBoMSAqIGNvcyArIGR4LCB5IC0gcjIgKyBoMSAqIHNpbiArIGR5KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vdG9wIGxlZnRcclxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyBoMiAqIGNvcyArIGR4LCB5ICsgcjIgKyBoMiAqIHNpbiArIGR5KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vdG9wIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgaDJuICogY29zICsgZHgsIHkgKyByMiArIGgybiAqIHNpbiArIGR5KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vYm90dG9tIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgaDFuICogY29zICsgZHgsIHkgLSByMiArIGgxbiAqIHNpbiArIGR5KVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3ZlcnRpY2FsIHNpZGUgLSBob3Jpem9udGFsIHNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbSBsZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4IC0gcjIgKyBoMSAqIGNvcyArIGR4LCB5ICsgaDEgKiBzaW4gKyBkeSlcclxuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbSByaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHIyICsgaDIgKiBjb3MgKyBkeCwgeSArIGgyICogc2luICsgZHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLy90b3AgcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyByMiArIGgybiAqIGNvcyArIGR4LCB5ICsgaDJuICogc2luICsgZHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLy90b3AgbGVmdFxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIHIyICsgaDFuICogY29zICsgZHgsIHkgKyBoMW4gKiBzaW4gKyBkeSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vY2cuY3R4LmNsb3NlUGF0aCgpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9maWxsXHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3JcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsKClcclxuXHJcbiAgICAgICAgICAgICAgICBjdW11bDEgKz0gdjFcclxuICAgICAgICAgICAgICAgIGN1bXVsMiArPSB2MlxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBkcmF3IG9ubHkgb25lIGxpbmVcclxuICAgICAgICAgICAgICAgIC8vZHJhdyBjb3JuZXIgbGluZVxyXG4gICAgICAgICAgICAgICAgLy9pZiAoc2lkZS5vciA9PSBcImhcIikge1xyXG4gICAgICAgICAgICAgICAgZHJhd0Nvcm5lckxpbmUoYzEpXHJcbiAgICAgICAgICAgICAgICBkcmF3Q29ybmVyTGluZShjMilcclxuICAgICAgICAgICAgICAgIC8vaWYgKHRoaXMuYW5nbGUgPiAwICYmIHNpZGUub3IgPT0gXCJoXCIpIGRyYXdDb3JuZXJMaW5lKGMyKVxyXG4gICAgICAgICAgICAgICAgLy9lbHNlIGRyYXdDb3JuZXJMaW5lKGMyKVxyXG4gICAgICAgICAgICAgICAgLy99XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiwgdmlld1NjYWxlOiB2aWV3U2NhbGUgfSlcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgY29tcHV0ZVRvdGFsID0gKGNlbGwsIGNhdGVnb3JpZXMpID0+IHtcclxuICAgIGlmICghY2VsbCkgcmV0dXJuIDBcclxuICAgIGxldCB0b3RhbCA9IDBcclxuICAgIGZvciAobGV0IGNvbHVtbiBvZiBjYXRlZ29yaWVzKSB7XHJcbiAgICAgICAgY29uc3QgdiA9IGNlbGxbY29sdW1uXVxyXG4gICAgICAgIGlmICghdikgY29udGludWVcclxuICAgICAgICB0b3RhbCArPSArdlxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvdGFsIHx8IDBcclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vY29yZS9TdHlsZS5qcydcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHN0eWxlXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBKb3lQbG90U3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgaGVpZ2h0IG9mIGEgY2VsbCBpbiBnZW9ncmFwaGljYWwgdW5pdC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLCBudW1iZXIsIG51bWJlciwgb2JqZWN0KTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRzLmhlaWdodCB8fCAoKGMsIHIpID0+IHIgKiBNYXRoLnJhbmRvbSgpKSAvLyhjLHIseix2cykgPT4ge31cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcix7bWluOm51bWJlciwgbWF4Om51bWJlcn0sbnVtYmVyLG51bWJlcik6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMubGluZUNvbG9yID0gb3B0cy5saW5lQ29sb3IgfHwgKCh5LCB5cywgciwgeikgPT4gJyNCQkInKVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIse21pbjpudW1iZXIsIG1heDpudW1iZXJ9LG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IG9wdHMubGluZVdpZHRoIHx8ICgoeSwgeXMsIHIsIHopID0+IHopXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcix7bWluOm51bWJlciwgbWF4Om51bWJlcn0sbnVtYmVyLG51bWJlcik6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gb3B0cy5maWxsQ29sb3IgfHwgKCh5LCB5cywgciwgeikgPT4gJyNjMDhjNTk2OCcpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbD59IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvblxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGRyYXcoY2VsbHMsIGdlb0NhbnZhcywgcmVzb2x1dGlvbikge1xyXG4gICAgICAgIC8vZmlsdGVyXHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcuelxyXG4gICAgICAgIGNvbnN0IGN0eCA9IGdlb0NhbnZhcy5vZmZzY3JlZW5DdHhcclxuXHJcbiAgICAgICAgLy9nZXQgdmlldyBzY2FsZVxyXG4gICAgICAgIGNvbnN0IHZpZXdTY2FsZSA9IHRoaXMudmlld1NjYWxlID8gdGhpcy52aWV3U2NhbGUoY2VsbHMsIHJlc29sdXRpb24sIHopIDogdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8vaW5kZXggY2VsbHMgYnkgeSBhbmQgeFxyXG4gICAgICAgIC8qKiAgQHR5cGUge29iamVjdH0gKi9cclxuICAgICAgICBjb25zdCBpbmQgPSB7fVxyXG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICBsZXQgcm93ID0gaW5kW2NlbGwueV1cclxuICAgICAgICAgICAgaWYgKCFyb3cpIHtcclxuICAgICAgICAgICAgICAgIHJvdyA9IHt9XHJcbiAgICAgICAgICAgICAgICBpbmRbY2VsbC55XSA9IHJvd1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvd1tjZWxsLnhdID0gdGhpcy5oZWlnaHQoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb21wdXRlIGV4dGVudFxyXG4gICAgICAgIGNvbnN0IGUgPSBnZW9DYW52YXMuZXh0R2VvXHJcbiAgICAgICAgaWYgKCFlKSByZXR1cm5cclxuICAgICAgICBjb25zdCB4TWluID0gTWF0aC5mbG9vcihlLnhNaW4gLyByZXNvbHV0aW9uKSAqIHJlc29sdXRpb25cclxuICAgICAgICBjb25zdCB4TWF4ID0gTWF0aC5mbG9vcihlLnhNYXggLyByZXNvbHV0aW9uKSAqIHJlc29sdXRpb25cclxuICAgICAgICBjb25zdCB5TWluID0gTWF0aC5mbG9vcihlLnlNaW4gLyByZXNvbHV0aW9uKSAqIHJlc29sdXRpb25cclxuICAgICAgICBjb25zdCB5TWF4ID0gTWF0aC5mbG9vcihlLnlNYXggLyByZXNvbHV0aW9uKSAqIHJlc29sdXRpb25cclxuXHJcbiAgICAgICAgLyoqICBAdHlwZSB7e21pbjpudW1iZXIsIG1heDpudW1iZXJ9fSAqL1xyXG4gICAgICAgIGNvbnN0IHlzID0geyBtaW46IHlNaW4sIG1heDogeU1heCB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBsaW5lcywgcm93IGJ5IHJvdywgc3RhdGluZyBmcm9tIHRoZSB0b3BcclxuICAgICAgICBjdHgubGluZUpvaW4gPSAncm91bmQnXHJcbiAgICAgICAgZm9yIChsZXQgeSA9IHlNYXg7IHkgPj0geU1pbjsgeSAtPSByZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vZ2V0IHJvd1xyXG4gICAgICAgICAgICBjb25zdCByb3cgPSBpbmRbeV1cclxuXHJcbiAgICAgICAgICAgIC8vbm8gcm93XHJcbiAgICAgICAgICAgIGlmICghcm93KSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9wbGFjZSBmaXJzdCBwb2ludFxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4TWluIC0gcmVzb2x1dGlvbiAvIDIsIHkpXHJcblxyXG4gICAgICAgICAgICAvL3N0b3JlIHRoZSBwcmV2aW91cyBoZWlnaHRcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgICAgICBsZXQgaEdfXHJcblxyXG4gICAgICAgICAgICAvL2dvIHRocm91Z2ggdGhlIGxpbmUgY2VsbHNcclxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IHhNaW47IHggPD0geE1heDsgeCArPSByZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvL2dldCBjb2x1bW4gdmFsdWVcclxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgICAgICAgICAgbGV0IGhHID0gcm93W3hdXHJcbiAgICAgICAgICAgICAgICBpZiAoIWhHKSBoRyA9IDBcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaEcgfHwgaEdfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9kcmF3IGxpbmUgb25seSB3aGVuIGF0IGxlYXN0IG9uZSBvZiBib3RoIHZhbHVlcyBpcyBub24tbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyB0ZXN0IGJlemllckN1cnZlVG9cclxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyByZXNvbHV0aW9uIC8gMiwgeSArIGhHKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2Vsc2UgbW92ZSB0aGUgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyByZXNvbHV0aW9uIC8gMiwgeSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vc3RvcmUgdGhlIHByZXZpb3VzIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBoR18gPSBoR1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2xhc3QgcG9pbnRcclxuICAgICAgICAgICAgaWYgKGhHXykgY3R4LmxpbmVUbyh4TWF4ICsgcmVzb2x1dGlvbiAvIDIsIHkpXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgZmlsbFxyXG4gICAgICAgICAgICBjb25zdCBmYyA9IHRoaXMuZmlsbENvbG9yKHksIHlzLCByZXNvbHV0aW9uLCB6KVxyXG4gICAgICAgICAgICBpZiAoZmMgJiYgZmMgIT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmNcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsKClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IGxpbmVcclxuICAgICAgICAgICAgY29uc3QgbGMgPSB0aGlzLmxpbmVDb2xvcih5LCB5cywgcmVzb2x1dGlvbiwgeilcclxuICAgICAgICAgICAgY29uc3QgbHcgPSB0aGlzLmxpbmVXaWR0aCh5LCB5cywgcmVzb2x1dGlvbiwgeilcclxuICAgICAgICAgICAgaWYgKGxjICYmIGxjICE9ICdub25lJyAmJiBsdyA+IDApIHtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxjXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbHdcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgVGFuYWthU3R5bGUgfSBmcm9tICcuL1RhbmFrYVN0eWxlLmpzJ1xyXG5pbXBvcnQgeyBTdHJva2VTdHlsZSB9IGZyb20gJy4vU3Ryb2tlU3R5bGUuanMnXHJcbmltcG9ydCB7IFNxdWFyZUNvbG9yQ2F0ZWdvcnlXZWJHTFN0eWxlIH0gZnJvbSAnLi9TcXVhcmVDb2xvckNhdGVnb3J5V2ViR0xTdHlsZS5qcydcclxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9jb3JlL1N0eWxlLmpzJ1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgc3R5bGVcclxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExlZ29TdHlsZSB7XHJcbiAgICBzdGF0aWMgZ2V0KHZhbHVlLCBicmVha3MsIGNvbG9ycywgb3B0cyA9IHt9KSB7XHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLy90aGUgY29sb3JzXHJcbiAgICAgICAgLy9odHRwOi8vd3d3Lmplbm55c2NyYXlvbmNvbGxlY3Rpb24uY29tLzIwMjEvMDYvYWxsLWN1cnJlbnQtbGVnby1jb2xvcnMuaHRtbFxyXG4gICAgICAgIC8vaHR0cHM6Ly9sZW9uYXdpY3ouZ2l0aHViLmlvL2xlZ29jb2xvcnMvcmVmZXJlbmNlL2ZpZ3VyZXMvUkVBRE1FLXBsb3QtMS5wbmdcclxuICAgICAgICAvKm9wdHMuY29sb3JzID0gb3B0cy5jb2xvcnMgfHwgW1xyXG4gICAgICAgICAgICAnIzAwODUyYicsIC8vZGFya2VyIGdyZWVuXHJcbiAgICAgICAgICAgICcjYWZkMjQ2JywgLy9saWdodCBncmVlblxyXG4gICAgICAgICAgICAnI2ZhYzgwYScsIC8vZGFyayB5ZWxsb3dcclxuICAgICAgICAgICAgJyNiYjgwNWEnLCAvL2Jyb3duXHJcbiAgICAgICAgICAgICcjZDY3OTIzJywgLy9tb3N0YXJkXHJcbiAgICAgICAgICAgICcjY2I0ZTI5JywgLy9yZWRpc2hcclxuICAgICAgICAgICAgJyNiNDAwMDAnLCAvL3JlZFxyXG4gICAgICAgICAgICAnIzcyMDAxMicsIC8vZGFyayByZWRcclxuICAgICAgICAgICAgLy9cInB1cnBsZVwiLFxyXG4gICAgICAgICAgICAvL1wiI2VlZVwiIC8vd2hpdGhlXHJcbiAgICAgICAgXSovXHJcblxyXG4gICAgICAgIG9wdHMuY29sRGFyayA9IG9wdHMuY29sRGFyayB8fCAnIzMzMydcclxuICAgICAgICBvcHRzLmNvbEJyaWdodCA9IG9wdHMuY29sQnJpZ2h0IHx8ICcjYWFhJ1xyXG4gICAgICAgIG9wdHMud2lkdGhGYWN0b3IgPSBvcHRzLndpZHRoRmFjdG9yIHx8IDAuMTJcclxuXHJcbiAgICAgICAgLy9yZXVzZSB0YW5ha2EgYXMgYmFzaXNcclxuICAgICAgICBjb25zdCB0cyA9IFRhbmFrYVN0eWxlLmdldCh2YWx1ZSwgYnJlYWtzLCBjb2xvcnMsIG9wdHMpXHJcbiAgICAgICAgLy9zdHlsZSB0byBzaG93IGxpbWl0cyBiZXR3ZWVuIHBpZWNlc1xyXG4gICAgICAgIGNvbnN0IHNzdCA9IG5ldyBTdHJva2VTdHlsZSh7XHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiAoKSA9PiAnIzY2NicsXHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAoYywgciwgeikgPT4gMC4yICogeixcclxuICAgICAgICAgICAgZmlsdGVyOiBvcHRzLmZpbHRlcixcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB0c1swXSxcclxuICAgICAgICAgICAgc3N0LFxyXG4gICAgICAgICAgICB0c1sxXSxcclxuICAgICAgICAgICAgbmV3IExlZ29Ub3BTdHlsZSh7IGNvbERhcms6IG9wdHMuY29sRGFyaywgY29sQnJpZ2h0OiBvcHRzLmNvbEJyaWdodCwgZmlsdGVyOiBvcHRzLmZpbHRlciB9KSxcclxuICAgICAgICBdXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCk6c3RyaW5nfSBjb2RlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29sb3JcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFN0eWxlPn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldENhdGVnb3J5KGNvZGUsIGNvbG9yLCBvcHRzKSB7XHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgb3B0cy5jb2xEYXJrID0gb3B0cy5jb2xEYXJrIHx8ICcjMzMzJ1xyXG4gICAgICAgIG9wdHMuY29sQnJpZ2h0ID0gb3B0cy5jb2xCcmlnaHQgfHwgJyNhYWEnXHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgY29uc3QgcyA9IG5ldyBTcXVhcmVDb2xvckNhdGVnb3J5V2ViR0xTdHlsZSh7IGNvZGU6IGNvZGUsIGNvbG9yOiBjb2xvciB9KVxyXG4gICAgICAgIC8vc3R5bGUgdG8gc2hvdyBsaW1pdHMgYmV0d2VlbiBwaWVjZXNcclxuICAgICAgICBjb25zdCBzc3QgPSBuZXcgU3Ryb2tlU3R5bGUoeyBzdHJva2VDb2xvcjogKCkgPT4gJyM2NjYnLCBzdHJva2VXaWR0aDogKGMsIHIsIHopID0+IDAuMiAqIHogfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIFtzLCBzc3QsIG5ldyBMZWdvVG9wU3R5bGUoeyBjb2xEYXJrOiBvcHRzLmNvbERhcmssIGNvbEJyaWdodDogb3B0cy5jb2xCcmlnaHQgfSldXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHN0eWxlIHRvIGRyYXcgdG9wIGNpcmNsZSBvZiBsZWdvIGJyaWNrcy5cclxuICovXHJcbmNsYXNzIExlZ29Ub3BTdHlsZSBleHRlbmRzIFN0eWxlIHtcclxuICAgIC8qKiBAcGFyYW0ge29iamVjdHx1bmRlZmluZWR9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcbiAgICAgICAgdGhpcy5jb2xEYXJrID0gb3B0cy5jb2xEYXJrIHx8ICcjMzMzJ1xyXG4gICAgICAgIHRoaXMuY29sQnJpZ2h0ID0gb3B0cy5jb2xCcmlnaHQgfHwgJyNhYWEnXHJcbiAgICB9XHJcblxyXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByKSB7XHJcbiAgICAgICAgLy9maWx0ZXJcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxyXG4gICAgICAgIGNvbnN0IGN0eCA9IGdlb0NhbnZhcy5vZmZzY3JlZW5DdHhcclxuXHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDAuNiAqIGdlb0NhbnZhcy52aWV3LnpcclxuXHJcbiAgICAgICAgLy9kYXJrIHBhcnRcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbERhcmtcclxuICAgICAgICBmb3IgKGxldCBjIG9mIGNlbGxzKSB7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICBjdHguYXJjKGMueCArIHIgKiAwLjUsIGMueSArIHIgKiAwLjUsIHIgKiAwLjU1ICogMC41LCBNYXRoLlBJIC8gNCwgLU1hdGguUEkgKiAoMyAvIDQpLCB0cnVlKVxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vYnJpZ2h0IHBhcnRcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbEJyaWdodFxyXG4gICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgIGN0eC5hcmMoYy54ICsgciAqIDAuNSwgYy55ICsgciAqIDAuNSwgciAqIDAuNTUgKiAwLjUsIE1hdGguUEkgLyA0LCAtTWF0aC5QSSAqICgzIC8gNCksIGZhbHNlKVxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL2NvcmUvU3R5bGUuanMnXHJcblxyXG4vKipcclxuICogQG1vZHVsZSBzdHlsZVxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTW9zYWljU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3Igb2YgdGhlIGNlbGwuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgoKSA9PiAnI0VBNkJBQycpIC8vKGMscix6LHZzKSA9PiB7fVxyXG5cclxuICAgICAgICAvKiogVGhlIG1vc2FpYyBmYWN0b3IsIHdpdGhpbiBbMCwwLjVdLiBTZXQgdG8gMCBmb3Igbm8gbW9zYWljIGVmZmVjdC4gU2V0IHRvIDAuNSBmb3Igc3Ryb25nIG1vc2FpYyBlZmZlY3QuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLm1vc2FpY0ZhY3RvciA9IG9wdHMubW9zYWljRmFjdG9yIHx8IDAuMTVcclxuXHJcbiAgICAgICAgLyoqIFRoZSBtb3NhaWMgc2hhZG93IGZhY3Rvciwgd2l0aGluIFswLDAuNV0uIFNldCB0byAwIGZvciBubyBtb3NhaWMgc2hhZG93LiBTZXQgdG8gMC41IGZvciBzdHJvbmcgbW9zYWljIHNoYWRvdy5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuc2hhZG93RmFjdG9yID0gb3B0cy5zaGFkb3dGYWN0b3IgfHwgMC4yXHJcblxyXG4gICAgICAgIC8qKiBUaGUgbW9zYWljIHNoYWRvdyBjb2xvci5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuc2hhZG93Q29sb3IgPSBvcHRzLnNoYWRvd0NvbG9yIHx8ICcjNTU1J1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL2NvcmUvRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXNcIikuR2VvQ2FudmFzfSBnZW9DYW52YXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uXHJcbiAgICAgKi9cclxuICAgIGRyYXcoY2VsbHMsIGdlb0NhbnZhcywgcmVzb2x1dGlvbikge1xyXG4gICAgICAgIC8vZmlsdGVyXHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcuelxyXG4gICAgICAgIGNvbnN0IGN0eCA9IGdlb0NhbnZhcy5vZmZzY3JlZW5DdHhcclxuXHJcbiAgICAgICAgLy9nZXQgdmlldyBzY2FsZVxyXG4gICAgICAgIGNvbnN0IHZpZXdTY2FsZSA9IHRoaXMudmlld1NjYWxlID8gdGhpcy52aWV3U2NhbGUoY2VsbHMsIHJlc29sdXRpb24sIHopIDogdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8vc2V0IHN0cm9rZSBzdHlsZSwgZm9yIHNoYWRvd1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc2hhZG93Q29sb3JcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zaGFkb3dGYWN0b3IgKiByZXNvbHV0aW9uXHJcbiAgICAgICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJ1xyXG4gICAgICAgIGN0eC5saW5lQ2FwID0gJ2J1dHQnXHJcblxyXG4gICAgICAgIC8vZnVuY3Rpb24gdG8gY29tcHV0ZSBwb3NpdGlvbiBtb3NhaWMgZWZmZWN0XHJcbiAgICAgICAgY29uc3QgZCA9IHJlc29sdXRpb24gKiB0aGlzLm1vc2FpY0ZhY3RvclxyXG4gICAgICAgIGNvbnN0IG1vc2FpYyA9ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgeDogTWF0aC5yYW5kb20oKSAqIGQsIHk6IE1hdGgucmFuZG9tKCkgKiBkIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgLy9zZXQgZmlsbCBjb2xvclxyXG4gICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yID8gdGhpcy5jb2xvcihjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PT0gJ25vbmUnKSBjb250aW51ZVxyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sXHJcblxyXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoY2VsbCwgcmVzb2x1dGlvbiwgeilcclxuXHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSBwb3NpdGlvbiBtb3NhaWMgZWZmZWN0XHJcbiAgICAgICAgICAgIGNvbnN0IGxsID0gbW9zYWljKCksXHJcbiAgICAgICAgICAgICAgICB1bCA9IG1vc2FpYygpLFxyXG4gICAgICAgICAgICAgICAgbHIgPSBtb3NhaWMoKSxcclxuICAgICAgICAgICAgICAgIHVyID0gbW9zYWljKClcclxuXHJcbiAgICAgICAgICAgIC8vc3Ryb2tlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvd0ZhY3RvciA+IDApIHtcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjZWxsLnggKyBvZmZzZXQuZHggKyBsbC54LCBjZWxsLnkgKyBvZmZzZXQuZHkgKyBsbC55KVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjZWxsLnggKyBvZmZzZXQuZHggKyByZXNvbHV0aW9uIC0gbHIueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgbHIueSlcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY2VsbC54ICsgb2Zmc2V0LmR4ICsgcmVzb2x1dGlvbiAtIHVyLngsIGNlbGwueSArIG9mZnNldC5keSArIHJlc29sdXRpb24gLSB1ci55KVxyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZmlsbFxyXG5cclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oY2VsbC54ICsgb2Zmc2V0LmR4ICsgbGwueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgbGwueSlcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhjZWxsLnggKyBvZmZzZXQuZHggKyByZXNvbHV0aW9uIC0gbHIueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgbHIueSlcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhjZWxsLnggKyBvZmZzZXQuZHggKyByZXNvbHV0aW9uIC0gdXIueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgcmVzb2x1dGlvbiAtIHVyLnkpXHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oY2VsbC54ICsgb2Zmc2V0LmR4ICsgdWwueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgcmVzb2x1dGlvbiAtIHVsLnkpXHJcbiAgICAgICAgICAgIGN0eC5maWxsKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiwgdmlld1NjYWxlOiB2aWV3U2NhbGUgfSlcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vY29yZS9TdHlsZS5qcydcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHN0eWxlXHJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBOaW5qYVN0YXJTdHlsZSBleHRlbmRzIFN0eWxlIHtcclxuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb2xvciBvZiB0aGUgY2VsbC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLCBudW1iZXIsIG51bWJlciwgb2JqZWN0KTpzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKCgpID0+ICcjRUE2QkFDJykgLy8oYyxyLHosdnMpID0+IHt9XHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgc2l6ZSBvZiBhIGNlbGwsIHdpdGhpbiBbMCwxXTpcclxuICAgICAgICAgKiAgLSAwLCBub3RoaW5nIHNob3duXHJcbiAgICAgICAgICogIC0gMSwgZW50aXJlIHNxdWFyZVxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnNpemUgPSBvcHRzLnNpemUgfHwgKChjZWxsLCByZXNvbHV0aW9uKSA9PiByZXNvbHV0aW9uKSAvLyhjLHIseix2cykgPT4ge31cclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaGFwZS5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkNlbGwpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnNoYXBlID0gb3B0cy5zaGFwZSB8fCAoKCkgPT4gJ28nKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbD59IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvblxyXG4gICAgICovXHJcbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcclxuICAgICAgICBjb25zdCBjdHggPSBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4XHJcblxyXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcclxuICAgICAgICBjb25zdCB2aWV3U2NhbGUgPSB0aGlzLnZpZXdTY2FsZSA/IHRoaXMudmlld1NjYWxlKGNlbGxzLCByZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxyXG5cclxuICAgICAgICBjb25zdCByMiA9IHJlc29sdXRpb24gKiAwLjVcclxuICAgICAgICBmb3IgKGxldCBjZWxsIG9mIGNlbGxzKSB7XHJcbiAgICAgICAgICAgIC8vY29sb3JcclxuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvciA/IHRoaXMuY29sb3IoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIWNvbCB8fCBjb2wgPT09ICdub25lJykgY29udGludWVcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbFxyXG5cclxuICAgICAgICAgICAgLy9zaXplIC0gaW4gZ2VvIHVuaXRcclxuICAgICAgICAgICAgbGV0IGsgPSB0aGlzLnNpemUoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKVxyXG4gICAgICAgICAgICBrID0gayA8IDAgPyAwIDogayA+IDEgPyAxIDoga1xyXG4gICAgICAgICAgICBjb25zdCBzRzIgPSBrICogcjJcclxuXHJcbiAgICAgICAgICAgIC8vc2hhcGVcclxuICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLnNoYXBlID8gdGhpcy5zaGFwZShjZWxsKSA6ICdvJ1xyXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdub25lJykgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxyXG4gICAgICAgICAgICAvL1RPRE8gdXNlXHJcbiAgICAgICAgICAgIC8vY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoY2VsbCwgciwgeilcclxuXHJcbiAgICAgICAgICAgIC8vY2VudGVyIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGN4ID0gY2VsbC54ICsgcjJcclxuICAgICAgICAgICAgY29uc3QgY3kgPSBjZWxsLnkgKyByMlxyXG5cclxuICAgICAgICAgICAgaWYgKHNoYXBlID09PSAncCcpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjeCwgY3kgKyByMilcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3ggKyBzRzIsIGN5ICsgc0cyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjeCArIHIyLCBjeSlcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3ggKyBzRzIsIGN5IC0gc0cyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjeCwgY3kgLSByMilcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3ggLSBzRzIsIGN5IC0gc0cyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjeCAtIHIyLCBjeSlcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3ggLSBzRzIsIGN5ICsgc0cyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAnbycpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjeCwgY3kgKyBzRzIpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN4ICsgcjIsIGN5ICsgcjIpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN4ICsgc0cyLCBjeSlcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3ggKyByMiwgY3kgLSByMilcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3gsIGN5IC0gc0cyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjeCAtIHIyLCBjeSAtIHIyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjeCAtIHNHMiwgY3kpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN4IC0gcjIsIGN5ICsgcjIpXHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2hhcGU6JyArIHNoYXBlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXHJcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHJlc29sdXRpb246IHJlc29sdXRpb24sIHo6IHosIHZpZXdTY2FsZTogdmlld1NjYWxlIH0pXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL2NvcmUvU3R5bGUuanMnXHJcblxyXG4vKipcclxuICogQG1vZHVsZSBzdHlsZVxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGlsbGFyU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgaGVpZ2h0IG9mIHRoZSBsaW5lIHJlcHJlc2VudGluZyBhIGNlbGwsIGluIGdlbyB1bml0XHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0cy5oZWlnaHRcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb2xvciBvZiB0aGUgbGluZSByZXByZXNlbnRpbmcgYSBjZWxsLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKCkgPT4gJyNjMDhjNTknKSAvLyhjLHIseix2cykgPT4ge31cclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB3aWR0aCBvZiB0aGUgbGluZSByZXByZXNlbnRpbmcgYSBjZWxsLCBpbiBnZW8gdW5pdFxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAoKGNlbGwsIHJlc29sdXRpb24pID0+IDAuNSAqIHJlc29sdXRpb24pXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgd2lkdGggb2YgdGhlIGxpbmUgcmVwcmVzZW50aW5nIGEgY2VsbCwgaW4gZ2VvIHVuaXRcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIsb2JqZWN0KTpib29sZWFufSAqL1xyXG4gICAgICAgIHRoaXMuc2ltcGxlID0gb3B0cy5zaW1wbGUgfHwgKCgpID0+IGZhbHNlKVxyXG5cclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnZpZXdIZWlnaHRGYWN0b3IgPSBvcHRzLnZpZXdIZWlnaHRGYWN0b3IgfHwgMS41XHJcbiAgICAgICAgLy8wLDAgaXMgdGhlIGNlbnRlclxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMudmlld1NYID0gb3B0cy52aWV3U1ggPT0gdW5kZWZpbmVkID8gMCA6IG9wdHMudmlld1NYXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy52aWV3U1kgPSBvcHRzLnZpZXdTWSA9PSB1bmRlZmluZWQgPyAtMC41IDogb3B0cy52aWV3U1lcclxuXHJcbiAgICAgICAgLy9UT0RPIHJlcGxhY2Ugd2l0aCBzdW4gbG9jYXRpb24gP1xyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuc2hhZG93RGlyZWN0aW9uID1cclxuICAgICAgICAgICAgb3B0cy5zaGFkb3dEaXJlY3Rpb24gPT0gdW5kZWZpbmVkID8gKC00MC4zICogTWF0aC5QSSkgLyAxODAuMCA6IG9wdHMuc2hhZG93RGlyZWN0aW9uXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5zaGFkb3dGYWN0b3IgPSBvcHRzLnNoYWRvd0ZhY3RvciB8fCAwLjNcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnNoYWRvd0NvbG9yID0gb3B0cy5zaGFkb3dDb2xvciB8fCAnIzAwMDAwMDMzJ1xyXG5cclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLm91dGxpbmVDb2wgPSBvcHRzLm91dGxpbmVDb2wgfHwgJyNGRkZGRkYnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5vdXRsaW5lV2lkdGhQaXggPSBvcHRzLm91dGxpbmVXaWR0aFBpeCA9PSB1bmRlZmluZWQgPyAwLjUgOiBvcHRzLm91dGxpbmVXaWR0aFBpeFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBjZWxscyBhcyBzZWdtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvblxyXG4gICAgICovXHJcbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcclxuICAgICAgICBjb25zdCBjdHggPSBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4XHJcblxyXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcclxuICAgICAgICBjb25zdCB2aWV3U2NhbGUgPSB0aGlzLnZpZXdTY2FsZSA/IHRoaXMudmlld1NjYWxlKGNlbGxzLCByZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAvL2dldCB2aWV3IGNlbnRlciBnZW8gcG9zaXRpb25cclxuICAgICAgICBjb25zdCBjdnggPSBnZW9DYW52YXMudmlldy54ICsgdGhpcy52aWV3U1ggKiBnZW9DYW52YXMudyAqIHpcclxuICAgICAgICBjb25zdCBjdnkgPSBnZW9DYW52YXMudmlldy55ICsgdGhpcy52aWV3U1kgKiBnZW9DYW52YXMuaCAqIHpcclxuICAgICAgICAvL2dldCB2aWV3IGhlaWdodFxyXG4gICAgICAgIGNvbnN0IEggPSB0aGlzLnZpZXdIZWlnaHRGYWN0b3IgKiAoZ2VvQ2FudmFzLncgKyBnZW9DYW52YXMuaCkgKiAwLjUgKiB6XHJcblxyXG4gICAgICAgIC8vc29ydCBjZWxscyBieSB5IGFuZCB4XHJcbiAgICAgICAgLy9jb25zdCBkaXN0VG9WaWV3Q2VudGVyID0gKGMpID0+IHsgY29uc3QgZHggPSBjdnggLSBjLngsIGR5ID0gY3Z5IC0gYy55OyByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSB9XHJcbiAgICAgICAgY2VsbHMuc29ydCgoYzEsIGMyKSA9PiAxMDAwMDAwMDAgKiAoYzIueSAtIGMxLnkpICsgYzEueCAtIGMyLngpXHJcblxyXG4gICAgICAgIC8vZ2V0IHNpbXBsZSBpbmZvcm1hdGlvblxyXG4gICAgICAgIGNvbnN0IHNpbXBsZSA9IHRoaXMuc2ltcGxlKHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSlcclxuXHJcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBzaW1wbGUgPyAnYnV0dCcgOiAncm91bmQnXHJcblxyXG4gICAgICAgIC8vZHJhdyBzaGFkb3dzXHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zaGFkb3dDb2xvclxyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNoYWRvd0NvbG9yXHJcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICAvL3dpZHRoXHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICAgICAgY29uc3Qgd0cgPSB0aGlzLndpZHRoID8gdGhpcy53aWR0aChjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmICghd0cgfHwgd0cgPCAwKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9oZWlnaHRcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgICAgICBjb25zdCBoRyA9IHRoaXMuaGVpZ2h0ID8gdGhpcy5oZWlnaHQoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIWhHIHx8IGhHIDwgMCkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxyXG4gICAgICAgICAgICAvL1RPRE8gdXNlIHRoYXRcclxuICAgICAgICAgICAgLy9jb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjLCByZXNvbHV0aW9uLCB6KVxyXG5cclxuICAgICAgICAgICAgLy9zZXQgd2lkdGhcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHdHXHJcblxyXG4gICAgICAgICAgICAvL2NvbXB1dGUgY2VsbCBjZW50ZXIgcG9zdGl0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGN4ID0gY2VsbC54ICsgcmVzb2x1dGlvbiAvIDJcclxuICAgICAgICAgICAgY29uc3QgY3kgPSBjZWxsLnkgKyByZXNvbHV0aW9uIC8gMlxyXG4gICAgICAgICAgICBjb25zdCBscyA9IGhHICogdGhpcy5zaGFkb3dGYWN0b3JcclxuXHJcbiAgICAgICAgICAgIC8vZHJhdyBzZWdtZW50XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICBjdHgubW92ZVRvKGN4LCBjeSlcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhjeCArIGxzICogTWF0aC5jb3ModGhpcy5zaGFkb3dEaXJlY3Rpb24pLCBjeSArIGxzICogTWF0aC5zaW4odGhpcy5zaGFkb3dEaXJlY3Rpb24pKVxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNpbXBsZSkge1xyXG4gICAgICAgICAgICAgICAgLy9kcmF3IGJhc2UgY2lyY2xlXHJcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjZy5jdHguYXJjKFxyXG4gICAgICAgICAgICAgICAgICAgIGN4LCBjeSxcclxuICAgICAgICAgICAgICAgICAgICB3RyAqIDAuNSxcclxuICAgICAgICAgICAgICAgICAgICAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgLy9jZy5jdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbCgpO1xyXG4gICAgICAgICAgICB9Ki9cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBwaWxsYXJzXHJcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICAvL2NvbG9yXHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvciA/IHRoaXMuY29sb3IoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIWNvbCkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8vd2lkdGhcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgICAgICBjb25zdCB3RyA9IHRoaXMud2lkdGggPyB0aGlzLndpZHRoKGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKCF3RyB8fCB3RyA8IDApIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL2hlaWdodFxyXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IGhHID0gdGhpcy5oZWlnaHQgPyB0aGlzLmhlaWdodChjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmICghaEcgfHwgaEcgPCAwKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9nZXQgb2Zmc2V0XHJcbiAgICAgICAgICAgIC8vVE9ETyB1c2UgdGhhdFxyXG4gICAgICAgICAgICAvL2NvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGMsIHJlc29sdXRpb24sIHopXHJcblxyXG4gICAgICAgICAgICAvL2NvbXB1dGUgY2VsbCBjZW50ZXIgcG9zdGl0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGN4ID0gY2VsbC54ICsgcmVzb2x1dGlvbiAvIDJcclxuICAgICAgICAgICAgY29uc3QgY3kgPSBjZWxsLnkgKyByZXNvbHV0aW9uIC8gMlxyXG5cclxuICAgICAgICAgICAgLy9jb21wdXRlIGFuZ2xlXHJcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gY3ggLSBjdngsXHJcbiAgICAgICAgICAgICAgICBkeSA9IGN5IC0gY3Z5XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBNYXRoLmF0YW4yKGR5LCBkeClcclxuICAgICAgICAgICAgY29uc3QgRCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcclxuICAgICAgICAgICAgY29uc3QgZCA9IChEICogaEcpIC8gKEggLSBoRylcclxuXHJcbiAgICAgICAgICAgIGlmIChzaW1wbGUpIHtcclxuICAgICAgICAgICAgICAgIC8vZHJhdyBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB3R1xyXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGN4LCBjeSlcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3ggKyBkICogTWF0aC5jb3MoYSksIGN5ICsgZCAqIE1hdGguc2luKGEpKVxyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgYmFja2dyb3VuZCBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLm91dGxpbmVDb2xcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB3RyArIDIgKiB0aGlzLm91dGxpbmVXaWR0aFBpeCAqIHpcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjeCwgY3kpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN4ICsgZCAqIE1hdGguY29zKGEpLCBjeSArIGQgKiBNYXRoLnNpbihhKSlcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZHJhdyBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB3R1xyXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGN4LCBjeSlcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3ggKyBkICogTWF0aC5jb3MoYSksIGN5ICsgZCAqIE1hdGguc2luKGEpKVxyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9kcmF3IHRvcCBjaXJjbGVcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMub3V0bGluZUNvbFxyXG4gICAgICAgICAgICAgICAgLy9jZy5jdHguZmlsbFN0eWxlID0gXCIjYzA4YzU5XCJcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLm91dGxpbmVXaWR0aFBpeCAqIHpcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4LmFyYyhjeCArIGQgKiBNYXRoLmNvcyhhKSwgY3kgKyBkICogTWF0aC5zaW4oYSksIHdHICogMC41LCAwLCAyICogTWF0aC5QSSwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKClcclxuICAgICAgICAgICAgICAgIC8vY2cuY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9pbiBjYXNlLi4uXHJcbiAgICAgICAgY3R4LmxpbmVDYXAgPSAnYnV0dCdcclxuXHJcbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByZXNvbHV0aW9uOiByZXNvbHV0aW9uLCB6OiB6LCB2aWV3U2NhbGU6IHZpZXdTY2FsZSB9KVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9jb3JlL1N0eWxlLmpzJ1xyXG5cclxuLyoqXHJcbiAqIEEgc3R5bGUgd2hlcmUgZWFjaCBjZWxsIGlzIHJlcHJlc2VudGVkIGJ5IGEgc2VnbWVudCB3aG9zZSBsZW5ndGgsIHdpZHRoLCBjb2xvciBhbmQgb3JpZW50YXRpb24gY2FuIHZhcnkgYWNjb3JkaW5nIHRvIHN0YXRpc3RpY2FsIHZhbHVlcy5cclxuICpcclxuICogQG1vZHVsZSBzdHlsZVxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2VnbWVudFN0eWxlIGV4dGVuZHMgU3R5bGUge1xyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIHRoZSBjZWxsIHNlZ21lbnQuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgoKSA9PiAnI0VBNkJBQycpIC8vKGMscix6LHZzKSA9PiB7fVxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHdpZHRoIG9mIHRoZSBzZWdtZW50IHJlcHJlc2VudGluZyBhIGNlbGwsIGluIGdlbyB1bml0XHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8ICgoY2VsbCwgcmVzb2x1dGlvbikgPT4gcmVzb2x1dGlvbiAqIDAuMSkgLy8oYyxyLHosdnMpID0+IHt9XHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbGVuZ3RoIG9mIHRoZSBzZWdtZW50IHJlcHJlc2VudGluZyBhIGNlbGwsIGluIGdlbyB1bml0XHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gb3B0cy5sZW5ndGggfHwgKChjZWxsLCByZXNvbHV0aW9uKSA9PiByZXNvbHV0aW9uICogMC45KSAvLyhjLHIseix2cykgPT4ge31cclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBvcmllbnRhdGlvbiAoaW4gZGVncmVlcykgb2YgdGhlIHNlZ21lbnQgcmVwcmVzZW50aW5nIGEgY2VsbC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLCBudW1iZXIsIG51bWJlciwgb2JqZWN0KTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IG9wdHMub3JpZW50YXRpb24gfHwgKCgpID0+IDE4MCAqIE1hdGgucmFuZG9tKCkpIC8vKGMscix6LHZzKSA9PiB7fVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBjZWxscyBhcyBzZWdtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvblxyXG4gICAgICovXHJcbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcclxuICAgICAgICBjb25zdCBjdHggPSBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4XHJcblxyXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcclxuICAgICAgICBjb25zdCB2aWV3U2NhbGUgPSB0aGlzLnZpZXdTY2FsZSA/IHRoaXMudmlld1NjYWxlKGNlbGxzLCByZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGN0eC5saW5lQ2FwID0gJ2J1dHQnXHJcblxyXG4gICAgICAgIC8vY29udmVyc2lvbiBmYWN0b3IgZGVncmVlIC0+IHJhZGlhblxyXG4gICAgICAgIGNvbnN0IGYgPSBNYXRoLlBJIC8gMTgwXHJcblxyXG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgLy9jb2xvclxyXG4gICAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sb3IgPyB0aGlzLmNvbG9yKGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKCFjb2wpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL3dpZHRoXHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICAgICAgY29uc3Qgd0cgPSB0aGlzLndpZHRoID8gdGhpcy53aWR0aChjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmICghd0cgfHwgd0cgPCAwKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9sZW5ndGhcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgICAgICBjb25zdCBsRyA9IHRoaXMubGVuZ3RoID8gdGhpcy5sZW5ndGgoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIWxHIHx8IGxHIDwgMCkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8vb3JpZW50YXRpb24gKGluIHJhZGlhbilcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IG9yID0gdGhpcy5vcmllbnRhdGlvbihjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpICogZlxyXG4gICAgICAgICAgICBpZiAob3IgPT09IHVuZGVmaW5lZCB8fCBpc05hTihvcikpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoY2VsbCwgcmVzb2x1dGlvbiwgeilcclxuXHJcbiAgICAgICAgICAgIC8vc2V0IGNvbG9yIGFuZCB3aWR0aFxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHdHXHJcblxyXG4gICAgICAgICAgICAvL2NvbXB1dGUgc2VnbWVudCBjZW50ZXIgcG9zdGl0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGN4ID0gY2VsbC54ICsgcmVzb2x1dGlvbiAvIDIgKyBvZmZzZXQuZHhcclxuICAgICAgICAgICAgY29uc3QgY3kgPSBjZWxsLnkgKyByZXNvbHV0aW9uIC8gMiArIG9mZnNldC5keVxyXG5cclxuICAgICAgICAgICAgLy9jb21wdXRlIHNlZ21lbnQgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gMC41ICogTWF0aC5jb3Mob3IpICogbEdcclxuICAgICAgICAgICAgY29uc3QgZHkgPSAwLjUgKiBNYXRoLnNpbihvcikgKiBsR1xyXG5cclxuICAgICAgICAgICAgLy9kcmF3IHNlZ21lbnRcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oY3ggLSBkeCwgY3kgLSBkeSlcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhjeCArIGR4LCBjeSArIGR5KVxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyB2aWV3U2NhbGU6IHZpZXdTY2FsZSwgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiwgY2VsbHM6IGNlbGxzIH0pXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL2NvcmUvU3R5bGUuanMnXHJcblxyXG4vKipcclxuICogQSB2ZXJ5IGdlbmVyaWMgc3R5bGUgdGhhdCBzaG93cyBncmlkIGNlbGxzIHdpdGggc3BlY2lmaWMgY29sb3IsIHNpemUgYW5kIHNoYXBlLlxyXG4gKiBJdCBjYW4gYmUgdXNlZCB0byBzaG93IHZhcmlhYmxlcyBhcyBjZWxsIGNvbG9ycywgY2VsbCBzaXplLCBjZWxsIHNoYXBlLCBvciBhbnkgY29tYmluYXRpb24gb2YgdGhlIHRocmVlIHZpc3VhbCB2YXJpYWJsZXMuXHJcbiAqXHJcbiAqIEBtb2R1bGUgc3R5bGVcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNoYXBlQ29sb3JTaXplU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcbiAgICAgICAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLCBudW1iZXIsIG51bWJlciwgb2JqZWN0KTpzdHJpbmcpIHwgc3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICcjRUE2QkFDJ1xyXG5cclxuICAgICAgICAvKiogQHR5cGUgeyhmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOm51bWJlcikgfCBudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5zaXplID0gb3B0cy5zaXplIHx8ICgoY2VsbCwgcmVzb2x1dGlvbikgPT4gcmVzb2x1dGlvbilcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHsoZnVuY3Rpb24oaW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0LmpzXCIpLkNlbGwsbnVtYmVyLCBudW1iZXIsb2JqZWN0KTppbXBvcnQoXCIuLi9jb3JlL1N0eWxlLmpzXCIpLlNoYXBlKSB8IHN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnNoYXBlID0gb3B0cy5zaGFwZSB8fCAnc3F1YXJlJ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBjZWxscyBhcyBzcXVhcmVzLCB3aXRoIHZhcmlvdXMgY29sb3JzIGFuZCBzaXplcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbD59IGNlbGxzIC0gVGhlIGdyaWQgY2VsbHMgdG8gZHJhdy5cclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29yZS9HZW9DYW52YXMuanNcIikuR2VvQ2FudmFzfSBnZW9DYW52YXMgLSBUaGUgY2FudmFzIHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiAtIFJlc29sdXRpb24gb2YgdGhlIGdyaWQuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgLy9maWx0ZXJcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxyXG5cclxuICAgICAgICAvL3pvb21cclxuICAgICAgICBjb25zdCB6ID0gZ2VvQ2FudmFzLnZpZXcuelxyXG5cclxuICAgICAgICAvL2dldCB2aWV3IHNjYWxlXHJcbiAgICAgICAgY29uc3Qgdmlld1NjYWxlID0gdGhpcy52aWV3U2NhbGUgPyB0aGlzLnZpZXdTY2FsZShjZWxscywgcmVzb2x1dGlvbiwgeikgOiB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgY29uc3QgcjIgPSByZXNvbHV0aW9uICogMC41XHJcblxyXG4gICAgICAgIC8vIFByZWNvbXB1dGUgaWYgY29sb3IsIHNpemUsIGFuZCBzaGFwZSBhcmUgZnVuY3Rpb25zLCBmb3IgZWZmaWNpZW5jeVxyXG4gICAgICAgIGNvbnN0IGlzQ29sb3JGdW5jdGlvbiA9IHR5cGVvZiB0aGlzLmNvbG9yID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgY29uc3QgaXNTaXplRnVuY3Rpb24gPSB0eXBlb2YgdGhpcy5zaXplID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgY29uc3QgaXNTaGFwZUZ1bmN0aW9uID0gdHlwZW9mIHRoaXMuc2hhcGUgPT09ICdmdW5jdGlvbidcclxuXHJcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbG9yID0gdGhpcy5jb2xvciB8fCAnYmxhY2snXHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFNpemUgPSB0aGlzLnNpemUgfHwgcmVzb2x1dGlvblxyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRTaGFwZSA9IHRoaXMuc2hhcGUgfHwgJ3NxdWFyZSdcclxuXHJcbiAgICAgICAgLy8gT3B0aW1pemVkXHJcbiAgICAgICAgY29uc3QgY29sb3JGdW5jdGlvbiA9IGlzQ29sb3JGdW5jdGlvbiA/IHRoaXMuY29sb3IgOiBudWxsXHJcbiAgICAgICAgY29uc3Qgc2l6ZUZ1bmN0aW9uID0gaXNTaXplRnVuY3Rpb24gPyB0aGlzLnNpemUgOiBudWxsXHJcbiAgICAgICAgY29uc3Qgc2hhcGVGdW5jdGlvbiA9IGlzU2hhcGVGdW5jdGlvbiA/IHRoaXMuc2hhcGUgOiBudWxsXHJcblxyXG4gICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGNvbG9yXHJcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBjb25zdCBjb2wgPSBjb2xvckZ1bmN0aW9uID8gY29sb3JGdW5jdGlvbihjLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogZGVmYXVsdENvbG9yXHJcbiAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PT0gJ25vbmUnKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHNpemVcclxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBzaXplRnVuY3Rpb24gPyBzaXplRnVuY3Rpb24oYywgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IGRlZmF1bHRTaXplXHJcbiAgICAgICAgICAgIGlmICghc2l6ZSkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSBzaGFwZVxyXG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSBzaGFwZUZ1bmN0aW9uID8gc2hhcGVGdW5jdGlvbihjLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogZGVmYXVsdFNoYXBlXHJcbiAgICAgICAgICAgIGlmIChzaGFwZSA9PT0gJ25vbmUnKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9nZXQgb2Zmc2V0XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGMsIHJlc29sdXRpb24sIHopXHJcblxyXG4gICAgICAgICAgICAvL2dldCBjb250ZXh0XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGdlb0NhbnZhcy5vZmZzY3JlZW5DdHhcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbFxyXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdzcXVhcmUnKSB7XHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgc3F1YXJlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gcmVzb2x1dGlvbiAqICgxIC0gc2l6ZSAvIHJlc29sdXRpb24pICogMC41XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoYy54ICsgZCArIG9mZnNldC5keCwgYy55ICsgZCArIG9mZnNldC5keSwgc2l6ZSwgc2l6ZSlcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2NpcmNsZScpIHtcclxuICAgICAgICAgICAgICAgIC8vZHJhdyBjaXJjbGVcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4LmFyYyhjLnggKyByMiArIG9mZnNldC5keCwgYy55ICsgcjIgKyBvZmZzZXQuZHksIHNpemUgKiAwLjUsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSlcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsKClcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2RvbnV0Jykge1xyXG4gICAgICAgICAgICAgICAgLy9kcmF3IGRvbnV0XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4YyA9IGMueCArIHIyICsgb2Zmc2V0LmR4LFxyXG4gICAgICAgICAgICAgICAgICAgIHljID0gYy55ICsgcjIgKyBvZmZzZXQuZHlcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4YywgeWMpXHJcbiAgICAgICAgICAgICAgICBjdHguYXJjKHhjLCB5YywgcjIsIDAsIDIgKiBNYXRoLlBJKVxyXG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4YywgeWMsICgxIC0gc2l6ZSAvIHJlc29sdXRpb24pICogcjIsIDAsIDIgKiBNYXRoLlBJLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpXHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdkaWFtb25kJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgczIgPSBzaXplICogMC41XHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oYy54ICsgcjIgLSBzMiwgYy55ICsgcjIpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGMueCArIHIyLCBjLnkgKyByMiArIHMyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjLnggKyByMiArIHMyLCBjLnkgKyByMilcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYy54ICsgcjIsIGMueSArIHIyIC0gczIpXHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICd0cmlhbmdsZV91cCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRyMiA9IChzaXplIC0gcmVzb2x1dGlvbikgLyAyXHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oYy54IC0gZHIyLCBjLnkgLSBkcjIpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGMueCArIHIyLCBjLnkgKyByZXNvbHV0aW9uICsgZHIyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjLnggKyByZXNvbHV0aW9uICsgZHIyLCBjLnkgLSBkcjIpXHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICd0cmlhbmdsZV9kb3duJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZHIyID0gKHNpemUgLSByZXNvbHV0aW9uKSAvIDJcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjLnggLSBkcjIsIGMueSArIHJlc29sdXRpb24gKyBkcjIpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGMueCArIHIyLCBjLnkgLSBkcjIpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGMueCArIHJlc29sdXRpb24gKyBkcjIsIGMueSArIHJlc29sdXRpb24gKyBkcjIpXHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICd0cmlhbmdsZV9sZWZ0Jykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZHIyID0gKHNpemUgLSByZXNvbHV0aW9uKSAvIDJcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjLnggKyByZXNvbHV0aW9uICsgZHIyLCBjLnkgKyByZXNvbHV0aW9uICsgZHIyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjLnggLSBkcjIsIGMueSArIHIyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjLnggKyByZXNvbHV0aW9uICsgZHIyLCBjLnkgLSBkcjIpXHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICd0cmlhbmdsZV9yaWdodCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRyMiA9IChzaXplIC0gcmVzb2x1dGlvbikgLyAyXHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oYy54IC0gZHIyLCBjLnkgLSBkcjIpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGMueCArIHJlc29sdXRpb24gKyBkcjIsIGMueSArIHIyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjLnggLSBkcjIsIGMueSArIHJlc29sdXRpb24gKyBkcjIpXHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2hhcGU6JyArIHNoYXBlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXHJcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgdmlld1NjYWxlOiB2aWV3U2NhbGUsIHJlc29sdXRpb246IHJlc29sdXRpb24sIHo6IHosIGNlbGxzOiBjZWxscyB9KVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgU2lkZVN0eWxlIH0gZnJvbSAnLi9TaWRlU3R5bGUuanMnXHJcblxyXG4vKipcclxuICogQSBzdHlsZSB0byBzaG93IHRoZSBzaWRlcyBvZiBncmlkIGNlbGxzIGJhc2VkIG9uIHRoZWlyIGRpZmZlcmVudCBjYXRlZ29yaWVzLlxyXG4gKlxyXG4gKiBAbW9kdWxlIHN0eWxlXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTaWRlQ2F0ZWdvcnlTdHlsZSBleHRlbmRzIFNpZGVTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY2F0ZWdvcnkgY29kZSBvZiBhIGNlbGwuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvZGUgPSBvcHRzLmNvZGVcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRpY3Rpb25hcnkgKHN0cmluZyAtPiBjb2xvcikgd2hpY2ggZ2l2ZSB0aGUgY29sb3Igb2YgZWFjaCBjYXRlZ29yeS5cclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbD59IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvblxyXG4gICAgICovXHJcbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcclxuICAgICAgICBjb25zdCBjdHggPSBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4XHJcblxyXG4gICAgICAgIC8vYnVpbGQgc2lkZXNcclxuXHJcbiAgICAgICAgLyoqICBAdHlwZSB7QXJyYXkuPGltcG9ydCgnLi9TaWRlU3R5bGUuanMnKS5TaWRlPn0gKi9cclxuICAgICAgICBjb25zdCBzaWRlcyA9IFNpZGVTdHlsZS5idWlsZFNpZGVzKGNlbGxzLCByZXNvbHV0aW9uKVxyXG4gICAgICAgIGlmIChzaWRlcy5sZW5ndGggPT0gMCkgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vZ2V0IHNpZGUgdmlldyBzY2FsZVxyXG4gICAgICAgIGNvbnN0IHZpZXdTY2FsZSA9IHRoaXMudmlld1NjYWxlID8gdGhpcy52aWV3U2NhbGUoc2lkZXMsIHJlc29sdXRpb24sIHopIDogdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8vZHJhdyBzaWRlc1xyXG5cclxuICAgICAgICBjdHgubGluZUNhcCA9ICdidXR0J1xyXG4gICAgICAgIGNvbnN0IHIyID0gcmVzb2x1dGlvbiAqIDAuNVxyXG4gICAgICAgIGZvciAobGV0IHNpZGUgb2Ygc2lkZXMpIHtcclxuICAgICAgICAgICAgLy9nZXQgY2F0ZWdvcnkgY29kZXMgZm9yIGJvdGggY2VsbHNcclxuICAgICAgICAgICAgY29uc3QgY29kZTEgPSBzaWRlLmMxID8gdGhpcy5jb2RlKHNpZGUuYzEsIHJlc29sdXRpb24sIHopIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUyID0gc2lkZS5jMiA/IHRoaXMuY29kZShzaWRlLmMyLCByZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoY29kZTEgPT0gY29kZTIpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL3dpZHRoXHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICAgICAgY29uc3Qgd0cgPSB0aGlzLndpZHRoID8gdGhpcy53aWR0aChzaWRlLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmICghd0cgfHwgd0cgPD0gMCkgY29udGludWVcclxuICAgICAgICAgICAgY29uc3QgdzIgPSB3RyAqIDAuNVxyXG5cclxuICAgICAgICAgICAgLy9zZXQgd2lkdGhcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHdHXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgc2VnbWVudCB3aXRoIGNvcnJlY3Qgb3JpZW50YXRpb25cclxuICAgICAgICAgICAgaWYgKHNpZGUub3IgPT09ICdoJykge1xyXG4gICAgICAgICAgICAgICAgLy90b3AgbGluZVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcltjb2RlMl1cclxuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHNpZGUueCAtIHIyLCBzaWRlLnkgKyB3MilcclxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHNpZGUueCArIHIyLCBzaWRlLnkgKyB3MilcclxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKClcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2JvdHRvbSBsaW5lXHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yW2NvZGUxXVxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc2lkZS54IC0gcjIsIHNpZGUueSAtIHcyKVxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc2lkZS54ICsgcjIsIHNpZGUueSAtIHcyKVxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9yaWdodCBsaW5lXHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yW2NvZGUyXVxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc2lkZS54ICsgdzIsIHNpZGUueSAtIHIyKVxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc2lkZS54ICsgdzIsIHNpZGUueSArIHIyKVxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vbGVmdCBsaW5lXHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yW2NvZGUxXVxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc2lkZS54IC0gdzIsIHNpZGUueSAtIHIyKVxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc2lkZS54IC0gdzIsIHNpZGUueSArIHIyKVxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXHJcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHJlc29sdXRpb246IHJlc29sdXRpb24sIHo6IHosIHZpZXdTY2FsZTogdmlld1NjYWxlIH0pXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL2NvcmUvU3R5bGUuanMnXHJcblxyXG4vKiogQHR5cGVkZWYge3sgeDpudW1iZXIsIHk6bnVtYmVyLCBvcjpcInZcInxcImhcIiwgYzE6KGltcG9ydCgnLi4vY29yZS9EYXRhc2V0JykuQ2VsbCl8dW5kZWZpbmVkLCBjMjooaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQnKS5DZWxsKXx1bmRlZmluZWQgfX0gU2lkZSAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihBcnJheS48U2lkZT4sbnVtYmVyLCBudW1iZXIpOip9IFNpZGVWaWV3U2NhbGUgKi9cclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHN0eWxlXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTaWRlU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3Igb2YgYSBjZWxsIHNpZGUuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKFNpZGUsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKHNpZGUsIHJlc29sdXRpb24sIHosIHNpZGVWaWV3U2NhbGUpID0+ICcjRUE2QkFDJylcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB3aWR0aCBvZiBhIGNlbGwgc2lkZSwgaW4gZ2VvIHVuaXRcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oU2lkZSwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8ICgoc2lkZSwgcmVzb2x1dGlvbiwgeiwgc2lkZVZpZXdTY2FsZSkgPT4gcmVzb2x1dGlvbiAvIDUpXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbGVuZ3RoIG9mIGEgY2VsbCBzaWRlLCBpbiBnZW8gdW5pdFxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihTaWRlLCBudW1iZXIsIG51bWJlciwgb2JqZWN0KTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBvcHRzLmxlbmd0aCB8fCAoKHNpZGUsIHJlc29sdXRpb24sIHosIHNpZGVWaWV3U2NhbGUpID0+IHJlc29sdXRpb24pXHJcblxyXG4gICAgICAgIC8qKiBTZXQgdG8gQSBvciB0cnVlIHNvIHRoYXQgdGhlIHNpZGUgaXMgZHJhd24gYXMgYSBkaWFtb25kICovXHJcbiAgICAgICAgdGhpcy5kaWFtb25kID0gb3B0cy5kaWFtb25kXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvblxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhc1xyXG4gICAgICovXHJcbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcclxuICAgICAgICBjb25zdCBjdHggPSBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4XHJcblxyXG4gICAgICAgIC8vYnVpbGQgc2lkZXNcclxuXHJcbiAgICAgICAgLyoqICBAdHlwZSB7QXJyYXkuPFNpZGU+fSAqL1xyXG4gICAgICAgIGNvbnN0IHNpZGVzID0gU2lkZVN0eWxlLmJ1aWxkU2lkZXMoY2VsbHMsIHJlc29sdXRpb24pXHJcbiAgICAgICAgaWYgKHNpZGVzLmxlbmd0aCA9PSAwKSByZXR1cm5cclxuXHJcbiAgICAgICAgLy9nZXQgc2lkZSB2aWV3IHNjYWxlXHJcbiAgICAgICAgY29uc3Qgdmlld1NjYWxlID0gdGhpcy52aWV3U2NhbGUgPyB0aGlzLnZpZXdTY2FsZShzaWRlcywgcmVzb2x1dGlvbiwgeikgOiB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgLy9kcmF3IHNpZGVzXHJcblxyXG4gICAgICAgIGN0eC5saW5lQ2FwID0gJ2J1dHQnXHJcbiAgICAgICAgY29uc3QgcjIgPSByZXNvbHV0aW9uICogMC41XHJcbiAgICAgICAgZm9yIChsZXQgc2lkZSBvZiBzaWRlcykge1xyXG4gICAgICAgICAgICAvL2NvbG9yXHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvciA/IHRoaXMuY29sb3Ioc2lkZSwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIWNvbCB8fCBjb2wgPT0gJ25vbmUnKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGlhbW9uZCkge1xyXG4gICAgICAgICAgICAgICAgLy9zZXQgY29sb3JcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xcclxuXHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgZGlhbW9uZFxyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHNpZGUueCxcclxuICAgICAgICAgICAgICAgICAgICB5ID0gc2lkZS55XHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCAtIHIyLCB5KVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcjIpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyByMiwgeSlcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSAtIHIyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpXHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL3dpZHRoXHJcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgICAgICAgICBjb25zdCB3RyA9IHRoaXMud2lkdGggPyB0aGlzLndpZHRoKHNpZGUsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIGlmICghd0cgfHwgd0cgPD0gMCkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgICAgICAvL2xlbmd0aFxyXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbEcgPSB0aGlzLmxlbmd0aCA/IHRoaXMubGVuZ3RoKHNpZGUsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIGlmICghbEcgfHwgbEcgPD0gMCkgY29udGludWVcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxHMiA9IGxHICogMC41XHJcblxyXG4gICAgICAgICAgICAgICAgLy9zZXQgd2lkdGhcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB3R1xyXG4gICAgICAgICAgICAgICAgLy9zZXQgY29sb3JcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbFxyXG5cclxuICAgICAgICAgICAgICAgIC8vZHJhdyBzZWdtZW50IHdpdGggY29ycmVjdCBvcmllbnRhdGlvblxyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHNpZGUueCxcclxuICAgICAgICAgICAgICAgICAgICB5ID0gc2lkZS55XHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGlmIChzaWRlLm9yID09PSAndicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkgLSBsRzIpXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgbEcyKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggLSBsRzIsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbEcyLCB5KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiwgdmlld1NjYWxlOiB2aWV3U2NhbGUgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoJy4uL2NvcmUvRGF0YXNldCcpLkNlbGw+fSBjZWxscyBUaGUgY2VsbHMgdG8gdXNlIHRvIGJ1aWxkIHRoZSBzaWRlcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSBjZWxscyByZXNvbHV0aW9uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhIb3Jpem9udGFsIFNldCB0byB0cnVlIHRvIGJ1aWxkIGhvcml6b250YWwgc2lkZXMsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aFZlcnRpY2FsIFNldCB0byB0cnVlIHRvIGJ1aWxkIHZlcnRpY2FsIHNpZGVzLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNlbnRlciBTZXQgdG8gdHJ1ZSBzbyB0aGF0IHRoZSBzaWRlIGNvb3JkaW5hdGUgYXJlIHRob3NlIG9mIGl0cyBjZW50ZXIgcG9pbnQgcmF0aGVyIHRoYW4gaXRzIGxlZnQvYm90dG9tIHBvaW50ICh0aGUgc2lkZSB4LHkgY29vcmRpbmF0ZXMgYXJlIHRob3NlIG9mIHRoZSBsZWZ0IHBvaW50IGZvciBob3Jpem9udGFsIHNpZGVzLCBhbmQgb2YgdGhlIGJvdHRvbSBwb2ludCBmb3IgdmVydGljYWwgc2lkZXMpXHJcbiAgICAgKiBAcmV0dXJucyB7IEFycmF5LjxTaWRlPiB9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBidWlsZFNpZGVzKGNlbGxzLCByZXNvbHV0aW9uLCB3aXRoSG9yaXpvbnRhbCA9IHRydWUsIHdpdGhWZXJ0aWNhbCA9IHRydWUsIGNlbnRlciA9IHRydWUpIHtcclxuICAgICAgICAvKiogQHR5cGUgeyBBcnJheS48U2lkZT4gfSAqL1xyXG4gICAgICAgIGNvbnN0IHNpZGVzID0gW11cclxuXHJcbiAgICAgICAgY29uc3QgcjIgPSBjZW50ZXIgPyByZXNvbHV0aW9uIC8gMiA6IDBcclxuXHJcbiAgICAgICAgLy9tYWtlIGhvcml6b250YWwgc2lkZXNcclxuICAgICAgICAvL3NvcnQgY2VsbHMgYnkgeCBhbmQgeVxyXG4gICAgICAgIGNlbGxzLnNvcnQoKGMxLCBjMikgPT4gKGMyLnggPT0gYzEueCA/IGMxLnkgLSBjMi55IDogYzEueCAtIGMyLngpKVxyXG4gICAgICAgIGxldCBjMSA9IGNlbGxzWzBdXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgYzIgPSBjZWxsc1tpXVxyXG5cclxuICAgICAgICAgICAgaWYgKGMxLnkgKyByZXNvbHV0aW9uID09IGMyLnkgJiYgYzEueCA9PSBjMi54KVxyXG4gICAgICAgICAgICAgICAgLy9jZWxscyBpbiBzYW1lIGNvbHVtbiBhbmQgdG91Y2ggYWxvbmcgaG9yaXpvbnRhbCBzaWRlXHJcbiAgICAgICAgICAgICAgICAvL21ha2Ugc2hhcmVkIHNpZGVcclxuICAgICAgICAgICAgICAgIHNpZGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG9yOiAnaCcsXHJcbiAgICAgICAgICAgICAgICAgICAgeDogYzEueCArIHIyLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGMyLnksXHJcbiAgICAgICAgICAgICAgICAgICAgYzE6IGMxLFxyXG4gICAgICAgICAgICAgICAgICAgIGMyOiBjMixcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9jZWxscyBkbyBub3QgdG91Y2ggYWxvbmcgaG9yaXpvbnRhbCBzaWRlXHJcbiAgICAgICAgICAgICAgICAvL21ha2UgdHdvIHNpZGVzOiB0b3Agb25lIGZvciBjMSwgYm90dG9tIGZvciBjMlxyXG4gICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3I6ICdoJyxcclxuICAgICAgICAgICAgICAgICAgICB4OiBjMS54ICsgcjIsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogYzEueSArIHJlc29sdXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgYzE6IGMxLFxyXG4gICAgICAgICAgICAgICAgICAgIGMyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3I6ICdoJyxcclxuICAgICAgICAgICAgICAgICAgICB4OiBjMi54ICsgcjIsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogYzIueSxcclxuICAgICAgICAgICAgICAgICAgICBjMTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIGMyOiBjMixcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGMxID0gYzJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbWFrZSB2ZXJ0aWNhbCBzaWRlc1xyXG4gICAgICAgIC8vc29ydCBjZWxscyBieSB5IGFuZCB4XHJcbiAgICAgICAgY2VsbHMuc29ydCgoYzEsIGMyKSA9PiAoYzIueSA9PSBjMS55ID8gYzEueCAtIGMyLnggOiBjMS55IC0gYzIueSkpXHJcbiAgICAgICAgYzEgPSBjZWxsc1swXVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGMyID0gY2VsbHNbaV1cclxuXHJcbiAgICAgICAgICAgIGlmIChjMS54ICsgcmVzb2x1dGlvbiA9PSBjMi54ICYmIGMxLnkgPT0gYzIueSlcclxuICAgICAgICAgICAgICAgIC8vY2VsbHMgaW4gc2FtZSByb3cgYW5kIHRvdWNoIGFsb25nIHZlcnRpY2FsIHNpZGVcclxuICAgICAgICAgICAgICAgIC8vbWFrZSBzaGFyZWQgc2lkZVxyXG4gICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3I6ICd2JyxcclxuICAgICAgICAgICAgICAgICAgICB4OiBjMS54ICsgcmVzb2x1dGlvbixcclxuICAgICAgICAgICAgICAgICAgICB5OiBjMS55ICsgcjIsXHJcbiAgICAgICAgICAgICAgICAgICAgYzE6IGMxLFxyXG4gICAgICAgICAgICAgICAgICAgIGMyOiBjMixcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9jZWxscyBkbyBub3QgdG91Y2ggYWxvbmcgdmVydGljYWwgc2lkZVxyXG4gICAgICAgICAgICAgICAgLy9tYWtlIHR3byBzaWRlczogcmlnaHQgb25lIGZvciBjMSwgbGVmdCBmb3IgYzJcclxuICAgICAgICAgICAgICAgIHNpZGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG9yOiAndicsXHJcbiAgICAgICAgICAgICAgICAgICAgeDogYzEueCArIHJlc29sdXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgeTogYzEueSArIHIyLFxyXG4gICAgICAgICAgICAgICAgICAgIGMxOiBjMSxcclxuICAgICAgICAgICAgICAgICAgICBjMjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIHNpZGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG9yOiAndicsXHJcbiAgICAgICAgICAgICAgICAgICAgeDogYzIueCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBjMi55ICsgcjIsXHJcbiAgICAgICAgICAgICAgICAgICAgYzE6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICBjMjogYzIsXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjMSA9IGMyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaWRlc1xyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9jb3JlL1N0eWxlLmpzJ1xyXG5pbXBvcnQgeyBtYWtlV2ViR0xDYW52YXMgfSBmcm9tICcuLi91dGlscy93ZWJHTFV0aWxzLmpzJ1xyXG5pbXBvcnQgeyBXZWJHTFNxdWFyZUNvbG9yaW5nQ2F0QWR2YW5jZWQgfSBmcm9tICcuLi91dGlscy9XZWJHTFNxdWFyZUNvbG9yaW5nQ2F0QWR2YW5jZWQuanMnXHJcblxyXG4vKipcclxuICogU3R5bGUgYmFzZWQgb24gd2ViR0xcclxuICogVG8gc2hvdyBjZWxscyBhcyBjb2xvcmVkIHNxdWFyZXMsIGZyb20gY2F0ZWdvcmllcy5cclxuICogQWxsIGNlbGxzIGFyZSBkcmF3biBhcyBzcXVhcmVzLCB3aXRoIHRoZSBzYW1lIHNpemVcclxuICpcclxuICogQG1vZHVsZSBzdHlsZVxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU3F1YXJlQ29sb3JDYXRlZ29yeVdlYkdMU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjYXRlZ29yeSBjb2RlIG9mIHRoZSBjZWxsLCBmb3IgY29sb3JpbmcuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCk6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuY29kZSA9IG9wdHMuY29kZVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGljdGlvbmFyeSAoY29kZSAtPiBjb2xvcikgd2hpY2ggZ2l2ZXMgdGhlIGNvbG9yIG9mIGVhY2ggY2F0ZWdvcnkgY29kZS5cclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fSAqL1xyXG4gICAgICAgIG9wdHMuY29sb3IgPSBvcHRzLmNvbG9yIHx8IHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAvKiogQHR5cGUgeyBBcnJheS48c3RyaW5nPiB9ICovXHJcbiAgICAgICAgY29uc3QgY29kZXMgPSBPYmplY3Qua2V5cyhvcHRzLmNvbG9yKVxyXG5cclxuICAgICAgICAvKiogQHR5cGUgeyBvYmplY3QgfSBAcHJpdmF0ZSAqL1xyXG4gICAgICAgIHRoaXMuY2F0VG9JID0ge31cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSsrKSB0aGlzLmNhdFRvSVtjb2Rlc1tpXV0gPSBpICsgJydcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHsgQXJyYXkuPHN0cmluZz4gfSBAcHJpdmF0ZSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3JzID0gW11cclxuICAgICAgICBmb3IgKGNvbnN0IGNvZGUgb2YgY29kZXMpIHRoaXMuY29sb3JzLnB1c2gob3B0cy5jb2xvclsnJyArIGNvZGVdKVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgc2l6ZSBvZiB0aGUgY2VsbHMsIGluIGdlb2dyYXBoaWNhbCB1bml0LiBBbGwgY2VsbHMgaGF2ZSB0aGUgc2FtZSBzaXplLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5zaXplID0gb3B0cy5zaXplIC8vIChyZXNvbHV0aW9uLCB6KSA9PiAuLi5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7IFdlYkdMU3F1YXJlQ29sb3JpbmdDYXRBZHZhbmNlZCB9ICovXHJcbiAgICAgICAgdGhpcy53Z3AgPSBuZXcgV2ViR0xTcXVhcmVDb2xvcmluZ0NhdEFkdmFuY2VkKHRoaXMuY29sb3JzKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0LmpzXCIpLkNlbGw+fSBjZWxsc1xyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhcy5qc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb25cclxuICAgICAqL1xyXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgLy9maWx0ZXJcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGNvbnN0IHogPSBnZW9DYW52YXMudmlldy56XHJcblxyXG4gICAgICAgIC8vYWRkIHZlcnRpY2UgYW5kIGZyYWdtZW50IGRhdGFcclxuICAgICAgICBjb25zdCByMiA9IHJlc29sdXRpb24gLyAyXHJcbiAgICAgICAgbGV0IGMsXHJcbiAgICAgICAgICAgIG5iID0gY2VsbHMubGVuZ3RoXHJcbiAgICAgICAgY29uc3QgdmVydGljZXNCdWZmZXIgPSBbXVxyXG4gICAgICAgIGNvbnN0IGlCdWZmZXIgPSBbXVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmI7IGkrKykge1xyXG4gICAgICAgICAgICBjID0gY2VsbHNbaV1cclxuICAgICAgICAgICAgY29uc3QgY2F0ID0gdGhpcy5jb2RlKGMpXHJcbiAgICAgICAgICAgIGlmIChjYXQgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5leHBlY3RlZCBjYXRlZ29yeTogJyArIGNhdClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IGlfID0gdGhpcy5jYXRUb0lbY2F0XVxyXG4gICAgICAgICAgICBpZiAoaXNOYU4oK2lfKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VuZXhwZWN0ZWQgY2F0ZWdvcnkgaW5kZXg6ICcgKyBjYXQgKyAnICcgKyBpXylcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmVydGljZXNCdWZmZXIucHVzaChjLnggKyByMiwgYy55ICsgcjIpXHJcbiAgICAgICAgICAgIGlCdWZmZXIucHVzaCgraV8pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NyZWF0ZSBjYW52YXMgYW5kIHdlYmdsIHJlbmRlcmVyXHJcbiAgICAgICAgY29uc3QgY3ZXR0wgPSBtYWtlV2ViR0xDYW52YXMoZ2VvQ2FudmFzLncgKyAnJywgZ2VvQ2FudmFzLmggKyAnJylcclxuICAgICAgICBpZiAoIWN2V0dMKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHdlYkdMJylcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXdcclxuICAgICAgICBjb25zdCBzaXplR2VvID0gdGhpcy5zaXplID8gdGhpcy5zaXplKHJlc29sdXRpb24sIHopIDogcmVzb2x1dGlvbiArIDAuMiAqIHpcclxuICAgICAgICB0aGlzLndncC5kcmF3KGN2V0dMLmdsLCB2ZXJ0aWNlc0J1ZmZlciwgaUJ1ZmZlciwgZ2VvQ2FudmFzLmdldFdlYkdMVHJhbnNmb3JtKCksIHNpemVHZW8gLyB6KVxyXG5cclxuICAgICAgICAvL2RyYXcgaW4gY2FudmFzIGdlb1xyXG4gICAgICAgIGdlb0NhbnZhcy5pbml0Q2FudmFzVHJhbnNmb3JtKClcclxuICAgICAgICBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4LmRyYXdJbWFnZShjdldHTC5jYW52YXMsIDAsIDApXHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiB9KVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9jb3JlL1N0eWxlLmpzJ1xyXG5pbXBvcnQgeyBtYWtlV2ViR0xDYW52YXMgfSBmcm9tICcuLi91dGlscy93ZWJHTFV0aWxzLmpzJ1xyXG5pbXBvcnQgeyBXZWJHTFNxdWFyZUNvbG9yaW5nQWR2YW5jZWQgfSBmcm9tICcuLi91dGlscy9XZWJHTFNxdWFyZUNvbG9yaW5nQWR2YW5jZWQuanMnXHJcblxyXG4vKipcclxuICogU3R5bGUgYmFzZWQgb24gd2ViR0xcclxuICogVG8gc2hvdyBjZWxscyBhcyBjb2xvcmVkIHNxdWFyZXMsIHdpdGggY29tcHV0YXRpb24gb2YgdGhlIGNvbG9ycyBvbiBHUFUgc2lkZSAoZmFzdGVyIHRoYW4gSmF2YVNjcmlwdCBzaWRlKS5cclxuICogQWxscyBzcXVhcmVzIHdpdGggdGhlIHNhbWUgc2l6ZVxyXG4gKlxyXG4gKiBAbW9kdWxlIHN0eWxlXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTcXVhcmVDb2xvcldlYkdMU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgdCB2YWx1ZSAod2l0aGluIFswLDFdKSBmb3IgYSBjZWxsLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsbnVtYmVyLG51bWJlcixvYmplY3QpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnRGdW4gPSBvcHRzLnRGdW4gLy8oYyxyLHosdnMpID0+IHt9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc3RyaWJ1dGlvbiBzdHJldGNoaW5nIG1ldGhvZC5cclxuICAgICAgICAgKiBUaGUgc3RyZXRjaGluZyBpcyBwZXJmb3JtZWQgb24gR1BVIHNpZGUgKGZyYWdtZW50IHNoYWRlcikuXHJcbiAgICAgICAgICogQHR5cGUge3sgZnVuOnN0cmluZywgYWxwaGE6bnVtYmVyIH19ICovXHJcbiAgICAgICAgdGhpcy5zdHJldGNoaW5nID0gb3B0cy5zdHJldGNoaW5nXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzYW1wbGUgb2YgdGhlIGNvbG9yIHJhbXAuXHJcbiAgICAgICAgICogVGhlIGNvbG9yIGlzIGNvbXB1dGVkIG9uIEdQVSBzaWRlIChmcmFnbWVudCBzaGFkZXIpIGJhc2VkIG9uIHRob3NlIHZhbHVlcyAobGluZWFyIGludGVycG9sYXRpb24pLlxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn0gKi9cclxuICAgICAgICB0aGlzLmNvbG9ycyA9XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzIHx8XHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICdyZ2IoMTU4LCAxLCA2NiknLFxyXG4gICAgICAgICAgICAgICAgJ3JnYigyNDgsIDE0MiwgODMpJyxcclxuICAgICAgICAgICAgICAgICdyZ2IoMjUxLCAyNDgsIDE3NiknLFxyXG4gICAgICAgICAgICAgICAgJ3JnYigxMzcsIDIwNywgMTY1KScsXHJcbiAgICAgICAgICAgICAgICAncmdiKDk0LCA3OSwgMTYyKScsXHJcbiAgICAgICAgICAgIF0ucmV2ZXJzZSgpXHJcbiAgICAgICAgaWYgKG9wdHMuY29sb3IpXHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JzID0gW1xyXG4gICAgICAgICAgICAgICAgb3B0cy5jb2xvcigwKSxcclxuICAgICAgICAgICAgICAgIG9wdHMuY29sb3IoMC4yKSxcclxuICAgICAgICAgICAgICAgIG9wdHMuY29sb3IoMC40KSxcclxuICAgICAgICAgICAgICAgIG9wdHMuY29sb3IoMC42KSxcclxuICAgICAgICAgICAgICAgIG9wdHMuY29sb3IoMC44KSxcclxuICAgICAgICAgICAgICAgIG9wdHMuY29sb3IoMSksXHJcbiAgICAgICAgICAgIF1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lIHRoZSBvcGFjaXR5IG9mIHRoZSBzdHlsZSwgd2l0aGluIFswLDFdLlxyXG4gICAgICAgICAqIElmIHRoaXMgb3BhY2l0eSBpcyBkZWZpbmVkLCB0aGUgaW5kaXZpZHVhbCBjb2xvciBvcGFjaXR5IHdpbGwgYmUgaWdub3JlZC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IG9wdHMub3BhY2l0eSAvLyAocix6KSA9PiAuLi5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpemUgb2YgdGhlIGNlbGxzLCBpbiBnZW9ncmFwaGljYWwgdW5pdC4gQWxsIGNlbGxzIGhhdmUgdGhlIHNhbWUgc2l6ZS5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZSAvLyAocmVzb2x1dGlvbiwgeikgPT4gLi4uXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbD59IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvblxyXG4gICAgICovXHJcbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcclxuXHJcbiAgICAgICAgLy9nZXQgdmlldyBzY2FsZVxyXG4gICAgICAgIGNvbnN0IHZpZXdTY2FsZSA9IHRoaXMudmlld1NjYWxlID8gdGhpcy52aWV3U2NhbGUoY2VsbHMsIHJlc29sdXRpb24sIHopIDogdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8vY3JlYXRlIGNhbnZhcyBhbmQgd2ViZ2wgcmVuZGVyZXJcclxuICAgICAgICAvL2ZvciBvcGFjaXR5IGNvbnRyb2wsIHNlZTogaHR0cHM6Ly93ZWJnbGZ1bmRhbWVudGFscy5vcmcvd2ViZ2wvbGVzc29ucy93ZWJnbC1hbmQtYWxwaGEuaHRtbFxyXG4gICAgICAgIGNvbnN0IGN2V0dMID0gbWFrZVdlYkdMQ2FudmFzKFxyXG4gICAgICAgICAgICBnZW9DYW52YXMudyArICcnLFxyXG4gICAgICAgICAgICBnZW9DYW52YXMuaCArICcnLFxyXG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgIT0gdW5kZWZpbmVkID8geyBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlIH0gOiB1bmRlZmluZWRcclxuICAgICAgICApXHJcbiAgICAgICAgaWYgKCFjdldHTCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyB3ZWJHTCcpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9hZGQgdmVydGljZSBhbmQgZnJhZ21lbnQgZGF0YVxyXG4gICAgICAgIGNvbnN0IHIyID0gcmVzb2x1dGlvbiAvIDJcclxuICAgICAgICBjb25zdCB2ZXJ0aWNlc0J1ZmZlciA9IFtdXHJcbiAgICAgICAgY29uc3QgdEJ1ZmZlciA9IFtdXHJcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcy50RnVuKGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSlcclxuICAgICAgICAgICAgaWYgKHQgPT0gbnVsbCB8fCB0ID09IHVuZGVmaW5lZCkgY29udGludWVcclxuICAgICAgICAgICAgdmVydGljZXNCdWZmZXIucHVzaChjZWxsLnggKyByMiwgY2VsbC55ICsgcjIpXHJcbiAgICAgICAgICAgIHRCdWZmZXIucHVzaCh0ID4gMSA/IDEgOiB0IDwgMCA/IDAgOiB0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb21wdXRlIHBpeGVsIHNpemVcclxuICAgICAgICBjb25zdCBzaXplR2VvID0gdGhpcy5zaXplID8gdGhpcy5zaXplKHJlc29sdXRpb24sIHopIDogcmVzb2x1dGlvbiArIDAuMiAqIHpcclxuXHJcbiAgICAgICAgLy9jb21wdXRlIG9wYWNpdHlcclxuICAgICAgICBjb25zdCBvcCA9IHRoaXMub3BhY2l0eSA/IHRoaXMub3BhY2l0eShyZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGNvbnN0IHdncCA9IG5ldyBXZWJHTFNxdWFyZUNvbG9yaW5nQWR2YW5jZWQoY3ZXR0wuZ2wsIHRoaXMuY29sb3JzLCB0aGlzLnN0cmV0Y2hpbmcsIHNpemVHZW8gLyB6LCBvcClcclxuXHJcbiAgICAgICAgLy9kcmF3XHJcbiAgICAgICAgd2dwLmRyYXcodmVydGljZXNCdWZmZXIsIHRCdWZmZXIsIGdlb0NhbnZhcy5nZXRXZWJHTFRyYW5zZm9ybSgpKVxyXG5cclxuICAgICAgICAvLyBkcmF3IGluIGNhbnZhcyBnZW9cclxuICAgICAgICAvLyBOT1RFOiBkcmF3aW5nIGVhY2ggdGlsZSB0aGlzIHdheSBpcyB2ZXJ5IGluZWZmaWNpZW50LiBXZWJHTCBpcyBiZXN0IHVzZWQgd2l0aCBmZXdlciwgaGVhdmllci9sYXJnZXIgZHJhdyBjYWxscy5cclxuICAgICAgICBnZW9DYW52YXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXHJcbiAgICAgICAgZ2VvQ2FudmFzLm9mZnNjcmVlbkN0eC5kcmF3SW1hZ2UoY3ZXR0wuY2FudmFzLCAwLCAwKVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXHJcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHJlc29sdXRpb246IHJlc29sdXRpb24sIHo6IHosIHZpZXdTY2FsZTogdmlld1NjYWxlIH0pXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL2NvcmUvU3R5bGUuanMnXHJcblxyXG4vKipcclxuICogQG1vZHVsZSBzdHlsZVxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU3Ryb2tlU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3Igb2YgdGhlIGNlbGwuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCxudW1iZXIsbnVtYmVyLG9iamVjdCk6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBvcHRzLnN0cm9rZUNvbG9yIHx8ICgoKSA9PiAnIzY2NicpIC8vKGMscix6LHZzKSA9PiB7fVxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpemUgb2YgYSBjZWxsIGluIGdlb2dyYXBoaWNhbCB1bml0LlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsbnVtYmVyLG51bWJlcixvYmplY3QpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnNpemUgPSBvcHRzLnNpemUgfHwgKChjZWxsLCByZXNvbHV0aW9uKSA9PiByZXNvbHV0aW9uKSAvLyhjLHIseix2cykgPT4ge31cclxuXHJcbiAgICAgICAgLyoqIFRoZSBzdHJva2UgbGluZSB3aWR0aCBpbiBnZW9ncmFwaGljYWwgdW5pdC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLG51bWJlcixudW1iZXIsb2JqZWN0KTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGggfHwgKChjZWxsLCByZXNvbHV0aW9uLCB6KSA9PiB6ICogMS41KSAvLyhjLHIseix2cykgPT4ge31cclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaGFwZSBvZiBhIGNlbGwuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlcixudW1iZXIsb2JqZWN0KTppbXBvcnQoXCIuLi9jb3JlL1N0eWxlLmpzXCIpLlNoYXBlfSAqL1xyXG4gICAgICAgIHRoaXMuc2hhcGUgPSBvcHRzLnNoYXBlIHx8ICgoKSA9PiAnc3F1YXJlJykgLy8oYyxyLHosdnMpID0+IHt9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGNlbGxzIGFzIHNxdWFyZXMsIHdpdGggdmFyaW91cyBjb2xvcnMgYW5kIHNpemUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb3JlL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGdlb0NhbnZhc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb25cclxuICAgICAqL1xyXG4gICAgZHJhdyhjZWxscywgZ2VvQ2FudmFzLCByZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgLy9maWx0ZXJcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGNvbnN0IHogPSBnZW9DYW52YXMudmlldy56XHJcbiAgICAgICAgY29uc3QgY3R4ID0gZ2VvQ2FudmFzLm9mZnNjcmVlbkN0eFxyXG5cclxuICAgICAgICAvL2dldCB2aWV3IHNjYWxlXHJcbiAgICAgICAgY29uc3Qgdmlld1NjYWxlID0gdGhpcy52aWV3U2NhbGUgPyB0aGlzLnZpZXdTY2FsZShjZWxscywgcmVzb2x1dGlvbiwgeikgOiB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgY29uc3QgcjIgPSByZXNvbHV0aW9uICogMC41XHJcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjZWxscykge1xyXG4gICAgICAgICAgICAvL2NvbG9yXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuc3Ryb2tlQ29sb3IgPyB0aGlzLnN0cm9rZUNvbG9yKGMsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKCFjb2wgfHwgY29sID09PSAnbm9uZScpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbFxyXG5cclxuICAgICAgICAgICAgLy9zaXplIC0gaW4gZ2VvIHVuaXRcclxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZSA/IHRoaXMuc2l6ZShjLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogcmVzb2x1dGlvblxyXG5cclxuICAgICAgICAgICAgLy93aWR0aFxyXG4gICAgICAgICAgICBjb25zdCB3aSA9IHRoaXMuc3Ryb2tlV2lkdGggPyB0aGlzLnN0cm9rZVdpZHRoKGMsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiAxICogelxyXG4gICAgICAgICAgICBpZiAoIXdpIHx8IHdpIDw9IDApIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB3aVxyXG5cclxuICAgICAgICAgICAgLy9zaGFwZVxyXG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuc2hhcGUgPyB0aGlzLnNoYXBlKGMsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiAnc3F1YXJlJ1xyXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdub25lJykgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjLCByZXNvbHV0aW9uLCB6KVxyXG5cclxuICAgICAgICAgICAgaWYgKHNoYXBlID09PSAnc3F1YXJlJykge1xyXG4gICAgICAgICAgICAgICAgLy9kcmF3IHNxdWFyZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IHJlc29sdXRpb24gKiAoMSAtIHNpemUgLyByZXNvbHV0aW9uKSAqIDAuNVxyXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgICAgICBjdHgucmVjdChjLnggKyBkICsgb2Zmc2V0LmR4LCBjLnkgKyBkICsgb2Zmc2V0LmR5LCBzaXplLCBzaXplKVxyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdjaXJjbGUnKSB7XHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgY2lyY2xlXHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGN0eC5hcmMoYy54ICsgcjIgKyBvZmZzZXQuZHgsIGMueSArIHIyICsgb2Zmc2V0LmR5LCBzaXplICogMC41LCAwLCAyICogTWF0aC5QSSwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKClcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2RpYW1vbmQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzMiA9IHNpemUgKiAwLjVcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjLnggKyByMiAtIHMyLCBjLnkgKyByMilcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYy54ICsgcjIsIGMueSArIHIyICsgczIpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGMueCArIHIyICsgczIsIGMueSArIHIyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjLnggKyByMiwgYy55ICsgcjIgLSBzMilcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYy54ICsgcjIgLSBzMiwgYy55ICsgcjIpXHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKClcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2RvbnV0Jykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm90IGltcGxlbWVudGVkJylcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3RyaWFuZ2xlX3VwJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZHIyID0gKHNpemUgLSByZXNvbHV0aW9uKSAvIDJcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjLnggLSBkcjIsIGMueSAtIGRyMilcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYy54ICsgcjIsIGMueSArIHJlc29sdXRpb24gKyBkcjIpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGMueCArIHJlc29sdXRpb24gKyBkcjIsIGMueSAtIGRyMilcclxuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICd0cmlhbmdsZV9kb3duJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZHIyID0gKHNpemUgLSByZXNvbHV0aW9uKSAvIDJcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjLnggLSBkcjIsIGMueSArIHJlc29sdXRpb24gKyBkcjIpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGMueCArIHIyLCBjLnkgLSBkcjIpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGMueCArIHJlc29sdXRpb24gKyBkcjIsIGMueSArIHJlc29sdXRpb24gKyBkcjIpXHJcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKClcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAndHJpYW5nbGVfbGVmdCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRyMiA9IChzaXplIC0gcmVzb2x1dGlvbikgLyAyXHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oYy54ICsgcmVzb2x1dGlvbiArIGRyMiwgYy55ICsgcmVzb2x1dGlvbiArIGRyMilcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYy54IC0gZHIyLCBjLnkgKyByMilcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYy54ICsgcmVzb2x1dGlvbiArIGRyMiwgYy55IC0gZHIyKVxyXG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpXHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKClcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3RyaWFuZ2xlX3JpZ2h0Jykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZHIyID0gKHNpemUgLSByZXNvbHV0aW9uKSAvIDJcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjLnggLSBkcjIsIGMueSAtIGRyMilcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYy54ICsgcmVzb2x1dGlvbiArIGRyMiwgYy55ICsgcjIpXHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGMueCAtIGRyMiwgYy55ICsgcmVzb2x1dGlvbiArIGRyMilcclxuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2hhcGU6JyArIHNoYXBlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXHJcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHJlc29sdXRpb246IHJlc29sdXRpb24sIHo6IHosIHZpZXdTY2FsZTogdmlld1NjYWxlIH0pXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTaWRlU3R5bGUgfSBmcm9tICcuL1NpZGVTdHlsZS5qcydcclxuaW1wb3J0IHsgU3F1YXJlQ29sb3JDYXRlZ29yeVdlYkdMU3R5bGUgfSBmcm9tICcuL1NxdWFyZUNvbG9yQ2F0ZWdvcnlXZWJHTFN0eWxlLmpzJ1xyXG5pbXBvcnQgeyBjbGFzc2lmaWVyIGFzIGNsRnVuLCBjb2xvckNsYXNzaWZpZXIgYXMgY2NsRnVuIH0gZnJvbSAnLi4vdXRpbHMvc2NhbGUuanMnXHJcblxyXG4vKipcclxuICogQHNlZSBodHRwczovL21hbmlmb2xkLm5ldC9kb2MvbWZkOS9leGFtcGxlX190YW5ha2FfY29udG91cnMuaHRtXHJcbiAqXHJcbiAqIEBtb2R1bGUgc3R5bGVcclxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRhbmFrYVN0eWxlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwpOm51bWJlcn0gdmFsdWUgRnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGNlbGxcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGJyZWFrcyBUaGUgYnJlYWsgdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgVGhlIGNvbG9ycywgb25lIG1vcmUgdGhhbiB0aGUgYnJlYWsgdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xyXG4gICAgICogQHJldHVybnMge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL1N0eWxlXCIpLlN0eWxlPn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCh2YWx1ZSwgYnJlYWtzLCBjb2xvcnMsIG9wdHMgPSB7fSkge1xyXG4gICAgICAgIC8vc2hhZG93IGNvbG9yc1xyXG4gICAgICAgIG9wdHMuY29sb3JEYXJrID0gb3B0cy5jb2xvckRhcmsgfHwgJyMxMTEnXHJcbiAgICAgICAgb3B0cy5jb2xvckJyaWdodCA9IG9wdHMuY29sb3JCcmlnaHQgfHwgJyNkZGQnXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7IGZ1bmN0aW9uKG51bWJlciwgbnVtYmVyKTpudW1iZXIgfSAqL1xyXG4gICAgICAgIG9wdHMud2lkdGggPVxyXG4gICAgICAgICAgICBvcHRzLndpZHRoIHx8XHJcbiAgICAgICAgICAgICgoc2lkZVZhbHVlLCByZXNvbHV0aW9uLCB6KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5XRyA9IDEgKiB6XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhXRyA9IDQgKiB6XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gKG1heFdHIC0gbWluV0cpIC8gM1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKG1pbldHICsgKHNpZGVWYWx1ZSAtIDEpICogc3RlcCwgbWF4V0cpXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vbWFrZSBjbGFzc2lmaWVyXHJcbiAgICAgICAgY29uc3QgY2xhc3NpZmllciA9IGNsRnVuKGJyZWFrcylcclxuICAgICAgICAvL21ha2UgY29sb3JzIHRhYmxlXHJcbiAgICAgICAgY29uc3QgY29sb3JzRGljdCA9IHt9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIGNvbG9yc0RpY3RbaSArICcnXSA9IGNvbG9yc1tpXVxyXG5cclxuICAgICAgICBjb25zdCBjZWxsU3R5bGUgPSBuZXcgU3F1YXJlQ29sb3JDYXRlZ29yeVdlYkdMU3R5bGUoe1xyXG4gICAgICAgICAgICBjb2RlOiAoY2VsbCkgPT4gY2xhc3NpZmllcih2YWx1ZShjZWxsKSksXHJcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcnNEaWN0LFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGNvbnN0IGdldFNpZGVWYWx1ZSA9IChzaWRlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsMSA9IHNpZGUuYzEgPyBjbGFzc2lmaWVyKHZhbHVlKHNpZGUuYzEpKSA6IC0xXHJcbiAgICAgICAgICAgIGNvbnN0IGNsMiA9IHNpZGUuYzIgPyBjbGFzc2lmaWVyKHZhbHVlKHNpZGUuYzIpKSA6IC0xXHJcbiAgICAgICAgICAgIHJldHVybiBjbDEgLSBjbDJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKiBUaGUgc2lkZSBzdHlsZSwgZm9yIHRoZSBzaGFkb3cgZWZmZWN0ICovXHJcbiAgICAgICAgY29uc3Qgc2lkZVN0eWxlID0gbmV3IFNpZGVTdHlsZSh7XHJcbiAgICAgICAgICAgIC8vd2hpdGUgb3IgYmxhY2ssIGRlcGVuZGluZyBvbiBvcmllbnRhdGlvbiBhbmQgdmFsdWVcclxuICAgICAgICAgICAgY29sb3I6IChzaWRlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gZ2V0U2lkZVZhbHVlKHNpZGUpXHJcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCkgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2lkZS5vciA9PT0gJ3YnKSByZXR1cm4gdiA8IDAgPyBvcHRzLmNvbG9yQnJpZ2h0IDogb3B0cy5jb2xvckRhcmtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2IDwgMCA/IG9wdHMuY29sb3JEYXJrIDogb3B0cy5jb2xvckJyaWdodFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvL3dpZHRoIGRlcGVuZHMgb24gdGhlIHZhbHVlLCB0aGF0IGlzIHRoZSBudW1iZXIgb2YgY2xhc3NlcyBvZiBkaWZmZXJlbmNlXHJcbiAgICAgICAgICAgIHdpZHRoOiAoc2lkZSwgcmVzb2x1dGlvbiwgeikgPT4gb3B0cy53aWR0aChNYXRoLmFicyhnZXRTaWRlVmFsdWUoc2lkZSkpLCByZXNvbHV0aW9uLCB6KSxcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gW2NlbGxTdHlsZSwgc2lkZVN0eWxlXVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9jb3JlL1N0eWxlLmpzJ1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgc3R5bGVcclxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRleHRTdHlsZSBleHRlbmRzIFN0eWxlIHtcclxuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB0ZXh0IG9mIGEgY2VsbC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLCBudW1iZXIsIG51bWJlciwgb2JqZWN0KTpzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy50ZXh0ID0gb3B0cy50ZXh0IHx8ICgoKSA9PiAnWCcpIC8vKGMscix6LHZzKSA9PiB7fVxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIHRoZSBjZWxsLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKCkgPT4gJ2JsYWNrJykgLy8oYyxyLHosdnMpID0+IHt9XHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgZm9udCBzaXplIG9mIGEgY2VsbCBpbiBnZW8gdW5pdC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KCcuLi9jb3JlL0RhdGFzZXQuanMnKS5DZWxsLCBudW1iZXIsIG51bWJlcixvYmplY3QpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLmZvbnRTaXplID0gb3B0cy5mb250U2l6ZSB8fCAoKGNlbGwsIHJlc29sdXRpb24pID0+IHJlc29sdXRpb24pIC8vKGMscix6LHZzKSA9PiB7fVxyXG5cclxuICAgICAgICAvKiogVGhlIHRleHQgZm9udCBmYW1pbHkuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9IG9wdHMuZm9udEZhbWlseSB8fCAoKCkgPT4gJ0FyaWFsJylcclxuXHJcbiAgICAgICAgLyoqIFRoZSB0ZXh0IGZvbnQgd2VpZ2h0LlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmZvbnRXZWlnaHQgPSBvcHRzLmZvbnRXZWlnaHQgfHwgKCgpID0+ICdib2xkJylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgY2VsbHMgYXMgdGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvblxyXG4gICAgICovXHJcbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcclxuICAgICAgICBjb25zdCBjdHggPSBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4XHJcbiAgICAgICAgLy9nZXQgdmlldyBzY2FsZVxyXG4gICAgICAgIGNvbnN0IHZpZXdTY2FsZSA9IHRoaXMudmlld1NjYWxlID8gdGhpcy52aWV3U2NhbGUoY2VsbHMsIHJlc29sdXRpb24sIHopIDogdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8vZHJhdyB3aXRoIEhUTUwgY2FudmFzXHJcbiAgICAgICAgLy9pbiBzY3JlZW4gY29vcmRpbmF0ZXNcclxuICAgICAgICBnZW9DYW52YXMuaW5pdENhbnZhc1RyYW5zZm9ybSgpXHJcblxyXG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgLy9nZXQgY2VsbCB0ZXh0XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLnRleHQgPyB0aGlzLnRleHQoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAodGV4dCA9PSB1bmRlZmluZWQgfHwgdGV4dCA9PSBudWxsIHx8IHRleHQgKyAnJyA9PT0gJycpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL2NvbG9yXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sb3IgPyB0aGlzLmNvbG9yKGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKCFjb2wpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xcclxuXHJcbiAgICAgICAgICAgIC8vZm9udCBzaXplXHJcbiAgICAgICAgICAgIC8vc2l6ZSAtIGluIHBpeGVsIHVuaXRcclxuICAgICAgICAgICAgY29uc3QgZm9udFNpemVQaXggPSB0aGlzLmZvbnRTaXplKGNlbGwsIHJlc29sdXRpb24sIHosIHZpZXdTY2FsZSkgLyB6XHJcbiAgICAgICAgICAgIGlmICghZm9udFNpemVQaXgpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL3NldCBmb250XHJcbiAgICAgICAgICAgIGNvbnN0IGZvbnRGYW1pbHkgPSB0aGlzLmZvbnRGYW1pbHkgPyB0aGlzLmZvbnRGYW1pbHkoY2VsbCwgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6ICdBcmlhbCdcclxuICAgICAgICAgICAgY29uc3QgZm9udFdlaWdodCA9IHRoaXMuZm9udFdlaWdodCA/IHRoaXMuZm9udFdlaWdodChjZWxsLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogJ2JvbGQnXHJcbiAgICAgICAgICAgIGN0eC5mb250ID0gZm9udFdlaWdodCArICcgJyArIGZvbnRTaXplUGl4ICsgJ3B4ICcgKyBmb250RmFtaWx5XHJcblxyXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoY2VsbCwgcmVzb2x1dGlvbiwgeilcclxuXHJcbiAgICAgICAgICAgIC8vdGV4dCBwb3NpdGlvblxyXG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcidcclxuICAgICAgICAgICAgY29uc3QgdHggPSBnZW9DYW52YXMuZ2VvVG9QaXhYKGNlbGwueCArIHJlc29sdXRpb24gKiAwLjUgKyBvZmZzZXQuZHgpXHJcbiAgICAgICAgICAgIGNvbnN0IHR5ID0gZ2VvQ2FudmFzLmdlb1RvUGl4WShjZWxsLnkgKyByZXNvbHV0aW9uICogMC41ICsgb2Zmc2V0LmR5KSArIGZvbnRTaXplUGl4ICogMC4zIC8vaXQgc2hvdWxkIGJlIDAuNSBidXQgMC4zIHNlZW1zIHRvIHdvcmsgYmV0dGVyXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgdGhlIHRleHRcclxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIHR4LCB0eSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiwgdmlld1NjYWxlOiB2aWV3U2NhbGUgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkIGEgZnVuY3Rpb24gWzAsMV0tPnN0cmluZyBmb3IgY2hhcmFjdGVycyBsZWdlbmRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjaGFyc1xyXG4gICAgICogQHBhcmFtIHsoZnVuY3Rpb24obnVtYmVyKTpudW1iZXIpfHVuZGVmaW5lZH0gc2NhbGVcclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihudW1iZXIpOnN0cmluZ31cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRleHRTY2FsZShjaGFycywgc2NhbGUgPSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb25zdCBuYiA9IGNoYXJzLmxlbmd0aFxyXG4gICAgICAgIHJldHVybiAodCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc2NhbGUpIHQgPSBzY2FsZSh0KVxyXG4gICAgICAgICAgICBpZiAodCA9PSAwKSByZXR1cm4gJydcclxuICAgICAgICAgICAgaWYgKHQgPj0gMSkgcmV0dXJuIGNoYXJzW25iIC0gMV1cclxuICAgICAgICAgICAgcmV0dXJuIGNoYXJzW01hdGguZmxvb3IodCAqIG5iKV1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL2NvcmUvU3R5bGUuanMnXHJcblxyXG4vKiogQHR5cGVkZWYge1wiZmlyc3RcInxcImJvdHRvbVwifFwiY2VudGVyXCJ8XCJ0b3BcInxcImxhc3RcIn0gQW5jaG9yTW9kZVlFbnVtICovXHJcblxyXG4vKipcclxuICogU2hvdyBjZWxsIGFzIHRpbWVzZXJpZXMgY2hhcnRcclxuICogQ2FuIGJlIHVzZWQgZm9yIHNwYXJrbGluZSBtYXAgb2YgaHR0cHM6Ly9kYXRhZ2lzdGlwcy5oeXBvdGhlc2VzLm9yZy80ODhcclxuICpcclxuICogQG1vZHVsZSBzdHlsZVxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGltZVNlcmllc1N0eWxlIGV4dGVuZHMgU3R5bGUge1xyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogVGhlIGNvbHVtbnMgb2YgdGhlIHRpbWUgc2VyaWVzLCBvcmRlcmVkIGluIGNocm9ub2xvZ2ljYWwgb3JkZXIuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fSAqL1xyXG4gICAgICAgIHRoaXMudHMgPSBvcHRzLnRzXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHNwZWNpZnlpbmcgd2hlbiBhIHZhbHVlIHNob3VsZCBiZSBjb25zaWRlcmVkIGFzIFwibm8gZGF0YVwiIGFuZCB0aHVzIG5vdCBpZ25vcmVkLiBUaGUgbGluZSB3aWxsIGhhdmUgYSBicmVhayBhdCB0aGVzZSB2YWx1ZXMuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKHN0cmluZyk6Ym9vbGVhbn0gKi9cclxuICAgICAgICB0aGlzLm5vRGF0YSA9IG9wdHMubm9EYXRhIHx8ICgodikgPT4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT0gJycgfHwgdiA9PT0gbnVsbCB8fCBpc05hTigrdikpXHJcblxyXG4gICAgICAgIC8veFxyXG4gICAgICAgIC8qKiBpbiBnZW8gdW5pdFxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbCxudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5vZmZzZXRYID0gb3B0cy5vZmZzZXRYIHx8ICgoYywgciwgeikgPT4gMClcclxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAoKGMsIHIsIHopID0+IHIpXHJcblxyXG4gICAgICAgIC8veVxyXG4gICAgICAgIC8qKiBpbiBnZW8gdW5pdFxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbCxudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5vZmZzZXRZID0gb3B0cy5vZmZzZXRZIHx8ICgoYywgciwgeikgPT4gMClcclxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0IHx8ICgoYywgciwgeikgPT4gcilcclxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL2NvcmUvRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlcixudW1iZXIpOkFuY2hvck1vZGVZRW51bX0gKi9cclxuICAgICAgICB0aGlzLmFuY2hvck1vZGVZID0gb3B0cy5hbmNob3JNb2RlWSB8fCAoKGMsIHIsIHopID0+ICdjZW50ZXInKVxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHdpZHRoIG9mIHRoZSBsaW5lLCBpbiBnZW8gdW5pdFxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL2NvcmUvRGF0YXNldC5qcycpLkNlbGwsIG51bWJlciwgbnVtYmVyLCBvYmplY3QpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IG9wdHMubGluZVdpZHRoIHx8ICgodiwgciwgcywgeikgPT4gMS41ICogeilcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb2xvciBvZiB0aGUgY2hhcnQuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vY29yZS9EYXRhc2V0LmpzJykuQ2VsbCwgbnVtYmVyLCBudW1iZXIsIG9iamVjdCk6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgoKSA9PiAnYmxhY2snKSAvLyhjLHIseix2cykgPT4ge31cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgY2VsbHMgYXMgdGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXQuanNcIikuQ2VsbD59IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvcmUvR2VvQ2FudmFzLmpzXCIpLkdlb0NhbnZhc30gZ2VvQ2FudmFzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvblxyXG4gICAgICovXHJcbiAgICBkcmF3KGNlbGxzLCBnZW9DYW52YXMsIHJlc29sdXRpb24pIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgY29uc3QgeiA9IGdlb0NhbnZhcy52aWV3LnpcclxuICAgICAgICBjb25zdCBjdHggPSBnZW9DYW52YXMub2Zmc2NyZWVuQ3R4XHJcblxyXG4gICAgICAgIC8vZ2V0IHZpZXcgc2NhbGVcclxuICAgICAgICBjb25zdCB2aWV3U2NhbGUgPSB0aGlzLnZpZXdTY2FsZSA/IHRoaXMudmlld1NjYWxlKGNlbGxzLCByZXNvbHV0aW9uLCB6KSA6IHVuZGVmaW5lZFxyXG5cclxuICAgICAgICAvL2NvbXB1dGUgY2VsbCBhbXBsaXR1ZGVcclxuICAgICAgICBjb25zdCBnZXRBbXBsaXR1ZGUgPSAoYykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbWluLCBtYXhcclxuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBjW3RdXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsID09IHVuZGVmaW5lZCkgY29udGludWVcclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPT0gdW5kZWZpbmVkIHx8IHZhbCA8IG1pbikgbWluID0gdmFsXHJcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09IHVuZGVmaW5lZCB8fCB2YWwgPiBtYXgpIG1heCA9IHZhbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtaW4gPT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIHJldHVybiBtYXggLSBtaW5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY29tcHV0ZSBtYXggYW1wbGl0dWRlXHJcbiAgICAgICAgbGV0IGFtcE1heFxyXG4gICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgY29uc3QgYW1wID0gZ2V0QW1wbGl0dWRlKGMpXHJcbiAgICAgICAgICAgIGlmIChhbXAgPT0gdW5kZWZpbmVkKSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoYW1wTWF4ID09IHVuZGVmaW5lZCB8fCBhbXAgPiBhbXBNYXgpIGFtcE1heCA9IGFtcFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFtcE1heCkgcmV0dXJuXHJcblxyXG4gICAgICAgIGNvbnN0IG5iID0gdGhpcy50cy5sZW5ndGhcclxuXHJcbiAgICAgICAgY3R4LmxpbmVDYXAgPSAnYnV0dCdcclxuICAgICAgICBmb3IgKGxldCBjIG9mIGNlbGxzKSB7XHJcbiAgICAgICAgICAgIC8vbGluZSB3aWR0aFxyXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IHdHID0gdGhpcy5saW5lV2lkdGggPyB0aGlzLmxpbmVXaWR0aChjLCByZXNvbHV0aW9uLCB6LCB2aWV3U2NhbGUpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmICghd0cgfHwgd0cgPCAwKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9saW5lIGNvbG9yXHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvciA/IHRoaXMuY29sb3IoYywgcmVzb2x1dGlvbiwgeiwgdmlld1NjYWxlKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIWNvbCkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8veFxyXG4gICAgICAgICAgICBjb25zdCBvZmZYID0gdGhpcy5vZmZzZXRYID8gdGhpcy5vZmZzZXRYKGMsIHJlc29sdXRpb24sIHopIDogMFxyXG4gICAgICAgICAgICBpZiAob2ZmWCA9PSB1bmRlZmluZWQgfHwgaXNOYU4ob2ZmWCkpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoID8gdGhpcy53aWR0aChjLCByZXNvbHV0aW9uLCB6KSA6IHJlc29sdXRpb25cclxuICAgICAgICAgICAgaWYgKHcgPT0gdW5kZWZpbmVkIHx8IGlzTmFOKHcpKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy95XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZlkgPSB0aGlzLm9mZnNldFkgPyB0aGlzLm9mZnNldFkoYywgcmVzb2x1dGlvbiwgeikgOiAwXHJcbiAgICAgICAgICAgIGlmIChvZmZZID09IHVuZGVmaW5lZCB8fCBpc05hTihvZmZZKSkgY29udGludWVcclxuICAgICAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID8gdGhpcy5oZWlnaHQoYywgcmVzb2x1dGlvbiwgeikgOiByZXNvbHV0aW9uXHJcbiAgICAgICAgICAgIGlmIChoID09IHVuZGVmaW5lZCB8fCBpc05hTihoKSkgY29udGludWVcclxuICAgICAgICAgICAgY29uc3QgYW5jaFkgPSB0aGlzLmFuY2hvck1vZGVZID8gdGhpcy5hbmNob3JNb2RlWShjLCByZXNvbHV0aW9uLCB6KSA6ICdjZW50ZXInXHJcbiAgICAgICAgICAgIGlmICghYW5jaFkpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gd0dcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sXHJcblxyXG4gICAgICAgICAgICAvL2NvbXB1dGUgYW5jaG9yIFkgZmlndXJlc1xyXG4gICAgICAgICAgICBsZXQgdmFsMCwgeTBcclxuICAgICAgICAgICAgaWYgKGFuY2hZID09PSAnZmlyc3QnKSB7XHJcbiAgICAgICAgICAgICAgICAvL2dldCBmaXJzdCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgdmFsMCA9IGNbdGhpcy50c1swXV1cclxuICAgICAgICAgICAgICAgIHkwID0gMFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFuY2hZID09PSAnbGFzdCcpIHtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IGxhc3QgdmFsdWVcclxuICAgICAgICAgICAgICAgIHZhbDAgPSBjW3RoaXMudHNbdGhpcy50cy5sZW5ndGggLSAxXV1cclxuICAgICAgICAgICAgICAgIHkwID0gMFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFuY2hZID09PSAnYm90dG9tJykge1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgbWluXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSArY1t0XVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gdW5kZWZpbmVkKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwwID09IHVuZGVmaW5lZCB8fCB2YWwgPCB2YWwwKSB2YWwwID0gdmFsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB5MCA9IDBcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbmNoWSA9PT0gJ3RvcCcpIHtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IG1heFxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gK2NbdF1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09IHVuZGVmaW5lZCkgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsMCA9PSB1bmRlZmluZWQgfHwgdmFsID4gdmFsMCkgdmFsMCA9IHZhbFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeTAgPSByZXNvbHV0aW9uXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5jaFkgPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAvL2dldCBtaW4gYW5kIG1heFxyXG4gICAgICAgICAgICAgICAgbGV0IG1pbiwgbWF4XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBjW3RdXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PSB1bmRlZmluZWQpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA9PSB1bmRlZmluZWQgfHwgdmFsIDwgbWluKSBtaW4gPSB2YWxcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4ID09IHVuZGVmaW5lZCB8fCB2YWwgPiBtYXgpIG1heCA9IHZhbFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFsMCA9ICgrbWF4ICsgK21pbikgKiAwLjVcclxuICAgICAgICAgICAgICAgIHkwID0gcmVzb2x1dGlvbiAvIDJcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmV4cGVjdGVkIGFuY2hvck1vZGVZOiAnICsgYW5jaFkpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKi9kcmF3IGxpbmVcclxuICAgICAgICAgICAgaWYgKHZhbDAgPT0gdW5kZWZpbmVkIHx8IGlzTmFOKHZhbDApKSBjb250aW51ZVxyXG4gICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgY29uc3Qgc1ggPSB3IC8gKG5iIC0gMSlcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBjW3RoaXMudHNbaV1dXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsID09IHVuZGVmaW5lZCB8fCBpc05hTih2YWwpKSBicmVha1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKGMueCArIGkgKiBzWCArIG9mZlgsIGMueSArIHkwICsgKHZhbCAtIHZhbDApICogaCAvIGFtcE1heCArIG9mZlkpXHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjLnggKyBpICogc1ggKyBvZmZYLCBjLnkgKyB5MCArICh2YWwgLSB2YWwwKSAqIGggLyBhbXBNYXggKyBvZmZZKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKSovXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgbGluZSwgc2VnbWVudCBieSBzZWdtZW50XHJcbiAgICAgICAgICAgIGNvbnN0IHNYID0gdyAvIChuYiAtIDEpXHJcblxyXG4gICAgICAgICAgICAvL2hhbmRsZSBmaXJzdCBwb2ludFxyXG4gICAgICAgICAgICBsZXQgdjAgPSBjW3RoaXMudHNbMF1dXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0RhdGEodjApKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oYy54ICsgb2ZmWCwgYy55ICsgeTAgKyAoKHYwIC0gdmFsMCkgKiBoKSAvIGFtcE1heCArIG9mZlkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh2MCwgaXNOYU4odjApKVxyXG5cclxuICAgICAgICAgICAgbGV0IHYxXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdjEgPSBjW3RoaXMudHNbaV1dXHJcblxyXG4gICAgICAgICAgICAgICAgLy9kcmF3IHNlZ21lbnQgZnJvbSB2MCB0byB2MVxyXG5cclxuICAgICAgICAgICAgICAgIC8vYm90aCBwb2ludHMgJ25vIGRhdGEnXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub0RhdGEodjApICYmIHRoaXMubm9EYXRhKHYxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vc2Vjb25kIHBvaW50ICdubyBkYXRhJ1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5ub0RhdGEodjApICYmIHRoaXMubm9EYXRhKHYxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IHBvaW50ICdubyBkYXRhJ1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5vRGF0YSh2MCkgJiYgIXRoaXMubm9EYXRhKHYxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oYy54ICsgaSAqIHNYICsgb2ZmWCwgYy55ICsgeTAgKyAoKHYxIC0gdmFsMCkgKiBoKSAvIGFtcE1heCArIG9mZlkpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYm90aCBwb2ludHMgaGF2ZSBkYXRhOiB0cmFjZSBsaW5lXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oYy54ICsgaSAqIHNYICsgb2ZmWCwgYy55ICsgeTAgKyAoKHYxIC0gdmFsMCkgKiBoKSAvIGFtcE1heCArIG9mZlkpXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCBpcyB0aGUgbGFzdCBwb2ludCwgc3Ryb2tlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gbmIgLSAxKSBjdHguc3Ryb2tlKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHYwID0gdjFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy91cGRhdGUgbGVnZW5kLCBpZiBhbnlcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwgejogeiwgdmlld1NjYWxlOiB2aWV3U2NhbGUgfSlcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IGluaXRTaGFkZXJQcm9ncmFtLCBjcmVhdGVTaGFkZXIgfSBmcm9tICcuL3dlYkdMVXRpbHMuanMnXHJcbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnZDMtY29sb3InXHJcblxyXG4vKipcclxuICogRXZlcnl0aGluZyB0byBlYXNpbHkgZHJhdyBjb2xvcmVkIHNxdWFyZXMgd2l0aCB3ZWJHTC5cclxuICogQWxsIHRoZSBzYW1lIHNpemUsIGJ1dCBkaWZmZXJlbnQgZmlsbCBjb2xvci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXZWJHTFNxdWFyZUNvbG9yaW5nIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgc2l6ZVBpeCkge1xyXG4gICAgICAgIHRoaXMuZ2wgPSBnbFxyXG4gICAgICAgIHRoaXMuc2l6ZVBpeCA9IHNpemVQaXggfHwgMTAuMFxyXG5cclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBpbml0U2hhZGVyUHJvZ3JhbShcclxuICAgICAgICAgICAgZ2wsXHJcbiAgICAgICAgICAgIGNyZWF0ZVNoYWRlcihcclxuICAgICAgICAgICAgICAgIGdsLFxyXG4gICAgICAgICAgICAgICAgZ2wuVkVSVEVYX1NIQURFUixcclxuICAgICAgICAgICAgICAgIGBcclxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgcG9zO1xyXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHNpemVQaXg7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyBtYXQ7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGNvbG9yO1xyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KG1hdCAqIHZlYzMocG9zLCAxLjApLCAxLjApO1xyXG4gICAgICAgICAgICAgIGdsX1BvaW50U2l6ZSA9IHNpemVQaXg7XHJcbiAgICAgICAgICAgICAgdkNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIGBcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgY3JlYXRlU2hhZGVyKFxyXG4gICAgICAgICAgICAgICAgZ2wsXHJcbiAgICAgICAgICAgICAgICBnbC5GUkFHTUVOVF9TSEFERVIsXHJcbiAgICAgICAgICAgICAgICBgXHJcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xyXG4gICAgICAgICAgICB2b2lkIG1haW4odm9pZCkge1xyXG4gICAgICAgICAgICAgICAgdmVjNCB2Q29sb3JfID0gdkNvbG9yIC8gMjU1LjA7XHJcbiAgICAgICAgICAgICAgICB2Q29sb3JfWzNdID0gMjU1LjAgKiB2Q29sb3JfWzNdO1xyXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yXztcclxuICAgICAgICAgICAgfWBcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIClcclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSlcclxuXHJcbiAgICAgICAgLy9idWZmZXIgZGF0YVxyXG4gICAgICAgIHRoaXMudmVydGljZXNCdWZmZXIgPSBbXVxyXG4gICAgICAgIHRoaXMuY29sb3JzQnVmZmVyID0gW11cclxuICAgIH1cclxuXHJcbiAgICAvKiogQWRkIGRhdGEgdG8gdmVydGljZXMvc2l6ZS9jb2xvciBidWZmZXJzIGZvciBjb2xvciBzcXVhcmVzIGRyYXdpbmcgKi9cclxuICAgIGFkZFBvaW50RGF0YSh4QywgeUMsIGNvbCkge1xyXG4gICAgICAgIC8vY29udmVydCBjb2xvclxyXG4gICAgICAgIGNvbnN0IGNjID0gY29sb3IoY29sKVxyXG4gICAgICAgIC8vY29uc3QgY2MgPSB7cjo0NSxnOjg3LGI6OTgsb3BhY2l0eTowLjl9XHJcbiAgICAgICAgaWYgKCFjYykgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vdmVydGljZXNcclxuICAgICAgICB0aGlzLnZlcnRpY2VzQnVmZmVyLnB1c2goeEMsIHlDKVxyXG4gICAgICAgIC8vY29sb3JcclxuICAgICAgICB0aGlzLmNvbG9yc0J1ZmZlci5wdXNoKGNjLnIsIGNjLmcsIGNjLmIsIGNjLm9wYWNpdHkpXHJcbiAgICB9XHJcblxyXG4gICAgYWRkUG9pbnREYXRhMih4QywgeUMsIHIsIGcsIGIsIG9wYWNpdHkpIHtcclxuICAgICAgICAvL3ZlcnRpY2VzXHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlc0J1ZmZlci5wdXNoKHhDLCB5QylcclxuICAgICAgICAvL2NvbG9yXHJcbiAgICAgICAgdGhpcy5jb2xvcnNCdWZmZXIucHVzaChyLCBnLCBiLCBvcGFjaXR5KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiAgKi9cclxuICAgIGRyYXcodHJhbnNmb01hdCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbFxyXG5cclxuICAgICAgICAvL3ZlcnRpY2UgZGF0YVxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBnbC5jcmVhdGVCdWZmZXIoKSlcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSh0aGlzLnZlcnRpY2VzQnVmZmVyKSwgZ2wuU1RBVElDX0RSQVcpXHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sICdwb3MnKVxyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgICAgICAgIHBvc2l0aW9uLFxyXG4gICAgICAgICAgICAyLCAvL251bUNvbXBvbmVudHNcclxuICAgICAgICAgICAgZ2wuRkxPQVQsIC8vdHlwZVxyXG4gICAgICAgICAgICBmYWxzZSwgLy9ub3JtYWxpc2VcclxuICAgICAgICAgICAgMCwgLy9zdHJpZGVcclxuICAgICAgICAgICAgMCAvL29mZnNldFxyXG4gICAgICAgIClcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbilcclxuXHJcbiAgICAgICAgLy9jb2xvciBkYXRhXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGdsLmNyZWF0ZUJ1ZmZlcigpKVxyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHRoaXMuY29sb3JzQnVmZmVyKSwgZ2wuU1RBVElDX0RSQVcpXHJcbiAgICAgICAgdmFyIGNvbG9yID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnY29sb3InKVxyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY29sb3IsIDQsIGdsLkZMT0FULCBmYWxzZSwgMCwgMClcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvcilcclxuXHJcbiAgICAgICAgLy9zaXplUGl4XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sICdzaXplUGl4JyksIDEuMCAqIHRoaXMuc2l6ZVBpeClcclxuXHJcbiAgICAgICAgLy90cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ21hdCcpLCBmYWxzZSwgbmV3IEZsb2F0MzJBcnJheSh0cmFuc2ZvTWF0KSlcclxuXHJcbiAgICAgICAgLy8gRW5hYmxlIHRoZSBkZXB0aCB0ZXN0XHJcbiAgICAgICAgLy9nbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XHJcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGNvbG9yIGJ1ZmZlciBiaXRcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKVxyXG4gICAgICAgIC8vIFNldCB0aGUgdmlldyBwb3J0XHJcbiAgICAgICAgLy9nbC52aWV3cG9ydCgwLCAwLCBjZy53LCBjZy5oKTtcclxuXHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIHRoaXMudmVydGljZXNCdWZmZXIubGVuZ3RoIC8gMilcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IGluaXRTaGFkZXJQcm9ncmFtLCBjcmVhdGVTaGFkZXIgfSBmcm9tICcuL3dlYkdMVXRpbHMuanMnXHJcbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnZDMtY29sb3InXHJcblxyXG4vKipcclxuICogRXZlcnl0aGluZyB0byBlYXNpbHkgZHJhdyBjb2xvcmVkIHNxdWFyZXMgd2l0aCB3ZWJHTC5cclxuICogQWxsIHRoZSBzYW1lIHNpemUsIGJ1dCBkaWZmZXJlbnQgZmlsbCBjb2xvci5cclxuICogVGhlIGNvbG9yIGludGVycG9sYXRpb24gaXMgY29tcHV0ZWQgaW4gdGhlIGZyYWdtZW50IHNoYWRlciBwcm9ncmFtLCBieSB0aGUgR1BVLCB0aHVzIGl0IGlzIGxlc3MgZmxleGlibGUgYnV0IGZhc3Rlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXZWJHTFNxdWFyZUNvbG9yaW5nQWR2YW5jZWQge1xyXG4gICAgLy9zZWU6XHJcbiAgICAvL2h0dHBzOi8vd2ViZ2xmdW5kYW1lbnRhbHMub3JnL3dlYmdsL2xlc3NvbnMvZnIvd2ViZ2wtc2hhZGVycy1hbmQtZ2xzbC5odG1sI2xlcy11bmlmb3Jtcy1kYW5zLWxlcy1zaGFkZXJzLWRlLXZlcnRleFxyXG4gICAgLy9odHRwczovL3RoZWJvb2tvZnNoYWRlcnMuY29tL2dsb3NzYXJ5Lz9zZWFyY2g9bWl4XHJcbiAgICAvL2h0dHBzOi8vdGhlYm9va29mc2hhZGVycy5jb20vMDYvXHJcbiAgICAvL2h0dHBzOi8vdGhlYm9va29mc2hhZGVycy5jb20vZ2xvc3NhcnkvXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBnbFxyXG4gICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gY29sb3JzXHJcbiAgICAgKiBAcGFyYW0ge3tmdW46c3RyaW5nLGFscGhhOm51bWJlcn19IHN0cmV0Y2hpbmdcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplUGl4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGdsb2JhbE9wYWNpdHlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ2wsIGNvbG9ycywgc3RyZXRjaGluZywgc2l6ZVBpeCA9IDEwLCBnbG9iYWxPcGFjaXR5ID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9ICovXHJcbiAgICAgICAgdGhpcy5nbCA9IGdsXHJcbiAgICAgICAgLy9nbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRydWUpO1xyXG4gICAgICAgIC8vZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcbiAgICAgICAgLy9nbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFNoYWRlcn0gKi9cclxuICAgICAgICBjb25zdCB2U2hhZGVyID0gY3JlYXRlU2hhZGVyKFxyXG4gICAgICAgICAgICBnbCxcclxuICAgICAgICAgICAgZ2wuVkVSVEVYX1NIQURFUixcclxuICAgICAgICAgICAgYFxyXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMyIHBvcztcclxuICAgICAgICB1bmlmb3JtIGZsb2F0IHNpemVQaXg7XHJcbiAgICAgICAgdW5pZm9ybSBtYXQzIG1hdDtcclxuXHJcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IHQ7XHJcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2dDtcclxuXHJcbiAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KG1hdCAqIHZlYzMocG9zLCAxLjApLCAxLjApO1xyXG4gICAgICAgICAgZ2xfUG9pbnRTaXplID0gc2l6ZVBpeDtcclxuICAgICAgICAgIHZ0ID0gdDtcclxuICAgICAgICB9XHJcbiAgICAgIGBcclxuICAgICAgICApXHJcblxyXG4gICAgICAgIC8vcHJlcGFyZSBmcmFnbWVudCBzaGFkZXIgY29kZVxyXG4gICAgICAgIC8vZGVjbGFyZSB0aGUgdW5pZm9ybSBhbmQgb3RoZXIgdmFyaWFibGVzXHJcbiAgICAgICAgbGV0IGZzaFN0cmluZyA9XHJcbiAgICAgICAgICAgICcnICtcclxuICAgICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbicgK1xyXG4gICAgICAgICAgICAndmFyeWluZyBmbG9hdCB2dDtcXG4nICtcclxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGE7XFxuJyArXHJcbiAgICAgICAgICAgICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSBbXVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIG91dC5wdXNoKCd1bmlmb3JtIHZlYzQgYycgKyBpICsgJztcXG4nKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5qb2luKCcnKVxyXG4gICAgICAgICAgICB9KSgpICtcclxuICAgICAgICAgICAgLy9zdGFydCB0aGUgbWFpbiBmdW5jdGlvbiwgYXBwbHkgdGhlIHN0cmV0Y2hpbmcgb2YgdFxyXG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHtcXG4nXHJcblxyXG4gICAgICAgIGlmIChzdHJldGNoaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChzdHJldGNoaW5nLmZ1biA9PSAncG93JylcclxuICAgICAgICAgICAgICAgIC8vc1BvdyA9ICh0LCBhbHBoYSA9IDMpID0+IE1hdGgucG93KHQsIGFscGhhKTtcclxuICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgZmxvYXQgdCA9IHBvdyh2dCwgYWxwaGEpO1xcbidcclxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyZXRjaGluZy5mdW4gPT0gJ3Bvd0ludicpXHJcbiAgICAgICAgICAgICAgICAvL3NQb3dSZXYgPSAodCwgYWxwaGEgPSAzKSA9PiAxIC0gTWF0aC5wb3coMSAtIHQsIDEgLyBhbHBoYSk7XHJcbiAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIGZsb2F0IHQgPSAxLjAtcG93KDEuMC12dCwgMS4wL2FscGhhKTtcXG4nXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmV0Y2hpbmcuZnVuID09ICdleHAnKVxyXG4gICAgICAgICAgICAgICAgLy9zRXhwID0gKHQsIGFscGhhID0gMykgPT4gYWxwaGEgPT0gMCA/IHQgOiAoTWF0aC5leHAodCAqIGFscGhhKSAtIDEpIC8gKE1hdGguZXhwKGFscGhhKSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZXRjaGluZy5hbHBoYSA9PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGZsb2F0IHQgPSB2dDtgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJyAgIGZsb2F0IHQgPSAoZXhwKHZ0ICogYWxwaGEpIC0gMS4wKSAvIChleHAoYWxwaGEpIC0gMS4wKTtcXG4nXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmV0Y2hpbmcuZnVuID09ICdsb2cnKVxyXG4gICAgICAgICAgICAgICAgLy9zRXhwUmV2ID0gKHQsIGFscGhhID0gMykgPT4gYWxwaGEgPT0gMCA/IHQgOiAxIC0gKDEgLyBhbHBoYSkgKiBNYXRoLmxvZyhNYXRoLmV4cChhbHBoYSkgKiAoMSAtIHQpICsgdCk7XHJcbiAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz1cclxuICAgICAgICAgICAgICAgICAgICBzdHJldGNoaW5nLmFscGhhID09IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgZmxvYXQgdCA9IHZ0O2BcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnICAgZmxvYXQgdCA9IDEuMCAtICgxLjAgLyBhbHBoYSkgKiBsb2coZXhwKGFscGhhKSAqICgxLjAgLSB2dCkgKyB2dCk7XFxuJ1xyXG4gICAgICAgICAgICBlbHNlIGlmIChzdHJldGNoaW5nLmZ1biA9PSAnY2lyY2xlJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0cmV0Y2hpbmcuYWxwaGEgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAvL2lmIChhbHBoYSA9PSAwKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIGZsb2F0IHQgPSB2dDtcXG4nXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJldGNoaW5nLmFscGhhID09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGFscGhhID09IDEpIHJldHVybiBNYXRoLnNxcnQoMiAqIHQgLSB0ICogdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICBmbG9hdCB0ID0gc3FydCh2dCAqICgyLjAgLSB2dCkpO1xcbidcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc3QgYSA9IGFscGhhIC8gKDEgLSBhbHBoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gTWF0aC5zcXJ0KDEgLyAoYSAqIGEpICsgdCAqICgyIC8gYSArIDIgLSB0KSkgLSAxIC8gYTtcclxuICAgICAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz1cclxuICAgICAgICAgICAgICAgICAgICAgICAgJyAgIGZsb2F0IGEgPSBhbHBoYSAvICgxLjAgLSBhbHBoYSk7XFxuJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcgICBmbG9hdCB0ID0gc3FydCgxLjAgLyAoYSAqIGEpICsgdnQgKiAoIDIuMC9hICsgMi4wIC0gdnQgKSkgLSAxLjAgLyBhO1xcbidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJldGNoaW5nLmZ1biA9PSAnY2lyY2xlSW52Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gMSAtIHNDaXJjbGVMb3coMSAtIHQsIGFscGhhKVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0cmV0Y2hpbmcuYWxwaGEgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAvL2lmIChhbHBoYSA9PSAwKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIGZsb2F0IHQgPSB2dDtcXG4nXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJldGNoaW5nLmFscGhhID09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGFscGhhID09IDEpIHJldHVybiBNYXRoLnNxcnQoMiAqIHQgLSB0ICogdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICBmbG9hdCB0ID0gMS4wIC0gc3FydCgoMS4wIC0gdnQpICogKDEuMCArIHZ0KSk7XFxuJ1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBhID0gYWxwaGEgLyAoMSAtIGFscGhhKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBNYXRoLnNxcnQoMSAvIChhICogYSkgKyAoMiAqIHQpIC8gYSArIDIgKiB0IC0gdCAqIHQpIC0gMSAvIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcgICBmbG9hdCBhID0gYWxwaGEgLyAoMS4wIC0gYWxwaGEpO1xcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnICAgZmxvYXQgdCA9IDEuMCAtIHNxcnQoMS4wIC8gKGEgKiBhKSArICgxLjAtdnQpICogKCAyLjAvYSArIDEuMCArIHZ0ICkpICsgMS4wIC8gYTtcXG4nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIHN0cmV0Y2hpbmcgZnVuY3Rpb24gY29kZTogJyArIHN0cmV0Y2hpbmcuZnVuKVxyXG4gICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICBmbG9hdCB0ID0gdnQ7XFxuJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICBmbG9hdCB0ID0gdnQ7XFxuJ1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jaG9vc2UgaW5pdGlhbCBhbmQgZmluYWwgY29sb3JzLCBhbmQgYWRqdXN0IHQgdmFsdWVcclxuICAgICAgICBpZiAoY29sb3JzLmxlbmd0aCA9PSAxKSBmc2hTdHJpbmcgKz0gJyAgIHZlYzQgY0k9YzA7XFxuICAgdmVjNCBjRj1jMDtcXG4nXHJcbiAgICAgICAgZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PSAyKSBmc2hTdHJpbmcgKz0gJyAgIHZlYzQgY0k9YzA7XFxuICAgdmVjNCBjRj1jMTtcXG4nXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5iID0gY29sb3JzLmxlbmd0aCAtIDFcclxuICAgICAgICAgICAgY29uc3QgbmJzID0gbmIgKyAnLjAnXHJcbiAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgdmVjNCBjSTtcXG4nXHJcbiAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgdmVjNCBjRjtcXG4nXHJcbiAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgaWYodDwxLjAvJyArIG5icyArICcpIHsgY0k9YzA7IGNGPWMxOyB0PXQqJyArIG5icyArICc7IH1cXG4nXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgbmI7IGkrKylcclxuICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPVxyXG4gICAgICAgICAgICAgICAgICAgICcgICBlbHNlIGlmKHQ8JyArXHJcbiAgICAgICAgICAgICAgICAgICAgaSArXHJcbiAgICAgICAgICAgICAgICAgICAgJy4wLycgK1xyXG4gICAgICAgICAgICAgICAgICAgIG5icyArXHJcbiAgICAgICAgICAgICAgICAgICAgJykgeyBjST1jJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKGkgLSAxKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzsgY0Y9YycgK1xyXG4gICAgICAgICAgICAgICAgICAgIGkgK1xyXG4gICAgICAgICAgICAgICAgICAgICc7IHQ9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgbmJzICtcclxuICAgICAgICAgICAgICAgICAgICAnKnQtJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKGkgLSAxKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJy4wOyB9XFxuJ1xyXG4gICAgICAgICAgICBmc2hTdHJpbmcgKz1cclxuICAgICAgICAgICAgICAgICcgICBlbHNlIHsgY0k9YycgKyAobmIgLSAxKSArICc7IGNGPWMnICsgbmIgKyAnOyB0PScgKyBuYnMgKyAnKnQtJyArIChuYiAtIDEpICsgJy4wOyB9XFxuJ1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9vbmUgc2luZ2xlIGNvbG9yXHJcbiAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPT0gMSkgZnNoU3RyaW5nICs9ICcgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGMwWzBdLCBjMFsxXSwgYzBbMl0sIGMwWzNdKTt9XFxuJ1xyXG4gICAgICAgIC8vc2V0IGludGVycG9sYXRlZCBjb2xvciwgYmV0d2VlbiBpbml0aWFsIGFuZCBmaW5hbCBvbmVcclxuICAgICAgICBlbHNlIGZzaFN0cmluZyArPSAnICAgZ2xfRnJhZ0NvbG9yID0gbWl4KGNJLCBjRiwgdCk7fVxcbidcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhmc2hTdHJpbmcpXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7V2ViR0xTaGFkZXJ9ICovXHJcbiAgICAgICAgY29uc3QgZlNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmc2hTdHJpbmcpXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7V2ViR0xQcm9ncmFtfSAqL1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IGluaXRTaGFkZXJQcm9ncmFtKGdsLCB2U2hhZGVyLCBmU2hhZGVyKVxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKVxyXG5cclxuICAgICAgICAvL3NldCB1bmlmb3Jtc1xyXG5cclxuICAgICAgICAvL3NpemVQaXhcclxuICAgICAgICAvL1RPRE86IGJ1ZyBoZXJlLiBTZWVtcyB0byBiZSBsaW1pdGVkIHRvIHNvbWUgdGhyZXNob2xkIHZhbHVlIChhcm91bmQgMjUwKS5cclxuICAgICAgICBnbC51bmlmb3JtMWYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ3NpemVQaXgnKSwgMS4wICogc2l6ZVBpeClcclxuXHJcbiAgICAgICAgLy9zdHJldGNoaW5nIGFscGhhIGZhY3RvclxyXG4gICAgICAgIGdsLnVuaWZvcm0xZihnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnYWxwaGEnKSwgc3RyZXRjaGluZyA/IDEuMCAqIHN0cmV0Y2hpbmcuYWxwaGEgOiAwLjApXHJcblxyXG4gICAgICAgIC8vY29sb3JzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYyA9IGNvbG9yKGNvbG9yc1tpXSlcclxuXHJcbiAgICAgICAgICAgIGxldCBvcGFjaXR5ID0gYy5vcGFjaXR5XHJcbiAgICAgICAgICAgIGlmIChjLm9wYWNpdHkgPT0gMSAmJiBnbG9iYWxPcGFjaXR5ICE9IHVuZGVmaW5lZCkgb3BhY2l0eSA9IGdsb2JhbE9wYWNpdHlcclxuXHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm00ZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2MnICsgaSksIFtcclxuICAgICAgICAgICAgICAgICtjLnIgLyAyNTUuMCxcclxuICAgICAgICAgICAgICAgICtjLmcgLyAyNTUuMCxcclxuICAgICAgICAgICAgICAgICtjLmIgLyAyNTUuMCxcclxuICAgICAgICAgICAgICAgICtvcGFjaXR5LFxyXG4gICAgICAgICAgICBdKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogICovXHJcbiAgICBkcmF3KHZlcnRpY2VzQnVmZmVyLCB0QnVmZmVyLCB0cmFuc2ZvTWF0KSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsXHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbVxyXG5cclxuICAgICAgICAvL3ZlcnRpY2UgZGF0YVxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBnbC5jcmVhdGVCdWZmZXIoKSlcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlc0J1ZmZlciksIGdsLlNUQVRJQ19EUkFXKVxyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ3BvcycpXHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcclxuICAgICAgICAgICAgcG9zaXRpb24sXHJcbiAgICAgICAgICAgIDIsIC8vbnVtQ29tcG9uZW50c1xyXG4gICAgICAgICAgICBnbC5GTE9BVCwgLy90eXBlXHJcbiAgICAgICAgICAgIGZhbHNlLCAvL25vcm1hbGlzZVxyXG4gICAgICAgICAgICAwLCAvL3N0cmlkZVxyXG4gICAgICAgICAgICAwIC8vb2Zmc2V0XHJcbiAgICAgICAgKVxyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uKVxyXG5cclxuICAgICAgICAvL3QgZGF0YVxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBnbC5jcmVhdGVCdWZmZXIoKSlcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSh0QnVmZmVyKSwgZ2wuU1RBVElDX0RSQVcpXHJcbiAgICAgICAgY29uc3QgdCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICd0JylcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHQsIDEsIGdsLkZMT0FULCBmYWxzZSwgMCwgMClcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0KVxyXG5cclxuICAgICAgICAvL3RyYW5zZm9ybWF0aW9uXHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ21hdCcpLCBmYWxzZSwgbmV3IEZsb2F0MzJBcnJheSh0cmFuc2ZvTWF0KSlcclxuXHJcbiAgICAgICAgLy8gRW5hYmxlIHRoZSBkZXB0aCB0ZXN0XHJcbiAgICAgICAgLy9nbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XHJcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGNvbG9yIGJ1ZmZlciBiaXRcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKVxyXG4gICAgICAgIC8vIFNldCB0aGUgdmlldyBwb3J0XHJcbiAgICAgICAgLy9nbC52aWV3cG9ydCgwLCAwLCBjZy53LCBjZy5oKTtcclxuXHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIHZlcnRpY2VzQnVmZmVyLmxlbmd0aCAvIDIpXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBpbml0U2hhZGVyUHJvZ3JhbSwgY3JlYXRlU2hhZGVyIH0gZnJvbSAnLi93ZWJHTFV0aWxzLmpzJ1xyXG5pbXBvcnQgeyBjb2xvciB9IGZyb20gJ2QzLWNvbG9yJ1xyXG5cclxuLyoqXHJcbiAqIEV2ZXJ5dGhpbmcgdG8gZWFzaWx5IGRyYXcgY29sb3JlZCBzcXVhcmVzIHdpdGggd2ViR0wuXHJcbiAqIEFsbCB0aGUgc2FtZSBzaXplLCBidXQgZGlmZmVyZW50IGZpbGwgY29sb3IuXHJcbiAqIENvbG9yIGJhc2VkIG9uIGNhdGVnb3JpZXMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV2ViR0xTcXVhcmVDb2xvcmluZ0NhdEFkdmFuY2VkIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbG9ycykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn0gKi9cclxuICAgICAgICB0aGlzLmNvbG9ycyA9IGNvbG9yc1xyXG5cclxuICAgICAgICAvKiogVmVjdG9yIHNoYWRlciBwcm9ncmFtXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnZzaFN0cmluZyA9IGBcclxuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBwb3M7XHJcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBzaXplUGl4O1xyXG4gICAgICAgIHVuaWZvcm0gbWF0MyBtYXQ7XHJcblxyXG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBpO1xyXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdmk7XHJcblxyXG4gICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChtYXQgKiB2ZWMzKHBvcywgMS4wKSwgMS4wKTtcclxuICAgICAgICAgIGdsX1BvaW50U2l6ZSA9IHNpemVQaXg7XHJcbiAgICAgICAgICB2aSA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGBcclxuXHJcbiAgICAgICAgLy9wcmVwYXJlIGZyYWdtZW50IHNoYWRlciBjb2RlXHJcbiAgICAgICAgLy9kZWNsYXJlIHRoZSB1bmlmb3JtIGFuZCBvdGhlciB2YXJpYWJsZXNcclxuICAgICAgICBjb25zdCBvdXQgPSBbXVxyXG4gICAgICAgIG91dC5wdXNoKCdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52YXJ5aW5nIGZsb2F0IHZpO1xcbicpXHJcbiAgICAgICAgLy9hZGQgY29sb3IgdW5pZm9ybXNcclxuICAgICAgICBvdXQucHVzaCgndW5pZm9ybSB2ZWM0JylcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIG91dC5wdXNoKCcsJylcclxuICAgICAgICAgICAgb3V0LnB1c2goJyBjJyArIGkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dC5wdXNoKCc7XFxuJylcclxuICAgICAgICAvL3N0YXJ0IHRoZSBtYWluIGZ1bmN0aW9uXHJcbiAgICAgICAgb3V0LnB1c2goJ3ZvaWQgbWFpbih2b2lkKSB7XFxuJylcclxuICAgICAgICAvL2Nob29zZSBjb2xvciBpXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSBvdXQucHVzaCgnZWxzZSAnKVxyXG4gICAgICAgICAgICBvdXQucHVzaCgnaWYodmk9PScpXHJcbiAgICAgICAgICAgIG91dC5wdXNoKGkpXHJcbiAgICAgICAgICAgIG91dC5wdXNoKCcuMCkgZ2xfRnJhZ0NvbG9yID0gdmVjNChjJylcclxuICAgICAgICAgICAgb3V0LnB1c2goaSlcclxuICAgICAgICAgICAgb3V0LnB1c2goJ1swXSwgYycpXHJcbiAgICAgICAgICAgIG91dC5wdXNoKGkpXHJcbiAgICAgICAgICAgIG91dC5wdXNoKCdbMV0sIGMnKVxyXG4gICAgICAgICAgICBvdXQucHVzaChpKVxyXG4gICAgICAgICAgICBvdXQucHVzaCgnWzJdLCBjJylcclxuICAgICAgICAgICAgb3V0LnB1c2goaSlcclxuICAgICAgICAgICAgb3V0LnB1c2goJ1szXSk7XFxuJylcclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0LnB1c2goJ2Vsc2UgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xcbn0nKVxyXG4gICAgICAgIC8qKiBGcmFnbWVudCBzaGFkZXIgcHJvZ3JhbVxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5mc2hTdHJpbmcgPSBvdXQuam9pbignJylcclxuICAgIH1cclxuXHJcbiAgICAvKiogICovXHJcbiAgICBkcmF3KGdsLCB2ZXJ0aWNlc0J1ZmZlciwgaUJ1ZmZlciwgdHJhbnNmb01hdCwgc2l6ZVBpeCA9IDEwKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFNoYWRlcn0gKi9cclxuICAgICAgICBjb25zdCB2U2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB0aGlzLnZzaFN0cmluZylcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFNoYWRlcn0gKi9cclxuICAgICAgICBjb25zdCBmU2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIHRoaXMuZnNoU3RyaW5nKVxyXG5cclxuICAgICAgICAvKiogQHR5cGUge1dlYkdMUHJvZ3JhbX0gKi9cclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gaW5pdFNoYWRlclByb2dyYW0oZ2wsIHZTaGFkZXIsIGZTaGFkZXIpXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKVxyXG5cclxuICAgICAgICAvL3NldCB1bmlmb3Jtc1xyXG5cclxuICAgICAgICAvL3NpemVQaXhcclxuICAgICAgICBnbC51bmlmb3JtMWYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdzaXplUGl4JyksIDEuMCAqIHNpemVQaXgpXHJcblxyXG4gICAgICAgIC8vY29sb3JzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjID0gY29sb3IodGhpcy5jb2xvcnNbaV0pXHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm00ZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdjJyArIGkpLCBbXHJcbiAgICAgICAgICAgICAgICArYy5yIC8gMjU1LjAsXHJcbiAgICAgICAgICAgICAgICArYy5nIC8gMjU1LjAsXHJcbiAgICAgICAgICAgICAgICArYy5iIC8gMjU1LjAsXHJcbiAgICAgICAgICAgICAgICArYy5vcGFjaXR5LFxyXG4gICAgICAgICAgICBdKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy92ZXJ0aWNlIGRhdGFcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpXHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXNCdWZmZXIpLCBnbC5TVEFUSUNfRFJBVylcclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdwb3MnKVxyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgICAgICAgIHBvc2l0aW9uLFxyXG4gICAgICAgICAgICAyLCAvL251bUNvbXBvbmVudHNcclxuICAgICAgICAgICAgZ2wuRkxPQVQsIC8vdHlwZVxyXG4gICAgICAgICAgICBmYWxzZSwgLy9ub3JtYWxpc2VcclxuICAgICAgICAgICAgMCwgLy9zdHJpZGVcclxuICAgICAgICAgICAgMCAvL29mZnNldFxyXG4gICAgICAgIClcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbilcclxuXHJcbiAgICAgICAgLy9pIGRhdGFcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpXHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoaUJ1ZmZlciksIGdsLlNUQVRJQ19EUkFXKVxyXG4gICAgICAgIGNvbnN0IGkgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnaScpXHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpLCAxLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApXHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSlcclxuXHJcbiAgICAgICAgLy90cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdtYXQnKSwgZmFsc2UsIG5ldyBGbG9hdDMyQXJyYXkodHJhbnNmb01hdCkpXHJcblxyXG4gICAgICAgIC8vIEVuYWJsZSB0aGUgZGVwdGggdGVzdFxyXG4gICAgICAgIC8vZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgIC8vIENsZWFyIHRoZSBjb2xvciBidWZmZXIgYml0XHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVClcclxuICAgICAgICAvLyBTZXQgdGhlIHZpZXcgcG9ydFxyXG4gICAgICAgIC8vZ2wudmlld3BvcnQoMCwgMCwgY2cudywgY2cuaCk7XHJcblxyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCB2ZXJ0aWNlc0J1ZmZlci5sZW5ndGggLyAyKVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgZXh0ZW50LCBtYXggfSBmcm9tICdkMy1hcnJheSdcclxuaW1wb3J0IHsgc2NhbGVRdWFudGlsZSB9IGZyb20gJ2QzLXNjYWxlJ1xyXG5cclxuLyoqXHJcbiAqIEEgc2NhbGUgaXMgc2ltcGx5IGEgZnVuY3Rpb24gdGhhdCBtYXAgYSBkb21haW4gdG8gYSByYW5nZS5cclxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfSBTY2FsZSAqL1xyXG5cclxuLyoqXHJcbiAqIEEgc2NhbGUgd2hvc2UgcmFuZ2UgaXMgYSBjb2xvciAoc3RyaW5nKS5cclxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG51bWJlcik6c3RyaW5nfSBDb2xvclNjYWxlICovXHJcblxyXG4vKipcclxuICogQG1vZHVsZSB1dGlsc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmljIGZ1bmN0aW9uIGZvciB2aWV3IHNjYWxlIC0gY29udGludW91cyBvciBkaXNjcmV0ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3sgdmFsdWVGdW5jdGlvbjpmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbCk6bnVtYmVyLCBtaW5WYWx1ZT86bnVtYmVyLCBtaW5TaXplUGl4PzpudW1iZXIsIG1heFNpemVGYWN0b3I/Om51bWJlciwgcmFuZ2U/OltudW1iZXIsIG51bWJlcl0sIGRvbWFpbj86W251bWJlciwgbnVtYmVyXSwgc3RyZXRjaGluZz86ZnVuY3Rpb24obnVtYmVyKTpudW1iZXIsIGNsYXNzTnVtYmVyPzpudW1iZXJ9fSBvcHRzXHJcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihBcnJheS48aW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkNlbGw+KTpTY2FsZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCB2aWV3U2NhbGUgPSAob3B0cykgPT4ge1xyXG4gICAgY29uc3QgdmFsdWVGdW5jdGlvbiA9IG9wdHMudmFsdWVGdW5jdGlvblxyXG4gICAgY29uc3QgbWluVmFsdWUgPSBvcHRzLm1pblZhbHVlIHx8IDBcclxuICAgIGNvbnN0IG1pblNpemVQaXggPSBvcHRzLm1pblNpemVQaXggfHwgMFxyXG4gICAgY29uc3QgbWF4U2l6ZUZhY3RvciA9IG9wdHMubWF4U2l6ZUZhY3RvciB8fCAxXHJcbiAgICBjb25zdCBzdHJldGNoaW5nID0gb3B0cy5zdHJldGNoaW5nXHJcbiAgICBjb25zdCByYW5nZV8gPSBvcHRzLnJhbmdlXHJcbiAgICBjb25zdCBkb21haW5fID0gb3B0cy5kb21haW5cclxuICAgIGNvbnN0IGNsYXNzTnVtYmVyID0gb3B0cy5jbGFzc051bWJlclxyXG4gICAgcmV0dXJuIChjZWxscywgcmVzb2x1dGlvbiwgeikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IGRvbWFpbl8gfHwgW21pblZhbHVlLCBtYXgoY2VsbHMsIHZhbHVlRnVuY3Rpb24pXVxyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gcmFuZ2VfIHx8IFttaW5TaXplUGl4ICogeiwgcmVzb2x1dGlvbiAqIG1heFNpemVGYWN0b3JdXHJcbiAgICAgICAgY29uc3QgZG9tYWluU2l6ZSA9IGRvbWFpblsxXSAtIGRvbWFpblswXSxcclxuICAgICAgICAgICAgZG9tYWluTWluID0gZG9tYWluWzBdXHJcbiAgICAgICAgY29uc3QgcmFuZ2VTaXplID0gcmFuZ2VbMV0gLSByYW5nZVswXSxcclxuICAgICAgICAgICAgcmFuZ2VNaW4gPSByYW5nZVswXVxyXG4gICAgICAgIHJldHVybiAodCkgPT4ge1xyXG4gICAgICAgICAgICAvL3NjYWxlIHRvIFswLDFdXHJcbiAgICAgICAgICAgIHQgPSAodCAtIGRvbWFpbk1pbikgLyBkb21haW5TaXplXHJcbiAgICAgICAgICAgIC8vc3RyZXRjaFxyXG4gICAgICAgICAgICBpZiAoc3RyZXRjaGluZykgdCA9IHN0cmV0Y2hpbmcodClcclxuICAgICAgICAgICAgLy9jbGFzc2lmeVxyXG4gICAgICAgICAgICBpZiAoY2xhc3NOdW1iZXIpIHQgPSB0ID09IDEgPyAxIDogTWF0aC5mbG9vcih0ICogY2xhc3NOdW1iZXIpIC8gKGNsYXNzTnVtYmVyIC0gMSlcclxuICAgICAgICAgICAgLy9zY2FsZSB0byByYW5nZVxyXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VNaW4gKyB0ICogcmFuZ2VTaXplXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJpYyBmdW5jdGlvbiBmb3IgdmlldyBzY2FsZSAtIHF1YW50aWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7eyB2YWx1ZUZ1bmN0aW9uOmZ1bmN0aW9uKGltcG9ydChcIi4uL2NvcmUvRGF0YXNldFwiKS5DZWxsKTpudW1iZXIsIGNsYXNzTnVtYmVyPzpudW1iZXIsIG1pblNpemVQaXg/Om51bWJlciwgbWF4U2l6ZUZhY3Rvcj86bnVtYmVyIH19IG9wdHNcclxuICogQHJldHVybnMge2Z1bmN0aW9uKEFycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD4pOlNjYWxlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHZpZXdTY2FsZVF1YW50aWxlID0gKG9wdHMpID0+IHtcclxuICAgIGNvbnN0IHZhbHVlRnVuY3Rpb24gPSBvcHRzLnZhbHVlRnVuY3Rpb25cclxuICAgIGNvbnN0IGNsYXNzTnVtYmVyID0gb3B0cy5jbGFzc051bWJlciB8fCAxMlxyXG4gICAgY29uc3QgbWluU2l6ZVBpeCA9IG9wdHMubWluU2l6ZVBpeCB8fCAxXHJcbiAgICBjb25zdCBtYXhTaXplRmFjdG9yID0gb3B0cy5tYXhTaXplRmFjdG9yIHx8IDFcclxuICAgIGNvbnN0IHNjYWxlID0gc2NhbGVRdWFudGlsZSgpXHJcbiAgICByZXR1cm4gKGNlbGxzLCByZXNvbHV0aW9uLCB6KSA9PiB7XHJcbiAgICAgICAgc2NhbGUuZG9tYWluKGNlbGxzLm1hcCh2YWx1ZUZ1bmN0aW9uKSlcclxuICAgICAgICBjb25zdCBtaW5TaXplR2VvID0gbWluU2l6ZVBpeCAqIHosXHJcbiAgICAgICAgICAgIG1heFNpemVHZW8gPSByZXNvbHV0aW9uICogbWF4U2l6ZUZhY3RvclxyXG4gICAgICAgIHNjYWxlLnJhbmdlKFxyXG4gICAgICAgICAgICBBcnJheS5mcm9tKFxyXG4gICAgICAgICAgICAgICAgeyBsZW5ndGg6IGNsYXNzTnVtYmVyIH0sXHJcbiAgICAgICAgICAgICAgICAoXywgaSkgPT4gbWluU2l6ZUdlbyArIChpICogKG1heFNpemVHZW8gLSBtaW5TaXplR2VvKSkgLyAoY2xhc3NOdW1iZXIgLSAxKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKVxyXG4gICAgICAgIHNjYWxlLmJyZWFrcyA9IHNjYWxlLnF1YW50aWxlcygpXHJcbiAgICAgICAgc2NhbGUudmFsdWVzID0gc2NhbGUucmFuZ2UoKVxyXG4gICAgICAgIHJldHVybiBzY2FsZVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJpYyBmdW5jdGlvbiBmb3IgY29sb3IgdmlldyBzY2FsZSAtIGNvbnRpbnVvdXMgb3IgZGlzY3JldGVcclxuICpcclxuICogQHBhcmFtIHt7IHZhbHVlRnVuY3Rpb246ZnVuY3Rpb24oaW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkNlbGwpOm51bWJlciwgY29sb3JTY2FsZT86ZnVuY3Rpb24obnVtYmVyKTpzdHJpbmcsIGNvbG9ycz86QXJyYXkuPHN0cmluZz4sIHN0cmV0Y2hpbmc/OmZ1bmN0aW9uKG51bWJlcik6bnVtYmVyIH19IG9wdHNcclxuICogQHJldHVybnMge2Z1bmN0aW9uKEFycmF5LjxpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbD4pOkNvbG9yU2NhbGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgdmlld1NjYWxlQ29sb3IgPSAob3B0cykgPT4ge1xyXG4gICAgY29uc3QgdmFsdWVGdW5jdGlvbiA9IG9wdHMudmFsdWVGdW5jdGlvblxyXG4gICAgY29uc3Qgc3RyZXRjaGluZyA9IG9wdHMuc3RyZXRjaGluZ1xyXG4gICAgbGV0IGNvbG9yU2NhbGUgPSBvcHRzLmNvbG9yU2NhbGUgfHwgKCgpID0+ICdwdXJwbGUnKVxyXG5cclxuICAgIC8vZGlzY3JldGUgY29sb3JzIGNhc2U6IGJ1aWxkIGNvbnRpbnVvdXMgY29sb3Igc2NhbGUgZnJvbSBkaXNjcmV0ZSBvbmVzLlxyXG4gICAgY29uc3QgbmJDbGFzcyA9IG9wdHMuY29sb3JzPy5sZW5ndGhcclxuICAgIGlmIChvcHRzLmNvbG9ycyAmJiBuYkNsYXNzKVxyXG4gICAgICAgIGNvbG9yU2NhbGUgPSAodCkgPT4gb3B0cy5jb2xvcnNbdCA9PSAxID8gbmJDbGFzcyAtIDEgOiBNYXRoLmZsb29yKHQgKiBuYkNsYXNzKV1cclxuXHJcbiAgICByZXR1cm4gKGNlbGxzKSA9PiB7XHJcbiAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCA9PSAwIHx8ICFjZWxscykgcmV0dXJuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtbdW5kZWZpbmVkLCB1bmRlZmluZWRdIHwgW251bWJlciwgbnVtYmVyXX0gKi9cclxuICAgICAgICBjb25zdCBkb21haW4gPSBleHRlbnQoY2VsbHMsIHZhbHVlRnVuY3Rpb24pXHJcbiAgICAgICAgaWYgKGRvbWFpblswXSA9PSB1bmRlZmluZWQpIHJldHVyblxyXG4gICAgICAgIGNvbnN0IGRvbWFpblNpemUgPSBkb21haW5bMV0gLSBkb21haW5bMF1cclxuICAgICAgICBjb25zdCBzY2FsZSA9ICh0KSA9PiB7XHJcbiAgICAgICAgICAgIC8vc2NhbGUgdG8gWzAsMV1cclxuICAgICAgICAgICAgdCA9ICh0IC0gZG9tYWluWzBdKSAvIGRvbWFpblNpemVcclxuICAgICAgICAgICAgLy9zdHJldGNoXHJcbiAgICAgICAgICAgIGlmIChzdHJldGNoaW5nKSB0ID0gc3RyZXRjaGluZyh0KVxyXG4gICAgICAgICAgICByZXR1cm4gY29sb3JTY2FsZSh0KVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL2Z1bmN0aW9uIHRoYXQgcmV0dXJuIHRoZSBkb21haW4gdmFsdWUgZnJvbSB0aGUgWzAsMV0gcmFuZ2UuXHJcbiAgICAgICAgc2NhbGUuaW52ZXJ0ID0gKHQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHN0cmV0Y2hpbmcpIHQgPSBzdHJldGNoaW5nLmludmVydCh0KVxyXG4gICAgICAgICAgICByZXR1cm4gZG9tYWluWzBdICsgdCAqIGRvbWFpblNpemVcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9kaXNjcmV0ZSBjb2xvcnM6IHJldHVybiB0aGUgYnJlYWtzXHJcbiAgICAgICAgaWYgKG9wdHMuY29sb3JzICYmIG5iQ2xhc3MpIHtcclxuICAgICAgICAgICAgc2NhbGUuYnJlYWtzID0gW11cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuYkNsYXNzOyBpKyspIHNjYWxlLmJyZWFrcy5wdXNoKHNjYWxlLmludmVydChpIC8gbmJDbGFzcykpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2NhbGVcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyaWMgZnVuY3Rpb24gZm9yIGNvbG9yIHZpZXcgc2NhbGUgLSBxdWFudGlsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3sgdmFsdWVGdW5jdGlvbjpmdW5jdGlvbihpbXBvcnQoXCIuLi9jb3JlL0RhdGFzZXRcIikuQ2VsbCk6bnVtYmVyLCBjbGFzc051bWJlcj86bnVtYmVyLCBjb2xvcnM/OkFycmF5LjxzdHJpbmc+LCBjb2xvclNjYWxlPzpmdW5jdGlvbihudW1iZXIpOnN0cmluZyB9fSBvcHRzXHJcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihBcnJheS48aW1wb3J0KFwiLi4vY29yZS9EYXRhc2V0XCIpLkNlbGw+KTpDb2xvclNjYWxlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHZpZXdTY2FsZUNvbG9yUXVhbnRpbGUgPSAob3B0cykgPT4ge1xyXG4gICAgY29uc3QgdmFsdWVGdW5jdGlvbiA9IG9wdHMudmFsdWVGdW5jdGlvblxyXG4gICAgY29uc3QgY2xhc3NOdW1iZXIgPSBvcHRzLmNsYXNzTnVtYmVyIHx8IDEyXHJcblxyXG4gICAgbGV0IGNvbG9ycyA9IG9wdHMuY29sb3JzXHJcbiAgICBpZiAob3B0cy5jb2xvclNjYWxlKSBjb2xvcnMgPSBkaXNjcmV0ZUNvbG9ycyhvcHRzLmNvbG9yU2NhbGUsIGNsYXNzTnVtYmVyKVxyXG4gICAgY29sb3JzID1cclxuICAgICAgICBjb2xvcnMgfHxcclxuICAgICAgICBBcnJheS5mcm9tKFxyXG4gICAgICAgICAgICB7IGxlbmd0aDogY2xhc3NOdW1iZXIgfSxcclxuICAgICAgICAgICAgKF8sIGkpID0+ICdyZ2IoJyArIE1hdGguZmxvb3IoKDI1NSAqIGkpIC8gKGNsYXNzTnVtYmVyIC0gMSkpICsgJywxNTAsMTUwKSdcclxuICAgICAgICApXHJcblxyXG4gICAgY29uc3Qgc2NhbGUgPSBzY2FsZVF1YW50aWxlKCkucmFuZ2UoY29sb3JzKVxyXG4gICAgcmV0dXJuIChjZWxscykgPT4ge1xyXG4gICAgICAgIHNjYWxlLmRvbWFpbihjZWxscy5tYXAodmFsdWVGdW5jdGlvbikpXHJcbiAgICAgICAgc2NhbGUuYnJlYWtzID0gc2NhbGUucXVhbnRpbGVzKClcclxuICAgICAgICBzY2FsZS5jb2xvcnMgPSBjb2xvcnNcclxuICAgICAgICByZXR1cm4gc2NhbGVcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbWJpbmUgdmlldyBzY2FsZSBmdW5jdGlvbnNcclxuICpcclxuICogQHBhcmFtIHsqfSBvYmpcclxuICogQHJldHVybnMge2Z1bmN0aW9ufVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHZpZXdTY2FsZUNvbWJpbmF0aW9uID0gKG9iaikgPT4ge1xyXG4gICAgLy9vYmo6IHByb3AgYW5kIGEgZnVuY3Rpb24gdG8gY2FsbFxyXG4gICAgcmV0dXJuIChjZWxscywgcmVzb2x1dGlvbiwgeikgPT4ge1xyXG4gICAgICAgIGNvbnN0IG91dCA9IHt9XHJcbiAgICAgICAgZm9yIChjb25zdCBwIGluIG9iaikge1xyXG4gICAgICAgICAgICBvdXRbcF0gPSBvYmpbcF0oY2VsbHMsIHJlc29sdXRpb24sIHopXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhIGNsYXNzaWZpZXIgZnVuY3Rpb24gZnJvbSBicmVhayB2YWx1ZXMuXHJcbiAqIFRoZSBjbGFzc2lmaWVyIGZ1bmN0aW9uIHJldHVybnMgdGhlIGNsYXNzIGlkIChmcm9tIDAgdG8gYnJlYWtzLmxlbmd0aCkgZnJvbSBhIHZhbHVlIHRvIGNsYXNzaWZpeS5cclxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYnJlYWtzIHRoZSBicmVha3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGFzc2lmaWVyKGJyZWFrcykge1xyXG4gICAgY29uc3QgYmwgPSBicmVha3MubGVuZ3RoXHJcbiAgICBjb25zdCBjbGFzc2lmaWVyID0gKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgbGV0IGkgPSAwXHJcbiAgICAgICAgd2hpbGUgKGkgPCBibCkge1xyXG4gICAgICAgICAgICBjb25zdCBicmVha18gPSBicmVha3NbaV1cclxuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IGJyZWFrXykgcmV0dXJuIGlcclxuICAgICAgICAgICAgaSsrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpXHJcbiAgICB9XHJcbiAgICBjbGFzc2lmaWVyLmJyZWFrcyA9IGJyZWFrc1xyXG4gICAgcmV0dXJuIGNsYXNzaWZpZXJcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhIGNvbG9yIGNsYXNzaWZpZXIgZnVuY3Rpb24gZnJvbSBicmVhayB2YWx1ZXMuXHJcbiAqIFRoZSBjbGFzc2lmaWVyIGZ1bmN0aW9uIHJldHVybnMgdGhlIGNvbG9yIGZyb20gYSB2YWx1ZSB0byBjbGFzc2lmaXkuXHJcbiAqIFRoZXJlIHNob3VsZCBiZSBvbmUgY29sb3IgbW9yZSB0aGFuIGJyZWFrIHZhbHVlcy5cclxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYnJlYWtzIHRoZSBicmVha3NcclxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzIHRoZSBjb2xvcnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb2xvckNsYXNzaWZpZXIoYnJlYWtzLCBjb2xvcnMpIHtcclxuICAgIGNvbnN0IGNsYXNzaWZpZXJfID0gY2xhc3NpZmllcihicmVha3MpXHJcbiAgICBjb25zdCBjb2xvckNsYXNzaWZpZXIgPSAodmFsdWUpID0+IGNvbG9yc1tjbGFzc2lmaWVyXyh2YWx1ZSldXHJcbiAgICBjb2xvckNsYXNzaWZpZXIuYnJlYWtzID0gYnJlYWtzXHJcbiAgICBjb2xvckNsYXNzaWZpZXIuY29sb3JzID0gY29sb3JzXHJcbiAgICByZXR1cm4gY29sb3JDbGFzc2lmaWVyXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYWtlIGFycmF5IG9mIGNvbG9ycyBmcm9tIGEgY29sb3JTY2FsZS5cclxuICogSXQgaXMgYSBraW5kIG9mIHNhbXBsaW5nLCBvciB1bi1pbnRlcnBvbGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyKTpzdHJpbmd9IGNvbG9yU2NhbGVcclxuICogQHBhcmFtIHtudW1iZXJ9IG5iXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGlzY3JldGVDb2xvcnMoY29sb3JTY2FsZSwgbmIpIHtcclxuICAgIGlmIChuYiA9PSAxKSByZXR1cm4gW2NvbG9yU2NhbGUoMC41KV1cclxuICAgIGNvbnN0IG91dCA9IFtdXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspIG91dC5wdXNoKGNvbG9yU2NhbGUoaSAvIChuYiAtIDEpKSlcclxuICAgIHJldHVybiBvdXRcclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHV0aWxzXHJcbiAqL1xyXG5cclxuLy9UT0RPIGludmVydCBmb3IgY2lyY3VsYXJcclxuLy9UT0RPIHVzZSBNYXRoLnNxcnRcclxuLy9UT0RPIHZhbGlkYXRlXHJcblxyXG4vKipcclxuICogU29tZSBmdW5jdGlvbiBbMCwxXS0+WzAsMV0gdG8gc3RyZXRjaCByYW5nZSBvZiB2YWx1ZXMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2V1cm9zdGF0L2dyaWR2aXovYmxvYi9tYXN0ZXIvZG9jcy9yZWZlcmVuY2UubWQjc3RyZXRjaGluZ1xyXG4gKiBAc2VlIGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AamdhZmZ1cmkvc3RyZXRjaGluZ1xyXG4gKi9cclxuXHJcbi8vaWRlbnRpdHkgZnVuY3Rpb25cclxuY29uc3QgaWRlbnRpdHkgPSAodCkgPT4gdFxyXG5pZGVudGl0eS5pbnZlcnQgPSBpZGVudGl0eVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXHJcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihudW1iZXIpOm51bWJlcn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBleHBvbmVudGlhbFNjYWxlID0gKGJhc2UgPSAzKSA9PiB7XHJcbiAgICBpZiAoYmFzZSA9PSAwKSByZXR1cm4gaWRlbnRpdHlcclxuICAgIGNvbnN0IGEgPSBNYXRoLmV4cChiYXNlKSAtIDFcclxuICAgIGNvbnN0IGYgPSAodCkgPT4gKE1hdGguZXhwKHQgKiBiYXNlKSAtIDEpIC8gYVxyXG4gICAgZi5pbnZlcnQgPSAodCkgPT4gTWF0aC5sb2coYSAqIHQgKyAxKSAvIGJhc2VcclxuICAgIHJldHVybiBmXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVxyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbG9nYXJpdGhtaWNTY2FsZSA9IChiYXNlID0gMykgPT4ge1xyXG4gICAgaWYgKGJhc2UgPT0gMCkgcmV0dXJuIGlkZW50aXR5XHJcbiAgICBjb25zdCBhID0gTWF0aC5leHAoYmFzZSksXHJcbiAgICAgICAgYiA9IDEgLSBhXHJcbiAgICBjb25zdCBmID0gKHQpID0+IDEgLSBNYXRoLmxvZyhhICsgdCAqIGIpIC8gYmFzZVxyXG4gICAgZi5pbnZlcnQgPSAodCkgPT4gKE1hdGguZXhwKCgxIC0gdCkgKiBiYXNlKSAtIGEpIC8gYlxyXG4gICAgcmV0dXJuIGZcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcG93ZXJTY2FsZSA9IChleHBvbmVudCA9IDMpID0+IHtcclxuICAgIGlmIChleHBvbmVudCA9PSAxKSByZXR1cm4gaWRlbnRpdHlcclxuICAgIC8vVE9ETyBpZiAoZXhwb25lbnQgPT0gMC41KSByZXR1cm4gTWF0aC5zcXJ0XHJcbiAgICBjb25zdCBmID0gKHQpID0+IE1hdGgucG93KHQsIGV4cG9uZW50KVxyXG4gICAgY29uc3QgYSA9IDEgLyBleHBvbmVudFxyXG4gICAgZi5pbnZlcnQgPSAodCkgPT4gTWF0aC5wb3codCwgYSlcclxuICAgIHJldHVybiBmXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcclxuICogQHJldHVybnMge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHBvd2VySW52ZXJzZVNjYWxlID0gKGV4cG9uZW50ID0gMykgPT4ge1xyXG4gICAgaWYgKGV4cG9uZW50ID09IDEpIHJldHVybiBpZGVudGl0eVxyXG4gICAgLy9UT0RPIGlmIChleHBvbmVudCA9PSAyKSByZXR1cm4gdCA9PiAxIC0gTWF0aC5zcXJ0KDEgLSB0KVxyXG4gICAgY29uc3QgYSA9IDEgLyBleHBvbmVudFxyXG4gICAgY29uc3QgZiA9ICh0KSA9PiAxIC0gTWF0aC5wb3coMSAtIHQsIGEpXHJcbiAgICBmLmludmVydCA9ICh0KSA9PiAxIC0gTWF0aC5wb3coMSAtIHQsIGV4cG9uZW50KVxyXG4gICAgcmV0dXJuIGZcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaXJjdWxhcml0eVxyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2lyY3VsYXJTY2FsZSA9IChjaXJjdWxhcml0eSA9IDAuOCkgPT4ge1xyXG4gICAgaWYgKGNpcmN1bGFyaXR5ID09IDApIHJldHVybiBpZGVudGl0eVxyXG4gICAgaWYgKGNpcmN1bGFyaXR5ID09IDEpIHJldHVybiAodCkgPT4gTWF0aC5zcXJ0KHQgKiAoMiAtIHQpKVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgYSA9IGNpcmN1bGFyaXR5IC8gKDEgLSBjaXJjdWxhcml0eSlcclxuICAgICAgICByZXR1cm4gKHQpID0+IE1hdGguc3FydCgxIC8gKGEgKiBhKSArIHQgKiAoMiAvIGEgKyAyIC0gdCkpIC0gMSAvIGFcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaXJjdWxhcml0eVxyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2lyY3VsYXJJbnZlcnNlU2NhbGUgPSAoY2lyY3VsYXJpdHkgPSAwLjgpID0+IHtcclxuICAgIGlmIChjaXJjdWxhcml0eSA9PSAwKSByZXR1cm4gaWRlbnRpdHlcclxuICAgIGNvbnN0IGYgPSBjaXJjdWxhclNjYWxlKGNpcmN1bGFyaXR5KVxyXG4gICAgcmV0dXJuICh0KSA9PiAxIC0gZigxIC0gdClcclxufVxyXG5cclxuLy90ZXN0XHJcbi8qXHJcbmNvbnN0IHRlc3QgPSAoZiwgZnVuLCBhLCBlcnIgPSAxZS0xMikgPT4ge1xyXG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPD0gMTsgdCArPSAxIC8gNTApIHtcclxuICAgICAgICBjb25zdCBlciA9IHQgLSBmLmludmVydChmKHQpKVxyXG4gICAgICAgIGlmIChNYXRoLmFicyhlcikgPCBlcnIpIGNvbnRpbnVlXHJcbiAgICAgICAgY29uc29sZS5sb2coZnVuLCBhLCBlcilcclxuICAgIH1cclxufVxyXG5cclxuZm9yIChsZXQgZnVuIG9mIFtwb3dlclNjYWxlLCBwb3dlckludmVyc2VTY2FsZV0pXHJcbiAgICBmb3IgKGxldCBleHAgPSAtMzA7IGV4cCA8PSA1MDsgZXhwICs9IDEpIHtcclxuICAgICAgICBpZiAoZXhwID09IDApIGNvbnRpbnVlXHJcbiAgICAgICAgY29uc3QgZiA9IGZ1bihleHApXHJcbiAgICAgICAgdGVzdChmLCBmdW4sIGV4cClcclxuICAgIH1cclxuXHJcblxyXG5mb3IgKGxldCBmdW4gb2YgW2V4cG9uZW50aWFsU2NhbGUsIGxvZ2FyaXRobWljU2NhbGVdKVxyXG4gICAgZm9yIChsZXQgYmFzZSA9IC0yMDsgYmFzZSA8PSAyMDsgYmFzZSArPSAxKSB7XHJcbiAgICAgICAgLy9pZiAoZXhwID09IDApIGNvbnRpbnVlXHJcbiAgICAgICAgY29uc3QgZiA9IGZ1bihiYXNlKVxyXG4gICAgICAgIHRlc3QoZiwgZnVuLCBiYXNlLCAxZS0xMClcclxuICAgIH1cclxuKi9cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBpbnRlcnBvbGF0ZUxhYiB9IGZyb20gJ2QzLWludGVycG9sYXRlJ1xyXG5cclxuZXhwb3J0IGNvbnN0IHRlcm5hcnlDbGFzc2lmaWVyID0gKHByb3BlcnRpZXMsIHRvdGFsRnVuY3Rpb24sIG9wdHMgPSB7fSkgPT4ge1xyXG4gICAgLy90aGUgdGhyZWUgcHJvcGVydGllc1xyXG4gICAgY29uc3QgcDAgPSBwcm9wZXJ0aWVzWzBdLFxyXG4gICAgICAgIHAxID0gcHJvcGVydGllc1sxXSxcclxuICAgICAgICBwMiA9IHByb3BlcnRpZXNbMl1cclxuXHJcbiAgICAvL3RoZSBjbGFzc2lmaWVyIGNlbnRlciBwb2ludC4gc3VtIG11c3QgYmUgZXF1YWwgdG8gMVxyXG4gICAgY29uc3QgW2MwLCBjMSwgYzJdID0gb3B0cy5jZW50ZXIgfHwgWzEgLyAzLCAxIC8gMywgMSAvIDNdXHJcblxyXG4gICAgLy9wYXJhbWV0ZXIgdG8gZGVjaWRlIHdldGhlciB0byB1c2UgbWl4ZWQgY2xhc3NlcyBtMCwgbTEsIG0yLlxyXG4gICAgY29uc3Qgd2l0aE1peGVkQ2xhc3NlcyA9IG9wdHMud2l0aE1peGVkQ2xhc3NlcyAhPSB1bmRlZmluZWQgPyBvcHRzLndpdGhNaXhlZENsYXNzZXMgOiB0cnVlXHJcblxyXG4gICAgLy9wYXJhbWV0ZXIgdG8gZGVjaWRlIHdldGhlciB0byB1c2UgYSBjZW50cmFsIGNsYXNzLCBhbmQgdGhlIHNpemUgb2YgdGhpcyBjZW50cmFsIGNsYXNzLlxyXG4gICAgLy9zZXQgdG8gMCBvciB1bmRlZmluZWQgZm9yIG5vdCBzaG93aW5nIGFueSBjZW50cmFsIGNsYXNzLiBTZXQgdG8gMSBmb3IgYSBjZW50cmFsIGNsYXNzIHRoYXQgY29udGFpbnMgdGhlIG1peCBjbGFzc2VzXHJcbiAgICBjb25zdCBjYyA9IG9wdHMuY2VudGVyQ29lZmZpY2llbnQgPyAxIC0gb3B0cy5jZW50ZXJDb2VmZmljaWVudCA6IHVuZGVmaW5lZFxyXG5cclxuICAgIC8vdGhlIG91dHB1dCBjbGFzc2lmaWVyIG1ldGhvZFxyXG4gICAgY29uc3QgZnVuID0gKGMpID0+IHtcclxuICAgICAgICAvL2dldCB0b3RhbFxyXG4gICAgICAgIGNvbnN0IHRvdCA9IHRvdGFsRnVuY3Rpb24oYylcclxuICAgICAgICBpZiAoIXRvdCkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgIC8vY29tcHV0ZSBzaGFyZXNcclxuICAgICAgICBjb25zdCBbczAsIHMxLCBzMl0gPSBbK2NbcDBdIC8gdG90LCArY1twMV0gLyB0b3QsICtjW3AyXSAvIHRvdF1cclxuXHJcbiAgICAgICAgLy9jbGFzcyAwXHJcbiAgICAgICAgaWYgKHMwID49IGMwICYmIHMxIDw9IGMxICYmIHMyIDw9IGMyKSB7XHJcbiAgICAgICAgICAgIC8vY2VudHJhbCBjbGFzcyBuZWFyIGNsYXNzIDBcclxuICAgICAgICAgICAgaWYgKGNjICE9IHVuZGVmaW5lZCAmJiAoczIgLSBjMikgKiAoYzEgLSBjYyAqIGMxKSA+PSAoczEgLSBjYyAqIGMxKSAqIChjYyAqIGMyIC0gYzIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdjZW50ZXInXHJcbiAgICAgICAgICAgIHJldHVybiAnMCdcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jbGFzcyAxXHJcbiAgICAgICAgaWYgKHMwIDw9IGMwICYmIHMxID49IGMxICYmIHMyIDw9IGMyKSB7XHJcbiAgICAgICAgICAgIC8vY2VudHJhbCBjbGFzcyBuZWFyIGNsYXNzIDFcclxuICAgICAgICAgICAgaWYgKGNjICE9IHVuZGVmaW5lZCAmJiAoczIgLSBjMikgKiAoYzAgLSBjYyAqIGMwKSA+PSAoczAgLSBjYyAqIGMwKSAqIChjYyAqIGMyIC0gYzIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdjZW50ZXInXHJcbiAgICAgICAgICAgIHJldHVybiAnMSdcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jbGFzcyAyXHJcbiAgICAgICAgaWYgKHMwIDw9IGMwICYmIHMxIDw9IGMxICYmIHMyID49IGMyKSB7XHJcbiAgICAgICAgICAgIC8vY2VudHJhbCBjbGFzcyBuZWFyIGNsYXNzIDJcclxuICAgICAgICAgICAgaWYgKGNjICE9IHVuZGVmaW5lZCAmJiAoczEgLSBjMSkgKiAoYzAgLSBjYyAqIGMwKSA+PSAoczAgLSBjYyAqIGMwKSAqIChjYyAqIGMxIC0gYzEpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdjZW50ZXInXHJcbiAgICAgICAgICAgIHJldHVybiAnMidcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9taWRkbGUgY2xhc3MgMCAtIGludGVyc2VjdGlvbiBjbGFzcyAxIGFuZCAyXHJcbiAgICAgICAgaWYgKHMwIDw9IGMwICYmIHMxID49IGMxICYmIHMyID49IGMyKSB7XHJcbiAgICAgICAgICAgIC8vY2VudHJhbCBjbGFzc1xyXG4gICAgICAgICAgICBpZiAoY2MgIT0gdW5kZWZpbmVkICYmIHMwID4gY2MgKiBjMCkgcmV0dXJuICdjZW50ZXInXHJcbiAgICAgICAgICAgIGlmICh3aXRoTWl4ZWRDbGFzc2VzKSByZXR1cm4gJ20xMidcclxuICAgICAgICAgICAgcmV0dXJuIHMxID4gczIgPyAnMScgOiAnMidcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9taWRkbGUgY2xhc3MgMSAtIGludGVyc2VjdGlvbiBjbGFzcyAwIGFuZCAxXHJcbiAgICAgICAgaWYgKHMwID49IGMwICYmIHMxIDw9IGMxICYmIHMyID49IGMyKSB7XHJcbiAgICAgICAgICAgIC8vY2VudHJhbCBjbGFzc1xyXG4gICAgICAgICAgICBpZiAoY2MgIT0gdW5kZWZpbmVkICYmIHMxID4gY2MgKiBjMSkgcmV0dXJuICdjZW50ZXInXHJcbiAgICAgICAgICAgIGlmICh3aXRoTWl4ZWRDbGFzc2VzKSByZXR1cm4gJ20wMidcclxuICAgICAgICAgICAgcmV0dXJuIHMwID4gczIgPyAnMCcgOiAnMidcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9taWRkbGUgY2xhc3MgMiAtIGludGVyc2VjdGlvbiBjbGFzcyAwIGFuZCAxXHJcbiAgICAgICAgaWYgKHMwID49IGMwICYmIHMxID49IGMxICYmIHMyIDw9IGMyKSB7XHJcbiAgICAgICAgICAgIC8vY2VudHJhbCBjbGFzc1xyXG4gICAgICAgICAgICBpZiAoY2MgIT0gdW5kZWZpbmVkICYmIHMyID4gY2MgKiBjMikgcmV0dXJuICdjZW50ZXInXHJcbiAgICAgICAgICAgIGlmICh3aXRoTWl4ZWRDbGFzc2VzKSByZXR1cm4gJ20wMSdcclxuICAgICAgICAgICAgcmV0dXJuIHMxID4gczAgPyAnMScgOiAnMCdcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9zaG91bGQgbm90IGhhcHBlblxyXG4gICAgICAgIHJldHVybiAndW5rbm93bidcclxuICAgIH1cclxuXHJcbiAgICAvL2F0dGFjaCBpbmZvcm1hdGlvbiB0byBvdXRwdXQgZnVuY3Rpb25cclxuICAgIGZ1bi5jZW50ZXIgPSBbYzAsIGMxLCBjMl1cclxuICAgIGZ1bi5jZW50ZXJDb2VmZmljaWVudCA9IG9wdHMuY2VudGVyQ29lZmZpY2llbnRcclxuXHJcbiAgICByZXR1cm4gZnVuXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB0ZXJuYXJ5Q29sb3JDbGFzc2lmaWVyID0gKHByb3BlcnRpZXMsIHRvdGFsRnVuY3Rpb24sIGNvbG9ycywgb3B0cyA9IHt9KSA9PiB7XHJcbiAgICAvL3RoZSB0aHJlZSBjb2xvcnNcclxuICAgIGNvbnN0IFtjb2xvcjAsIGNvbG9yMSwgY29sb3IyXSA9IGNvbG9ycyB8fCBbJ3JlZCcsICdncmVlbicsICdibHVlJ11cclxuXHJcbiAgICAvL3RoZSBjb2xvciBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uXHJcbiAgICBjb25zdCBjb2xvckludGVycG9sYXRpb24gPSBvcHRzLmNvbG9ySW50ZXJwb2xhdGlvbiB8fCBpbnRlcnBvbGF0ZUxhYlxyXG5cclxuICAgIC8vcGFyYW1ldGVyIHRvIGRlY2lkZSB3ZXRoZXIgdG8gdXNlIG1peGVkIGNsYXNzZXMuXHJcbiAgICBjb25zdCB3aXRoTWl4ZWRDbGFzc2VzID0gb3B0cy53aXRoTWl4ZWRDbGFzc2VzICE9IHVuZGVmaW5lZCA/IG9wdHMud2l0aE1peGVkQ2xhc3NlcyA6IHRydWVcclxuICAgIC8vaHR0cHM6Ly9kM2pzLm9yZy9kMy1pbnRlcnBvbGF0ZS9jb2xvclxyXG4gICAgY29uc3QgbWl4Q29sb3JGdW5jdGlvbiA9IChjb2xvcjEsIGNvbG9yMikgPT4gY29sb3JJbnRlcnBvbGF0aW9uKGNvbG9yMSwgY29sb3IyKSgwLjUpXHJcbiAgICAvL3RoZSBjb2xvcnMgY29ycmVzcG9uZGluZyB0byB0aGUgbWl4ZWQgY2xhc3Nlc1xyXG4gICAgY29uc3QgW21peENvbG9yMCwgbWl4Q29sb3IxLCBtaXhDb2xvcjJdID1cclxuICAgICAgICBvcHRzLm1peGVkQ29sb3JzIHx8IHdpdGhNaXhlZENsYXNzZXNcclxuICAgICAgICAgICAgPyBbXHJcbiAgICAgICAgICAgICAgICAgIG1peENvbG9yRnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpLFxyXG4gICAgICAgICAgICAgICAgICBtaXhDb2xvckZ1bmN0aW9uKGNvbG9yMCwgY29sb3IyKSxcclxuICAgICAgICAgICAgICAgICAgbWl4Q29sb3JGdW5jdGlvbihjb2xvcjAsIGNvbG9yMSksXHJcbiAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICA6IFtdXHJcblxyXG4gICAgLy90aGUgY2VudHJhbCBjb2xvciwgdXNlZCBmb3IgdGhlIGNlbnRyYWwgY2xhc3MsIGlmIGFueS4gVGhlIGNlbnRyYWwgY2xhc3MgaXMgdGhlIGNsYXNzIG9mIHJlbGF0aXZlbHkgYmFsYW5jZWQgdmFsdWVzLCBhcm91bmQgdGhlIGNlbnRlciBwb2ludFxyXG4gICAgY29uc3QgY2VudGVyQ29sb3IgPVxyXG4gICAgICAgIG9wdHMuY2VudGVyQ29sb3IgfHwgY29sb3JJbnRlcnBvbGF0aW9uKG1peENvbG9yRnVuY3Rpb24oY29sb3IwLCBjb2xvcjEpLCBjb2xvcjIpKDAuMzMzKVxyXG5cclxuICAgIC8vbWFrZSBjbGFzc2lmaWVyXHJcbiAgICBjb25zdCBjbGFzc2lmaWVyID0gdGVybmFyeUNsYXNzaWZpZXIocHJvcGVydGllcywgdG90YWxGdW5jdGlvbiwgb3B0cylcclxuXHJcbiAgICAvL3RoZSBvdXRwdXQgY29sb3IgY2xhc3NpZmllciBtZXRob2RcclxuICAgIGNvbnN0IGZ1biA9IChjKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2xhID0gY2xhc3NpZmllcihjKVxyXG4gICAgICAgIGlmIChjbGEgPT0gJzAnKSByZXR1cm4gY29sb3IwXHJcbiAgICAgICAgaWYgKGNsYSA9PSAnMScpIHJldHVybiBjb2xvcjFcclxuICAgICAgICBpZiAoY2xhID09ICcyJykgcmV0dXJuIGNvbG9yMlxyXG4gICAgICAgIGlmIChjbGEgPT0gJ20xMicpIHJldHVybiBtaXhDb2xvcjBcclxuICAgICAgICBpZiAoY2xhID09ICdtMDInKSByZXR1cm4gbWl4Q29sb3IxXHJcbiAgICAgICAgaWYgKGNsYSA9PSAnbTAxJykgcmV0dXJuIG1peENvbG9yMlxyXG4gICAgICAgIGlmIChjbGEgPT0gJ2NlbnRlcicpIHJldHVybiBjZW50ZXJDb2xvclxyXG4gICAgICAgIHJldHVybiBvcHRzLmRlZmF1bHRDb2xvciB8fCAnYmxhY2snXHJcbiAgICB9XHJcbiAgICBmdW4uY2VudGVyID0gY2xhc3NpZmllci5jZW50ZXJcclxuICAgIGZ1bi5jZW50ZXJDb2VmZmljaWVudCA9IG9wdHMuY2VudGVyQ29lZmZpY2llbnRcclxuICAgIGZ1bi5jb2xvcnMgPSBbY29sb3IwLCBjb2xvcjEsIGNvbG9yMl1cclxuICAgIGZ1bi5taXhDb2xvcnMgPSBbbWl4Q29sb3IwLCBtaXhDb2xvcjEsIG1peENvbG9yMl1cclxuICAgIGZ1bi5jZW50ZXJDb2xvciA9IGNlbnRlckNvbG9yXHJcbiAgICBmdW4uY2xhc3NpZmllciA9IGNsYXNzaWZpZXJcclxuXHJcbiAgICByZXR1cm4gZnVuXHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8vIE9MRCBWRVJTSU9OU1xyXG5cclxuLypcclxuY29uc3Qgb3JkZXJlZEluZGV4ZXNEZWMgPSBhcnIgPT4gWy4uLmFyci5rZXlzKCldLnNvcnQoKGEsIGIpID0+IGFycltiXSAtIGFyclthXSk7XHJcbmNvbnN0IG9yZGVyZWRJbmRleGVzSW5jID0gYXJyID0+IFsuLi5hcnIua2V5cygpXS5zb3J0KChhLCBiKSA9PiBhcnJbYV0gLSBhcnJbYl0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IHRlcm5hcnlDbGFzc2lmaWVyID0gKHByb3BlcnRpZXMsIHRvdGFsRnVuY3Rpb24sIG9wdHMgPSB7fSkgPT4ge1xyXG4gICAgY29uc3QgbG93VGhyZXNob2xkID0gb3B0cy5sb3dUaHJlc2hvbGQgfHwgWzEgLyAzLCAxIC8gMywgMSAvIDNdXHJcbiAgICBjb25zdCBoaWdoVGhyZXNob2xkID0gb3B0cy5oaWdoVGhyZXNob2xkIHx8IFsyIC8gMywgMiAvIDMsIDIgLyAzXVxyXG4gICAgY29uc3QgY29sb3JzID0gb3B0cy5jb2xvcnMgfHwgW1wicmVkXCIsIFwiZ3JlZW5cIiwgXCJibHVlXCJdXHJcbiAgICBjb25zdCBjb2xvckludGVycG9sYXRpb24gPSBvcHRzLmNvbG9ySW50ZXJwb2xhdGlvbiB8fCBpbnRlcnBvbGF0ZUxhYlxyXG5cclxuICAgIC8vaHR0cHM6Ly9kM2pzLm9yZy9kMy1pbnRlcnBvbGF0ZS9jb2xvclxyXG4gICAgY29uc3QgbWlkZGxlQ29sb3JGdW5jdGlvbiA9IChjb2xvcjEsIGNvbG9yMikgPT4gY29sb3JJbnRlcnBvbGF0aW9uKGNvbG9yMSwgY29sb3IyKSgwLjUpXHJcbiAgICBjb25zdCBtaWRkbGVDb2xvcnMgPSBvcHRzLm1pZGRsZUNvbG9ycyB8fCBbbWlkZGxlQ29sb3JGdW5jdGlvbihjb2xvcnNbMV0sIGNvbG9yc1syXSksIG1pZGRsZUNvbG9yRnVuY3Rpb24oY29sb3JzWzBdLCBjb2xvcnNbMl0pLCBtaWRkbGVDb2xvckZ1bmN0aW9uKGNvbG9yc1swXSwgY29sb3JzWzFdKV1cclxuICAgIGNvbnN0IGNlbnRlckNvbG9yID0gb3B0cy5jZW50ZXJDb2xvciB8fCBjb2xvckludGVycG9sYXRpb24obWlkZGxlQ29sb3JzWzJdLCBjb2xvcnNbMl0pKDAuMzMzKVxyXG5cclxuICAgIGNvbnN0IGhpZ2hfID0gb3JkZXJlZEluZGV4ZXNEZWMoaGlnaFRocmVzaG9sZClcclxuICAgIGNvbnN0IGxvd18gPSBvcmRlcmVkSW5kZXhlc0luYyhsb3dUaHJlc2hvbGQpXHJcblxyXG4gICAgY29uc3QgcDAgPSBwcm9wZXJ0aWVzWzBdLCBwMSA9IHByb3BlcnRpZXNbMV0sIHAyID0gcHJvcGVydGllc1syXVxyXG4gICAgY29uc3QgZnVuID0gYyA9PiB7XHJcbiAgICAgICAgLy9nZXQgdG90YWxcclxuICAgICAgICBjb25zdCB0b3QgPSB0b3RhbEZ1bmN0aW9uKGMpXHJcbiAgICAgICAgaWYgKCF0b3QpIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICAvL2NvbXB1dGUgc2hhcmVzXHJcbiAgICAgICAgY29uc3Qgc2hhcmVzID0gWytjW3AwXSAvIHRvdCwgK2NbcDFdIC8gdG90LCArY1twMl0gLyB0b3RdXHJcbiAgICAgICAgLy9yZXR1cm4gY29sb3JzXHJcbiAgICAgICAgLy9zdGFydCBmaXJzdCB3aXRoIHRoZSBleHRyZW1lIGhpZ2ggKHRyaWFuZ2xlcyk6IGZyb20gdGhlIGxhcmdlciB2YWx1ZSAoc21hbGwgdHJpYW5nbGUpIHRvIHRoZSBsb3dlciB2YWx1ZSAobGFyZ2UgdHJpYW5nbGUpXHJcbiAgICAgICAgZm9yIChsZXQgaSBvZiBoaWdoXykgaWYgKHNoYXJlc1tpXSA+IGhpZ2hUaHJlc2hvbGRbaV0pIHJldHVybiBjb2xvcnNbaV1cclxuICAgICAgICAvL3RoZW4gZHJhdyB0aGUgZXh0cmVtZSBsb3cgKHRyYXBleml1bXMpOiBmcm9tIHRoZSBsb3dlciB2YWx1ZSAoc21hbGwgdHJhcGV6aXVtcykgdG8gdGhlIGxhcmdlciB2YWx1ZXMgKGxhcmdlIHRyYXBleml1bSlcclxuICAgICAgICBmb3IgKGxldCBpIG9mIGxvd18pIGlmIChzaGFyZXNbaV0gPCBsb3dUaHJlc2hvbGRbaV0pIHJldHVybiBtaWRkbGVDb2xvcnNbaV1cclxuICAgICAgICAvL2Vsc2UgY2VudHJhbCBjb2xvclxyXG4gICAgICAgIHJldHVybiBjZW50ZXJDb2xvclxyXG4gICAgfVxyXG4gICAgZnVuLmxvd1RocmVzaG9sZCA9IGxvd1RocmVzaG9sZFxyXG4gICAgZnVuLmhpZ2hUaHJlc2hvbGQgPSBoaWdoVGhyZXNob2xkXHJcbiAgICBmdW4uY29sb3JzID0gY29sb3JzXHJcbiAgICBmdW4ubWlkZGxlQ29sb3JzID0gbWlkZGxlQ29sb3JzXHJcbiAgICBmdW4uY2VudGVyQ29sb3IgPSBjZW50ZXJDb2xvclxyXG4gICAgZnVuLmxvd0luZGV4ID0gbG93X1xyXG4gICAgZnVuLmhpZ2hJbmRleCA9IGhpZ2hfXHJcbiAgICByZXR1cm4gZnVuXHJcbn1cclxuKi9cclxuXHJcbi8qXHJcbmV4cG9ydCBjb25zdCB0ZXJuYXJ5Q2xhc3NpZmllcjMgPSAocHJvcGVydGllcywgdG90YWxGdW5jdGlvbiwgb3B0cyA9IHt9KSA9PiB7XHJcbiAgICBjb25zdCBbYTAxLCBhMTIsIGEyMF0gPSBvcHRzLnRocmVzaG9sZHMgfHwgWzEvMywgMS8zLCAxLzNdXHJcbiAgICBjb25zdCBbYzAsIGMxLCBjMl0gPSBvcHRzLmNvbG9ycyB8fCBbXCJyZWRcIiwgXCJncmVlblwiLCBcImJsdWVcIl1cclxuICAgIGNvbnN0IGNlbnRlckNvbG9yID0gb3B0cy5jZW50ZXJDb2xvciB8fCBcImdyYXlcIlxyXG5cclxuICAgIGNvbnN0IGZmZiA9IGEgPT4gYSA9PSAxID8gSW5maW5pdHkgOiBhIC8gKDEgLSBhKVxyXG4gICAgY29uc3QgYzAxID0gZmZmKGEwMSksIGMxMiA9IGZmZihhMTIpLCBjMjAgPSBmZmYoYTIwKVxyXG5cclxuICAgIGNvbnN0IHAwID0gcHJvcGVydGllc1swXSwgcDEgPSBwcm9wZXJ0aWVzWzFdLCBwMiA9IHByb3BlcnRpZXNbMl1cclxuICAgIGNvbnN0IGZ1biA9IGMgPT4ge1xyXG4gICAgICAgIC8vZ2V0IHRvdGFsXHJcbiAgICAgICAgY29uc3QgdG90ID0gdG90YWxGdW5jdGlvbihjKVxyXG4gICAgICAgIGlmICghdG90KSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgLy9jb21wdXRlIHNoYXJlc1xyXG4gICAgICAgIGNvbnN0IFtzMCwgczEsIHMyXSA9IFsrY1twMF0gLyB0b3QsICtjW3AxXSAvIHRvdCwgK2NbcDJdIC8gdG90XVxyXG4gICAgICAgIC8vcmV0dXJuIGNvbG9yc1xyXG4gICAgICAgIGlmIChzMCAqIGMwMSA+IHMxICYmIHMwID4gczIgKiBjMjApIHJldHVybiBjMFxyXG4gICAgICAgIGVsc2UgaWYgKHMxID4gczAgKiBjMDEgJiYgczEgKiBjMTIgPiBzMikgcmV0dXJuIGMxXHJcbiAgICAgICAgZWxzZSBpZiAoczIgKiBjMjAgPiBzMCAmJiBzMiA+IHMxICogYzEyKSByZXR1cm4gYzJcclxuICAgICAgICBlbHNlIHJldHVybiBjZW50ZXJDb2xvclxyXG4gICAgfVxyXG4gICAgZnVuLmNvbG9ycyA9IFtjMCwgYzEsIGMyXVxyXG4gICAgZnVuLmNlbnRlckNvbG9yID0gY2VudGVyQ29sb3JcclxuICAgIHJldHVybiBmdW5cclxufVxyXG4qL1xyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGNsYXNzIGlkIGZyb20gYSB2YWx1ZSBhbmQgY2xhc3MgYnJlYWsgdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2IHRoZSB2YWx1ZVxyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBicmVha3MgdGhlIGJyZWFrc1xyXG4gKiBAcmV0dXJucyBUaGUgY2xhc3MgaWQsIGZyb20gMCB0byBicmVha3MubGVuZ3RoXHJcbiAqIEBkZXByZWNhdGVkIHVzZSBnZXRDbGFzc2lmaWVyIGluc3RlYWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3ModiwgYnJlYWtzKSB7XHJcbiAgICBpZiAoIWJyZWFrcykgcmV0dXJuXHJcbiAgICBpZiAoYnJlYWtzLmxlbmd0aCA9PSAwKSByZXR1cm4gMFxyXG4gICAgaWYgKHYgPD0gYnJlYWtzWzBdKSByZXR1cm4gMFxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBicmVha3MubGVuZ3RoOyBpKyspIGlmIChicmVha3NbaSAtIDFdIDwgdiAmJiB2IDw9IGJyZWFrc1tpXSkgcmV0dXJuIGlcclxuICAgIHJldHVybiBicmVha3MubGVuZ3RoXHJcbn1cclxuXHJcbi8vdGFrZSAnbmljZScgdmFsdWUgKHBvd2VyIG9mIHRlbiwgb3IgbXVsdGlwbGUpXHJcbmV4cG9ydCBmdW5jdGlvbiBuaWNlKHYsIG11bHRpcGxlcyA9IFs4LCA2LCA1LCA0LCAyLjUsIDJdKSB7XHJcbiAgICAvL2NvbXB1dGUgYmlnZ2VyIHBvd2VyIG9mIHRlbiBiZWxvd1xyXG4gICAgY29uc3Qgdl8gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZzEwKHYpKSlcclxuICAgIGZvciAobGV0IG11bHRpcGxlIG9mIG11bHRpcGxlcykgaWYgKHZfICogbXVsdGlwbGUgPD0gdikgcmV0dXJuIHZfICogbXVsdGlwbGVcclxuICAgIHJldHVybiB2X1xyXG59XHJcblxyXG4vKlxyXG4vL25vIGxvbmdlciB1c2VkXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW1hZ2Uoc3JjKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7IHJlc29sdmUoaW1nKTsgfTtcclxuICAgICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmVqZWN0KG5ldyBFcnJvcignRXJyb3IgbG9hZGluZyBpbWFnZScpKTsgfTtcclxuICAgICAgICBpbWcuc3JjID0gc3JjO1xyXG4gICAgfSk7XHJcbn1cclxuKi9cclxuXHJcbi8qXHJcbmV4cG9ydCBsZXQgbW9uaXRvciA9IGZhbHNlXHJcblxyXG5sZXQgcHJldmlvdXNEYXRlXHJcbmV4cG9ydCBmdW5jdGlvbiBtb25pdG9yRHVyYXRpb24obWVzc2FnZSkge1xyXG4gICAgY29uc3Qgbm93RGF0ZSA9IERhdGUubm93KClcclxuXHJcbiAgICAvL2ZpcnN0IGNhbGxcclxuICAgIGlmICghcHJldmlvdXNEYXRlKSB7XHJcbiAgICAgICAgcHJldmlvdXNEYXRlID0gbm93RGF0ZVxyXG4gICAgICAgIGNvbnNvbGUubG9nKHByZXZpb3VzRGF0ZSwgbWVzc2FnZSlcclxuICAgICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkID0gbm93RGF0ZSAtIHByZXZpb3VzRGF0ZVxyXG4gICAgcHJldmlvdXNEYXRlID0gbm93RGF0ZVxyXG4gICAgY29uc29sZS5sb2coZCwgbWVzc2FnZSlcclxufVxyXG4qL1xyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd2lkdGhcclxuICogQHBhcmFtIHtzdHJpbmd9IGhlaWdodFxyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0c1xyXG4gKiBAcmV0dXJucyB7e2NhbnZhczpIVE1MQ2FudmFzRWxlbWVudCwgZ2w6V2ViR0xSZW5kZXJpbmdDb250ZXh0fX1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYWtlV2ViR0xDYW52YXMod2lkdGgsIGhlaWdodCwgb3B0cyA9IHt9KSB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxyXG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3aWR0aClcclxuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodClcclxuICAgIC8qKiBAdHlwZSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSAqL1xyXG4gICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRzKVxyXG4gICAgaWYgKCFnbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGluaXRpYWxpemUgV2ViR0wuIFlvdXIgYnJvd3NlciBvciBtYWNoaW5lIG1heSBub3Qgc3VwcG9ydCBpdC4nKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgY2FudmFzOiBjYW52YXMsIGdsOiBnbCB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgc2hhZGVyIHByb2dyYW0sIHNvIFdlYkdMIGtub3dzIGhvdyB0byBkcmF3IG91ciBkYXRhXHJcbiAqXHJcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxyXG4gKiBAcGFyYW0gIHsuLi5XZWJHTFNoYWRlcn0gc2hhZGVyc1xyXG4gKiBAcmV0dXJucyB7V2ViR0xQcm9ncmFtfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGluaXRTaGFkZXJQcm9ncmFtKGdsLCAuLi5zaGFkZXJzKSB7XHJcbiAgICAvKiogQHR5cGUge1dlYkdMUHJvZ3JhbXxudWxsfSAqL1xyXG4gICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKVxyXG4gICAgaWYgKHByb2dyYW0gPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIHdlYkdMIHByb2dyYW0nKVxyXG4gICAgZm9yIChjb25zdCBzaGFkZXIgb2Ygc2hhZGVycykgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcilcclxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pXHJcbiAgICBpZiAoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHJldHVybiBwcm9ncmFtXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkgfHwgJ0Nhbm5vdCBjcmVhdGUgd2ViR0wgcHJvZ3JhbSAoMiknKVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNoYWRlciBvZiB0aGUgZ2l2ZW4gdHlwZSwgdXBsb2FkcyB0aGUgc291cmNlIGFuZCBjb21waWxlcyBpdC5cclxuICpcclxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXHJcbiAqIEBwYXJhbSAgey4uLnN0cmluZ30gc291cmNlc1xyXG4gKiBAcmV0dXJucyB7V2ViR0xTaGFkZXJ9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2hhZGVyKGdsLCB0eXBlLCAuLi5zb3VyY2VzKSB7XHJcbiAgICAvKiogQHR5cGUge1dlYkdMU2hhZGVyfG51bGx9ICovXHJcbiAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSlcclxuICAgIGlmIChzaGFkZXIgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIHdlYkdMIHNoYWRlcicpXHJcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2VzLmpvaW4oJ1xcbicpKVxyXG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpXHJcbiAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSByZXR1cm4gc2hhZGVyXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpIHx8ICdDYW5ub3QgY3JlYXRlIHdlYkdMIHNoYWRlciAoMiknKVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgd2ViR0wgaXMgc3VwcG9ydGVkXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrV2ViR0xTdXBwb3J0KCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxyXG4gICAgICAgIHJldHVybiAhIShcclxuICAgICAgICAgICAgISF3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0ICYmXHJcbiAgICAgICAgICAgIChjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJykpXHJcbiAgICAgICAgKVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbn1cclxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbi8vIHRoZSBhcHBsaWNhdGlvblxyXG5leHBvcnQgeyBNYXAgfSBmcm9tICcuL2NvcmUvTWFwLmpzJ1xyXG5leHBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuL2NvcmUvR2VvQ2FudmFzLmpzJ1xyXG5leHBvcnQgeyBTdHlsZSB9IGZyb20gJy4vY29yZS9TdHlsZS5qcydcclxuZXhwb3J0IHsgTGF5ZXIgfSBmcm9tICcuL2NvcmUvTGF5ZXIuanMnXHJcbmV4cG9ydCB7IERhdGFzZXQgfSBmcm9tICcuL2NvcmUvRGF0YXNldC5qcydcclxuZXhwb3J0IHsgTXVsdGlSZXNvbHV0aW9uRGF0YXNldCB9IGZyb20gJy4vY29yZS9NdWx0aVJlc29sdXRpb25EYXRhc2V0LmpzJ1xyXG5cclxuLy8gZXhwb3J0IGRhdGFzZXQgdHlwZXNcclxuZXhwb3J0IHsgVGlsZWRHcmlkIH0gZnJvbSAnLi9kYXRhc2V0L1RpbGVkR3JpZC5qcydcclxuZXhwb3J0IHsgQ1NWR3JpZCB9IGZyb20gJy4vZGF0YXNldC9DU1ZHcmlkLmpzJ1xyXG5leHBvcnQgeyBKU0dyaWQgfSBmcm9tICcuL2RhdGFzZXQvSlNHcmlkLmpzJ1xyXG5cclxuLy8gZXhwb3J0IHN0eWxlc1xyXG5leHBvcnQgeyBTaGFwZUNvbG9yU2l6ZVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9TaGFwZUNvbG9yU2l6ZVN0eWxlLmpzJ1xyXG5leHBvcnQgeyBTdHJva2VTdHlsZSB9IGZyb20gJy4vc3R5bGUvU3Ryb2tlU3R5bGUuanMnXHJcbmV4cG9ydCB7IEpveVBsb3RTdHlsZSB9IGZyb20gJy4vc3R5bGUvSm95UGxvdFN0eWxlLmpzJ1xyXG5leHBvcnQgeyBDb21wb3NpdGlvblN0eWxlIH0gZnJvbSAnLi9zdHlsZS9Db21wb3NpdGlvblN0eWxlLmpzJ1xyXG5leHBvcnQgeyBTZWdtZW50U3R5bGUgfSBmcm9tICcuL3N0eWxlL1NlZ21lbnRTdHlsZS5qcydcclxuZXhwb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSAnLi9zdHlsZS9UZXh0U3R5bGUuanMnXHJcbmV4cG9ydCB7IFBpbGxhclN0eWxlIH0gZnJvbSAnLi9zdHlsZS9QaWxsYXJTdHlsZS5qcydcclxuZXhwb3J0IHsgU2lkZVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9TaWRlU3R5bGUuanMnXHJcbi8vZXhwb3J0IHsgQ29udG91clN0eWxlIH0gZnJvbSAnLi9zdHlsZS9Db250b3VyU3R5bGUuanMnXHJcbmV4cG9ydCB7IFNpZGVDYXRlZ29yeVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9TaWRlQ2F0ZWdvcnlTdHlsZS5qcydcclxuZXhwb3J0IHsgRG90RGVuc2l0eVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9Eb3REZW5zaXR5U3R5bGUuanMnXHJcbmV4cG9ydCB7IFRhbmFrYVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9UYW5ha2FTdHlsZS5qcydcclxuZXhwb3J0IHsgTGVnb1N0eWxlIH0gZnJvbSAnLi9zdHlsZS9MZWdvU3R5bGUuanMnXHJcbmV4cG9ydCB7IFNxdWFyZUNvbG9yV2ViR0xTdHlsZSB9IGZyb20gJy4vc3R5bGUvU3F1YXJlQ29sb3JXZWJHTFN0eWxlLmpzJ1xyXG5leHBvcnQgeyBTcXVhcmVDb2xvckNhdGVnb3J5V2ViR0xTdHlsZSB9IGZyb20gJy4vc3R5bGUvU3F1YXJlQ29sb3JDYXRlZ29yeVdlYkdMU3R5bGUuanMnXHJcbmV4cG9ydCB7IE1vc2FpY1N0eWxlIH0gZnJvbSAnLi9zdHlsZS9Nb3NhaWNTdHlsZS5qcydcclxuZXhwb3J0IHsgTmluamFTdGFyU3R5bGUgfSBmcm9tICcuL3N0eWxlL05pbmphU3RhclN0eWxlLmpzJ1xyXG5leHBvcnQgeyBUaW1lU2VyaWVzU3R5bGUgfSBmcm9tICcuL3N0eWxlL1RpbWVTZXJpZXNTdHlsZS5qcydcclxuZXhwb3J0IHsgSXNvRmVuY2VTdHlsZSB9IGZyb20gJy4vc3R5bGUvSXNvRmVuY2VTdHlsZS5qcydcclxuZXhwb3J0IHsgSW1hZ2VTdHlsZSB9IGZyb20gJy4vc3R5bGUvSW1hZ2VTdHlsZS5qcydcclxuXHJcbi8vIGV4cG9ydCBhZGRpdGlvbmFsIGxheWVyc1xyXG5leHBvcnQgeyBHcmlkTGF5ZXIgfSBmcm9tICcuL2xheWVyL0dyaWRMYXllci5qcydcclxuZXhwb3J0IHsgQmFja2dyb3VuZExheWVyIH0gZnJvbSAnLi9sYXllci9CYWNrZ3JvdW5kTGF5ZXIuanMnXHJcbmV4cG9ydCB7IEJhY2tncm91bmRMYXllcldNUyB9IGZyb20gJy4vbGF5ZXIvQmFja2dyb3VuZExheWVyV01TLmpzJ1xyXG5leHBvcnQgeyBCYWNrZ3JvdW5kTGF5ZXJJbWFnZSB9IGZyb20gJy4vbGF5ZXIvQmFja2dyb3VuZExheWVySW1hZ2UuanMnXHJcbmV4cG9ydCB7IExhYmVsTGF5ZXIgfSBmcm9tICcuL2xheWVyL0xhYmVsTGF5ZXIuanMnXHJcbmV4cG9ydCB7IEdlb0pTT05MYXllciB9IGZyb20gJy4vbGF5ZXIvR2VvSlNPTkxheWVyLmpzJ1xyXG5cclxuLy8gZXhwb3J0IGxlZ2VuZHNcclxuZXhwb3J0IHsgQ29sb3JMZWdlbmQgfSBmcm9tICcuL2xlZ2VuZC9Db2xvckxlZ2VuZC5qcydcclxuZXhwb3J0IHsgQ29sb3JEaXNjcmV0ZUxlZ2VuZCB9IGZyb20gJy4vbGVnZW5kL0NvbG9yRGlzY3JldGVMZWdlbmQuanMnXHJcbmV4cG9ydCB7IENvbG9yQ2F0ZWdvcnlMZWdlbmQgfSBmcm9tICcuL2xlZ2VuZC9Db2xvckNhdGVnb3J5TGVnZW5kLmpzJ1xyXG5leHBvcnQge1xyXG4gICAgU2l6ZUxlZ2VuZCxcclxuICAgIHNpemVMZWdlbmQsXHJcbiAgICBzaXplTGVnZW5kVmlld1NjYWxlLFxyXG4gICAgc2l6ZURpc2NyZXRlTGVnZW5kLFxyXG4gICAgc2l6ZURpc2NyZXRlVmlld1NjYWxlTGVnZW5kLFxyXG59IGZyb20gJy4vbGVnZW5kL1NpemVMZWdlbmQuanMnXHJcbmV4cG9ydCB7IE9yaWVudGF0aW9uTGVnZW5kLCBvcmllbnRhdGlvbkxlZ2VuZCB9IGZyb20gJy4vbGVnZW5kL09yaWVudGF0aW9uTGVnZW5kLmpzJ1xyXG5leHBvcnQgeyBUZXJuYXJ5TGVnZW5kIH0gZnJvbSAnLi9sZWdlbmQvVGVybmFyeUxlZ2VuZC5qcydcclxuXHJcbi8vIGV4cG9ydCB7IGdvVG9TdHJhaWdodCwgem9vbVRvIH0gZnJvbSBcIi4vdXRpbHMvem9vbVV0aWxzXCJcclxuZXhwb3J0ICogZnJvbSAnLi91dGlscy9zdHJldGNoaW5nLmpzJ1xyXG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL3NjYWxlLmpzJ1xyXG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL3Rlcm5hcnkuanMnXHJcbmV4cG9ydCB7IG5pY2UgfSBmcm9tICcuL3V0aWxzL3V0aWxzLmpzJ1xyXG5cclxuaW1wb3J0IHsgR2VvQ2FudmFzIH0gZnJvbSAnLi9jb3JlL0dlb0NhbnZhcy5qcydcclxuZXhwb3J0IGNvbnN0IGdldFBhcmFtZXRlckJ5TmFtZSA9IEdlb0NhbnZhcy5nZXRQYXJhbWV0ZXJCeU5hbWVcclxuXHJcbi8vIHNldCBkZWZhdWx0IGQzIGxvY2FsZVxyXG5pbXBvcnQgeyBmb3JtYXREZWZhdWx0TG9jYWxlIH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5mb3JtYXREZWZhdWx0TG9jYWxlKHtcclxuICAgIGRlY2ltYWw6ICcuJyxcclxuICAgIHRob3VzYW5kczogJyAnLFxyXG4gICAgZ3JvdXBpbmc6IFszXSxcclxuICAgIGN1cnJlbmN5OiBbJycsICfigqwnXSxcclxufSlcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9