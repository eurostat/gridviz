(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["gviz"] = factory();
	else
		root["gviz"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "Rgb": () => (/* binding */ Rgb),
/* harmony export */   "brighter": () => (/* binding */ brighter),
/* harmony export */   "darker": () => (/* binding */ darker),
/* harmony export */   "default": () => (/* binding */ color),
/* harmony export */   "hsl": () => (/* binding */ hsl),
/* harmony export */   "hslConvert": () => (/* binding */ hslConvert),
/* harmony export */   "rgb": () => (/* binding */ rgb),
/* harmony export */   "rgbConvert": () => (/* binding */ rgbConvert)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "extend": () => (/* binding */ extend)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "yesdrag": () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}


/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "nonpassive": () => (/* binding */ nonpassive),
/* harmony export */   "nonpassivecapture": () => (/* binding */ nonpassivecapture),
/* harmony export */   "nopropagation": () => (/* binding */ nopropagation)
/* harmony export */ });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/csv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/csv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "csvFormat": () => (/* binding */ csvFormat),
/* harmony export */   "csvFormatBody": () => (/* binding */ csvFormatBody),
/* harmony export */   "csvFormatRow": () => (/* binding */ csvFormatRow),
/* harmony export */   "csvFormatRows": () => (/* binding */ csvFormatRows),
/* harmony export */   "csvFormatValue": () => (/* binding */ csvFormatValue),
/* harmony export */   "csvParse": () => (/* binding */ csvParse),
/* harmony export */   "csvParseRows": () => (/* binding */ csvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var csv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;


/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}


/***/ }),

/***/ "./node_modules/d3-dsv/src/tsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/tsv.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tsvFormat": () => (/* binding */ tsvFormat),
/* harmony export */   "tsvFormatBody": () => (/* binding */ tsvFormatBody),
/* harmony export */   "tsvFormatRow": () => (/* binding */ tsvFormatRow),
/* harmony export */   "tsvFormatRows": () => (/* binding */ tsvFormatRows),
/* harmony export */   "tsvFormatValue": () => (/* binding */ tsvFormatValue),
/* harmony export */   "tsvParse": () => (/* binding */ tsvParse),
/* harmony export */   "tsvParseRows": () => (/* binding */ tsvParseRows)
/* harmony export */ });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "./node_modules/d3-dsv/src/dsv.js");


var tsv = (0,_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;


/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cubicIn": () => (/* binding */ cubicIn),
/* harmony export */   "cubicInOut": () => (/* binding */ cubicInOut),
/* harmony export */   "cubicOut": () => (/* binding */ cubicOut)
/* harmony export */ });
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/dsv.js":
/*!******************************************!*\
  !*** ./node_modules/d3-fetch/src/dsv.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "csv": () => (/* binding */ csv),
/* harmony export */   "default": () => (/* binding */ dsv),
/* harmony export */   "tsv": () => (/* binding */ tsv)
/* harmony export */ });
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/csv.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/tsv.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-fetch/src/text.js");



function dsvParse(parse) {
  return function(input, init, row) {
    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
    return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
      return parse(response, row);
    });
  };
}

function dsv(delimiter, input, init, row) {
  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
  var format = (0,d3_dsv__WEBPACK_IMPORTED_MODULE_1__["default"])(delimiter);
  return (0,_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(response) {
    return format.parse(response, row);
  });
}

var csv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_2__.csvParse);
var tsv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_3__.tsvParse);


/***/ }),

/***/ "./node_modules/d3-fetch/src/json.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205) return;
  return response.json();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseJson);
}


/***/ }),

/***/ "./node_modules/d3-fetch/src/text.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/text.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(input, init) {
  return fetch(input, init).then(responseText);
}


/***/ }),

/***/ "./node_modules/d3-format/src/defaultLocale.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/defaultLocale.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ defaultLocale),
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "formatPrefix": () => (/* binding */ formatPrefix)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__["default"])(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-format/src/exponent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/exponent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatDecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatDecimal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "formatDecimalParts": () => (/* binding */ formatDecimalParts)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatGroup.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatGroup.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatNumerals.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/formatNumerals.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatPrefixAuto.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-format/src/formatPrefixAuto.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "prefixExponent": () => (/* binding */ prefixExponent)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatRounded.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatRounded.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatSpecifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/formatSpecifier.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FormatSpecifier": () => (/* binding */ FormatSpecifier),
/* harmony export */   "default": () => (/* binding */ formatSpecifier)
/* harmony export */ });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "./node_modules/d3-format/src/formatTrim.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-format/src/formatTrim.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatTypes.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatRounded.js */ "./node_modules/d3-format/src/formatRounded.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => (0,_formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"])(x * 100, p),
  "r": _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  "s": _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});


/***/ }),

/***/ "./node_modules/d3-format/src/identity.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/identity.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-format/src/locale.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-format/src/locale.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup.js */ "./node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals.js */ "./node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier.js */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTrim.js */ "./node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTypes.js */ "./node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-format/src/identity.js");









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatGroup_js__WEBPACK_IMPORTED_MODULE_1__["default"])(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"] : (0,_formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__["default"])(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "−" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__["default"][type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0,_formatTrim_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__["default"])(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_7__["default"])(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "basis": () => (/* binding */ basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ nogamma),
/* harmony export */   "gamma": () => (/* binding */ gamma),
/* harmony export */   "hue": () => (/* binding */ hue)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "rgbBasis": () => (/* binding */ rgbBasis),
/* harmony export */   "rgbBasisClosed": () => (/* binding */ rgbBasisClosed)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function rgbGamma(y) {
  var color = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(start)).r, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "identity": () => (/* binding */ identity)
/* harmony export */ });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "interpolateTransformCss": () => (/* binding */ interpolateTransformCss),
/* harmony export */   "interpolateTransformSvg": () => (/* binding */ interpolateTransformSvg)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseSvg, ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseCss": () => (/* binding */ parseCss),
/* harmony export */   "parseSvg": () => (/* binding */ parseSvg)
/* harmony export */ });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity : (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  value = value.matrix;
  return (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-random/src/defaultSource.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-random/src/defaultSource.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Math.random);


/***/ }),

/***/ "./node_modules/d3-random/src/normal.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-random/src/normal.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _defaultSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultSource.js */ "./node_modules/d3-random/src/defaultSource.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y;

      // If available, use the second previously-generated uniform random.
      if (x != null) y = x, x = null;

      // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);

      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;

  return randomNormal;
})(_defaultSource_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ array)
/* harmony export */ });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we don’t ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_1__["default"])(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "childMatcher": () => (/* binding */ childMatcher),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}



/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}


/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "xhtml": () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});


/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event, node) {
  event = (0,_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string"
      ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[document.querySelector(selector)]], [document.documentElement])
      : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.root);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");




function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isn’t worried about “live” collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// don’t; we’d rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return !this.node();
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EnterNode": () => (/* binding */ EnterNode),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Selection": () => (/* binding */ Selection),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "root": () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");



































var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"],
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selection);


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, before) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0,_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function* __WEBPACK_DEFAULT_EXPORT__() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(lower);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(merges, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return Array.from(this);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(raise);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(remove);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");




function arrayAll(select) {
  return function() {
    return (0,_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select.apply(this, arguments));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = (0,_selectorAll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(subgroups, parents);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(update) {
  return new Array(update.length);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "styleValue": () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}


/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}


/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Timer": () => (/* binding */ Timer),
/* harmony export */   "now": () => (/* binding */ now),
/* harmony export */   "timer": () => (/* binding */ timer),
/* harmony export */   "timerFlush": () => (/* binding */ timerFlush)
/* harmony export */ });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/active.js":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/active.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");



var root = [null];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.SCHEDULED && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "active": () => (/* reexport safe */ _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "interrupt": () => (/* reexport safe */ _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "transition": () => (/* reexport safe */ _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/active.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/interrupt.js");






/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/interrupt.js":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/interrupt.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.STARTING && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDING;
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/selection/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/selection/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/selection/transition.js");




d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/selection/interrupt.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/selection/interrupt.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/interrupt.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return this.each(function() {
    (0,_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/selection/transition.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/selection/transition.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/cubic.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_0__.cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var id,
      timing;

  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition) {
    id = name._id, name = name._name;
  } else {
    id = (0,_transition_index_js__WEBPACK_IMPORTED_MODULE_1__.newId)(), (timing = defaultTiming).time = (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__.now)(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        (0,_transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(groups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/attr.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/attr.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name), i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.interpolateTransformSvg : _interpolate_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_3__.tweenValue)(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/attrTween.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/attrTween.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/delay.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/delay.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).delay;
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/duration.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/duration.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).duration;
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/ease.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/ease.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = value;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).ease;
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/easeVarying.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/easeVarying.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");


function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = v;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/end.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/end.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/filter.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/filter.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/matcher.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/index.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(subgroups, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Transition": () => (/* binding */ Transition),
/* harmony export */   "default": () => (/* binding */ transition),
/* harmony export */   "newId": () => (/* binding */ newId)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/end.js");






















var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/interpolate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/interpolate.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/string.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["default"]
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_1__["default"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"]
      : (c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"])
      : d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])(a, b);
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/merge.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/merge.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(merges, this._parents, this._name, this._id);
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/on.js":
/*!******************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/on.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__.init : _schedule_js__WEBPACK_IMPORTED_MODULE_0__.set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/remove.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/remove.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.on("end.remove", removeFunction(this._id));
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js":
/*!************************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CREATED": () => (/* binding */ CREATED),
/* harmony export */   "ENDED": () => (/* binding */ ENDED),
/* harmony export */   "ENDING": () => (/* binding */ ENDING),
/* harmony export */   "RUNNING": () => (/* binding */ RUNNING),
/* harmony export */   "SCHEDULED": () => (/* binding */ SCHEDULED),
/* harmony export */   "STARTED": () => (/* binding */ STARTED),
/* harmony export */   "STARTING": () => (/* binding */ STARTING),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "get": () => (/* binding */ get),
/* harmony export */   "init": () => (/* binding */ init),
/* harmony export */   "set": () => (/* binding */ set)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timeout.js");



var emptyOn = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = (0,d3_timer__WEBPACK_IMPORTED_MODULE_1__.timer)(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/select.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/select.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selector.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(subgroup[i], name, id, i, subgroup, (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id));
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, this._parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/selectAll.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/selectAll.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, parents, name, id);
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/selection.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/selection.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");


var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.constructor;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new Selection(this._groups, this._parents);
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/style.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/style.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/interpolate.js");






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        string1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.set)(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.interpolateTransformCss : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_4__.tweenValue)(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/styleTween.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/styleTween.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/text.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/text.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction((0,_tween_js__WEBPACK_IMPORTED_MODULE_0__.tweenValue)(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/textTween.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/textTween.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/transition.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/transition.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var name = this._name,
      id0 = this._id,
      id1 = (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.newId)();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id0);
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(groups, this._parents, name, id1);
}


/***/ }),

/***/ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/tween.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/d3-zoom/node_modules/d3-transition/src/transition/tween.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "tweenValue": () => (/* binding */ tweenValue)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-zoom/node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(node, id).value[name];
  };
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ZoomEvent)
/* harmony export */ });
function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ZoomTransform": () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.Transform),
/* harmony export */   "zoom": () => (/* reexport safe */ _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "zoomIdentity": () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.identity),
/* harmony export */   "zoomTransform": () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");




/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "nopropagation": () => (/* binding */ nopropagation)
/* harmony export */ });
function nopropagation(event) {
  event.stopImmediatePropagation();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Transform": () => (/* binding */ Transform),
/* harmony export */   "default": () => (/* binding */ transform),
/* harmony export */   "identity": () => (/* binding */ identity)
/* harmony export */ });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-zoom/node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_3__.identity;
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"],
      listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_6__["default"])("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_3__.identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this.that).datum();
      listeners.call(
        type,
        this.that,
        new _event_js__WEBPACK_IMPORTED_MODULE_2__["default"](type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__["default"])(event.view);
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    g.mouse = [p, this.__zoom.invert(p)];
    (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
    g.start();

    function mousemoved(event) {
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__.yesdrag)(event.view, g.moved);
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    if (duration > 0) (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).transition().duration(duration).call(schedule, t1, p0, event);
    else (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
}


/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "App": () => (/* binding */ App)
/* harmony export */ });
/* harmony import */ var _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GeoCanvas.js */ "./src/GeoCanvas.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ "./src/Layer.js");
/* harmony import */ var _Dataset_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Dataset.js */ "./src/Dataset.js");
/* harmony import */ var _Tooltip_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Tooltip.js */ "./src/Tooltip.js");
/* harmony import */ var _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dataset/CSVGrid.js */ "./src/dataset/CSVGrid.js");
/* harmony import */ var _dataset_LGrid_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dataset/LGrid.js */ "./src/dataset/LGrid.js");
/* harmony import */ var _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dataset/TiledGrid.js */ "./src/dataset/TiledGrid.js");
/* harmony import */ var _BackgroundLayer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./BackgroundLayer.js */ "./src/BackgroundLayer.js");
/* harmony import */ var _BackgroundLayerWMS_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BackgroundLayerWMS.js */ "./src/BackgroundLayerWMS.js");
/* harmony import */ var _LabelLayer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./LabelLayer.js */ "./src/LabelLayer.js");
/* harmony import */ var _LineLayer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./LineLayer.js */ "./src/LineLayer.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/Utils.js */ "./src/utils/Utils.js");
/* harmony import */ var _button_ZoomButtons_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./button/ZoomButtons.js */ "./src/button/ZoomButtons.js");
/* harmony import */ var _button_FullscreenButton_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./button/FullscreenButton.js */ "./src/button/FullscreenButton.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
//@ts-check


// internal imports
;














// external imports


/**
 * A gridviz application.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class App {
    /**
     * @param {HTMLDivElement} container
     * @param {object} opts
     */
    constructor(container, opts) {
        opts = opts || {}

        /**
         * The layers.
         * @type {Array.<Layer>}
         * */
        this.layers = []

        //get container element
        this.container = container || document.getElementById('gridviz')
        if (!this.container) {
            console.error('Cannot find gridviz container element.')
            return
        }

        //https://css-tricks.com/absolute-positioning-inside-relative-positioning/
        this.container.style.position = "relative"; // container element must have relative positioning

        //set dimensions
        /** @type {number} */
        this.w = opts.w || this.container.offsetWidth
        /** @type {number} */
        this.h = opts.h || this.container.offsetHeight

        //create canvas element if user doesnt specify one
        /** @type {HTMLCanvasElement} */
        let canvas = opts.canvas || null
        if (!canvas) {
            canvas = document.createElement('canvas')
            canvas.setAttribute('width', '' + this.w)
            canvas.setAttribute('height', '' + this.h)
            this.container.appendChild(canvas)
        }

        /** Make geo canvas
         * @type {GeoCanvas}
         * @private */
        this.cg = new _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_0__.GeoCanvas(canvas, undefined, 1, opts)
        this.cg.redraw = (strong = true) => {
            if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_11__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_11__.monitorDuration)('Start redraw')
            //console.log("?x=" + this.cg.getCenter().x + "&y=" + this.cg.getCenter().y + "&z=" + this.cg.getZf())

            //remove legend elements
            if (this.legend && strong) this.legend.selectAll('*').remove()

            //clear
            this.cg.initCanvasTransform()
            this.cg.clear(this.cg.backgroundColor)

            const zf = this.getZoomFactor()
            this.updateExtentGeo()

            //go through the background layers
            if (this.showBgLayers)
                for (const layer of this.bgLayers) {
                    //check if layer is visible
                    if (!layer.visible) continue
                    if (zf > layer.maxZoom) continue
                    if (zf < layer.minZoom) continue

                    //draw layer
                    layer.draw(this.cg)
                }

            //go through the layers
            for (const layer of this.layers) {
                //check if layer is visible
                if (!layer.visible) continue
                if (zf > layer.maxZoom) continue
                if (zf < layer.minZoom) continue

                //get layer dataset component
                /** @type {import('./DatasetComponent').DatasetComponent|undefined} */
                const dsc = layer.getDatasetComponent(zf)
                if (!dsc) continue

                //launch data download, if necessary
                if (strong)
                    dsc.getData(this.cg.extGeo, () => {
                        this.cg.redraw()
                    })

                //update dataset view cache
                if (strong) dsc.updateViewCache(this.cg.extGeo)

                //set layer alpha and blend mode
                this.cg.ctx.globalAlpha = layer.alpha ? layer.alpha(zf) : 1.0
                this.cg.ctx.globalCompositeOperation = layer.blendOperation(zf)

                //draw cells, style by style
                if (strong)
                    for (const s of layer.styles) {
                        //check if style is visible
                        if (!s.visible) continue
                        if (zf > s.maxZoom) continue
                        if (zf < s.minZoom) continue

                        //set style alpha and blend mode
                        //TODO: multiply by layer alpha ?
                        this.cg.ctx.globalAlpha = s.alpha ? s.alpha(zf) : 1.0
                        this.cg.ctx.globalCompositeOperation = s.blendOperation(zf)

                        s.draw(dsc.getViewCache(), dsc.getResolution(), this.cg)
                    }

                //add legend element
                if (this.legend && strong) {
                    for (const s of layer.styles) {
                        if (zf > s.maxZoom) continue
                        if (zf < s.minZoom) continue
                        for (const lg of s.legends) {
                            //console.log(s, lg)
                            //this.legend.append(lg.div)
                            //s1.node().appendChild(s2.node())
                            this.legend.node().append(lg.div.node())
                        }

                        //case for styles of styles, like kernel smoothing
                        //TODO do better
                        if (s['styles']) {
                            for (const s2 of s.styles) {
                                if (zf > s2.maxZoom) continue
                                if (zf < s2.minZoom) continue
                                for (const lg of s2.legends) {
                                    //console.log(s, lg)
                                    //this.legend.append(lg.div)
                                    //s1.node().appendChild(s2.node())
                                    this.legend.node().append(lg.div.node())
                                }
                            }
                        }
                    }
                }

                //restore default alpha and blend operation
                this.cg.ctx.globalAlpha = 1.0
                this.cg.ctx.globalCompositeOperation = this.defaultGlobalCompositeOperation
            }

            //draw boundary layer
            //if (strong)
            if (this.showBoundaries && this.boundaryLayer) this.boundaryLayer.draw(this.cg)

            //draw label layer
            //if (strong)
            if (this.showLabels && this.labelLayer) this.labelLayer.draw(this.cg)

            //
            this.canvasSave = null

            if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_11__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_11__.monitorDuration)('End redraw')

            // listen for resize events on the App's container and handle them
            this.defineResizeObserver(this.container, canvas)

            return this
        }

        /** @type {Array.<BackgroundLayer|BackgroundLayerWMS>} */
        this.bgLayers = []
        /** @type {boolean} */
        this.showBgLayers = true

        /** @type {LabelLayer | undefined} */
        this.labelLayer = undefined
        /** @type {boolean} */
        this.showLabels = true

        /** @type {LineLayer | undefined} */
        this.boundaryLayer = undefined
        /** @type {boolean} */
        this.showBoundaries = true

        // legend div
        this.legendDivId = opts.legendDivId || 'gvizLegend'
        this.legend = (0,d3_selection__WEBPACK_IMPORTED_MODULE_14__["default"])('#' + this.legendDivId)
        if (this.legend.empty()) {
            this.legend = (0,d3_selection__WEBPACK_IMPORTED_MODULE_14__["default"])(
                this.container.id && this.container.id != '' ? '#' + this.container.id : 'body'
            )
                .append('div')
                .attr('id', this.legendDivId)
                .style('position', 'absolute')
                .style('width', 'auto')
                .style('height', 'auto')
                .style('background', '#FFFFFF')
                //.style("padding", this.padding)
                .style('border', '0px')
                //.style('border-radius', '5px')
                .style('box-shadow', '3px 3px 3px grey, -3px -3px 3px #ddd')
                .style('font-family', 'Helvetica, Arial, sans-serif')
                .style('bottom', '15px')
                .style('right', '15px')
            //hide
            //.style("visibility", "hidden")
        }

        //tooltip

        // set App container as default parent element for tooltip
        if (!opts.tooltip) opts.tooltip = {}
        if (!opts.tooltip.parentElement) opts.tooltip.parentElement = this.container

        /**
         * @private
         * @type {Tooltip} */
        this.tooltip = new _Tooltip_js__WEBPACK_IMPORTED_MODULE_3__.Tooltip(opts.tooltip)

        /** @param {MouseEvent} e */
        const focusCell = (e) => {
            //compute mouse geo position
            const mousePositionGeo = {
                x: this.cg.pixToGeoX(e.offsetX + this.tooltip.xMouseOffset),
                y: this.cg.pixToGeoY(e.offsetY + this.tooltip.yMouseOffset),
            }
            /** @type {{cell:import('./Dataset').Cell,html:string,resolution:number} | undefined} */
            const focus = this.getCellFocusInfo(mousePositionGeo)

            // transparent background (e.g. leaflet) 'red painting' fix
            if (opts.transparentBackground) {
                if (focus) {
                    this.tooltip.html(focus.html)
                    this.tooltip.setPosition(e)
                    this.tooltip.show()
                } else {
                    this.tooltip.hide()
                }
                this.canvasSave = document.createElement('canvas')
                this.canvasSave.setAttribute('width', '' + this.w)
                this.canvasSave.setAttribute('height', '' + this.h)
                this.canvasSave.getContext('2d').drawImage(this.cg.canvas, 0, 0)
                this.cg.initCanvasTransform()
                return
            }

            if (focus) {
                this.tooltip.html(focus.html)
                this.tooltip.setPosition(e)
                this.tooltip.show()

                //show cell position as a rectangle
                if (!this.canvasSave) {
                    this.canvasSave = document.createElement('canvas')
                    this.canvasSave.setAttribute('width', '' + this.w)
                    this.canvasSave.setAttribute('height', '' + this.h)
                    this.canvasSave.getContext('2d').drawImage(this.cg.canvas, 0, 0)
                } else {
                    this.cg.ctx.drawImage(this.canvasSave, 0, 0)
                }

                //draw image saved + draw rectangle
                const rectWPix = this.selectionRectangleWidthPix
                    ? this.selectionRectangleWidthPix(focus.resolution, this.getZoomFactor())
                    : 4
                this.cg.initCanvasTransform()
                this.cg.ctx.strokeStyle = this.selectionRectangleColor
                this.cg.ctx.lineWidth = rectWPix
                this.cg.ctx.beginPath()

                this.cg.ctx.rect(
                    this.cg.geoToPixX(focus.cell.x) - rectWPix / 2,
                    this.cg.geoToPixY(focus.cell.y) + rectWPix / 2,
                    focus.resolution / this.getZoomFactor() + rectWPix,
                    -focus.resolution / this.getZoomFactor() - rectWPix
                )
                this.cg.ctx.stroke()
            } else {
                this.tooltip.hide()
                if (this.canvasSave) this.cg.ctx.drawImage(this.canvasSave, 0, 0)
            }
        }

        // add event listeners to container
        this.mouseOverHandler = (e) => focusCell(e)
        this.mouseMoveHandler = (e) => focusCell(e)
        this.mouseOutHandler = (e) => this.tooltip.hide()
        this.cg.canvas.addEventListener('mouseover', this.mouseOverHandler)
        this.cg.canvas.addEventListener('mousemove', this.mouseMoveHandler)
        this.cg.canvas.addEventListener('mouseout', this.mouseOutHandler)

        // add extra logic to onZoomStartFun
        this.cg.onZoomStartFun = (e) => {
            if (opts.onZoomStartFun) opts.onZoomStartFun(e)
            this.tooltip.hide()
        }

        //for mouse over
        /**
         * @private
         * @type {HTMLCanvasElement|null} */
        this.canvasSave = null

        this.selectionRectangleColor = opts.selectionRectangleColor || 'red'
        this.selectionRectangleWidthPix = opts.selectionRectangleWidthPix || (() => 4) //(r,zf) => {}

        //
        //canvas.addEventListener("keydown", e => { console.log(arguments) });

        //set default globalCompositeOperation
        this.defaultGlobalCompositeOperation =
            opts.defaultGlobalCompositeOperation || this.cg.ctx.globalCompositeOperation
    }

    /**
     * @param {number} marginPx
     * @returns {import('./Dataset').Envelope}
     * @public
     */
    updateExtentGeo(marginPx = 20) {
        return this.cg.updateExtentGeo(marginPx)
    }

    /**
     * Return the cell HTML info at a given geo position.
     * This is usefull for user interactions, to show this info where the user clicks for example.
     *
     * @param {{x:number,y:number}} posGeo
     * @returns {{cell:import('./Dataset').Cell,html:string,resolution:number} | undefined}
     * @protected
     */
    getCellFocusInfo(posGeo) {
        //go through the layers, starting from top
        const zf = this.getZoomFactor()
        for (let i = this.layers.length - 1; i >= 0; i--) {
            /** @type {Layer} */
            const layer = this.layers[i]
            if (!layer.visible) continue
            if (!layer.cellInfoHTML) continue
            //if (layer.cellInfoHTML === 'none') continue
            const dsc = layer.getDatasetComponent(zf)
            if (!dsc) continue

            //get cell at mouse position
            /** @type {import('./Dataset').Cell|undefined} */
            const cell = dsc.getCellFromPosition(posGeo, dsc.getViewCache())
            //console.log(cell, dsc.resolution)
            if (!cell) return undefined
            const html = layer.cellInfoHTML(cell, dsc.getResolution())
            if (!html) return undefined
            return { cell: cell, html: html, resolution: dsc.getResolution() }
        }
    }

    //getters and setters

    /** @returns {{x:number,y:number}} */
    getGeoCenter() {
        return this.cg.getCenter()
    }
    /** @param {{x:number,y:number}} val @returns {this} */
    setGeoCenter(val) {
        this.cg.setCenter(val)
        return this
    }

    /** @returns {number} */
    getZoomFactor() {
        return this.cg.getZf()
    }
    /** @param {number} val @returns {this} */
    setZoomFactor(val) {
        this.cg.setZf(val)
        return this
    }

    /** @returns {Array.<number>} */
    getZoomFactorExtent() {
        return this.cg.getZfExtent()
    }
    /** @param {Array.<number>} val @returns {this} */
    setZoomFactorExtent(val) {
        this.cg.setZfExtent(val)
        return this
    }

    /** @returns {string} */
    getBackgroundColor() {
        return this.cg.backgroundColor
    }
    /** @param {string} val @returns {this} */
    setBackgroundColor(val) {
        this.cg.backgroundColor = val
        return this
    }

    /** @returns {LineLayer | undefined} */
    getBoundaryLayer() {
        return this.boundaryLayer
    }
    /** @param {object} opts @returns {this} */
    setBoundaryLayer(opts) {
        this.boundaryLayer = new _LineLayer_js__WEBPACK_IMPORTED_MODULE_10__.LineLayer(opts)
        return this
    }

    /** @returns {LabelLayer | undefined} */
    getLabelLayer() {
        return this.labelLayer
    }
    /** @param {object} opts @returns {this} */
    setLabelLayer(opts) {
        this.labelLayer = new _LabelLayer_js__WEBPACK_IMPORTED_MODULE_9__.LabelLayer(opts)
        return this
    }

    /** @returns {this} */
    redraw() {
        this.cg.redraw()
        return this
    }

    /**
     * Add a layer to the app.
     *
     * @param {Dataset} dataset The dataset of the layer
     * @param {Array.<import('./Style').Style>} styles The styles of the layer
     * @param {{visible?:boolean,minZoom?:number,maxZoom?:number,pixNb?:number,cellInfoHTML?:function(import('./Dataset').Cell):string}} opts The layer options.
     * @returns {this}
     */
    addLayerFromDataset(dataset, styles, opts) {
        const lay = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer(dataset, styles, opts)
        this.layers.push(lay)
        return this
    }

    //dataset creation

    /**
     * Make a local grid dataset.
     *
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {Array} cells The cells.
     * @param {object=} opts The parameters of the dataset.
     * @returns {Dataset}
     */
    makeLGridDataset(resolution, cells, opts) {
        return new _Dataset_js__WEBPACK_IMPORTED_MODULE_2__.Dataset([new _dataset_LGrid_js__WEBPACK_IMPORTED_MODULE_5__.LGrid(resolution, cells)], [], opts)
    }

    /**
     * Make a CSV grid dataset.
     *
     * @param {string} url The URL of the dataset.
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {object=} opts The parameters of the dataset.
     * @returns {Dataset}
     */
    makeCSVGridDataset(url, resolution, opts) {
        return new _Dataset_js__WEBPACK_IMPORTED_MODULE_2__.Dataset(
            [
                new _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_4__.CSVGrid(url, resolution, opts).getData(undefined, () => {
                    this.cg.redraw()
                }),
            ],
            [],
            opts
        )
    }

    /**
     * Make a tiled grid dataset.
     *
     * @param {string} url
     * @param {{preprocess?:function(import('./Dataset').Cell):boolean}} opts
     * @returns {Dataset}
     */
    makeTiledGridDataset(url, opts) {
        return new _Dataset_js__WEBPACK_IMPORTED_MODULE_2__.Dataset(
            [
                new _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_6__.TiledGrid(url, this, opts).loadInfo(() => {
                    this.cg.redraw()
                }),
            ],
            [],
            opts
        )
    }

    //multi scale dataset creation

    /**
     * Make a multi scale CSV grid dataset.
     *
     * @param {Array.<number>} resolutions
     * @param {function(number):string} resToURL
     * @param {{preprocess?:function(import('./Dataset').Cell):boolean}} opts
     * @returns {Dataset}
     */
    makeMultiScaleCSVGridDataset(resolutions, resToURL, opts) {
        return _Dataset_js__WEBPACK_IMPORTED_MODULE_2__.Dataset.make(
            resolutions,
            (res) =>
                new _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_4__.CSVGrid(resToURL(res), res, opts).getData(undefined, () => {
                    this.cg.redraw()
                }),
            opts
        )
    }

    //tiled multiscale

    /**
     * Make a multi scale tiled grid dataset.
     *
     * @param {Array.<number>} resolutions
     * @param {function(number):string} resToURL
     * @param {{preprocess?:function(import('./Dataset').Cell):boolean}} opts
     * @returns {Dataset}
     */
    makeMultiScaleTiledGridDataset(resolutions, resToURL, opts) {
        return _Dataset_js__WEBPACK_IMPORTED_MODULE_2__.Dataset.make(
            resolutions,
            (res) =>
                new _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_6__.TiledGrid(resToURL(res), this, opts).loadInfo(() => {
                    this.cg.redraw()
                }),
            opts
        )
    }

    // direct layer creation

    /**
     * Add a layer from a CSV grid dataset.
     *
     * @param {string} url The URL of the dataset.
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {Array.<import('./Style').Style>} styles The styles, ordered in drawing order.
     * @param {object=} opts The parameters of the dataset and layer.
     * @returns {this}
     */
    addCSVGridLayer(url, resolution, styles, opts) {
        const ds = this.makeCSVGridDataset(url, resolution, opts)
        return this.addLayerFromDataset(ds, styles, opts)
    }

    /**
     *
     * @param {string} url
     * @param {Array.<import('./Style').Style>} styles
     * @param {{visible?:boolean,minZoom?:number,maxZoom?:number,pixNb?:number,cellInfoHTML?:function(import('./Dataset').Cell):string, preprocess?:function(import('./Dataset').Cell):boolean}} opts
     * @returns {this}
     */
    addTiledGridLayer(url, styles, opts) {
        const ds = this.makeTiledGridDataset(url, opts)
        return this.addLayerFromDataset(ds, styles, opts)
    }

    /**
     * Add a layer from a CSV grid dataset.
     *
     * @param {Array.<number>} resolutions
     * @param {function(number):string} resToURL
     * @param {Array.<import('./Style').Style>} styles The styles, ordered in drawing order.
     * @param {object=} opts The parameters of the dataset and layer.
     * @returns {this}
     */
    addMultiScaleCSVGridLayer(resolutions, resToURL, styles, opts) {
        const ds = this.makeMultiScaleCSVGridDataset(resolutions, resToURL, opts)
        return this.addLayerFromDataset(ds, styles, opts)
    }

    /**
     * @param {Array.<number>} resolutions
     * @param {function(number):string} resToURL
     * @param {Array.<import('./Style').Style>} styles
     * @param {{visible?:boolean,minZoom?:number,maxZoom?:number,pixNb?:number,cellInfoHTML?:function(import('./Dataset').Cell):string, preprocess?:function(import('./Dataset').Cell):boolean}} opts
     * @returns {this}
     */
    addMultiScaleTiledGridLayer(resolutions, resToURL, styles, opts) {
        const ds = this.makeMultiScaleTiledGridDataset(resolutions, resToURL, opts)
        return this.addLayerFromDataset(ds, styles, opts)
    }

    /**
     * Add a background layer to the app.
     *
     * @param {object} opts
     * @returns {this}
     */
    addBackgroundLayer(opts) {
        this.bgLayers.push(new _BackgroundLayer_js__WEBPACK_IMPORTED_MODULE_7__.BackgroundLayer(opts))
        this.redraw()
        return this
    }

    /**
     * Add a WMS background layer to the app.
     *
     * @param {object} opts
     * @returns {this}
     */
    addBackgroundLayerWMS(opts) {
        this.bgLayers.push(new _BackgroundLayerWMS_js__WEBPACK_IMPORTED_MODULE_8__.BackgroundLayerWMS(opts))
        this.redraw()
        return this
    }

    /**
     *
     * @param {string} id
     * @param {object} opts
     * @returns {this}
     */
    addZoomSlider(id, opts) {
        this.cg.addZoomSlider(id, opts)
        return this
    }

    /**
     * Adds a set of zoom buttons to the app
     *
     * @param {object} opts
     * @returns {this}
     */
    addZoomButtons(opts) {
        // * opts.id
        // * opts.onZoom - custom event handler function
        // * opts.x
        // * opts.y
        // * opts.delta - zoom delta applied on each click

        this.zoomButtons = new _button_ZoomButtons_js__WEBPACK_IMPORTED_MODULE_12__.ZoomButtons({
            app: this,
            id: opts?.id || 'gridviz-zoom-buttons',
            class: opts?.class,
            x: opts?.x,
            y: opts?.y,
            onZoom: opts?.onZoom,
            delta: opts?.delta || 0.2
        })

        return this
    }

    /**
     * Adds a fullscreen toggle button to the app
     *
     * @param {object} opts
     * @returns {this}
     */
    addFullscreenButton(opts) {
        // * opts.app - the gridviz app
        // * opts.id
        // * opts.x
        // * opts.y

        this.fullscreenButton = new _button_FullscreenButton_js__WEBPACK_IMPORTED_MODULE_13__.FullscreenButton({
            app: this,
            id: opts?.id || 'gridviz-fullscreen-button',
            class: opts?.class,
            x: opts?.x,
            y: opts?.y
        })

        return this
    }

    /** @returns {this} */
    setViewFromURL() {
        this.cg.setViewFromURL()
        return this
    }

    /**
     * @description Add a resize event observer to the Apps container and update the canvas accordingly
     * @param {HTMLDivElement} container The App's container element
     * @param {HTMLCanvasElement} canvas The App canvas element
     * @memberof App
     */
    defineResizeObserver(container, canvas) {
        // listen to resize events
        const resizeObserver = new ResizeObserver((entries) => {
            // make sure canvas has been built
            if (container.clientWidth > 0 && container.clientHeight > 0) {
                // make sure we dont exceed loop limit first
                // see: https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded
                window.requestAnimationFrame(() => {
                    if (!Array.isArray(entries) || !entries.length) {
                        return
                    }
                    // update the app and canvas size
                    if (this.h !== container.clientHeight || this.w !== container.clientWidth) {
                        this.h = container.clientHeight
                        this.w = container.clientWidth
                        this.cg.h = container.clientHeight
                        this.cg.w = container.clientWidth
                        canvas.setAttribute('width', '' + this.w)
                        canvas.setAttribute('height', '' + this.h)
                        this.redraw()

                        //update button positions
                        // if (this.zoomButtons) this.zoomButtons.node.style.left = this.w - 50 + 'px'
                        // if (this.fullscreenButton) this.fullscreenButton.node.style.left = this.w - 50 + 'px'
                    }
                })
            }
        })

        resizeObserver.observe(container)
    }

    /**
     * @description Destroy the app and it's event listeners
     * This should significantly reduce the memory used when creating and destroying gridviz app instances (for example in leaflet-gridviz)
     * @memberof App
     */
    destroy() {
        // clear layers
        this.layers = []
        this.bgLayers = []

        // remove event listeners from container
        this.container.removeEventListener('mouseover', this.mouseOverHandler)
        this.container.removeEventListener('mousemove', this.mouseMoveHandler)
        this.container.removeEventListener('mouseout', this.mouseOutHandler)

        // remove canvas
        this.cg.canvas.remove()

        // remove legend
        this.legend?.remove()

        // remove tooltip
        this.tooltip.tooltip?.remove()
    }
}


/***/ }),

/***/ "./src/BackgroundLayer.js":
/*!********************************!*\
  !*** ./src/BackgroundLayer.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BackgroundLayer": () => (/* binding */ BackgroundLayer)
/* harmony export */ });
//@ts-check


/**
 *
 * A map background layer in "Slippy map" XYZ standard.
 * See https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames
 * https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/#6/27.88/44.48
 * 
 * @author Julien Gaffuri
 */
class BackgroundLayer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** An attribute to specify if a layer should be drawn or not
         * @type {boolean} */
        this.visible = opts.visible == false ? false : true

        /** The minimum zoom factor: Below this level, the layer is not shown.
         * @type {number} */
        this.minZoom = opts.minZoom || 0

        /** The maximum zoom factor: Above this level, the layer is not shown.
         * @type {number} */
        this.maxZoom = opts.maxZoom || Infinity

        //ensure acceptable values for the zoom limits.
        if (this.minZoom >= this.maxZoom)
            throw new Error('Unexpected zoom limits for layer. Zoom min should be smaller than zoom max.')

        /** The image cache, indexed by z/y/x */
        this.cache = {}

        /**
         * @type {string} */
        this.url = opts.url
        /** @type {function(number,number,number):string} */
        this.urlFun = opts.urlFun || ((x, y, z) => this.url + z + '/' + x + '/' + y + '.png')

        /** @type {Array.<number>} */
        this.resolutions = opts.resolutions
        if (!this.resolutions || this.resolutions.length == 0)
            throw new Error('No resolutions provided for background layer')

        /** @type {number} */
        this.nbPix = opts.nbPix || 256
        /** CRS coordinates of top left corner
         * @type {Array.<number>} */
        this.origin = opts.origin || [0, 0]
        /** @type {number} */
        this.z0 = opts.z0 || 0

        /** @type {function(number):string} */
        this.filterColor = opts.filterColor // (zf) => "#eee7"
    }

    /**
     * Get z/x/y cache data.
     * @param {number} z
     * @param {number} x
     * @param {number} y
     * @returns {HTMLImageElement|string|undefined}
     * @private
     */
    get(z, x, y) {
        let d = this.cache[z]
        if (!d) return
        d = d[x]
        if (!d) return
        return d[y]
    }

    /**
     * Get z/x/y cache data.
     * @param {HTMLImageElement|string} img
     * @param {number} z
     * @param {number} x
     * @param {number} y
     * @returns
     * @private
     */
    put(img, z, x, y) {
        if (!this.cache[z]) this.cache[z] = {}
        if (!this.cache[z][x]) this.cache[z][x] = {}
        this.cache[z][x][y] = img
    }

    /**
     * @param {import("./GeoCanvas").GeoCanvas} cg The canvas where to draw the layer.
     * @returns {void}
     */
    draw(cg) {
        if (!this.resolutions || this.resolutions.length == 0) {
            console.error('No resolutions provided for background layer')
            return
        }

        //
        const zf = cg.getZf()
        const x0 = this.origin[0],
            y0 = this.origin[1]

        //get zoom level and resolution
        let z = 0
        for (z = 0; z < this.resolutions.length; z++) if (this.resolutions[z] < zf) break
        z -= 1
        z = Math.max(0, z)
        z = Math.min(z, this.resolutions.length - 1)
        //console.log(this.resolutions.length, z)
        const res = this.resolutions[z]

        z += this.z0

        const sizeG = this.nbPix * res
        const size = sizeG / zf

        //get tile numbers
        const xGeoToTMS = (x) => Math.ceil((x - x0) / sizeG)
        const yGeoToTMS = (y) => Math.ceil(-(y - y0) / sizeG)
        const xMin = xGeoToTMS(cg.extGeo.xMin) - 1
        const xMax = xGeoToTMS(cg.extGeo.xMax)
        const yMax = yGeoToTMS(cg.extGeo.yMin)
        const yMin = yGeoToTMS(cg.extGeo.yMax) - 1

        //TODO ?
        //cg.setCanvasTransform()

        //handle images
        for (let x = xMin; x < xMax; x++) {
            for (let y = yMin; y < yMax; y++) {
                //get image
                let img = this.get(z, x, y)

                //load image
                if (!img) {
                    const img = new Image()
                    this.put(img, z, x, y)
                    img.onload = () => {
                        cg.redraw()
                    }
                    img.onerror = () => {
                        //case when no image
                        this.put('failed', z, x, y)
                    }
                    img.src = this.urlFun(x, y, z)
                    continue
                }

                //case when no image
                if (img === 'failed') continue
                if (!(img instanceof HTMLImageElement)) {
                    console.log(img)
                    continue
                }
                if (img.width == 0 || img.height == 0) continue

                //draw image
                const xGeo = x0 + x * sizeG
                const yGeo = y0 - y * sizeG
                try {
                    cg.ctx.drawImage(img, cg.geoToPixX(xGeo), cg.geoToPixY(yGeo), size, size)
                    //cg.ctx.drawImage(img, xGeo, yGeo, sizeG, -sizeG)
                } catch (error) {
                    console.error(error)
                }
            }
        }

        //apply filter
        if (this.filterColor) {
            const fc = this.filterColor(zf)
            if (fc && fc != 'none') {
                cg.ctx.fillStyle = fc
                cg.ctx.fillRect(0, 0, cg.w, cg.h)
            }
        }
    }
}


/***/ }),

/***/ "./src/BackgroundLayerWMS.js":
/*!***********************************!*\
  !*** ./src/BackgroundLayerWMS.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BackgroundLayerWMS": () => (/* binding */ BackgroundLayerWMS)
/* harmony export */ });
//@ts-check


/**
 *
 * A map WMS background layer.
 * 
 * @author Julien Gaffuri
 */
class BackgroundLayerWMS {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** An attribute to specify if a layer should be drawn or not
         * @type {boolean} */
        this.visible = opts.visible == false ? false : true

        /** The minimum zoom factor: Below this level, the layer is not shown.
         * @type {number} */
        this.minZoom = opts.minZoom || 0

        /** The maximum zoom factor: Above this level, the layer is not shown.
         * @type {number} */
        this.maxZoom = opts.maxZoom || Infinity

        //ensure acceptable values for the zoom limits.
        if (this.minZoom >= this.maxZoom)
            throw new Error('Unexpected zoom limits for layer. Zoom min should be smaller than zoom max.')

        /**
         * @type {string} */
        this.url = opts.url

        /** @type {function(number):string} */
        this.filterColor = opts.filterColor // (zf) => "#eee7"

        /** @type {HTMLImageElement|undefined} */
        this.img = undefined;

        /** @type {number|undefined} */
        this.xMin = undefined;
        /** @type {number|undefined} */
        this.xMax = undefined;
        /** @type {number|undefined} */
        this.yMin = undefined;
        /** @type {number|undefined} */
        this.yMax = undefined;
    }

    /** Check if the view has moved and a new image needs to be retrieved.
     * @private */
    hasMoved(extGeo) {
        if ((extGeo.xMin) != this.xMin) return true
        else if ((extGeo.xMax) != this.xMax) return true
        else if ((extGeo.yMin) != this.yMin) return true
        else if ((extGeo.yMax) != this.yMax) return true
        else return false
    }


    /**
     * @param {import("./GeoCanvas").GeoCanvas} cg The canvas where to draw the layer.
     * @returns {void}
     */
    draw(cg) {

        //update map extent
        cg.updateExtentGeo(0)

        if (!this.hasMoved(cg.extGeo) && this.img) {
            //the map did not move and the image was already downloaded: draw the image
            cg.ctx.drawImage(this.img, 0, 0, cg.w, cg.h)

        } else {
            //the map moved: retrieve new image

            //
            this.xMin = cg.extGeo.xMin
            this.xMax = cg.extGeo.xMax
            this.yMin = cg.extGeo.yMin
            this.yMax = cg.extGeo.yMax

            //build WMS URL
            const url = []
            url.push(this.url)
            url.push("&width=")
            url.push(cg.w)
            url.push("&height=")
            url.push(cg.h)
            //bbox: xmin ymin xmax ymax
            url.push("&bbox=")
            url.push(cg.extGeo.xMin)
            url.push(",")
            url.push(cg.extGeo.yMin)
            url.push(",")
            url.push(cg.extGeo.xMax)
            url.push(",")
            url.push(cg.extGeo.yMax)

            const urlS = url.join("")
            //console.log(urlS)

            if (!this.img) {
                this.img = new Image()
                this.img.onload = () => {
                    cg.redraw()
                }
                this.img.onerror = () => {
                    //case when no image
                    console.warn("Could not retrieve WMS background image from", urlS)
                }
            }

            //set URL to launch the download
            this.img.src = urlS
        }

        //apply filter
        const zf = cg.getZf()
        if (this.filterColor) {
            const fc = this.filterColor(zf)
            if (fc && fc != 'none') {
                cg.ctx.fillStyle = fc
                cg.ctx.fillRect(0, 0, cg.w, cg.h)
            }
        }
    }
}


/***/ }),

/***/ "./src/Dataset.js":
/*!************************!*\
  !*** ./src/Dataset.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dataset": () => (/* binding */ Dataset)
/* harmony export */ });
//@ts-check


/**
 * A grid cell.
 * @typedef {{x: number, y: number}} Cell */
/**
 * An envelope.
 * @typedef { {xMin: number, xMax: number, yMin: number, yMax: number} } Envelope */

/**
 * A multi resolution dataset of grid cells.
 * It consists of different {@link DatasetComponent}s for each resolution.
 *
 * @abstract
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class Dataset {
    /**
     * @param {Array.<import("./DatasetComponent").DatasetComponent>} datasetComponents The dataset components
     * @param {Array.<number>} resolutions The resolutions of the dataset components, in CRS geographical unit
     * @param { {preprocess?:function(Cell):boolean} } opts Options. preprocess: A function to apply on each dataset cell to prepare its values. Can be used also to select cells to keep.
     */
    constructor(datasetComponents, resolutions, opts = {}) {
        opts = opts || {}

        /** The dataset components.
         * @type {Array.<import("./DatasetComponent").DatasetComponent>} */
        this.datasetComponents = datasetComponents

        /** The resolutions of the dataset components, in CRS geographical unit.
         * @type {Array.<number>} */
        this.resolutions = resolutions

        //there must be as many dataset components as resolutions
        if (this.datasetComponents.length > 1 && this.datasetComponents.length != this.resolutions.length)
            throw new Error(
                'Uncompatible number of datasets and resolutions: ' +
                    this.datasetComponents.length +
                    ' ' +
                    this.resolutions.length
            )

        //set dataset preprocesses if specified
        if (opts.preprocess) this.setPrepocesses(opts.preprocess)
    }

    /**
     * Set a preprocess function for all dataset components.
     * This is a function applied on each cell after it has been loaded.
     *
     * @param {function(Cell):boolean} preprocess
     * @returns {this}
     */
    setPrepocesses(preprocess) {
        for (let ds of this.datasetComponents) ds.preprocess = preprocess
        return this
    }

    /**
     * A function to ease the creation of datasets from their components.
     *
     * @param {Array.<number>} resolutions The resolutions of the dataset components, in CRS geographical unit
     * @param {function(number):import("./DatasetComponent").DatasetComponent} resToDatasetComponent Function returning a dataset component from a resolution
     * @param { {preprocess?:function(Cell):boolean} } opts Options. preprocess: A function to apply on each dataset cell to prepare its values
     * @returns {Dataset}
     */
    static make(resolutions, resToDatasetComponent, opts) {
        //make dataset components
        const dsc = []
        for (const res of resolutions) dsc.push(resToDatasetComponent(res))
        //make dataset
        return new Dataset(dsc, resolutions, opts)
    }
}


/***/ }),

/***/ "./src/DatasetComponent.js":
/*!*********************************!*\
  !*** ./src/DatasetComponent.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DatasetComponent": () => (/* binding */ DatasetComponent)
/* harmony export */ });
//@ts-check


/**
 * A dataset component, of grid cells.
 * @abstract
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class DatasetComponent {
    /**
     * @param {string} url The URL of the dataset.
     * @param {number} resolution The dataset resolution, in the CRS geographical unit.
     * @param {{preprocess?:function(import("./Dataset").Cell):boolean}} opts
     * @abstract
     */
    constructor(url, resolution, opts = {}) {
        opts = opts || {}

        /**
         * The url of the dataset.
         * @protected
         * @type {string} */
        this.url = url

        /**
         * The dataset resolution in geographical unit.
         * @protected
         * @type {number} */
        this.resolution = resolution

        /**
         * A preprocess to run on each cell after loading. It can be used to apply some specific treatment before or compute a new column. And also to determine which cells to keep after loading.
         * @type {(function(import("./Dataset").Cell):boolean )| undefined } */
        this.preprocess = opts.preprocess || undefined

        /** The cells within the view
         * @protected
         * @type {Array.<import("./Dataset").Cell>} */
        this.cellsViewCache = []
    }

    /**
     * Request data within a geographic envelope.
     *
     * @abstract
     * @param {import("./Dataset").Envelope|undefined} extGeo
     * @param {function():void} callback
     * @returns {this}
     */
    getData(extGeo, callback) {
        throw new Error('Method getData not implemented.')
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     * @abstract
     * @param {import("./Dataset").Envelope} extGeo The view geographical envelope.
     * @returns {void}
     */
    updateViewCache(extGeo) {
        throw new Error('Method updateViewCache not implemented.')
    }

    /**
     * Get a cell under a given position, if any.
     *
     * @param {{x:number,y:number}} posGeo
     * @param {Array.<import("./Dataset").Cell>} cells Some cells from the dataset (a subset if necessary, usually the view cache).
     * @returns {import("./Dataset").Cell|undefined}
     */
    getCellFromPosition(posGeo, cells) {
        //compute candidate cell position
        /** @type {number} */
        //const r = this.getResolution()
        /** @type {number} */
        //const cellX = r * Math.floor(posGeo.x / r)
        /** @type {number} */
        //const cellY = r * Math.floor(posGeo.y / r)

        /*/get cell
        for (const cell of cells) {
            if (cell.x != cellX) continue
            if (cell.y != cellY) continue
            return cell
        }
        return undefined*/

        /** @type {number} */
        const r = this.getResolution()
        for (const cell of cells) {
            if (posGeo.x < cell.x) continue
            else if (cell.x + r < posGeo.x) continue
            else if (posGeo.y < cell.y) continue
            else if (cell.y + r < posGeo.y) continue
            else return cell
        }
        return undefined

    }

    //getters and setters

    /** @returns {number} */
    getResolution() {
        return this.resolution
    }

    /** @returns {Array.<import("./Dataset").Cell>} */
    getViewCache() {
        return this.cellsViewCache
    }
}


/***/ }),

/***/ "./src/GeoCanvas.js":
/*!**************************!*\
  !*** ./src/GeoCanvas.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GeoCanvas": () => (/* binding */ GeoCanvas)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
//@ts-check


/** @typedef { {xMin: number, xMax: number, yMin: number, yMax: number} } Envelope */

;


/**
 * A HTML canvas for geo data display, enhanced with zoom and pan capabilities.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class GeoCanvas {
    /**
     * @constructor
     * @param {HTMLCanvasElement} canvas
     * @param {object} center Geographical coordinates of the center
     * @param {number} zf The zoom factor (pixel size, in ground m)
     * @param {object} opts
     */
    constructor(canvas, center, zf, opts) {
        this.opts = opts || {}

        /** @type {HTMLCanvasElement} */
        this.canvas = canvas

        /** @type {number} */
        this.w = this.canvas.offsetWidth
        /** @type {number} */
        this.h = this.canvas.offsetHeight

        this.canvas.width = this.w
        this.canvas.height = this.h

        const ctx = this.canvas.getContext('2d')
        if (!ctx) throw 'Impossible to create canvas 2D context'
        /**@type {CanvasRenderingContext2D} */
        this.ctx = ctx

        // set geo coordinates of the center
        this.center = center || { x: this.w * 0.5, y: this.h * 0.5 }

        // zoom factor: pixel size, in m/pix
        /** @type {number} */
        this.zf = zf

        /** Background color.
         * @type {string} */
        this.backgroundColor = opts.backgroundColor || 'white'

        /** @type {function():void} */
        this.onZoomStartFun = opts.onZoomStartFun

        /** @type {function():void} */
        this.onZoomEndFun = opts.onZoomEndFun

        /** @type {function():void} */
        this.onZoomFun = opts.onZoomFun

        //current extent
        /** @type {Envelope} */
        this.extGeo = { xMin: NaN, xMax: NaN, yMin: NaN, yMax: NaN }
        this.updateExtentGeo()

        //rely on d3 zoom for pan/zoom
        if (!opts.disableZoom) {
            let tP = d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity
            const z = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()
                //to make the zooming a bit faster
                .wheelDelta((e) => -e.deltaY * (e.deltaMode === 1 ? 0.07 : e.deltaMode ? 1 : 0.004))
                .on('zoom', (e) => {
                    const t = e.transform
                    const f = tP.k / t.k
                    if (f == 1) {
                        //pan
                        const dx = tP.x - t.x
                        const dy = tP.y - t.y
                        this.pan(dx * this.getZf(), -dy * this.getZf())
                    } else {
                        const se = e.sourceEvent
                        if (se instanceof WheelEvent) {
                            //zoom at the mouse position
                            this.zoom(
                                f,
                                this.pixToGeoX(e.sourceEvent.offsetX),
                                this.pixToGeoY(e.sourceEvent.offsetY)
                            )
                        } else if (se instanceof TouchEvent) {
                            //compute average position of the touches
                            let tx = 0,
                                ty = 0
                            for (let tt of se.targetTouches) {
                                tx += tt.clientX
                                ty += tt.clientY
                            }
                            tx /= se.targetTouches.length
                            ty /= se.targetTouches.length
                            //zoom at this average position
                            this.zoom(f, this.pixToGeoX(tx), this.pixToGeoY(ty))
                        }
                    }
                    tP = t

                    if (this.onZoomFun) this.onZoomFun(e)
                })
                .on('start', (e) => {
                    this.canvasSave.c = document.createElement('canvas')
                    this.canvasSave.c.setAttribute('width', '' + this.w)
                    this.canvasSave.c.setAttribute('height', '' + this.h)
                    this.canvasSave.c.getContext('2d').drawImage(this.canvas, 0, 0)
                    this.canvasSave.dx = 0
                    this.canvasSave.dy = 0
                    this.canvasSave.f = 1

                    if (this.onZoomStartFun) this.onZoomStartFun(e)
                })
                .on('end', (e) => {
                    this.redraw(true)
                    this.canvasSave = { c: null, dx: 0, dy: 0, f: 1 }

                    if (this.onZoomEndFun) this.onZoomEndFun(e)
                })
            z((0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this.canvas))
        }
        //select(this.canvas).call(z);

        /** Zoom extent, to limit zoom in and out
         *  @type {Array.<number>} */
        this.zfExtent = [0, Infinity]

        /** Canvas state, to be used to avoid unnecessary redraws on zoom/pan
         *  @type {{c:HTMLCanvasElement|null,dx:number,dy:number,f:number}} */
        this.canvasSave = { c: null, dx: 0, dy: 0, f: 1 }
    }

    /** @param {{x:number,y:number}} v Geographical coordinates of the center */
    setCenter(v) {
        this.center = v
    }
    /** @returns {{x:number,y:number}} Geographical coordinates of the center */
    getCenter() {
        return this.center
    }

    /** @param {number} v The zoom factor (pixel size, in ground m) */
    setZf(v) {
        this.zf = v
        if (this.slider) this.slider.attr('value', +this.zf)
    }
    /** @returns {number} The zoom factor (pixel size, in ground m) */
    getZf() {
        return this.zf
    }

    /** @param {Array.<number>} v */
    setZfExtent(v) {
        this.zfExtent = v
    }
    /** @returns {Array.<number>} */
    getZfExtent() {
        return this.zfExtent
    }

    /** Initialise canvas transform with identity transformation. */
    initCanvasTransform() {
        this.ctx.setTransform(1, 0, 0, 1, 0, 0)
    }

    /** Initialise canvas transform with geo to screen transformation, so that geo objects can be drawn directly in geo coordinates. */
    setCanvasTransform() {
        const k = 1 / this.getZf()
        const tx = -this.center.x / this.getZf() + this.w * 0.5
        const ty = this.center.y / this.getZf() + this.h * 0.5
        this.ctx.setTransform(k, 0, 0, -k, tx, ty)
    }

    /** Get the transformation matrix to webGL screen coordinates, within [-1,1]*[-1,1] */
    getWebGLTransform() {
        const kx = 2.0 / (this.w * this.getZf())
        const ky = 2.0 / (this.h * this.getZf())
        return [kx, 0.0, 0.0, 0.0, ky, 0.0, -kx * this.center.x, -ky * this.center.y, 1.0]
    }

    /** The function specifying how to draw the map.
     * @param {boolean} strong */
    redraw(strong = true) {
        throw new Error('Method redraw not implemented.')
    }

    /**
     * Clear. To be used before a redraw for example.
     * @param {string} color
     */
    clear(color = 'white') {
        if (this.opts.transparentBackground) {
            this.ctx.clearRect(0, 0, this.w, this.h)
        } else {
            if (this.ctx) this.ctx.fillStyle = color
            this.ctx.fillRect(0, 0, this.w, this.h)
        }
    }

    /**
     * @param {number} dxGeo
     * @param {number} dyGeo
     */
    pan(dxGeo = 0, dyGeo = 0) {
        //TODO force extend to remain
        this.center.x += dxGeo
        this.center.y += dyGeo
        this.updateExtentGeo()

        if (this.canvasSave.c) {
            this.canvasSave.dx -= dxGeo / this.getZf()
            this.canvasSave.dy += dyGeo / this.getZf()
            this.clear(this.backgroundColor)
            // this doesnt work on mobile https://github.com/eurostat/gridviz/issues/98
            this.ctx.drawImage(this.canvasSave.c, this.canvasSave.dx, this.canvasSave.dy)
        }
    }

    /**
     * Zoom.
     * @param {number} f The zoom factor, within ]0, Infinity]. 1 is for no change. <1 to zoom-in, >1 to zoom-out.
     * @param {number} xGeo The x geo position fixed in the screen.
     * @param {number} yGeo The y geo position fixed in the screen.
     */
    zoom(f = 1, xGeo = this.center.x, yGeo = this.center.y) {
        //TODO force geo extend to remain

        //trying to zoom in/out beyond limit
        if (this.zfExtent[0] == this.getZf() && f <= 1) return
        if (this.zfExtent[1] == this.getZf() && f >= 1) return

        //ensure zoom extent preserved
        const newZf = f * this.getZf()
        if (newZf < this.zfExtent[0]) f = this.zfExtent[0] / this.getZf()
        if (newZf > this.zfExtent[1]) f = this.zfExtent[1] / this.getZf()

        this.setZf(f * this.getZf())
        const dxGeo = (xGeo - this.center.x) * (1 - f)
        this.center.x += dxGeo
        const dyGeo = (yGeo - this.center.y) * (1 - f)
        this.center.y += dyGeo
        this.updateExtentGeo()

        //TODO
        //this.redraw(false)
        if (this.canvasSave.c) {
            this.clear(this.backgroundColor)
            this.canvasSave.f /= f
            this.canvasSave.dx = this.geoToPixX(xGeo) * (1 - this.canvasSave.f)
            this.canvasSave.dy = this.geoToPixY(yGeo) * (1 - this.canvasSave.f)
            this.clear(this.backgroundColor)
            this.ctx.drawImage(
                this.canvasSave.c,
                this.canvasSave.dx,
                this.canvasSave.dy,
                this.canvasSave.f * this.canvasSave.c.width,
                this.canvasSave.f * this.canvasSave.c.height
            )
        }
    }

    /**
     * @param {number} marginPx
     * @returns {Envelope} The envelope of the view, in geo coordinates.
     */
    updateExtentGeo(marginPx = 20) {
        this.extGeo = {
            xMin: this.pixToGeoX(-marginPx),
            xMax: this.pixToGeoX(this.w + marginPx),
            yMin: this.pixToGeoY(this.h + marginPx),
            yMax: this.pixToGeoY(-marginPx),
        }
        return this.extGeo
    }

    /**
     * Check if the object has to be drawn
     *
     * @param {{x:number,y:number}} obj
     */
    toDraw(obj) {
        if (obj.x < this.extGeo.xMin) return false
        if (obj.x > this.extGeo.xMax) return false
        if (obj.y < this.extGeo.yMin) return false
        if (obj.y > this.extGeo.yMax) return false
        return true
    }

    //conversion functions
    /**
     * @param {number} xGeo Geo x coordinate, in m.
     * @returns {number} Screen x coordinate, in pix.
     */
    geoToPixX(xGeo) {
        return (xGeo - this.center.x) / this.getZf() + this.w * 0.5
    }
    /**
     * @param {number} yGeo Geo y coordinate, in m.
     * @returns {number} Screen y coordinate, in pix.
     */
    geoToPixY(yGeo) {
        return -(yGeo - this.center.y) / this.getZf() + this.h * 0.5
    }
    /**
     * @param {number} x Screen x coordinate, in pix.
     * @returns {number} Geo x coordinate, in m.
     */
    pixToGeoX(x) {
        return (x - this.w * 0.5) * this.getZf() + this.center.x
    }
    /**
     * @param {number} y Screen y coordinate, in pix.
     * @returns {number} Geo y coordinate, in m.
     */
    pixToGeoY(y) {
        return -(y - this.h * 0.5) * this.getZf() + this.center.y
    }

    /** Get x,y,z elements from URL and assign them to the view center and zoom level. */
    setViewFromURL() {
        const x = GeoCanvas.getParameterByName('x'),
            y = GeoCanvas.getParameterByName('y'),
            z = GeoCanvas.getParameterByName('z')
        const c = this.getCenter()
        if (x != null && x != undefined && !isNaN(+x)) c.x = +x
        if (y != null && y != undefined && !isNaN(+y)) c.y = +y
        if (z != null && z != undefined && !isNaN(+z)) this.setZf(+z)
    }

    /**
     *
     * @param {string} id
     * @param {object} opts
     * @returns {this}
     */
    addZoomSlider(id, opts) {
        opts = opts || {}
        opts.width = opts.width || '30px'
        opts.height = opts.height || '300px'

        //the div element
        const div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])('#' + id)
        if (div.empty()) {
            console.error('Could not find div element to build zoom slider. Id: ' + id)
            return this
        }

        const th = this
        /** */
        this.slider = div
            .append('input')
            .attr('type', 'range')
            .attr('min', this.getZfExtent()[0])
            .attr('max', this.getZfExtent()[1])
            .attr('value', this.getZf())
            .on('input', function (d) {
                if (!this || !this.value) return
                const v = +this.value
                ;(0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this).attr('value', v)
                th.setZf(v)
                //redraw
                th.redraw()
            })
            .style('width', opts.width)
            .style('height', opts.height)
            .style('opacity', 0.7)
            .on('mouseover', function (d) {
                (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this).style('opacity', 1)
            })
            .on('mouseout', function (d) {
                (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(this).style('opacity', 0.7)
            })
            .style('-webkit-appearance', 'slider-vertical') //for chrome
            .style('writing-mode', 'bt-lr') //for IE/edge
            .attr('orient', 'vertical') //for firefox
            .style('background', 'lightgray')
            .style('outline', 'none')
            .style('-webkit-transition', '.2s')
            .style('transition', 'opacity .2s')

        //TODO
        /*select(".slider::-webkit-slider-thumb")
            .style("-webkit-appearance", "none")
            .style("appearance", "none")
            .style("width", "30px")
            .style("height", "40px")
            .style("background", "black")
            .style("cursor", "pointer")*/

        /*select("slider::-moz-range-thumb")
            .style("-webkit-appearance", "none")
            .style("width", "30px")
            .style("height", "40px")
            .style("background", "#04AA6D")
            .style("cursor", "pointer")*/
        /*
            .slider::ms-thumb,
        .slider::-moz-range-thumb {
        }*/

        return this
    }

    /**
     * Get a URL parameter by name.
     *
     * @param {string} name
     * @returns {string | null}
     */
    static getParameterByName(name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]')
        var regex = new RegExp('[\\?&]' + name + '=([^&#]*)'),
            results = regex.exec(location.search)
        return !results ? null : decodeURIComponent(results[1].replace(/\+/g, ' '))
    }
}


/***/ }),

/***/ "./src/LabelLayer.js":
/*!***************************!*\
  !*** ./src/LabelLayer.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelLayer": () => (/* binding */ LabelLayer)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
//@ts-check


;

/** A label. The name is the text to show. (x,y) are the coordinates in the same CRS as the grid.
 * @typedef {{name: string, x:number, y:number }} Label */

/**
 * A (generic) layer for placename labels, to be shown on top of the grid layers.
 * The input is a CSV file with the position (x, y) of the labels and name + some other info on the label importance.
 * If the label data is not in the expected format or in the same CRS as the grid, it can be corrected with the "preprocess" function.
 * The selection of the label, their style (font, weight, etc.) and color can be specified depending on their importance and the zoom level.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class LabelLayer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /**
         * The URL of the label data, as CSV file.
         * The file should contain the information for each label such as the text, the position and other information for the display of the label according to the zoom level.
         * If necessary, this data can be reformated with the 'preprocess' parameter.
         * @private
         * @type {string} */
        this.url = opts.url

        /** Specify if and how a label should be drawn, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):string} */
        this.style = opts.style || (() => 'bold 1em Arial')

        /** Specify the label color, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):string} */
        this.color = opts.color || (opts.dark ? () => '#ddd' : () => '#222')

        /** Specify the label halo color, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):string} */
        this.haloColor = opts.haloColor || (opts.dark ? () => '#000000BB' : () => '#FFFFFFBB')

        /** Specify the label halo width, depending on its importance and the zoom level.
         * @private
         * @type {function(Label,number):number} */
        this.haloWidth = opts.haloWidth || (() => 4)

        /** The anchor where to draw the text, from label position. See HTML-canvas textAlign property.
         * "left" || "right" || "center" || "start" || "end"
         * @private
         * @type {CanvasTextAlign} */
        this.textAlign = opts.textAlign || 'start'

        /**
         * @private
         * @type {Array.<number>} */
        this.offsetPix = opts.offsetPix || [5, 5]

        /**
         * A preprocess to run on each label after loading.
         * It can be used to apply some specific treatment before, format the label data, project coordinates, etc.
         * Return false if the label should not be kept.
         * @private
         * @type {function(Label):boolean} */
        this.preprocess = opts.preprocess

        /**
         * @private
         * @type {Array.<Label> | undefined} */
        this.labels = undefined

        /**
         * @private
         * @type {string} */
        this.loadingStatus = 'notLoaded'
    }

    /**
     * Draw the label layer.
     *
     * @param {import("./GeoCanvas").GeoCanvas} cg The canvas where to draw the layer.
     * @returns {void}
     */
    draw(cg) {
        //load labels, if not done yet.
        if (!this.labels) {
            this.load(cg.redraw)
            return
        }

        //zoom factor
        const zf = cg.getZf()

        //text align
        cg.ctx.textAlign = this.textAlign || 'start'

        //line join and cap
        cg.ctx.lineJoin = 'bevel' //|| "round" || "miter";
        cg.ctx.lineCap = 'butt' //|| "round" || "square";

        //draw in pix coordinates
        cg.initCanvasTransform()

        //draw labels, one by one
        for (const lb of this.labels) {
            //get label style
            const st = this.style(lb, zf)
            if (!st) continue
            cg.ctx.font = st

            //check label within the view, to be drawn
            if (!cg.toDraw(lb)) continue

            //position
            const xP = cg.geoToPixX(lb.x) + this.offsetPix[0]
            const yP = cg.geoToPixY(lb.y) - this.offsetPix[1]

            //label stroke, for the halo
            if (this.haloColor && this.haloWidth) {
                const hc = this.haloColor(lb, zf)
                const hw = this.haloWidth(lb, zf)
                if (hc && hw && hw > 0) {
                    cg.ctx.strokeStyle = hc
                    cg.ctx.lineWidth = hw
                    cg.ctx.strokeText(lb.name, xP, yP)
                }
            }

            //label fill
            if (this.color) {
                const col = this.color(lb, zf)
                if (col) {
                    cg.ctx.fillStyle = col
                    cg.ctx.fillText(lb.name, xP, yP)
                }
            }
        }
    }

    /**
     * Load data for labels, from URL this.url
     * @param {function():void} callback
     * @private
     */
    async load(callback) {
        if (!this.url) {
            console.log('Failed loading labels: No URL specified. ' + this.url)
            this.loadingStatus = 'failed'
            this.labels = []
            return
        }

        //check if data already loaded
        if (this.loadingStatus != 'notLoaded') return

        //load data
        this.loadingStatus = 'loading'

        try {
            /** @type { Array.<Label> } */
            const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_0__.csv)(this.url)

            //preprocess/filter
            if (this.preprocess) {
                this.labels = []
                for (const c of data) {
                    const b = this.preprocess(c)
                    if (b == false) continue
                    this.labels.push(c)
                }
            } else {
                //store labels
                this.labels = data
            }

            this.loadingStatus = 'loaded'

            //redraw
            if (callback) callback()
        } catch (error) {
            console.log('Failed loading labels from ' + this.url)
            this.labels = []
            this.loadingStatus = 'failed'
        }
    }
}


/***/ }),

/***/ "./src/Layer.js":
/*!**********************!*\
  !*** ./src/Layer.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Layer": () => (/* binding */ Layer)
/* harmony export */ });
//@ts-check


/**
 * A layer, which specifies a dataset to be shown with specified styles.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class Layer {
    /**
     * @param {import("./Dataset").Dataset} dataset The multi resolution dataset to show.
     * @param {Array.<import("./Style").Style>} styles The styles, ordered in drawing order.
     * @param {{visible?:boolean,alpha?:number,blendOperation?:GlobalCompositeOperation,minZoom?:number,maxZoom?:number,pixNb?:number,cellInfoHTML?:function(import("./Dataset").Cell):string}} opts
     *      minZoom: The minimum zoom level when to show the layer. maxZoom: The maximum zoom level when to show the layer
     */
    constructor(dataset, styles, opts = {}) {
        opts = opts || {}

        /** @type {import("./Dataset").Dataset} */
        this.dataset = dataset
        /** @type {Array.<import("./Style").Style>} */
        this.styles = styles

        /** An attribute to specify if a layer should be drawn or not
         * @type {boolean} */
        this.visible = opts.visible === false ? false : true

        /** A function returning the alpha (transparency/opacity), between 0.0 (fully transparent) and 1.0 (fully opaque).
         *  The function parameter is the zoom factor.
         * (see CanvasRenderingContext2D: globalAlpha property)
         * @type {function(number):number|undefined} */
        this.alpha = opts.alpha

        /** A function returning the blend operation. The function parameter is the zoom factor.
         * (see CanvasRenderingContext2D: globalCompositeOperation property)
         * @type {GlobalCompositeOperation} */
        this.blendOperation = opts.blendOperation || (zf => "source-over")

        /** The minimum zoom factor: Below this level, the layer is not shown.
         * @type {number} */
        this.minZoom = opts.minZoom || 0

        /** The maximum zoom factor: Above this level, the layer is not shown.
         * @type {number} */
        this.maxZoom = opts.maxZoom || Infinity

        //ensure acceptable values for the zoom limits.
        if (this.minZoom >= this.maxZoom)
            throw new Error('Unexpected zoom limits for layer. Zoom min should be smaller than zoom max.')

        /** Unit: number of pixels
         * @type {number} */
        this.pixNb = opts.pixNb || 3

        /**
         * The function returning cell information as HTML.
         * This is typically used for tooltip information.
         * @type {function(import("./Dataset").Cell, number):string} */
        this.cellInfoHTML = opts.cellInfoHTML || Layer.defaultCellInfoHTML
    }

    /**
     * Return the relevant dataset component for a specified zoom factor.
     *
     * @param {number} zf
     * @returns {import("./DatasetComponent").DatasetComponent|undefined}
     * */
    getDatasetComponent(zf) {
        if (zf < this.minZoom || zf > this.maxZoom) return

        //special case whith single component dataset
        if (this.dataset.datasetComponents.length == 1) return this.dataset.datasetComponents[0]

        const rs = this.dataset.resolutions
        let i = 0
        let z = rs[i] / this.pixNb
        while (z < zf && i < rs.length) {
            i++
            z = rs[i] / this.pixNb
        }
        //if (i == 0) return this.dataset.datasetComponents[0];
        //return this.dataset.datasetComponents[i - 1];
        if (i == rs.length) return this.dataset.datasetComponents[rs.length - 1]
        return this.dataset.datasetComponents[i]
    }

    /**
     * The default function returning cell information as HTML.
     * This is typically used for tooltip information.
     *
     * @param {import("./Dataset").Cell} cell
     * @returns {string}
     */
    static defaultCellInfoHTML(cell) {
        const buf = []
        for (const key of Object.keys(cell)) {
            if (key === 'x') continue
            if (key === 'y') continue
            buf.push('<b>', key, '</b>', ' : ', cell[key], '<br>')
        }
        return buf.join('')
    }
}


/***/ }),

/***/ "./src/Legend.js":
/*!***********************!*\
  !*** ./src/Legend.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Legend": () => (/* binding */ Legend)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
//@ts-check


;

/**
 * A legend container.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class Legend {
    /**
     * @param {Object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** @type {string} */
        this.id = opts.id

        //TODO stop using it. Use style method below instead.

        /** @type {number} @deprecated */
        this.top = opts.top
        /** @type {number} @deprecated */
        this.bottom = opts.bottom
        /** @type {number} @deprecated */
        this.left = opts.left
        /** @type {number} @deprecated */
        this.right = opts.right
        /** @type {string} @deprecated */
        this.background = opts.background || 'none'
        /** @type {string} @deprecated */
        this.padding = opts.padding || '5px'
        /** @type {string} @deprecated */
        this.border = opts.border || '0px'
        /** @type {string} @deprecated */
        this['border-radius'] = opts['border-radius'] || 'none'
        /** @type {string} @deprecated */
        this['box-shadow'] = opts['box-shadow'] || 'none'
        /** @type {string} @deprecated */
        this['font-family'] = opts['font-family'] || 'Helvetica, Arial, sans-serif'
        /** @type {string} @deprecated */
        this.width = opts.width
        /** @type {string} @deprecated */
        this.height = opts.height

        //the div element
        if (this.id) this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + this.id)

        if (!this.div || this.div.empty()) {
            this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(document.createElement('div'))
            if (this.id) this.div.attr('id', this.id)
        }

        //set style
        this.div.style('background', this.background)
        this.div.style('padding', this.padding)
        this.div.style('border', this.border)
        this.div.style('border-radius', this['border-radius'])
        this.div.style('box-shadow', this['box-shadow'])
        this.div.style('font-family', this['font-family'])

        if (this.width) this.div.style('width', this.width)
        if (this.height) this.div.style('height', this.height)
    }

    /**
     * Apply a style to the legend div.
     * @param {string} k
     * @param {string} v
     * @returns {this}
     */
    style(k, v) {
        this.div.style(k, v)
        return this
    }

    /**
     * @param {Object} opts
     * @abstract
     */
    update(opts) {
        console.error('Legend update not implemented yet.')
    }
}


/***/ }),

/***/ "./src/LineLayer.js":
/*!**************************!*\
  !*** ./src/LineLayer.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LineLayer": () => (/* binding */ LineLayer)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
//@ts-check


;

/**
 * @author Joseph Davies, Julien Gaffuri
 */
class LineLayer {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /**
         * @private
         * @type {string} */
        this.url = opts.url

        /**
         * A preprocess to run on each feature after loading.
         * It can be used to apply some specific treatment before, format the label data, project coordinates, etc.
         * Return false if the label should not be kept.
         * @private
         * @type {function(object):boolean} */
        this.preprocess = opts.preprocess

        /**
         * @private
         * @type {function(object,number):string} */
        this.color = opts.color || ((f, zf) => 'gray')
        /**
         * @private
         * @type {function(object,number):number} */
        this.width = opts.width || ((f, zf) => 2)
        /**
         * @private
         * @type {function(object,number):Array.<number>|undefined} */
        this.lineDash = opts.lineDash || ((f, zf) => undefined)

        /**
         * @private
         * @type {Array.<object> | undefined} */
        this.fs = undefined

        /**
         * @private
         * @type {string} */
        this.loadingStatus = 'notLoaded'
    }

    /**
     * Draw the layer.
     * @param {import("./GeoCanvas").GeoCanvas} cg The canvas where to draw the layer.
     * @returns {void}
     */
    draw(cg) {
        //load data, if not done yet.
        if (!this.fs) {
            this.load(cg.redraw)
            return
        }

        //TODO sort lines by width ?

        //zoom factor
        const zf = cg.getZf()

        //draw in geo coordinates
        cg.setCanvasTransform()

        for (const f of this.fs) {
            const cs = f.geometry.coordinates
            if (cs.length < 2) continue

            //set color
            const col = this.color(f, zf)
            if (!col || col == 'none') continue
            cg.ctx.strokeStyle = col

            //set linewidth
            const wP = this.width(f, zf)
            if (!wP || wP < 0) continue
            cg.ctx.lineWidth = wP * zf

            //set line dash
            const ldP = this.lineDash(f, zf)
            if (ldP) cg.ctx.setLineDash(ldP)

            //draw line
            cg.ctx.beginPath()
            cg.ctx.moveTo(cs[0][0], cs[0][1])
            for (let i = 1; i < cs.length; i++) cg.ctx.lineTo(cs[i][0], cs[i][1])
            cg.ctx.stroke()
        }

        //...
        cg.ctx.setLineDash([])
    }

    /**
     * Load data for labels, from URL this.url
     * @param {function():void} callback
     * @private
     */
    async load(callback) {
        if (!this.url) {
            console.log('Failed loading boundaries: No URL specified. ' + this.url)
            this.loadingStatus = 'failed'
            this.labels = []
            return
        }

        //check if data already loaded
        if (this.loadingStatus != 'notLoaded') return

        //load data
        this.loadingStatus = 'loading'

        try {
            const data_ = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_0__["default"])(this.url)

            /** @type { Array.<object> } */
            const data = data_.features

            //preprocess/filter
            if (this.preprocess) {
                this.fs = []
                for (const c of data) {
                    const b = this.preprocess(c)
                    if (b == false) continue
                    this.fs.push(c)
                }
            } else {
                //store labels
                this.fs = data
            }

            this.loadingStatus = 'loaded'

            //redraw
            if (callback) callback()
        } catch (error) {
            console.log('Failed loading boundaries from ' + this.url)
            this.fs = []
            this.loadingStatus = 'failed'
        }
    }
}


/***/ }),

/***/ "./src/Style.js":
/*!**********************!*\
  !*** ./src/Style.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Style": () => (/* binding */ Style)
/* harmony export */ });
//@ts-check


/**
 * Statistics of a set of values
 * @typedef {{min:number,max:number}} Stat */

/** @typedef {"square"|"circle"|"diamond"|"donut"|"none"} Shape */

/**
 * A style, to show a grid dataset.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class Style {
    /**
     * @abstract
     * @param {{filter?:function(import('./Dataset').Cell):boolean,offset?:function(import('./Dataset').Cell,number,number):{dx:number,dy:number},visible?:boolean,alpha?:function(number):number,blendOperation?:function(number):GlobalCompositeOperation,minZoom?:number,maxZoom?:number,drawFun?:function}} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** A filter function to apply to the cell list, to filter out some cells not to be drawn (such as for example the cells with value=0).
         * @protected
         * @type {function(import('./Dataset').Cell):boolean} */
        this.filter = opts.filter || (() => true)

        /** An offset. This is to alter the position of all symbols in a given direction. In geographical unit.
         * @protected
         * @type {function(import('./Dataset').Cell,number,number):{dx:number,dy:number}} */
        this.offset = opts.offset || ((c, r, zf) => ({ dx: 0, dy: 0 }))

        /** An attribute to specify if a style should be drawn or not
         * @type {boolean} */
        this.visible = opts.visible === false ? false : true

        /** A function returning the alpha (transparency/opacity), between 0.0 (fully transparent) and 1.0 (fully opaque).
         *  The function parameter is the zoom factor.
         * (see CanvasRenderingContext2D: globalAlpha property)
         * @type {function(number):number|undefined} */
        this.alpha = opts.alpha

        /** A function returning the blend operation. The function parameter is the zoom factor.
         * (see CanvasRenderingContext2D: globalCompositeOperation property)
         * @type {function(number):GlobalCompositeOperation} */
        this.blendOperation = opts.blendOperation || (zf => "source-over")

        /** The minimum zoom factor: Below this level, the layer is not shown.
         * @type {number}
         * */
        this.minZoom = opts.minZoom || 0

        /** The maximum zoom factor: Above this level, the layer is not shown.
         * @type {number}
         * */
        this.maxZoom = opts.maxZoom || Infinity

        /** A draw function for the style.
         * @type {function} */
        this.drawFun = opts.drawFun

        //ensure acceptable values for the zoom limits.
        if (this.minZoom >= this.maxZoom)
            throw new Error('Unexpected zoom limits for layer. Zoom min should be smaller than zoom max.')

        /**
         * @public
         * @type {Array.<import("./Legend").Legend>} */
        this.legends = []
    }

    /**
     * Draw cells.
     *
     * @param {Array.<import('./Dataset').Cell>} cells The cells to draw.
     * @param {number} resolution Their resolution (in geographic unit)
     * @param {import("./GeoCanvas").GeoCanvas} cg The canvas where to draw them.
     * @abstract
     */
    draw(cells, resolution, cg) {
        if (this.drawFun) this.drawFun(cells, resolution, cg)
        else throw new Error('Method draw not implemented.')
    }

    //getters and setters

    /** @returns {function(import('./Dataset').Cell,number,number):{dx:number,dy:number}} */
    getOffset() {
        return this.offset
    }
    /** @param {function(import('./Dataset').Cell,number,number):{dx:number,dy:number}} val @returns {this} */
    setOffset(val) {
        this.offset = val
        return this
    }

    /** Hide all legend elements of the style, if any
     * @param {object} opts
     * @returns {this} */
    updateLegends(opts) {
        for (const lg of this.legends) lg.update(opts)
        return this
    }

    /**
     * Compute some statistics on a value of some cells.
     * This is used to define how to draw specifically the cells within the view.
     * TODO: compute median ?
     *
     * @param {Array.<import('./Dataset').Cell>} cells
     * @param {function(import('./Dataset').Cell):number} valFun
     * @param {boolean} ignoreZeros
     * @returns {Stat | undefined}
     */
    static getStatistics(cells, valFun, ignoreZeros) {
        if (!cells || cells.length == 0) return undefined
        let min = Infinity
        let max = -Infinity
        //let sum = 0
        //let nb = 0
        for (const cell of cells) {
            const v = +valFun(cell)
            if (ignoreZeros && !v) continue
            if (v < min) min = v
            if (v > max) max = v
            //sum += v
            //nb++
        }
        return { min: min, max: max }
    }
}


/***/ }),

/***/ "./src/Tooltip.js":
/*!************************!*\
  !*** ./src/Tooltip.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tooltip": () => (/* binding */ Tooltip)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
//@ts-check


;
//import { transition } from "d3-transition";

/**
 * A generic class to make a tooltip.
 * It is a div element, which can be moved under the mouse pointer and filled with some information in html.
 */
class Tooltip {
    /**
     * @param {object} opts
     */
    constructor(opts) {
        opts = opts || {}

        /** @type {string} */
        this.div = opts.div || 'tooltip_eurostat'
        /** @type {string} */
        this.maxWidth = opts.maxWidth || '20em'
        /** @type {string} */
        this.fontSize = opts.fontSize || '1.2em'
        /** @type {string} */
        this.background = opts.background || 'white'
        /** @type {string} */
        this.padding = opts.padding || '5px'
        /** @type {string} */
        this.border = opts.border || '0px'
        /** @type {string} */
        this['border-radius'] = opts['border-radius'] || '0px'
        /** @type {string} */
        this['box-shadow'] = opts['box-shadow'] || '5px 5px 5px grey'
        /** @type {string} */
        this['font-family'] = opts['font-family'] || 'Helvetica, Arial, sans-serif'

        /** @type {number} */
        this.transitionDuration = opts.transitionDuration || 100
        /** @type {number} */
        this.xOffset = opts.xOffset || 30
        /** @type {number} */
        this.yOffset = opts.yOffset || 20
        /** @type {number} */ // e.g. to prevent mouse cursor covering cell being highlighted
        this.yMouseOffset = opts.yMouseOffset || 0
        /** @type {number} */
        this.xMouseOffset = opts.xMouseOffset || 0
        /** @type {HTMLElement} */
        this.parentElement = opts.parentElement || document.body

        /**
         * @public
         * @type {import("d3-selection").Selection} */
        this.tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + this.div)

        if (this.tooltip.empty()) {
            //create tooltip DOM node
            // this.tooltip = select(
            //     '#' + this.parentElement.id && this.parentElement.id != ''
            //         ? '#' + this.parentElement.id
            //         : 'body'
            // )
            this.tooltip = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('body').append('div').attr('id', this.div)
        }

        //initialise
        this.tooltip.style('max-width', this.maxWidth)
        this.tooltip.style('overflow', 'hidden')
        this.tooltip.style('font-size', this.fontSize)
        this.tooltip.style('background', this.background)
        this.tooltip.style('padding', this.padding)
        this.tooltip.style('border', this.border)
        this.tooltip.style('border-radius', this['border-radius'])
        this.tooltip.style('box-shadow', this['box-shadow'])
        this.tooltip.style('font-family', this['font-family'])
        this.tooltip.style('position', 'absolute')
        this.tooltip.style('pointer-events', 'none')
        this.tooltip.style('opacity', '0')
        this.tooltip.style('text-wrap', 'nowrap')

        // aria-labels (thanks to wahlatlas)
        this.tooltip.attr('role', 'tooltip').attr('aria-live', 'polite')
    }

    /** Show the tooltip */
    show() {
        // @ts-ignore
        this.tooltip.transition().duration(this.transitionDuration).style('opacity', 1)
    }

    /** Hide the tooltip */
    hide() {
        // @ts-ignore
        this.tooltip.transition().duration(this.transitionDuration).style('opacity', 0)
    }

    /**
     * Set the content of the tooltip.
     * @param {string} html
     */
    html(html) {
        this.tooltip.html(html)
    }

    /**
     * Set the position of the tooltip at the mouse event position.
     * @param {MouseEvent} event
     */
    setPosition(event) {
        let parentRect = this.parentElement.getBoundingClientRect()

        let x = event.pageX + this.xOffset
        let y = event.pageY - this.yOffset

        this.tooltip.style('left', x + 'px').style('top', y + 'px')

        this.ensureTooltipInsideContainer(event, parentRect)
    }

    /*
	my.mouseover = function (event, html) {
		if (html) my.html(html);
		my.setPosition(event);
		my.show()
		//this.ensureTooltipInsideContainer();
	};
	
	my.mousemove = function (event) {
		my.setPosition(event);
		//this.ensureTooltipInsideContainer();
	};
	
	my.mouseout = function () {
		my.hide();
	};*/

    style(k, v) {
        if (arguments.length == 1) return this.tooltip.style(k)
        this.tooltip.style(k, v)
        return this
    }

    attr(k, v) {
        if (arguments.length == 1) return this.tooltip.attr(k)
        this.tooltip.attr(k, v)
        return this
    }

    /**
     * @function ensureTooltipInsideContainer
     * @description Prevents the tooltip from overflowing out of the App container (ensures that the tooltip is inside the gridviz container)
     * @param {MouseEvent} event
     * @param {DOMRect} parentRect
     */
    ensureTooltipInsideContainer = function (event, parentRect) {
        let node = this.tooltip.node()
        let parentWidth = parentRect.width
        let parentHeight = parentRect.height

        //too far right
        if (node.offsetLeft > parentRect.left + parentWidth - node.clientWidth) {
            let left = event.x - node.clientWidth - this.xOffset
            node.style.left = left + 'px'
            // check if mouse covers tooltip
            if (node.offsetLeft + node.clientWidth > event.x) {
                //move tooltip left so it doesnt cover mouse
                let left2 = event.x - node.clientWidth - this.xOffset
                node.style.left = left2 + 'px'
            }
            // node.style.top = node.offsetTop + config.yOffset + "px";
        }

        //too far down
        if (node.offsetTop + node.clientHeight > parentRect.top + parentHeight) {
            node.style.top = node.offsetTop - node.clientHeight + 'px'
        }

        //too far up
        if (node.offsetTop < parentRect.top) {
            node.style.top = parentRect.top + this.yOffset + 'px'
        }
    }
}


/***/ }),

/***/ "./src/button/Button.js":
/*!******************************!*\
  !*** ./src/button/Button.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Button": () => (/* binding */ Button)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");


/**
 * Parent class for button elements used to interact with the gridviz viewer.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class Button {
    /**
     * @param {Object} opts
     * opts.parentNode
     * opts.id
     * opts.title
     * opts.class
     * opts.onClickFunction
     * opts.x
     * opts.y
     */
    constructor(opts) {
        opts = opts || {}

        this.app = opts.app
        this.parentNode = opts.parentNode || opts.app.container

        // the div element
        if (this.id) this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])('#' + this.id)

        if (!this.div || this.div.empty()) {
            this.div = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(document.createElement('div'))
            if (this.id) this.div.attr('id', this.id)
        }

        if (opts.title) this.div.attr('title',opts.title)
        if (opts.class) this.div.attr('class',opts.class)

        // add events
        if (opts.onClickFunction) this.div.on('click', opts.onClickFunction)

        //set styles
        this.style('box-shadow','0 7px 8px rgba(0,47,103,.08), 0 0 22px rgba(0,47,103,.04), 0 12px 17px rgba(0,47,103,.04), 0 -4px 4px rgba(0,47,103,.04)') //.ecl-u-shadow-3
        this.style('background-color','#ffffff')
        this.style('position' , 'absolute')
        this.style('cursor' , 'pointer')
        this.style('display' , 'flex')
        this.style('justify-content' , 'center')
        this.style('align-items' , 'center')
        this.style('width' , '30px')
        this.style('height' , '30px')
        // this.style(padding , '4px'


        // append to parent
        this.parentNode.appendChild(this.div.node())
    }

    /**
     * Apply a style to the button div.
     * @param {string} k
     * @param {string} v
     * @returns {this}
     */
    style(k, v) {
        this.div.style(k, v)
        return this
    }
}


/***/ }),

/***/ "./src/button/FullscreenButton.js":
/*!****************************************!*\
  !*** ./src/button/FullscreenButton.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FullscreenButton": () => (/* binding */ FullscreenButton)
/* harmony export */ });
/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.js */ "./src/button/Button.js");


/**
 * Button for toggling fullscreen mode
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class FullscreenButton extends _Button_js__WEBPACK_IMPORTED_MODULE_0__.Button {
    /**
     * @param {Object} opts
     * opts.parentNode - the node that the button is appended to
     * opts.canvas - the gridviz canvas
     * opts.id
     * opts.title - HTML title attribute
     * opts.class - css class
     * opts.onClickFunction
     * opts.x - x position of the button
     * opts.y - y position of the button
     */

    // default state
    isFullscreen = false

    constructor(opts) {
        super(opts)

        // append fullscreen icon to button container
        this.div.node().innerHTML = `
        <svg
            style="height: 1.2rem; width: 1.2rem; fill:black; margin:0;"
            focusable="false"
            aria-hidden="true"
        >
            <svg fill="#000000" viewBox="0 0 96 96" xmlns="http://www.w3.org/2000/svg">
            <title/>
            <g>
            <path d="M30,0H6A5.9966,5.9966,0,0,0,0,6V30a6,6,0,0,0,12,0V12H30A6,6,0,0,0,30,0Z"/>
            <path d="M90,0H66a6,6,0,0,0,0,12H84V30a6,6,0,0,0,12,0V6A5.9966,5.9966,0,0,0,90,0Z"/>
            <path d="M30,84H12V66A6,6,0,0,0,0,66V90a5.9966,5.9966,0,0,0,6,6H30a6,6,0,0,0,0-12Z"/>
            <path d="M90,60a5.9966,5.9966,0,0,0-6,6V84H66a6,6,0,0,0,0,12H90a5.9966,5.9966,0,0,0,6-6V66A5.9966,5.9966,0,0,0,90,60Z"/>
            </g>
            </svg>
        </svg>
        `

        //save initial app dimensions
        this.defaultHeight = this.app.h
        this.defaultWidth = this.app.w

        // event handler
        this.div.on('click', (e) => {
            this.onClickFunction(e)
        })
        this.div.on('mouseover', (e) => {
            this.style('background-color', 'lightgrey')
        })
        this.div.on('mouseout', (e) => {
            this.style('background-color', '#ffffff')
        })

        //set position
        if (opts.x) {
            this.style('left', opts.x + 'px')
        } else {
            this.style('right', '10px')
        }
        if (opts.y) {
            this.style('top', opts.y + 'px')
        } else {
            this.style('top', '90px')
        }
    }

    onClickFunction(e) {
        if (this.isFullscreen) {
            this.closeFullscreen(this.app.container)
            //resize canvas to default
            this.app.h = this.defaultHeight
            this.app.w = this.defaultWidth
            this.app.cg.h = this.defaultHeight
            this.app.cg.w = this.defaultWidth
            this.app.cg.canvas.setAttribute('width', '' + this.defaultWidth)
            this.app.cg.canvas.setAttribute('height', '' + this.defaultHeight)
            this.app.redraw()
            this.isFullscreen = false
        } else {
            this.openFullscreen(this.app.container)
            //resize canvas to fullscreen
            this.app.h = window.screen.height
            this.app.w = window.screen.width
            this.isFullscreen = true
        }
    }

    /* Open fullscreen */
    openFullscreen(elem) {
        if (elem.requestFullscreen) {
            elem.requestFullscreen()
        } else if (elem.webkitRequestFullscreen) {
            /* Safari */
            elem.webkitRequestFullscreen()
        } else if (elem.msRequestFullscreen) {
            /* IE11 */
            elem.msRequestFullscreen()
        }
    }

    /* Close fullscreen */
    closeFullscreen() {
        if (document.exitFullscreen) {
            document.exitFullscreen()
        } else if (document.webkitExitFullscreen) {
            /* Safari */
            document.webkitExitFullscreen()
        } else if (document.msExitFullscreen) {
            /* IE11 */
            document.msExitFullscreen()
        }
    }
}


/***/ }),

/***/ "./src/button/ZoomButtons.js":
/*!***********************************!*\
  !*** ./src/button/ZoomButtons.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ZoomButtons": () => (/* binding */ ZoomButtons)
/* harmony export */ });
/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.js */ "./src/button/Button.js");


/**
 * Button for toggling fullscreen mode
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class ZoomButtons extends _Button_js__WEBPACK_IMPORTED_MODULE_0__.Button {
    /**
     * @param {Object} opts
     */
    constructor(opts) {
        super(opts)

        this.onZoom = opts.onZoom // custom user event handler
        this.delta = opts.delta || 0.2

        // zoom in btn
        this.zoomInBtn = document.createElement('a')
        this.zoomInBtn.innerHTML = `<a id="zoomin" class="gridviz-zoom-button" title="Zoom in">+</a>`
        this.zoomInBtn.title = 'Zoom in'
        this.zoomInBtn.addEventListener('click', (e) => {
            this.zoomIn(e)
        })
        this.zoomInBtn.addEventListener('mouseover', (e) => {
            this.zoomInBtn.style.backgroundColor = 'lightgrey'
        })
        this.zoomInBtn.addEventListener('mouseout', (e) => {
            this.zoomInBtn.style.backgroundColor = '#ffffff'
        })

        // zoom out btn
        this.zoomOutBtn = document.createElement('a')
        this.zoomOutBtn.innerHTML = `<a id="zoomin" class="gridviz-zoom-button" title="Zoom out">-</a>`
        this.zoomOutBtn.title = 'Zoom out'
        this.zoomOutBtn.addEventListener('click', (e) => {
            this.zoomOut(e)
        })
        this.zoomOutBtn.addEventListener('mouseover', (e) => {
            this.zoomOutBtn.style.backgroundColor = 'lightgrey'
        })
        this.zoomOutBtn.addEventListener('mouseout', (e) => {
            this.zoomOutBtn.style.backgroundColor = '#ffffff'
        })

        //set styles
        let btns = [this.zoomInBtn, this.zoomOutBtn]
        btns.forEach((btn, i) => {
            btn.style.alignItems = 'center'
            btn.style.justifyContent = 'center'
            btn.style.display = 'flex'
            btn.style.border = 'none'
            btn.style.color = 'black'
            btn.style.textAlign = 'center'
            btn.style.textDecoration = 'none'
            btn.style.padding = '4px'
            btn.style.fontSize = '20px'
            btn.style.fontWeight = 'bold'
            btn.style.userSelect = 'none'
            if (i == 0) btn.style.borderBottom = '1px solid grey'
        })

        // unset parent class height and display for dual buttons
        this.style('height', 'unset')
        this.style('display', 'unset')

        //set position
        if (opts.x) {
            this.style('left', opts.x + 'px')
        } else {
            this.style('right', '10px')
        }
        if (opts.y) {
            this.style('top', opts.y + 'px')
        } else {
            this.style('top', '10px')
        }

        // append to button container
        this.div.node().appendChild(this.zoomInBtn)
        this.div.node().appendChild(this.zoomOutBtn)
    }

    /* Zoom in */
    zoomIn(e) {
        this.app.setZoomFactor(this.app.getZoomFactor() * (1 - this.delta)).redraw()
        if (this.onZoom) this.onZoom(e)
    }

    /* Zoom out */
    zoomOut(e) {
        this.app.setZoomFactor(this.app.getZoomFactor() * (1 + this.delta)).redraw()
        if (this.onZoom) this.onZoom(e)
    }
}


/***/ }),

/***/ "./src/dataset/CSVGrid.js":
/*!********************************!*\
  !*** ./src/dataset/CSVGrid.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSVGrid": () => (/* binding */ CSVGrid)
/* harmony export */ });
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
/* harmony import */ var _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DatasetComponent.js */ "./src/DatasetComponent.js");
//@ts-check


/** @typedef {{ dims: object, crs: string, tileSizeCell: number, originPoint: {x:number,y:number}, resolutionGeo: number, tilingBounds:import("../Dataset").Envelope }} GridInfo */

;


/**
 * A dataset composed of a single CSV file (not tiled).
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class CSVGrid extends _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_0__.DatasetComponent {
    /**
     * @param {string} url The URL of the dataset.
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {{preprocess?:(function(import("../Dataset").Cell):boolean)}} opts
     */
    constructor(url, resolution, opts = {}) {
        super(url, resolution, opts)

        /**
         * @private
         * @type {Array.<import("../Dataset").Cell>} */
        this.cells = []

        /**
         * @type {string}
         * @private  */
        this.infoLoadingStatus = 'notLoaded'
    }

    /**
     * Request data within a geographic envelope.
     *
     * @param {import("../Dataset").Envelope|undefined} e
     * @param {function():void} redraw
     */
    getData(e, redraw) {
        //check if data already loaded
        if (this.infoLoadingStatus != 'notLoaded') return this

        //load data
        this.infoLoadingStatus = 'loading'
        ;(async () => {
            try {
                const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_1__.csv)(this.url)

                //convert coordinates in numbers
                for (const c of data) {
                    c.x = +c.x
                    c.y = +c.y
                }

                //preprocess/filter
                if (this.preprocess) {
                    this.cells = []
                    for (const c of data) {
                        const b = this.preprocess(c)
                        if (b == false) continue
                        this.cells.push(c)
                    }
                } else {
                    this.cells = data
                }

                //TODO check if redraw is necessary
                //that is if the dataset belongs to a layer which is visible at the current zoom level

                //execute the callback, usually a draw function
                if (redraw) redraw()

                this.infoLoadingStatus = 'loaded'
            } catch (error) {
                //mark as failed
                this.infoLoadingStatus = 'failed'
                this.cells = []
            }
        })()

        return this
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     *
     * @param {import("../Dataset").Envelope} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //data not loaded yet
        if (!this.cells) return

        this.cellsViewCache = []
        for (const cell of this.cells) {
            if (+cell.x + this.resolution < extGeo.xMin) continue
            if (+cell.x - this.resolution > extGeo.xMax) continue
            if (+cell.y + this.resolution < extGeo.yMin) continue
            if (+cell.y - this.resolution > extGeo.yMax) continue
            this.cellsViewCache.push(cell)
        }
    }
}


/***/ }),

/***/ "./src/dataset/GridTile.js":
/*!*********************************!*\
  !*** ./src/dataset/GridTile.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GridTile": () => (/* binding */ GridTile)
/* harmony export */ });
//@ts-check


/**
 * A grid tile.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class GridTile {
    /**
     * @param {Array.<import("../Dataset").Cell>} cells The tile cells.
     * @param {number} xT The X position of the tile.
     * @param {number} yT The Y position of the tile.
     * @param {import("./CSVGrid").GridInfo} gridInfo The grid info object.
     */
    constructor(cells, xT, yT, gridInfo) {
        /** @type {Array.<import("../Dataset").Cell>} */
        this.cells = cells
        /** @type {number} */
        this.x = xT
        /** @type {number} */
        this.y = yT

        const r = gridInfo.resolutionGeo
        const s = gridInfo.tileSizeCell

        /** @type {import("../Dataset").Envelope} */
        this.extGeo = {
            xMin: gridInfo.originPoint.x + r * s * this.x,
            xMax: gridInfo.originPoint.x + r * s * (this.x + 1),
            yMin: gridInfo.originPoint.y + r * s * this.y,
            yMax: gridInfo.originPoint.y + r * s * (this.y + 1),
        }

        //convert cell coordinates into geographical coordinates
        for (let cell of this.cells) {
            cell.x = this.extGeo.xMin + cell.x * r
            cell.y = this.extGeo.yMin + cell.y * r
        }
    }
}


/***/ }),

/***/ "./src/dataset/LGrid.js":
/*!******************************!*\
  !*** ./src/dataset/LGrid.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LGrid": () => (/* binding */ LGrid)
/* harmony export */ });
/* harmony import */ var _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DatasetComponent.js */ "./src/DatasetComponent.js");
//@ts-check


/** @typedef {{ dims: object, crs: string, tileSizeCell: number, originPoint: {x:number,y:number}, resolutionGeo: number, tilingBounds:import("../Dataset.js").Envelope }} GridInfo */

;

/**
 * A dataset composed of a single CSV file (not tiled).
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class LGrid extends _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_0__.DatasetComponent {
    /**
     * @param {number} resolution The dataset resolution in geographical unit.
     * @param {Array.<Object>} cells The cells.
     */
    constructor(resolution, cells) {
        super("", resolution)

        /**
         * @private
         * @type {Array.<import("../Dataset.js").Cell>} */
        this.cells = cells || []
    }

    /**
     * Request data within a geographic envelope.
     *
     * @param {import("../Dataset.js").Envelope|undefined} e
     * @param {function():void} redraw
     */
    getData(e, redraw) { return this }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     *
     * @param {import("../Dataset.js").Envelope} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //data not loaded yet
        if (!this.cells) return

        this.cellsViewCache = []
        for (const cell of this.cells) {
            if (+cell.x + this.resolution < extGeo.xMin) continue
            if (+cell.x - this.resolution > extGeo.xMax) continue
            if (+cell.y + this.resolution < extGeo.yMin) continue
            if (+cell.y - this.resolution > extGeo.yMax) continue
            this.cellsViewCache.push(cell)
        }
    }
}


/***/ }),

/***/ "./src/dataset/TiledGrid.js":
/*!**********************************!*\
  !*** ./src/dataset/TiledGrid.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TiledGrid": () => (/* binding */ TiledGrid)
/* harmony export */ });
/* harmony import */ var _GridTile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GridTile.js */ "./src/dataset/GridTile.js");
/* harmony import */ var _App_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../App.js */ "./src/App.js");
/* harmony import */ var _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DatasetComponent.js */ "./src/DatasetComponent.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Utils.js */ "./src/utils/Utils.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/json.js");
/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-fetch */ "./node_modules/d3-fetch/src/dsv.js");
//@ts-check


/** @typedef {{ dims: object, crs: string, tileSizeCell: number, originPoint: {x:number,y:number}, resolutionGeo: number, tilingBounds:import("../Dataset").Envelope, format:import("../DatasetComponent").Format }} GridInfo */

// internal
;




// external


/**
 * A tiled dataset, composed of CSV tiles.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class TiledGrid extends _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_2__.DatasetComponent {
    /**
     * @param {string} url The URL of the dataset.
     * @param {App} app The application.
     * @param {{preprocess?:(function(import("../Dataset").Cell):boolean) }} opts
     */
    constructor(url, app, opts = {}) {
        super(url, 0, opts)

        /**
         * The app being used.
         * @type {App}
         */
        this.app = app

        /**
         * The grid info object, from the info.json file.
         *  @type {GridInfo | undefined}
         * @private
         *  */
        this.info = undefined

        /**
         * @type {string}
         * @private  */
        this.infoLoadingStatus = 'notLoaded'

        /**
         * The cache of the loaded tiles. It is double indexed: by xT and then yT.
         * Example: this.cache[xT][yT] returns the tile at [xT][yT] location.
         *
         * @type {object}
         * */
        this.cache = {}

    }

    /**
     * Load the info.json from the url.
     *
     * @param {function():void} callback
     * @returns this
     */
    loadInfo(callback) {
        if (!this.info && this.infoLoadingStatus === 'notLoaded') {
            ; (async () => {
                try {
                    const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_4__["default"])(this.url + 'info.json')
                    this.info = data
                    this.resolution = data.resolutionGeo
                    this.infoLoadingStatus = 'loaded'
                    if (callback) callback()
                } catch (error) {
                    //mark as failed
                    this.infoLoadingStatus = 'failed'
                }
            })()
        } else if (callback && (this.infoLoadingStatus === 'loaded' || this.infoLoadingStatus === 'failed'))
            callback()
        return this
    }

    /**
     * Compute a tiling envelope from a geographical envelope.
     * This is the function to use to know which tiles to download for a geographical view.
     *
     * @param {import("../Dataset").Envelope} e
     * @returns {import("../Dataset").Envelope|undefined}
     */
    getTilingEnvelope(e) {
        if (!this.info) {
            this.loadInfo(() => { })
            return
        }

        const po = this.info.originPoint,
            r = this.info.resolutionGeo,
            s = this.info.tileSizeCell

        return {
            xMin: Math.floor((e.xMin - po.x) / (r * s)),
            xMax: Math.floor((e.xMax - po.x) / (r * s)),
            yMin: Math.floor((e.yMin - po.y) / (r * s)),
            yMax: Math.floor((e.yMax - po.y) / (r * s)),
        }
    }

    /**
     * Request data within a geographic envelope.
     *
     * @param {import("../Dataset").Envelope} extGeo
     * @param {function():void} redrawFun
     * @returns {this}
     */
    getData(extGeo, redrawFun) {
        //TODO empty cache when it gets too big ?

        //check if info has been loaded
        if (!this.info) return this

        //tiles within the scope
        /** @type {import("../Dataset").Envelope|undefined} */
        const tb = this.getTilingEnvelope(extGeo)
        if (!tb) return this

        //grid bounds
        /** @type {import("../Dataset").Envelope} */
        const gb = this.info.tilingBounds

        for (let xT = Math.max(tb.xMin, gb.xMin); xT <= Math.min(tb.xMax, gb.xMax); xT++) {
            for (let yT = Math.max(tb.yMin, gb.yMin); yT <= Math.min(tb.yMax, gb.yMax); yT++) {
                //prepare cache
                if (!this.cache[xT]) this.cache[xT] = {}

                //check if tile exists in the cache
                /** @type {GridTile} */
                let tile = this.cache[xT][yT]
                if (tile) continue

                //mark tile as loading
                this.cache[xT][yT] = "loading";
                (async () => {
                    //request tile
                    /** @type {Array.<import("../Dataset").Cell>}  */
                    let cells

                    try {
                        /** @type {Array.<import("../Dataset").Cell>}  */
                        // @ts-ignore
                        const data = await (0,d3_fetch__WEBPACK_IMPORTED_MODULE_5__.csv)(this.url + xT + '/' + yT + '.csv')

                        //if (monitor) monitorDuration('*** TiledGrid parse start')

                        //preprocess/filter
                        if (this.preprocess) {
                            cells = []
                            for (const c of data) {
                                const b = this.preprocess(c)
                                if (b == false) continue
                                cells.push(c)
                            }
                        } else {
                            cells = data
                        }

                        //if (monitor) monitorDuration('preprocess / filter')
                    } catch (error) {
                        //mark as failed
                        this.cache[xT][yT] = 'failed'
                        return
                    }

                    //store tile in cache
                    if (!this.info) {
                        console.error('Tile info inknown')
                        return
                    }
                    const tile_ = new _GridTile_js__WEBPACK_IMPORTED_MODULE_0__.GridTile(cells, xT, yT, this.info)
                    this.cache[xT][yT] = tile_

                    //if (monitor) monitorDuration('storage')

                    //if no redraw is specified, then leave
                    if (!redrawFun) return

                    //check if redraw is really needed, that is if:

                    // 1. the dataset belongs to a layer which is visible at the current zoom level
                    let redraw = false
                    //go through the layers
                    const zf = this.app.getZoomFactor()
                    for (const lay of this.app.layers) {
                        if (!lay.visible) continue
                        if (lay.getDatasetComponent(zf) != this) continue
                        //found one layer. No need to seek more.
                        redraw = true
                        break
                    }
                    //if (monitor) monitorDuration('check redraw 1')

                    if (!redraw) return

                    // 2. the tile is within the view, that is its geo envelope intersects the viewer geo envelope.
                    const env = this.app.updateExtentGeo()
                    const envT = tile_.extGeo
                    if (env.xMax <= envT.xMin) return
                    if (env.xMin >= envT.xMax) return
                    if (env.yMax <= envT.yMin) return
                    if (env.yMin >= envT.yMax) return

                    //if (monitor) monitorDuration('check redraw 2')
                    //if (monitor) monitorDuration('*** TiledGrid parse end')

                    //redraw
                    redrawFun()
                })()
            }
        }
        return this
    }

    /**
     * Fill the view cache with all cells which are within a geographical envelope.
     * @abstract
     * @param {import("../Dataset").Envelope} extGeo
     * @returns {void}
     */
    updateViewCache(extGeo) {
        //
        this.cellsViewCache = []

        //check if info has been loaded
        if (!this.info) return

        //tiles within the scope
        /** @type {import("../Dataset").Envelope|undefined} */
        const tb = this.getTilingEnvelope(extGeo)
        if (!tb) return

        //grid bounds
        /** @type {import("../Dataset").Envelope} */
        const gb = this.info.tilingBounds

        for (let xT = Math.max(tb.xMin, gb.xMin); xT <= Math.min(tb.xMax, gb.xMax); xT++) {
            if (!this.cache[xT]) continue
            for (let yT = Math.max(tb.yMin, gb.yMin); yT <= Math.min(tb.yMax, gb.yMax); yT++) {
                //get tile
                /** @type {GridTile} */
                const tile = this.cache[xT][yT]
                if (!tile || typeof tile === 'string') continue

                //get cells
                //this.cellsViewCache = this.cellsViewCache.concat(tile.cells)

                for (const cell of tile.cells) {
                    if (+cell.x + this.resolution < extGeo.xMin) continue
                    if (+cell.x - this.resolution > extGeo.xMax) continue
                    if (+cell.y + this.resolution < extGeo.yMin) continue
                    if (+cell.y - this.resolution > extGeo.yMax) continue
                    this.cellsViewCache.push(cell)
                }
            }
        }
    }
}


/***/ }),

/***/ "./src/legend/ColorCategoryLegend.js":
/*!*******************************************!*\
  !*** ./src/legend/ColorCategoryLegend.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorCategoryLegend": () => (/* binding */ ColorCategoryLegend)
/* harmony export */ });
/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Legend.js */ "./src/Legend.js");
//@ts-check


;

/**
 * A legend element for color categrories.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class ColorCategoryLegend extends _Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //col/categories array, in display order
        /**
         * @private
         * @type {Array.<Array.<string>>} */
        this.colCat = opts.colCat || [['gray', '-']]

        /**
         * @private
         * @type {import("../Style").Shape} */
        this.shape = opts.shape || 'circle'
        this.dimension = opts.dimension || { r: 8 }
        this.strokeColor = opts.strokeColor || 'gray'
        this.strokeWidth = opts.strokeWidth || 1

        this.title = opts.title
        this.titleFontSize = opts.titleFontSize || '0.8em'
        this.titleFontWeight = opts.titleFontWeight || 'bold'

        //label
        this.labelFontSize = opts.labelFontSize || '0.8em'
    }

    /**
     * @param {{ style: import("../Style").Style, r: number, zf: number, sSize: import("../Style").Stat, sColor: import("../Style").Stat }} opts
     */
    update(opts) {
        //clear
        this.div.selectAll('*').remove()

        //build

        //title
        if (this.title)
            this.div
                .append('div')
                .style('font-size', this.titleFontSize)
                .style('font-weight', this.titleFontWeight)
                .style('margin-bottom', '7px')
                .text(this.title)

        //categories
        const nb = this.colCat.length
        if (nb == 0) return

        for (let i = 0; i < nb; i++) {
            const cat = this.colCat[i]

            //make div for category
            const d = this.div.append('div')
            //to enable vertical centering
            //.style("position", "relative")

            const sw = this.strokeWidth

            //draw graphic element: box / circle
            if (this.shape === 'square') {
                const h = this.dimension.h || 15
                const w = this.dimension.w || 20
                d.append('div')
                    .style('display', 'inline')

                    .append('svg')
                    .attr('width', w + 2 * sw)
                    .attr('height', h + 2 * sw)

                    .append('rect')
                    .attr('x', sw)
                    .attr('y', sw)
                    .attr('width', w)
                    .attr('height', h)
                    .style('fill', cat[0])
                    .style('stroke', this.strokeColor)
                    .style('stroke-width', this.strokeWidth)
            } else if (this.shape === 'circle') {
                const r = this.dimension.r || 8
                const h = 2 * r + 2 * sw
                d.append('div')
                    .style('display', 'inline')

                    .append('svg')
                    .attr('width', h)
                    .attr('height', h)

                    .append('circle')
                    .attr('cx', r + sw)
                    .attr('cy', r + sw)
                    .attr('r', r)
                    .style('fill', cat[0])
                    .style('stroke', this.strokeColor)
                    .style('stroke-width', this.strokeWidth)
            } else {
                throw new Error('Unexpected shape:' + this.shape)
            }

            //write label text
            d.append('div')
                //show on right of graphic
                .style('display', 'inline')

                //center vertically
                //.style("position", "absolute").style("top", "0").style("bottom", "0")

                .style('padding-left', '5px')
                .style('font-size', this.labelFontSize)
                .text(cat[1])
        }
    }
}


/***/ }),

/***/ "./src/legend/ColorDiscreteLegend.js":
/*!*******************************************!*\
  !*** ./src/legend/ColorDiscreteLegend.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorDiscreteLegend": () => (/* binding */ ColorDiscreteLegend)
/* harmony export */ });
/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Legend.js */ "./src/Legend.js");
//@ts-check


;

/**
 * A legend element for discrete color style.
 * Inspiration: https://observablehq.com/@d3/color-legend
 *
 * @author Julien Gaffuri
 */
class ColorDiscreteLegend extends _Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** @private @type {Array.<Array.<string>>} */
        this.colors = opts.colors
        /** @private @type {Array.<Array.<string>>} */
        this.breaksText = opts.breaksText

        this.width = opts.width || 300
        this.height = opts.height || 15

        this.title = opts.title
        this.titleFontSize = opts.titleFontSize || '0.8em'
        this.titleFontWeight = opts.titleFontWeight || 'bold'

        this.tickSize = opts.tickSize || 3

        //label
        this.labelFontSize = opts.labelFontSize || '0.8em'
        this.invert = opts.invert
    }

    /**
     * @param {{ style: import("../Style").Style, r: number, zf: number, sSize: import("../Style").Stat, sColor: import("../Style").Stat }} opts
     */
    update(opts) {
        //clear
        this.div.selectAll('*').remove()

        //build

        //title
        if (this.title)
            this.div
                .append('div')
                .style('font-size', this.titleFontSize)
                .style('font-weight', this.titleFontWeight)
                .style('margin-bottom', '7px')
                .text(this.title)

        //classes
        const nb = this.colors.length
        if (nb == 0) return
        const w = this.width / nb

        //make svg element
        const svg = this.div
            .append('svg')
            .attr('width', this.width)
            .attr('height', this.height + this.tickSize + 2 + 10)

        //draw graphic elements
        for (let i = 0; i < nb; i++) {
            svg.append('rect')
                .attr('x', i * w)
                .attr('y', 0)
                .attr('width', w)
                .attr('height', this.height)
                .style('fill', this.colors[i])
        }

        //tick line
        for (let i = 1; i < nb; i++) {
            svg.append('line')
                .attr('x1', w * i)
                .attr('y1', 0)
                .attr('x2', w * i)
                .attr('y2', this.height + this.tickSize)
                .style('stroke', 'black')
        }

        //labels
        for (let i = 1; i < nb; i++) {
            //prepare label
            svg.append('text')
                .attr('id', 'ticklabel_' + i)
                .attr('x', w * i)
                .attr('y', this.height + this.tickSize + 2)
                .style('font-size', this.labelFontSize)
                //.style("font-weight", "bold")
                //.style("font-family", "Arial")
                .style('text-anchor', i == 0 ? 'start' : i == this.ticks - 1 ? 'end' : 'middle')
                .style('alignment-baseline', 'top')
                .style('dominant-baseline', 'hanging')
                .style('pointer-events', 'none')
                .text(this.breaksText[i - 1])
        }
    }
}


/***/ }),

/***/ "./src/legend/ColorLegend.js":
/*!***********************************!*\
  !*** ./src/legend/ColorLegend.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorLegend": () => (/* binding */ ColorLegend)
/* harmony export */ });
/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Legend.js */ "./src/Legend.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
//@ts-check


;


/**
 * A legend element for continuous color style.
 * Inspiration: https://observablehq.com/@d3/color-legend
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class ColorLegend extends _Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        this.colorRamp = opts.colorRamp

        //function (t[0,1], r, s) -> v (for label text)
        this.fun = opts.fun

        this.title = opts.title
        this.tickSize = opts.tickSize || 6
        this.width = opts.width || 300
        this.height = opts.height || 15
        this.margin = opts.margin || 5
        this.ticks = opts.ticks || Math.floor(this.width / 50)
        this.tickFormat = opts.tickFormat || ',.0f'
        this.tickUnit = opts.tickUnit

        this.fontSize = opts.fontSize || '0.8em'
        this.invert = opts.invert

        //to be used as opts => opts.sAlpha to show legend on alpha channel
        this.getStats = opts.getStats || (opts => opts.sColor)
    }

    /**
     * @param {{ style: import("../Style").Style, r: number, zf: number, sSize: import("../Style").Stat, sColor: import("../Style").Stat, sAlpha: import("../Style").Stat }} opts
     */
    update(opts) {
        //could happen when data is still loading
        if (!opts.sColor) return

        //clear
        this.div.selectAll('*').remove()

        const titleHeight = 12

        const svgW = this.width + 2 * this.margin
        const svgH = this.height + 3 * this.margin + titleHeight + this.tickSize + 10
        const svg = this.div.append('svg').attr('width', svgW).attr('height', svgH)
        //  <rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />

        //title
        svg.append('text')
            .attr('x', this.margin)
            .attr('y', this.margin)
            .style('font-size', '0.8em')
            .style('font-weight', 'bold')
            .style('alignment-baseline', 'top')
            .style('dominant-baseline', 'hanging')
            .style('pointer-events', 'none')
            .text(this.title)

        const g = svg
            .append('g')
            .attr('transform', 'translate(' + this.margin + ' ' + (2 * this.margin + titleHeight) + ')')

        //draw color bar
        const w = this.width,
            h = this.height
        const step = 5
        for (let i = 0; i < w; i += step) {
            let t = i / (w - 1)
            if (this.invert) t = 1 - t
            g.append('rect')
                .attr('x', i)
                .attr('y', 0)
                .attr('width', step)
                .attr('height', h)
                .style('fill', this.colorRamp(t))
        }

        for (let i = 0; i < this.ticks; i++) {
            let t = i / (this.ticks - 1)

            //tick line
            g.append('line')
                .attr('x1', w * t)
                .attr('y1', 0)
                .attr('x2', w * t)
                .attr('y2', h + this.tickSize)
                .style('stroke', 'black')

            //prepare tick label
            g.append('text')
                .attr('id', 'ticklabel_' + i)
                .attr('x', w * t)
                .attr('y', h + this.tickSize + 2)
                .style('font-size', this.fontSize)
                //.style("font-weight", "bold")
                //.style("font-family", "Arial")
                .style('text-anchor', i == 0 ? 'start' : i == this.ticks - 1 ? 'end' : 'middle')
                .style('alignment-baseline', 'top')
                .style('dominant-baseline', 'hanging')
                .style('pointer-events', 'none')
            //.text("-")
        }

        //update tick labels

        //label text format
        const f = this.tickFormat && this.tickFormat != 'text' ? (0,d3_format__WEBPACK_IMPORTED_MODULE_1__.format)(this.tickFormat) : (v) => v
        const stat = this.getStats(opts)
        for (let i = 0; i < this.ticks; i++) {
            let t = i / (this.ticks - 1)

            const v = this.fun(t, opts.r, stat)
            const text = (v ? f(v) : '0') + (this.tickUnit ? this.tickUnit : '')

            //tick label
            this.div.select('#' + 'ticklabel_' + i).text(text)
        }
    }
}


/***/ }),

/***/ "./src/legend/SegmentOrientationLegend.js":
/*!************************************************!*\
  !*** ./src/legend/SegmentOrientationLegend.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SegmentOrientationLegend": () => (/* binding */ SegmentOrientationLegend)
/* harmony export */ });
/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Legend.js */ "./src/Legend.js");
//@ts-check


;

/**
 * A legend element for segment orientation.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class SegmentOrientationLegend extends _Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //title
        this.title = opts.title
        this.titleFontSize = opts.titleFontSize || '0.8em'
        this.titleFontWeight = opts.titleFontWeight || 'bold'

        //exageration
        this.exaggerationFactor = opts.exaggerationFactor || 0.5

        //color
        this.color = opts.color || 'gray'
        //orientation
        this.orientation = opts.orientation || 0
        //width
        this.widthPix = opts.widthPix || 3

        //label
        this.labelFontSize = opts.labelFontSize || '0.8em'
        this.labelUnitText = opts.labelUnitText || ''
    }

    /**
     * @param {{ style: import("../style/SegmentStyle").SegmentStyle, r: number, zf: number, sColor: import("../Style").Stat, sLength: import("../Style").Stat, sWidth: import("../Style").Stat }} opts
     */
    update(opts) {
        //could happen when data is still loading
        if (!opts.sWidth) return

        //clear
        this.div.selectAll('*').remove()

        const d = this.div.append('div')

        //title
        if (this.title) {
            d.append('div')
                .attr('class', 'title')
                .style('font-size', this.titleFontSize)
                .style('font-weight', this.titleFontWeight)
                .text(this.title)
        }

        //compute segment width and length, in pix
        const sWidth = this.widthPix
        const sLength = (1 * opts.r) / opts.zf

        //draw SVG segment
        const svgS = Math.max(sLength, sWidth)
        const svg = d.append('svg').attr('width', svgS).attr('height', svgS).style('', 'inline-block')

        const cos = Math.cos((-this.orientation * Math.PI) / 180)
        const sin = Math.sin((-this.orientation * Math.PI) / 180)
        const dc = svgS * 0.5,
            l2 = sLength * 0.5
        svg.append('line')
            .attr('x1', dc - cos * l2)
            .attr('y1', dc - sin * l2)
            .attr('x2', dc + cos * l2)
            .attr('y2', dc + sin * l2)
            .style('stroke', this.color)
            .style('stroke-width', sWidth)

        //text label
        d.append('div')
            //show on right of svg
            .style('display', 'inline')
            .style('padding-left', '5px')
            .style('font-size', this.labelFontSize)
            //.style("font-weight", "bold")
            .text(this.labelUnitText)
    }
}


/***/ }),

/***/ "./src/legend/SegmentWidthLegend.js":
/*!******************************************!*\
  !*** ./src/legend/SegmentWidthLegend.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SegmentWidthLegend": () => (/* binding */ SegmentWidthLegend)
/* harmony export */ });
/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Legend.js */ "./src/Legend.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
//@ts-check


;


/**
 * A legend element for segment width.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class SegmentWidthLegend extends _Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //title
        this.title = opts.title
        this.titleFontSize = opts.titleFontSize || '0.8em'
        this.titleFontWeight = opts.titleFontWeight || 'bold'

        //exageration
        //if set to 1, the segment width in the legend will be the one of the maximum width on the map
        this.exaggerationFactor = opts.exaggerationFactor || 0.5

        //color of the segment in the legend
        this.color = opts.color || 'gray'
        //orientation of the segment in the legend
        this.orientation = opts.orientation || 0

        //label
        this.labelFontSize = opts.labelFontSize || '0.8em'
        this.labelUnitText = opts.labelUnitText || ''

        //segment length in geo unit - a function of the resolution r and zoom level zf
        this.lengthFun = opts.lengthExaggerationFactor || ((r, zf) => r)
    }

    /**
     * @param {{ style: import("../style/SegmentStyle").SegmentStyle, r: number, zf: number, sColor: import("../Style").Stat, sLength: import("../Style").Stat, sWidth: import("../Style").Stat }} opts
     */
    update(opts) {
        //could happen when data is still loading
        if (!opts.sWidth) return

        //clear
        this.div.selectAll('*').remove()

        const d = this.div.append('div')

        //title
        if (this.title) {
            d.append('div')
                .attr('class', 'title')
                .style('font-size', this.titleFontSize)
                .style('font-weight', this.titleFontWeight)
                .text(this.title)
        }

        //get segment max value
        const value_ = opts.sWidth.max * this.exaggerationFactor
        //make 'nice' value (power of ten, or multiple)
        let pow10 = Math.log10(value_)
        pow10 = Math.floor(pow10)
        let value = Math.pow(10, pow10)
        if (value * 8 <= value_) value *= 8
        else if (value * 6 <= value_) value *= 6
        else if (value * 5 <= value_) value *= 5
        else if (value * 4 <= value_) value *= 4
        else if (value * 2.5 <= value_) value *= 2.5
        else if (value * 2 <= value_) value *= 2
        else if (value * 1.5 <= value_) value *= 1.5

        //compute segment width and length, in pix
        const sWidth = opts.widthFun(value, opts.r, opts.sWidth, opts.zf) / opts.zf
        const sLength = this.lengthFun(opts.r, opts.zf) / opts.zf

        //TODO use orientation

        const svg = d.append('svg').attr('width', sLength).attr('height', sWidth).style('', 'inline-block')

        //<line x1="0" y1="0" x2="200" y2="200" style="stroke:rgb(255,0,0);stroke-width:2" />
        svg.append('line')
            .attr('x1', 0)
            .attr('y1', sWidth / 2)
            .attr('x2', sLength)
            .attr('y2', sWidth / 2)
            .style('stroke', this.color)
            .style('stroke-width', sWidth)

        const valueT = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__.format)(',.2r')(value)
        d.append('div')
            //show on right of graphic
            .style('display', 'inline')
            .style('padding-left', '5px')
            .style('font-size', this.labelFontSize)
            //.style("font-weight", "bold")
            .text(valueT + (this.labelUnitText ? ' ' : '') + this.labelUnitText)
    }
}


/***/ }),

/***/ "./src/legend/SizeLegend.js":
/*!**********************************!*\
  !*** ./src/legend/SizeLegend.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SizeLegend": () => (/* binding */ SizeLegend)
/* harmony export */ });
/* harmony import */ var _Legend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Legend.js */ "./src/Legend.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
//@ts-check


;


/**
 * A legend element for proportional symbols.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class SizeLegend extends _Legend_js__WEBPACK_IMPORTED_MODULE_0__.Legend {
    /** @param {Object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        //exageration
        this.exaggerationFactor = opts.exaggerationFactor || 0.8

        //if value is to be forced
        this.value = opts.value || undefined

        //title
        this.title = opts.title
        this.titleFontSize = opts.titleFontSize || '0.8em'
        this.titleFontWeight = opts.titleFontWeight || 'bold'

        //symbol
        /**
         * @private
         * @type {import("../Style").Shape} */
        this.shape = opts.shape || 'circle'
        this.fillColor = opts.fillColor || 'none'
        this.strokeColor = opts.strokeColor || 'gray'
        this.strokeWidth = opts.strokeWidth || 1

        //label
        this.labelFontSize = opts.labelFontSize || '0.8em'
        this.labelUnitText = opts.labelUnitText || ''
        this.labelFormat = opts.labelFormat || ',.2r'

        //
        //this.div.style("text-align", "center")
    }

    /**
     * @param {{ style: import("../style/ShapeColorSizeStyle").ShapeColorSizeStyle, r: number, zf: number, sSize: import("../Style").Stat, sColor: import("../Style").Stat }} opts
     */
    update(opts) {
        //could happen when data is still loading
        if (!opts.sSize) return

        //clear
        this.div.selectAll('*').remove()

        //get value
        let value = this.value
        if (value == undefined) {
            //compute 'nice value

            //get max value
            const value_ = opts.sSize.max * this.exaggerationFactor

            //take 'nice' value (power of ten, or multiple)
            let pow10 = Math.log10(value_)
            pow10 = Math.floor(pow10)
            value = Math.pow(10, pow10)
            if (value * 8 <= value_) value *= 8
            else if (value * 6 <= value_) value *= 6
            else if (value * 5 <= value_) value *= 5
            else if (value * 4 <= value_) value *= 4
            else if (value * 2.5 <= value_) value *= 2.5
            else if (value * 2 <= value_) value *= 2
        }

        if (!value) return

        const d = this.div.append('div')
        //to enable vertical centering
        //.style("position", "relative")

        //title
        if (this.title) {
            d.append('div')
                .attr('class', 'title')
                .style('font-size', this.titleFontSize)
                .style('font-weight', this.titleFontWeight)
                .text(this.title)
        }

        //compute size of symbol, in pix
        const size = opts.style.size(value, opts.r, opts.sSize, opts.zf) / opts.zf

        const svg = d
            .append('svg')
            .attr('width', size + this.strokeWidth + 2)
            .attr('height', size + this.strokeWidth + 2)
            .style('', 'inline-block')

        if (this.shape === 'square') {
            svg.append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', size)
                .attr('height', size)
                .style('fill', this.fillColor)
                .style('stroke', this.strokeColor)
                .style('stroke-width', this.strokeWidth)
            //TODO test
        } else if (this.shape === 'circle') {
            // <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
            const r = (size + this.strokeWidth) * 0.5
            svg.append('circle')
                .attr('cx', r + 1)
                .attr('cy', r + 1)
                .attr('r', r)
                .style('fill', this.fillColor)
                .style('stroke', this.strokeColor)
                .style('stroke-width', this.strokeWidth)
        } else if (this.shape === 'donut') {
            //TODO
        } else if (this.shape === 'diamond') {
            //TODO
        } else {
            throw new Error('Unexpected shape:' + this.shape)
        }

        const valueT = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__.format)(this.labelFormat)(value)
        d.append('div')
            //show on right of graphic
            .style('display', 'inline')

            //center vertically
            //.style("position", "absolute").style("top", "0").style("bottom", "0")

            .style('padding-left', '5px')
            .style('font-size', this.labelFontSize)
            .text(valueT + (this.labelUnitText ? ' ' : '') + this.labelUnitText)
    }
}


/***/ }),

/***/ "./src/style/CompositionStyle.js":
/*!***************************************!*\
  !*** ./src/style/CompositionStyle.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CompositionStyle": () => (/* binding */ CompositionStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
//@ts-check


;

/** @typedef {"flag"|"piechart"|"ring"|"segment"|"radar"|"agepyramid"|"halftone"} CompositionType */

/**
 * A style showing the composition of a total in different categories, with different color hues.
 * It consists of a symbol with different parts, whose size reflect the proportion of the corresponding category.
 * For a list of supported symbols, @see CompositionType
 * The symbol can be scaled depending on the cell importance.
 *
 * @author Julien Gaffuri
 */
class CompositionStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        this.color = opts.color

        /**
         * A function returning the type of decomposition symbol of a cell, @see CompositionType
         * @type {function(import("../Dataset").Cell):CompositionType} */
        this.type = opts.type

        /** The column where to get the size values.
         * @type {string} */
        this.sizeCol = opts.sizeCol

        /** A function returning the size of a cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.size = opts.size || ((v, r, s, zf) => r)

        /** For style types with stripes (flag, segment), the orientation of the stripes (0 for horizontal, other for vertical).
         * @type {function(import("../Dataset").Cell,number,number):number} */
        this.stripesOrientation = opts.stripesOrientation || (() => 0) //(c,r,zf) => ...

        /** The function specifying an offset angle for a radar, halftone or pie chart style.
         * The angle is specified in degree. The rotation is anti-clockwise.
         * @type {function(import("../Dataset").Cell,number,number):number} */
        this.offsetAngle = opts.offsetAngle || (() => 0) //(cell,r,zf) => ...

        /** The function specifying the height of the age pyramid, in geo unit.
         * @type {function(import("../Dataset").Cell,number,number):number} */
        this.agePyramidHeight = opts.agePyramidHeight || ((c, r, zf) => r) //(cell,r,zf) => ...

        /** For pie chart, this is parameter for internal radius, so that the pie chart looks like a donut.
         * 0 for normal pie charts, 0.5 to empty half of the radius.
         * @type {number} */
        this.pieChartInternalRadiusFactor = opts.pieChartInternalRadiusFactor || 0
    }

    /**
     * Draw cells as squares depending on their value.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let stat
        if (this.sizeCol) {
            //if size is used, sort cells by size so that the biggest are drawn first
            cells.sort((c1, c2) => c2[this.sizeCol] - c1[this.sizeCol])
            //and compute statistics
            stat = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.sizeCol], true)
        }

        //nb categories - used for radar and agepyramid
        const nbCat = Object.entries(this.color).length

        //draw in geo coordinates
        cg.setCanvasTransform()

        //draw calls
        for (let cell of cells) {
            //size
            /** @type {function(number,number,import("../Style").Stat|undefined,number):number} */
            let s_ = this.size || (() => r)
            //size - in geo
            /** @type {number} */
            const sG = s_(cell[this.sizeCol], r, stat, zf)

            //get offset
            const offset = this.offset(cell, r, zf)

            //get symbol type
            const type_ = this.type ? this.type(cell) : 'flag'

            //compute center position
            const xc = cell.x + offset.dx + (type_ === 'agepyramid' ? 0 : r * 0.5)
            const yc = cell.y + offset.dy + (type_ === 'agepyramid' ? 0 : r * 0.5)

            //compute offset angle, when relevant
            const offAng = this.offsetAngle ? (this.offsetAngle(cell, r, zf) * Math.PI) / 180 : 0

            if (type_ === 'agepyramid' || type_ === 'radar' || type_ === 'halftone') {
                //get cell category max value
                let maxVal = -Infinity
                for (let key of Object.keys(this.color)) {
                    const v = +cell[key]
                    if (v > maxVal) maxVal = v
                }

                //cumul
                let cumul = 0
                if (type_ === 'agepyramid' && this.agePyramidHeight)
                    cumul = (r - this.agePyramidHeight(cell, r, zf)) / 2
                if (type_ === 'radar' || type_ === 'halftone') cumul = Math.PI / 2 + offAng

                //compute the increment, which is the value to increment the cumul for each category
                const incr =
                    type_ === 'agepyramid'
                        ? (this.agePyramidHeight ? this.agePyramidHeight(cell, r, zf) : r) / nbCat
                        : type_ === 'radar' || type_ === 'halftone'
                        ? (2 * Math.PI) / nbCat
                        : undefined
                if (incr === undefined) throw new Error('Unexpected symbol type:' + type_)

                for (let [column, color] of Object.entries(this.color)) {
                    if (type_ === 'agepyramid') {
                        //set category color
                        cg.ctx.fillStyle = color

                        //get category value
                        const val = cell[column]

                        //compute category length - in geo
                        /** @type {number} */
                        const wG = (sG * val) / maxVal

                        //draw bar
                        cg.ctx.fillRect(xc + (r - wG) / 2, yc + cumul, wG, incr)

                        //next height
                        cumul += incr
                    } else if (type_ === 'radar') {
                        //set category color
                        cg.ctx.fillStyle = color

                        //get categroy value
                        const val = cell[column]

                        //compute category radius - in geo
                        /** @type {number} */
                        //const rG = this.radius(val, r, stat, cellStat, zf)
                        const rG = (sG / 2) * Math.sqrt(val / maxVal)

                        //draw angular sector
                        cg.ctx.beginPath()
                        cg.ctx.moveTo(xc, yc)
                        cg.ctx.arc(xc, yc, rG, cumul - incr, cumul)
                        cg.ctx.lineTo(xc, yc)
                        cg.ctx.fill()

                        //next angular sector
                        cumul += incr
                    } else if (type_ === 'halftone') {
                        //set category color
                        cg.ctx.fillStyle = color

                        //get categroy value
                        const val = cell[column]

                        //compute category radius - in geo
                        /** @type {number} */
                        const rG = sG * 0.333 * Math.sqrt(val / maxVal)

                        //draw circle
                        cg.ctx.beginPath()
                        cg.ctx.arc(
                            xc + r * 0.25 * Math.cos(cumul),
                            yc + r * 0.25 * Math.sin(cumul),
                            rG,
                            0,
                            2 * Math.PI
                        )
                        cg.ctx.fill()

                        //next angular sector
                        cumul += incr
                    } else {
                        throw new Error('Unexpected symbol type:' + type_)
                    }
                }
            } else {
                //compute total
                let total = 0
                for (let column of Object.keys(this.color)) {
                    const v = +cell[column]
                    if (!v) continue
                    total += v
                }
                if (!total || isNaN(total)) continue

                //draw decomposition symbol
                let cumul = 0
                const d = r * (1 - sG / r) * 0.5
                const ori = this.stripesOrientation(cell, r, zf)

                for (let [column, color] of Object.entries(this.color)) {
                    //get share
                    const share = cell[column] / total
                    if (!share || isNaN(share)) continue

                    //set color
                    cg.ctx.fillStyle = color

                    //draw symbol part
                    if (type_ === 'flag') {
                        //draw flag stripe
                        if (ori == 0) {
                            //horizontal
                            cg.ctx.fillRect(
                                cell.x + d + offset.dx,
                                cell.y + d + cumul * sG + offset.dy,
                                sG,
                                share * sG
                            )
                        } else {
                            //vertical
                            cg.ctx.fillRect(
                                cell.x + d + cumul * sG + offset.dx,
                                cell.y + d + offset.dy,
                                share * sG,
                                sG
                            )
                        }
                    } else if (type_ === 'piechart') {
                        //draw pie chart angular sector

                        //compute angles
                        const a1 = cumul * 2 * Math.PI
                        const a2 = (cumul + share) * 2 * Math.PI

                        //draw
                        cg.ctx.beginPath()
                        cg.ctx.moveTo(xc, yc)
                        cg.ctx.arc(xc, yc, sG * 0.5, a1 + offAng, a2 + offAng)
                        if (this.pieChartInternalRadiusFactor)
                            cg.ctx.arc(
                                xc,
                                yc,
                                sG * 0.5 * this.pieChartInternalRadiusFactor,
                                a1 + offAng,
                                a2 + offAng,
                                true
                            )
                        cg.ctx.closePath()
                        cg.ctx.fill()
                    } else if (type_ === 'ring') {
                        //draw ring
                        cg.ctx.beginPath()
                        cg.ctx.arc(xc, yc, Math.sqrt(1 - cumul) * sG * 0.5, 0, 2 * Math.PI)
                        cg.ctx.fill()
                    } else if (type_ === 'segment') {
                        //draw segment sections
                        const wG = (sG * sG) / r
                        if (ori == 0) {
                            //horizontal
                            cg.ctx.fillRect(
                                cell.x + offset.dx,
                                cell.y + (r - wG) / 2 + cumul * wG + offset.dy,
                                r,
                                share * wG
                            )
                        } else {
                            //vertical
                            cg.ctx.fillRect(
                                cell.x + cumul * r + offset.dx,
                                cell.y + (r - wG) / 2 + offset.dy,
                                share * r,
                                wG
                            )
                        }
                    } else {
                        throw new Error('Unexpected symbol type:' + type_)
                    }

                    cumul += share
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sSize: stat })
    }
}


/***/ }),

/***/ "./src/style/ContourStyle.js":
/*!***********************************!*\
  !*** ./src/style/ContourStyle.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContourStyle": () => (/* binding */ ContourStyle)
/* harmony export */ });
/* harmony import */ var _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SideStyle.js */ "./src/style/SideStyle.js");
//@ts-check


;

/** @typedef {{x:number,y:number,or:"v"|"h",value:number}} Side */

/**
 *
 * @author Julien Gaffuri
 */
class ContourStyle extends _SideStyle_js__WEBPACK_IMPORTED_MODULE_0__.SideStyle {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** @type {number} */
        //opts.interval = opts.interval || 100

        /** @type {Array.<number>} */
        opts.breaks = opts.breaks || [100, 1000, 10000, 100000, 1000000]

        /** @type {function(Side,number,number):string} */
        opts.width = opts.width || (() => 1) //(s, r, zf) => ...

        /** @type {function(Side,number,number):string} */
        opts.color = opts.color || (() => '#E7A935') //(s, r, zf) => ...

        //override method for contour drawing

        const getClass = function (v) {
            if (v == undefined) return 0
            for (let i = 0; i < opts.breaks.length; i++) if (v < opts.breaks[i]) return i
            return opts.breaks.length
        }

        this.value = (v1, v2, r, s, zf) => {
            //if (!v1 || !v2) return 0
            return Math.abs(getClass(v2) - getClass(v1))

            //check if v1 - v2 cross a contour line
            //const r1 = Math.floor(v1 / opts.interval);
            //const r2 = Math.floor(v2 / opts.interval);
            //return Math.abs(r2 - r1);
        }

        //same color for all
        this.color = (side, r, s, zf) => (side.value ? opts.color(side, r, zf) : undefined)

        //width: multiple of
        this.width = (side, r, s, zf) => side.value * zf * opts.width(side, r, zf)
    }
}


/***/ }),

/***/ "./src/style/DotDensityStyle.js":
/*!**************************************!*\
  !*** ./src/style/DotDensityStyle.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DotDensityStyle": () => (/* binding */ DotDensityStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
/* harmony import */ var d3_random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-random */ "./node_modules/d3-random/src/normal.js");
/* harmony import */ var _utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webGLUtils.js */ "./src/utils/webGLUtils.js");
/* harmony import */ var _utils_WebGLSquareColoring_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/WebGLSquareColoring.js */ "./src/utils/WebGLSquareColoring.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Utils.js */ "./src/utils/Utils.js");
//@ts-check


;






/**
 *
 * @author Julien Gaffuri
 */
class DotDensityStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for dot number.
         * @type {string} */
        this.nbCol = opts.nbCol

        /** A function returning the number of dots for a cell value.
         * @type {function(number,number,import("../Style").Stat,number):number} */
        this.nb = opts.nb || ((v, r, s, zf) => (((0.3 * r * r) / (zf * zf)) * v) / s.max)

        /** The color of the dots. Same color for all dots within a cell.
         * @type {function(import("../Dataset").Cell):string} */
        this.color = opts.color || (() => '#FF5733')

        /** A function returning the size of the dots, in geo unit.
         * @type {function(number,number):number} */
        this.dotSize = opts.dotSize //|| ((r, zf) => ...

        /** A function returning the sigma of the distribution from the resolution, in geo unit.
         * @type {function(number,number):number} */
        this.sigma = opts.sigma //|| ((r,zf) => ...
    }

    /**
     * Draw cells as text.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('*** DotDensityStyle draw')

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let stat
        if (this.nbCol) stat = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.nbCol], true)
        if (!stat) return

        //size of the dots
        const sGeo = this.dotSize ? this.dotSize(r, zf) : 2 * zf

        //make random function
        const sig = this.sigma ? this.sigma(r, zf) : r * 0.4
        const rand = (0,d3_random__WEBPACK_IMPORTED_MODULE_4__["default"])(0, sig)

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)(' preparation')

        if ((0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.checkWebGLSupport)()) {
            //create canvas and webgl renderer
            const cvWGL = (0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.makeWebGLCanvas)(cg.w + '', cg.h + '')
            if (!cvWGL) {
                console.error('No webGL')
                return
            }

            //create webGL program
            const prog = new _utils_WebGLSquareColoring_js__WEBPACK_IMPORTED_MODULE_2__.WebGLSquareColoring(cvWGL.gl, sGeo / zf)

            if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)(' webgl creation')

            const r2 = r / 2

            let col, offset, nb, cx, cy, cc
            for (let c of cells) {
                //get color
                col = this.color(c)
                if (!col || col === 'none') continue

                //get offset
                offset = this.offset(c, r, zf)

                //number of dots
                nb = this.nb(c[this.nbCol], r, stat, zf)

                //cell center
                cx = c.x + offset.dx + r2
                cy = c.y + offset.dy + r2

                //convert color
                cc = (0,d3_color__WEBPACK_IMPORTED_MODULE_5__["default"])(col)
                if (!cc) return

                //random points
                for (let i = 0; i <= nb; i++)
                    prog.addPointData2(cx + rand(), cy + rand(), cc.r, cc.g, cc.b, cc.opacity)
            }

            if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)(' data preparation')

            //draw
            prog.draw(cg.getWebGLTransform())

            if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)(' webgl drawing')

            //draw in canvas geo
            cg.initCanvasTransform()
            cg.ctx.drawImage(cvWGL.canvas, 0, 0)

            if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)(' canvas drawing')
        } else {
            //draw with HTML canvas

            //draw in geo coordinates
            cg.setCanvasTransform()

            for (let c of cells) {
                //get color
                const col = this.color(c)
                if (!col || col === 'none') continue
                //set color
                cg.ctx.fillStyle = col

                //get offset
                const offset = this.offset(c, r, zf)

                //number of dots
                const nb = this.nb(c[this.nbCol], r, stat, zf)

                //draw random dots
                const cx = c.x + offset.dx + r / 2,
                    cy = c.y + offset.dy + r / 2
                for (let i = 0; i <= nb; i++) {
                    cg.ctx.fillRect(cx + rand(), cy + rand(), sGeo, sGeo)
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf })

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('*** DotDensityStyle end draw')
    }
}


/***/ }),

/***/ "./src/style/IsoFenceStyle.js":
/*!************************************!*\
  !*** ./src/style/IsoFenceStyle.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsoFenceStyle": () => (/* binding */ IsoFenceStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
//@ts-check


;

/** @typedef {{x:number,y:number,or:"v"|"h",c1:import('../Dataset.js').Cell|undefined,c2:import('../Dataset.js').Cell|undefined}} Side */

/**
 * @author Julien Gaffuri
 */
class IsoFenceStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {

    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        this.color = opts.color

        /** The column where to get the height values.
         * @type {string} */
        this.heightCol = opts.heightCol

        /** A function returning the height of a cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.height = opts.height || ((v, r, s, zf) => r * 0.4)

        /** The perspective angle, in degree, within [-180,180], from [O,x] axis.
         * @type {number} */
        this.angle = opts.angle != undefined ? opts.angle : 50

        /** A function returning the corner line stroke style.
         * @type {function(import('../Dataset.js').Cell,number,number,number):string} */
        this.cornerLineStrokeColor = opts.cornerLineStrokeColor || ((c, r, zf, angle) => "#999")

        /** A function returning the corner line width.
        * @type {function(import('../Dataset.js').Cell,number,number,number):number} */
        this.cornerLineWidth = opts.cornerLineWidth || ((c, r, zf, angle) => (angle % 90 == 0 ? 0 : 0.8 * zf))

        /**
        * Show vertical cross-sections.
        * @type {boolean} */
        this.sVert = opts.sVert != undefined ? opts.sVert : true

        /**
        * Show horizontal cross-sections.
        * @type {boolean} */
        this.sHor = opts.sHor != undefined ? opts.sHor : true
    }

    /**
     * Draw cells as segments.
     *
     * @param {Array.<import("../Dataset.js").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas.js").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let stat
        if (this.heightCol) {
            //if size is used, sort cells by size so that the biggest are drawn first
            cells.sort((c1, c2) => c2[this.heightCol] - c1[this.heightCol])
            //and compute statistics
            stat = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.heightCol], true)
        }

        //nb categories - used for radar and agepyramid
        const cats = Object.keys(this.color)

        //half resolution
        const r2 = r / 2

        //get offset
        // @ts-ignore
        const offset = this.offset(undefined, r, zf), dx = offset.dx, dy = offset.dy

        //height
        /** @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        let h_ = this.height

        //make sides
        /**  @type {Array.<Side>} */
        const sides = []

        //make horizontal sides - except when angle%180=0
        //sort cells by x and y
        if (this.angle % 180 != 90 && this.sVert) {
            cells.sort((c1, c2) => (c2.x == c1.x ? c1.y - c2.y : c1.x - c2.x))
            let c1 = cells[0]
            for (let i = 1; i < cells.length; i++) {
                let c2 = cells[i]

                if ((c1.y + r == c2.y) && (c1.x == c2.x))
                    //cells in same column and touch along horizontal side
                    //make shared side
                    sides.push({ x: c1.x + r2, y: c2.y, or: 'h', c1: c1, c2: c2 })
                else {
                    //cells do not touch along horizontal side
                    //make two sides: top one for c1, bottom for c2
                    sides.push({ x: c1.x + r2, y: c1.y + r, or: 'h', c1: c1, c2: undefined })
                    sides.push({ x: c2.x + r2, y: c2.y, or: 'h', c1: undefined, c2: c2 })
                }

                c1 = c2
            }
        }

        //make vertical sides - except when angle%180=90
        //sort cells by y and x
        if (this.angle % 180 != 0 && this.sHor) {
            cells.sort((c1, c2) => (c2.y == c1.y ? c1.x - c2.x : c1.y - c2.y))
            let c1 = cells[0]
            for (let i = 1; i < cells.length; i++) {
                let c2 = cells[i]

                if ((c1.x + r == c2.x) && (c1.y == c2.y))
                    //cells in same row and touch along vertical side
                    //make shared side
                    sides.push({ x: c2.x, y: c1.y + r2, or: 'v', c1: c1, c2: c2 })
                else {
                    //cells do not touch along vertical side
                    //make two sides: right one for c1, left for c2
                    sides.push({ x: c1.x + r, y: c1.y + r2, or: 'v', c1: c1, c2: undefined })
                    sides.push({ x: c2.x, y: c2.y + r2, or: 'v', c1: undefined, c2: c2 })
                }

                c1 = c2
            }
        }

        //
        if (sides.length == 0) return

        //angle in radians
        const aRad = this.angle * Math.PI / 180, cos = Math.cos(aRad), sin = Math.sin(aRad)

        //sort sides so that the back ones are drawn first. This depends on the angle.
        //depending on distance to the reference corner point
        const xCorner = Math.abs(this.angle) < 90 ? cg.extGeo.xMin : cg.extGeo.xMax
        const yCorner = this.angle < 0 ? cg.extGeo.yMax : cg.extGeo.yMin
        sides.sort((s1, s2) => (Math.hypot(s2.x - xCorner, s2.y - yCorner) - Math.hypot(s1.x - xCorner, s1.y - yCorner)))

        //prepare function to draw corner line for a cell *c*
        const drawCornerLine = (c) => {

            if (!c) return
            //line style
            const lw = this.cornerLineWidth ? this.cornerLineWidth(c, r, zf, this.angle) : 0.8 * zf
            if (lw == 0) return
            cg.ctx.strokeStyle = this.cornerLineStrokeColor ? this.cornerLineStrokeColor(c, r, zf, this.angle) : "#333"
            cg.ctx.lineWidth = lw

            //height - in geo
            const hG = h_(c[this.heightCol], r, stat, zf)

            //draw line
            cg.ctx.beginPath()
            cg.ctx.moveTo(c.x + r2 + dx, c.y + r2 + dy)
            cg.ctx.lineTo(c.x + r2 + hG * cos + dx, c.y + r2 + hG * sin + dy)
            cg.ctx.stroke()
        }

        //draw in geo coordinates
        cg.setCanvasTransform()

        //draw sides
        cg.ctx.lineCap = "round";
        for (let s of sides) {

            //heights - in geo
            const hG1 = s.c1 ? h_(s.c1[this.heightCol], r, stat, zf) : 0,
                hG2 = s.c2 ? h_(s.c2[this.heightCol], r, stat, zf) : 0

            //compute totals for both cells
            const total1 = computeTotal(s.c1, cats),
                total2 = computeTotal(s.c2, cats)
            if (total1 == 0 && total2 == 0) continue

            let cumul1 = 0, cumul2 = 0
            for (let [column, color] of Object.entries(this.color)) {
                //draw stripe of side s and category column

                //get values for both cells
                let v1 = s.c1 ? +s.c1[column] : 0
                let v2 = s.c2 ? +s.c2[column] : 0
                if (v1 == 0 && v2 == 0) continue

                //compute heights
                const h1 = hG1 * cumul1 / total1 || 0
                const h1n = hG1 * (cumul1 + v1) / total1 || 0
                const h2 = hG2 * cumul2 / total2 || 0
                const h2n = hG2 * (cumul2 + v2) / total2 || 0

                //make path
                cg.ctx.beginPath()
                if (s.or == "h") {
                    //horizontal side - vertical section
                    //bottom left
                    cg.ctx.moveTo(s.x + h1 * cos + dx, s.y - r2 + h1 * sin + dy)
                    //top left
                    cg.ctx.lineTo(s.x + h2 * cos + dx, s.y + r2 + h2 * sin + dy)
                    //top right
                    cg.ctx.lineTo(s.x + h2n * cos + dx, s.y + r2 + h2n * sin + dy)
                    //bottom right
                    cg.ctx.lineTo(s.x + h1n * cos + dx, s.y - r2 + h1n * sin + dy)
                } else {
                    //vertical side - horizontal section
                    //bottom left
                    cg.ctx.moveTo(s.x - r2 + h1 * cos + dx, s.y + h1 * sin + dy)
                    //bottom right
                    cg.ctx.lineTo(s.x + r2 + h2 * cos + dx, s.y + h2 * sin + dy)
                    //top right
                    cg.ctx.lineTo(s.x + r2 + h2n * cos + dx, s.y + h2n * sin + dy)
                    //top left
                    cg.ctx.lineTo(s.x - r2 + h1n * cos + dx, s.y + h1n * sin + dy)
                }
                //cg.ctx.closePath()

                //fill
                cg.ctx.fillStyle = color
                cg.ctx.fill()

                cumul1 += v1
                cumul2 += v2

                //TODO draw only one line
                //draw corner line
                //if (s.or == "h") {
                drawCornerLine(s.c1)
                drawCornerLine(s.c2)
                //if (this.angle > 0 && s.or == "h") drawCornerLine(s.c2)
                //else drawCornerLine(s.c2)
                //}
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sSize: stat })
    }
}



const computeTotal = (cell, categories) => {
    if (!cell) return 0
    let total = 0
    for (let column of categories) {
        const v = cell[column]
        if (!v) continue
        total += +v
    }
    return total || 0
}


/***/ }),

/***/ "./src/style/JoyPlotStyle.js":
/*!***********************************!*\
  !*** ./src/style/JoyPlotStyle.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JoyPlotStyle": () => (/* binding */ JoyPlotStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
//@ts-check


;

/**
 *
 * @author Julien Gaffuri
 */
class JoyPlotStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The cell column where to get the value to represent.
         * @type {string} */
        this.heightCol = opts.heightCol

        /** A function returning the height of a cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.height = opts.height || ((v) => Math.sqrt(v))

        /**
         * @type {function(number,{min:number, max:number},number,number):string} */
        this.lineColor = opts.lineColor || ((y, ys, r, zf) => '#BBB')
        /**
         * @type {function(number,{min:number, max:number},number,number):number} */
        this.lineWidth = opts.lineWidth || ((y, ys, r, zf) => zf)
        /**
         * @type {function(number,{min:number, max:number},number,number):string} */
        this.fillColor = opts.fillColor || ((y, ys, r, zf) => '#c08c5968')
    }

    /**
     * Draw cells as squares depending on their value.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     * */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        cg.ctx.lineJoin = 'round'

        //zoom factor
        const zf = cg.getZf()

        //compute statistics
        const stat = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.heightCol], true)

        //index cells by y and x
        /**  @type {object} */
        const ind = {}
        for (const cell of cells) {
            let row = ind[cell.y]
            if (!row) {
                row = {}
                ind[cell.y] = row
            }
            row[cell.x] = this.height(cell[this.heightCol], r, stat, zf)
        }

        //compute extent
        const e = cg.extGeo
        if (!e) return
        const xMin = Math.floor(e.xMin / r) * r
        const xMax = Math.floor(e.xMax / r) * r
        const yMin = Math.floor(e.yMin / r) * r
        const yMax = Math.floor(e.yMax / r) * r

        /**  @type {{min:number, max:number}} */
        const ys = { min: yMin, max: yMax }

        //draw in geo coordinates
        cg.setCanvasTransform()

        //draw lines, row by row, stating from the top
        for (let y = yMax; y >= yMin; y -= r) {
            //get row
            const row = ind[y]

            //no row
            if (!row) continue

            //place first point
            cg.ctx.beginPath()
            cg.ctx.moveTo(xMin - r / 2, y)

            //store the previous height
            /** @type {number|undefined} */
            let hG_

            //go through the line cells
            for (let x = xMin; x <= xMax; x += r) {
                //get column value
                /** @type {number} */
                let hG = row[x]
                if (!hG) hG = 0

                if (hG || hG_) {
                    //draw line only when at least one of both values is non-null
                    //TODO test bezierCurveTo
                    cg.ctx.lineTo(x + r / 2, y + hG)
                } else {
                    //else move the point
                    cg.ctx.moveTo(x + r / 2, y)
                }
                //store the previous value
                hG_ = hG
            }

            //last point
            if (hG_) cg.ctx.lineTo(xMax + r / 2, y)

            //draw fill
            const fc = this.fillColor(y, ys, r, zf)
            if (fc && fc != 'none') {
                cg.ctx.fillStyle = fc
                cg.ctx.fill()
            }

            //draw line
            const lc = this.lineColor(y, ys, r, zf)
            const lw = this.lineWidth(y, ys, r, zf)
            if (lc && lc != 'none' && lw > 0) {
                cg.ctx.strokeStyle = lc
                cg.ctx.lineWidth = lw
                cg.ctx.stroke()
            }
        }
    }
}


/***/ }),

/***/ "./src/style/LegoStyle.js":
/*!********************************!*\
  !*** ./src/style/LegoStyle.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LegoStyle": () => (/* binding */ LegoStyle)
/* harmony export */ });
/* harmony import */ var _TanakaStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TanakaStyle.js */ "./src/style/TanakaStyle.js");
/* harmony import */ var _StrokeStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StrokeStyle.js */ "./src/style/StrokeStyle.js");
/* harmony import */ var _SquareColorCatWGLStyle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SquareColorCatWGLStyle.js */ "./src/style/SquareColorCatWGLStyle.js");
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
//@ts-check


;




/**
 * @author Julien Gaffuri
 */
class LegoStyle {
    /**
     * @param {string} col
     * @param {object} opts
     * @returns {Array.<Style>}
     */
    static get(col, opts) {
        opts = opts || {}

        //the colors
        //http://www.jennyscrayoncollection.com/2021/06/all-current-lego-colors.html
        //https://leonawicz.github.io/legocolors/reference/figures/README-plot-1.png
        opts.colors = opts.colors || [
            '#00852b', //darker green
            '#afd246', //light green
            '#fac80a', //dark yellow
            '#bb805a', //brown
            '#d67923', //mostard
            '#cb4e29', //redish
            '#b40000', //red
            '#720012', //dark red
            //"purple",
            //"#eee" //whithe
        ]

        opts.colDark = opts.colDark || '#333'
        opts.colBright = opts.colBright || '#aaa'
        opts.widthFactor = opts.widthFactor || 0.12

        //reuse tanaka as basis
        const ts = _TanakaStyle_js__WEBPACK_IMPORTED_MODULE_0__.TanakaStyle.get(col, opts)
        //style to show limits between pieces
        const sst = new _StrokeStyle_js__WEBPACK_IMPORTED_MODULE_1__.StrokeStyle({
            strokeColor: () => '#666',
            strokeWidth: (v, r, s, z) => 0.2 * z,
            filter: opts.filter,
        })

        return [
            ts[0],
            sst,
            ts[1],
            new LegoTopStyle({ colDark: opts.colDark, colBright: opts.colBright, filter: opts.filter }),
        ]
    }

    /**
     * @param {function(string):string} col
     * @param {object} opts
     * @returns {Array.<Style>}
     */
    static getCat(col, opts) {
        opts = opts || {}

        opts.colDark = opts.colDark || '#333'
        opts.colBright = opts.colBright || '#aaa'

        //
        const s = new _SquareColorCatWGLStyle_js__WEBPACK_IMPORTED_MODULE_2__.SquareColorCatWGLStyle({ colorCol: col, color: opts.color })
        //style to show limits between pieces
        const sst = new _StrokeStyle_js__WEBPACK_IMPORTED_MODULE_1__.StrokeStyle({ strokeColor: () => '#666', strokeWidth: (v, r, s, z) => 0.2 * z })

        return [s, sst, new LegoTopStyle({ colDark: opts.colDark, colBright: opts.colBright })]
    }
}

/**
 * A style to draw top circle of lego bricks.
 */
class LegoTopStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_3__.Style {
    /** @param {object|undefined} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}
        this.colDark = opts.colDark || '#333'
        this.colBright = opts.colBright || '#aaa'
    }

    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        cg.ctx.lineWidth = 0.6 * cg.getZf()

        //dark part
        cg.ctx.strokeStyle = this.colDark
        for (let c of cells) {
            cg.ctx.beginPath()
            cg.ctx.arc(c.x + r * 0.5, c.y + r * 0.5, r * 0.55 * 0.5, Math.PI / 4, -Math.PI * (3 / 4), true)
            cg.ctx.stroke()
        }

        //bright part
        cg.ctx.strokeStyle = this.colBright
        for (let c of cells) {
            cg.ctx.beginPath()
            cg.ctx.arc(c.x + r * 0.5, c.y + r * 0.5, r * 0.55 * 0.5, Math.PI / 4, -Math.PI * (3 / 4), false)
            cg.ctx.stroke()
        }
    }
}


/***/ }),

/***/ "./src/style/MosaicStyle.js":
/*!**********************************!*\
  !*** ./src/style/MosaicStyle.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MosaicStyle": () => (/* binding */ MosaicStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
//@ts-check


;

/**
 * @author Julien Gaffuri
 */
class MosaicStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for color.
         * @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the cell.
         * @type {function(number,number,import("../Style").Stat|undefined):string} */
        this.color = opts.color || (() => '#EA6BAC')

        /** The mosaic factor, within [0,0.5]. Set to 0 for no mosaic effect. Set to 0.5 for strong mosaic effect.
         * @type {number} */
        this.mosaicFactor = opts.mosaicFactor || 0.15

        /** The mosaic shadow factor, within [0,0.5]. Set to 0 for no mosaic shadow. Set to 0.5 for strong mosaic shadow.
         * @type {number} */
        this.shadowFactor = opts.shadowFactor || 0.2

        /** The mosaic shadow color.
         * @type {string} */
        this.shadowColor = opts.shadowColor || '#555'
    }

    /**
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} resolution
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, resolution, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        //set stroke style, for shadow
        cg.ctx.strokeStyle = this.shadowColor
        cg.ctx.lineWidth = this.shadowFactor * resolution
        cg.ctx.lineJoin = 'round'
        cg.ctx.lineCap = 'butt'

        //function to compute position mosaic effect
        const d = resolution * this.mosaicFactor
        const mosaic = () => {
            return { x: Math.random() * d, y: Math.random() * d }
        }

        //draw with HTML canvas in geo coordinates
        cg.setCanvasTransform()

        for (let cell of cells) {
            //set fill color
            const col = this.color ? this.color(cell[this.colorCol], resolution, statColor) : undefined
            if (!col || col === 'none') continue
            cg.ctx.fillStyle = col

            //get offset
            const offset = this.offset(cell, resolution, zf)

            //compute position mosaic effect
            const ll = mosaic(),
                ul = mosaic(),
                lr = mosaic(),
                ur = mosaic()

            //stroke
            if (this.shadowFactor > 0) {
                cg.ctx.beginPath()
                cg.ctx.moveTo(cell.x + offset.dx + ll.x, cell.y + offset.dy + ll.y)
                cg.ctx.lineTo(cell.x + offset.dx + resolution - lr.x, cell.y + offset.dy + lr.y)
                cg.ctx.lineTo(cell.x + offset.dx + resolution - ur.x, cell.y + offset.dy + resolution - ur.y)
                cg.ctx.stroke()
            }

            //fill

            cg.ctx.beginPath()
            cg.ctx.moveTo(cell.x + offset.dx + ll.x, cell.y + offset.dy + ll.y)
            cg.ctx.lineTo(cell.x + offset.dx + resolution - lr.x, cell.y + offset.dy + lr.y)
            cg.ctx.lineTo(cell.x + offset.dx + resolution - ur.x, cell.y + offset.dy + resolution - ur.y)
            cg.ctx.lineTo(cell.x + offset.dx + ul.x, cell.y + offset.dy + resolution - ul.y)
            cg.ctx.fill()
        }

        //update legends
        this.updateLegends({ style: this, r: resolution, zf: zf, sColor: statColor })
    }
}


/***/ }),

/***/ "./src/style/NinjaStarStyle.js":
/*!*************************************!*\
  !*** ./src/style/NinjaStarStyle.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NinjaStarStyle": () => (/* binding */ NinjaStarStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
//@ts-check


;

/**
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class NinjaStarStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for color.
         * @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):string} */
        this.color = opts.color || (() => '#EA6BAC') //(v,r,s,zf) => {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for size.
         * @type {string} */
        this.sizeCol = opts.sizeCol

        /** A function returning the size of a cell, within [0,1]:
         *  - 0, nothing shown
         *  - 1, entire square
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.size = opts.size

        /** A function returning the shape.
         * @type {function(import("../Dataset").Cell):string} */
        this.shape = opts.shape || (() => 'o')
    }

    /**
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statSize
        if (this.sizeCol) {
            //if size is used, sort cells by size so that the biggest are drawn first
            cells.sort((c1, c2) => c2[this.sizeCol] - c1[this.sizeCol])
            //and compute size variable statistics
            statSize = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.sizeCol], true)
        }

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        //draw with HTML canvas
        //in geo coordinates
        cg.setCanvasTransform()

        const r2 = r * 0.5
        for (let cell of cells) {
            //color
            const col = this.color ? this.color(cell[this.colorCol], r, statColor, zf) : undefined
            if (!col || col === 'none') continue
            cg.ctx.fillStyle = col

            //shape
            const shape = this.shape ? this.shape(cell) : 'o'
            if (shape === 'none') continue

            //size
            /** @type {function(number,number,import("../Style").Stat|undefined,number):number} */
            let s_ = this.size || (() => 0.5)
            //size - in geo unit
            const sG2 = s_(cell[this.sizeCol], r, statSize, zf) * r2

            //get offset
            //TODO use
            //const offset = this.offset(cell, r, zf)

            //center position
            const cx = cell.x + r2
            const cy = cell.y + r2

            if (shape === 'p') {
                cg.ctx.beginPath()
                cg.ctx.moveTo(cx, cy + r2)
                cg.ctx.lineTo(cx + sG2, cy + sG2)
                cg.ctx.lineTo(cx + r2, cy)
                cg.ctx.lineTo(cx + sG2, cy - sG2)
                cg.ctx.lineTo(cx, cy - r2)
                cg.ctx.lineTo(cx - sG2, cy - sG2)
                cg.ctx.lineTo(cx - r2, cy)
                cg.ctx.lineTo(cx - sG2, cy + sG2)
                cg.ctx.fill()
            } else if (shape === 'o') {
                cg.ctx.beginPath()
                cg.ctx.moveTo(cx, cy + sG2)
                cg.ctx.lineTo(cx + r2, cy + r2)
                cg.ctx.lineTo(cx + sG2, cy)
                cg.ctx.lineTo(cx + r2, cy - r2)
                cg.ctx.lineTo(cx, cy - sG2)
                cg.ctx.lineTo(cx - r2, cy - r2)
                cg.ctx.lineTo(cx - sG2, cy)
                cg.ctx.lineTo(cx - r2, cy + r2)
                cg.ctx.fill()
            } else {
                throw new Error('Unexpected shape:' + shape)
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sSize: statSize, sColor: statColor })
    }
}


/***/ }),

/***/ "./src/style/PillarStyle.js":
/*!**********************************!*\
  !*** ./src/style/PillarStyle.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PillarStyle": () => (/* binding */ PillarStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
//@ts-check


;

/**
 * @author Julien Gaffuri
 */
class PillarStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    //TODO make a webGL version ?

    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** @type {string} */
        this.heightCol = opts.heightCol

        /** A function returning the height of the line representing a cell, in geo unit
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.height = opts.height

        /** @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the line representing a cell.
         * @type {function(number,number,import("../Style").Stat|undefined):string} */
        this.color = opts.color || (() => '#c08c59') //bb

        /** @type {string} */
        this.widthCol = opts.widthCol

        /** A function returning the width of the line representing a cell, in geo unit
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.width = opts.width || ((v, r) => 0.5 * r)

        /** @type {boolean} */
        this.simple = opts.simple == true

        /** @type {number} */
        this.viewHeightFactor = opts.viewHeightFactor || 1.5
        //0,0 is the center
        /** @type {number} */
        this.viewSX = opts.viewSX == undefined ? 0 : opts.viewSX
        /** @type {number} */
        this.viewSY = opts.viewSY == undefined ? -0.5 : opts.viewSY

        //TODO replace with sun location ?
        /** @type {number} */
        this.shadowDirection =
            opts.shadowDirection == undefined ? (-40.3 * Math.PI) / 180.0 : opts.shadowDirection
        /** @type {number} */
        this.shadowFactor = opts.shadowFactor || 0.3
        /** @type {string} */
        this.shadowColor = opts.shadowColor || '#00000033'

        /** @type {string} */
        this.outlineCol = opts.outlineCol || '#FFFFFF'
        /** @type {number} */
        this.outlineWidthPix = opts.outlineWidthPix == undefined ? 0.5 : opts.outlineWidthPix
    }

    /**
     * Draw cells as segments.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statHeight
        if (this.heightCol) {
            //compute size variable statistics
            statHeight = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.heightCol], true)
        }

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        let statWidth
        if (this.widthCol) {
            //and compute size variable statistics
            statWidth = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.widthCol], true)
        }

        //get view center geo position
        const cvx = cg.getCenter().x + this.viewSX * cg.w * zf
        const cvy = cg.getCenter().y + this.viewSY * cg.h * zf
        //get view height
        const H = this.viewHeightFactor * (cg.w + cg.h) * 0.5 * zf

        //sort cells by y and x
        //const distToViewCenter = (c) => { const dx = cvx - c.x, dy = cvy - c.y; return Math.sqrt(dx * dx + dy * dy) }
        cells.sort((c1, c2) => 100000000 * (c2.y - c1.y) + c1.x - c2.x)

        cg.ctx.lineCap = this.simple ? 'butt' : 'round'

        //draw in geo coordinates
        cg.setCanvasTransform()

        //draw shadows
        cg.ctx.strokeStyle = this.shadowColor
        cg.ctx.fillStyle = this.shadowColor
        for (let c of cells) {
            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(c[this.widthCol], r, statWidth, zf) : undefined
            if (!wG || wG < 0) continue

            //height
            /** @type {number|undefined} */
            const hG = this.height ? this.height(c[this.heightCol], r, statHeight, zf) : undefined
            if (!hG || hG < 0) continue

            //get offset
            //TODO use that
            const offset = this.offset(c, r, zf)

            //set width
            cg.ctx.lineWidth = wG

            //compute cell centre postition
            const cx = c.x + r / 2
            const cy = c.y + r / 2
            const ls = hG * this.shadowFactor

            //draw segment
            cg.ctx.beginPath()
            cg.ctx.moveTo(cx, cy)
            cg.ctx.lineTo(cx + ls * Math.cos(this.shadowDirection), cy + ls * Math.sin(this.shadowDirection))
            cg.ctx.stroke()

            /*
            if (this.simple) {
                //draw base circle
                cg.ctx.beginPath();
                cg.ctx.arc(
                    cx, cy,
                    wG * 0.5,
                    0, 2 * Math.PI, false);
                //cg.ctx.stroke();
                cg.ctx.fill();
            }*/
        }

        //draw pillars
        for (let c of cells) {
            //color
            /** @type {string|undefined} */
            const col = this.color ? this.color(c[this.colorCol], r, statColor) : undefined
            if (!col) continue

            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(c[this.widthCol], r, statWidth, zf) : undefined
            if (!wG || wG < 0) continue

            //height
            /** @type {number|undefined} */
            const hG = this.height ? this.height(c[this.heightCol], r, statHeight, zf) : undefined
            if (!hG || hG < 0) continue

            //get offset
            //TODO use that
            const offset = this.offset(c, r, zf)

            //compute cell centre postition
            const cx = c.x + r / 2
            const cy = c.y + r / 2

            //compute angle
            const dx = cx - cvx,
                dy = cy - cvy
            const a = Math.atan2(dy, dx)
            const D = Math.sqrt(dx * dx + dy * dy)
            const d = (D * hG) / (H - hG)

            if (this.simple) {
                //draw segment
                cg.ctx.strokeStyle = col
                cg.ctx.lineWidth = wG
                cg.ctx.beginPath()
                cg.ctx.moveTo(cx, cy)
                cg.ctx.lineTo(cx + d * Math.cos(a), cy + d * Math.sin(a))
                cg.ctx.stroke()
            } else {
                //draw background segment
                cg.ctx.strokeStyle = this.outlineCol
                cg.ctx.lineWidth = wG + 2 * this.outlineWidthPix * zf
                cg.ctx.beginPath()
                cg.ctx.moveTo(cx, cy)
                cg.ctx.lineTo(cx + d * Math.cos(a), cy + d * Math.sin(a))
                cg.ctx.stroke()

                //draw segment
                cg.ctx.strokeStyle = col
                cg.ctx.lineWidth = wG
                cg.ctx.beginPath()
                cg.ctx.moveTo(cx, cy)
                cg.ctx.lineTo(cx + d * Math.cos(a), cy + d * Math.sin(a))
                cg.ctx.stroke()

                //draw top circle
                cg.ctx.strokeStyle = this.outlineCol
                //cg.ctx.fillStyle = "#c08c59"
                cg.ctx.lineWidth = this.outlineWidthPix * zf
                cg.ctx.beginPath()
                cg.ctx.arc(cx + d * Math.cos(a), cy + d * Math.sin(a), wG * 0.5, 0, 2 * Math.PI, false)
                cg.ctx.stroke()
                //cg.ctx.fill();
            }
        }

        //in case...
        cg.ctx.lineCap = 'butt'

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sColor: statColor })
    }
}


/***/ }),

/***/ "./src/style/SegmentStyle.js":
/*!***********************************!*\
  !*** ./src/style/SegmentStyle.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SegmentStyle": () => (/* binding */ SegmentStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
//@ts-check


;

/**
 * A style where each cell is represented by a segment whose length, width, color and orientation can vary according to statistical values.
 *
 * @author Julien Gaffuri
 */
class SegmentStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** A function returning the orientation (in degrees) of the segment representing a cell.
         * @type {function(import("../Dataset").Cell):number} */
        this.orientation = opts.orientation || (() => 0)

        /**
         * @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the cell segment.
         * @type {function(number,number,import("../Style").Stat|undefined):string} */
        this.color = opts.color || (() => '#EA6BAC')

        /**
         * @type {string} */
        this.lengthCol = opts.lengthCol

        /** A function returning the length of the segment representing a cell, in geo unit
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.length = opts.length

        /**
         * @type {string} */
        this.widthCol = opts.widthCol

        /** A function returning the width of the segment representing a cell, in geo unit
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.width = opts.width
    }

    /**
     * Draw cells as segments.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        let statLength
        if (this.lengthCol) {
            //if length is used, sort cells by length so that the longests are drawn first
            cells.sort((c1, c2) => c2[this.lengthCol] - c1[this.lengthCol])
            //and compute size variable statistics
            statLength = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.lengthCol], true)
        }

        let statWidth
        if (this.widthCol) {
            //and compute size variable statistics
            statWidth = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.widthCol], true)
        }

        //
        cg.ctx.lineCap = 'butt'

        //conversion factor degree -> radian
        const f = Math.PI / 180

        //draw in geo coordinates
        cg.setCanvasTransform()

        for (let c of cells) {
            //color
            /** @type {string|undefined} */
            const col = this.color ? this.color(c[this.colorCol], r, statColor) : undefined
            if (!col) continue

            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(c[this.widthCol], r, statWidth, zf) : undefined
            if (!wG || wG < 0) continue

            //length
            /** @type {number|undefined} */
            const lG = this.length ? this.length(c[this.lengthCol], r, statLength, zf) : undefined
            if (!lG || lG < 0) continue

            //orientation (in radian)
            /** @type {number} */
            const or = this.orientation(c) * f
            if (or === undefined || isNaN(or)) continue

            //get offset
            const offset = this.offset(c, r, zf)

            //set color and width
            cg.ctx.strokeStyle = col
            cg.ctx.lineWidth = wG

            //compute segment centre postition
            const cx = c.x + r / 2 + offset.dx
            const cy = c.y + r / 2 + offset.dy

            //compute segment direction
            const dx = 0.5 * Math.cos(or) * lG
            const dy = 0.5 * Math.sin(or) * lG

            //draw segment
            cg.ctx.beginPath()
            cg.ctx.moveTo(cx - dx, cy - dy)
            cg.ctx.lineTo(cx + dx, cy + dy)
            cg.ctx.stroke()
        }

        //update legend, if any
        this.updateLegends({
            widthFun: this.width,
            r: r,
            zf: zf,
            sColor: statColor,
            //sLength: statLength,
            sWidth: statWidth,
        })
    }
}


/***/ }),

/***/ "./src/style/ShapeColorSizeStyle.js":
/*!******************************************!*\
  !*** ./src/style/ShapeColorSizeStyle.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShapeColorSizeStyle": () => (/* binding */ ShapeColorSizeStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * A very generic style that shows grid cells with specific color, size and shape.
 * It can be used to show variables as cell colors, cell size, cell shape, or any combination of the three visual variables.
 *
 * @author Joseph Davies, Julien Gaffuri
 */
class ShapeColorSizeStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for color.
         * @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):string} */
        this.color = opts.color || (() => '#EA6BAC') //(v,r,s,zf) => {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for size.
         * @type {string} */
        this.sizeCol = opts.sizeCol

        /** A function returning the size of a cell in geographical unit.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.size = opts.size

        /** A function returning the shape of a cell.
         * @type {function(import("../Dataset").Cell):import("../Style").Shape} */
        this.shape = opts.shape || (() => 'square')

        /** The name of the column/attribute of the tabular data where to retrieve the variable for color alpha.
         * @type {string} */
        this.alphaCol = opts.alphaCol

        /** A function returning the color alpha of the cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.alphaF = opts.alphaF
    }

    /**
     * Draw cells as squares, with various colors and size.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statSize
        if (this.sizeCol) {
            //if size is used, sort cells by size so that the biggest are drawn first
            cells.sort((c1, c2) => c2[this.sizeCol] - c1[this.sizeCol])
            //and compute size variable statistics
            statSize = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.sizeCol], true)
        }

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        let statAlpha
        if (this.alphaCol) {
            //compute color alpha variable statistics
            statAlpha = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.alphaCol], true)
        }

        //draw with HTML canvas
        //in geo coordinates
        cg.setCanvasTransform()

        const r2 = r * 0.5
        for (let cell of cells) {
            //color
            let col = this.color ? this.color(cell[this.colorCol], r, statColor, zf) : undefined
            if (!col || col === 'none') continue

            //alpha
            if (this.alphaCol && this.alphaF) {
                //get alpha
                const alpha = this.alphaF(cell[this.alphaCol], r, statAlpha, zf)
                if (alpha == 0) continue
                //apply alpha to color col
                const col_ = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(col);
                if (col_) col = `rgba(${col_.r}, ${col_.g}, ${col_.b}, ${alpha})`;
                else console.warn("Could not decode color " + col + " in ShapeColorSizeStyle")
            }

            //shape
            const shape = this.shape ? this.shape(cell) : 'square'
            if (shape === 'none') continue

            //size
            /** @type {function(number,number,import("../Style").Stat|undefined,number):number} */
            let s_ = this.size || (() => r)
            //size - in geo unit
            const sG = s_(cell[this.sizeCol], r, statSize, zf)

            //get offset
            const offset = this.offset(cell, r, zf)

            cg.ctx.fillStyle = col
            if (shape === 'square') {
                //draw square
                const d = r * (1 - sG / r) * 0.5
                cg.ctx.fillRect(cell.x + d + offset.dx, cell.y + d + offset.dy, sG, sG)
            } else if (shape === 'circle') {
                //draw circle
                cg.ctx.beginPath()
                cg.ctx.arc(cell.x + r2 + offset.dx, cell.y + r2 + offset.dy, sG * 0.5, 0, 2 * Math.PI, false)
                cg.ctx.fill()
            } else if (shape === 'donut') {
                //draw donut
                const xc = cell.x + r2 + offset.dx,
                    yc = cell.y + r2 + offset.dy
                cg.ctx.beginPath()
                cg.ctx.moveTo(xc, yc)
                cg.ctx.arc(xc, yc, r2, 0, 2 * Math.PI)
                cg.ctx.arc(xc, yc, (1 - sG / r) * r2, 0, 2 * Math.PI, true)
                cg.ctx.closePath()
                cg.ctx.fill()
            } else if (shape === 'diamond') {
                const s2 = sG * 0.5
                cg.ctx.beginPath()
                cg.ctx.moveTo(cell.x + r2 - s2, cell.y + r2)
                cg.ctx.lineTo(cell.x + r2, cell.y + r2 + s2)
                cg.ctx.lineTo(cell.x + r2 + s2, cell.y + r2)
                cg.ctx.lineTo(cell.x + r2, cell.y + r2 - s2)
                cg.ctx.fill()
            } else {
                throw new Error('Unexpected shape:' + shape)
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sSize: statSize, sColor: statColor, sAlpha: statAlpha })
    }
}


/***/ }),

/***/ "./src/style/SideCatStyle.js":
/*!***********************************!*\
  !*** ./src/style/SideCatStyle.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SideCatStyle": () => (/* binding */ SideCatStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
//@ts-check


;

/** @typedef {{x:number,y:number,or:"v"|"h",v1:string|undefined,v2:string|undefined}} Side */

/**
 * A style to show the sides of grid cells based on their different categories.
 *
 * @author Julien Gaffuri
 */
class SideCatStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the categorical value.
         * @type {string} */
        this.col = opts.col

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        this.color = opts.color

        /** A function returning the width of a cell side line, in geo unit
         * @type {function(Side,number,number):number} */
        this.width = opts.width || ((side, r, z) => r * 0.2)

        /** A fill color for the cells.
         * @type {function(import("../Dataset").Cell):string} */
        this.fillColor = opts.fillColor
    }

    /**
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        if (!cells || cells.length == 0) return

        //zoom factor
        const zf = cg.getZf()

        /**  @type {Array.<Side>} */
        const sides = []

        //make horizontal sides
        //sort cells by x and y
        cells.sort((c1, c2) => (c2.x == c1.x ? c1.y - c2.y : c1.x - c2.x))
        let c1 = cells[0]
        let v1 = c1[this.col]
        for (let i = 1; i < cells.length; i++) {
            let c2 = cells[i]
            let v2 = c2[this.col]

            if (c1.y + r == c2.y && c1.x == c2.x) {
                //cells in same column and touch along horizontal side
                //make shared side
                if (v1 != v2) sides.push({ x: c1.x, y: c2.y, or: 'h', v1: v1, v2: v2 })
            } else {
                //cells do not touch along horizontal side
                //make two sides: top one for c1, bottom for c2
                sides.push({ x: c1.x, y: c1.y + r, or: 'h', v1: v1, v2: undefined })
                sides.push({ x: c2.x, y: c2.y, or: 'h', v1: undefined, v2: v2 })
            }

            c1 = c2
            v1 = v2
        }

        //make vertical sides
        //sort cells by y and x
        cells.sort((c1, c2) => (c2.y == c1.y ? c1.x - c2.x : c1.y - c2.y))
        c1 = cells[0]
        v1 = c1[this.col]
        for (let i = 1; i < cells.length; i++) {
            let c2 = cells[i]
            let v2 = c2[this.col]

            if (c1.x + r == c2.x && c1.y == c2.y) {
                //cells in same row and touch along vertical side
                //make shared side
                if (v1 != v2) sides.push({ x: c1.x + r, y: c1.y, or: 'v', v1: v1, v2: v2 })
            } else {
                //cells do not touch along vertical side
                //make two sides: right one for c1, left for c2
                sides.push({ x: c1.x + r, y: c1.y, or: 'v', v1: v1, v2: undefined })
                sides.push({ x: c2.x, y: c2.y, or: 'v', v1: undefined, v2: v2 })
            }

            c1 = c2
            v1 = v2
        }

        //
        if (sides.length == 0) return

        //draw in geo coordinates
        cg.setCanvasTransform()

        //draw cells, if fillColor specified
        if (this.fillColor)
            for (let c of cells) {
                const fc = this.fillColor(c)
                if (!fc || fc == 'none') continue
                cg.ctx.fillStyle = fc
                cg.ctx.fillRect(c.x, c.y, r, r)
            }

        //draw sides
        cg.ctx.lineCap = 'butt'
        for (let s of sides) {
            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(s, r, zf) : undefined
            if (!wG || wG <= 0) continue
            const w2 = wG * 0.5

            //set color and width
            cg.ctx.lineWidth = wG

            //draw segment with correct orientation
            if (s.or === 'h') {
                //top line
                if (s.v2) {
                    cg.ctx.beginPath()
                    cg.ctx.strokeStyle = this.color[s.v2]
                    cg.ctx.moveTo(s.x, s.y + w2)
                    cg.ctx.lineTo(s.x + r, s.y + w2)
                    cg.ctx.stroke()
                }

                //bottom line
                if (s.v1) {
                    cg.ctx.beginPath()
                    cg.ctx.strokeStyle = this.color[s.v1]
                    cg.ctx.moveTo(s.x, s.y - w2)
                    cg.ctx.lineTo(s.x + r, s.y - w2)
                    cg.ctx.stroke()
                }
            } else {
                //right line
                if (s.v2) {
                    cg.ctx.beginPath()
                    cg.ctx.strokeStyle = this.color[s.v2]
                    cg.ctx.moveTo(s.x + w2, s.y)
                    cg.ctx.lineTo(s.x + w2, s.y + r)
                    cg.ctx.stroke()
                }

                //left line
                if (s.v1) {
                    cg.ctx.beginPath()
                    cg.ctx.strokeStyle = this.color[s.v1]
                    cg.ctx.moveTo(s.x - w2, s.y)
                    cg.ctx.lineTo(s.x - w2, s.y + r)
                    cg.ctx.stroke()
                }
            }
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf })
    }
}


/***/ }),

/***/ "./src/style/SideStyle.js":
/*!********************************!*\
  !*** ./src/style/SideStyle.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SideStyle": () => (/* binding */ SideStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
//@ts-check


;

/** @typedef {{x:number,y:number,or:"v"|"h",value:number}} Side */

/**
 *
 * @author Julien Gaffuri
 */
class SideStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for the cell values.
         * @type {string} */
        this.valueCol = opts.valueCol

        /** A function returning the value of a cell side. This value is computed from the two adjacent cell values.
         * For horizontal sides, v1 is the value of the cell below and v2 the value of the cell above.
         * For vertical sides, v1 is the value of the cell left and v2 the value of the cell right.
         * @type {function(number|undefined,number|undefined,number,import("../Style").Stat|undefined,number):number} */
        this.value = opts.value || ((v1, v2, r, s, zf) => 1)

        /** A function returning the color of a cell side.
         * @type {function(Side,number,import("../Style").Stat|undefined,number):string} */
        this.color = opts.color || (() => '#EA6BAC')

        /** A function returning the width of a cell side, in geo unit
         * @type {function(Side,number,import("../Style").Stat|undefined,number):number} */
        this.width = opts.width || ((side, r, s, zf) => (r * side.value) / 5)

        /** orientation. Set to 90 to show sides as slope lines for example.
         * @type {number} */
        this.orientation = opts.orientation || 0

        /** A fill color for the cells.
         * @type {function(import("../Dataset").Cell):string} */
        this.fillColor = opts.fillColor
    }

    /**
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        //compute stats on cell values
        let statValue
        if (this.valueCol) {
            //compute color variable statistics
            statValue = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.valueCol], true)
        }

        /**  @type {Array.<Side>} */
        const sides = []

        //make horizontal sides
        //sort cells by x and y
        cells.sort((c1, c2) => (c2.x == c1.x ? c1.y - c2.y : c1.x - c2.x))
        let c1 = cells[0]
        for (let i = 1; i < cells.length; i++) {
            let c2 = cells[i]

            if ((c1.y + r == c2.y) && (c1.x == c2.x))
                //cells in same column and touch along horizontal side
                //make shared side
                sides.push({
                    x: c1.x,
                    y: c2.y,
                    or: 'h',
                    value: this.value(c1[this.valueCol], c2[this.valueCol], r, statValue, zf),
                })
            else {
                //cells do not touch along horizontal side
                //make two sides: top one for c1, bottom for c2
                sides.push({
                    x: c1.x,
                    y: c1.y + r,
                    or: 'h',
                    value: this.value(c1[this.valueCol], undefined, r, statValue, zf),
                })
                sides.push({
                    x: c2.x,
                    y: c2.y,
                    or: 'h',
                    value: this.value(undefined, c2[this.valueCol], r, statValue, zf),
                })
            }

            c1 = c2
        }

        //make vertical sides
        //sort cells by y and x
        cells.sort((c1, c2) => (c2.y == c1.y ? c1.x - c2.x : c1.y - c2.y))
        c1 = cells[0]
        for (let i = 1; i < cells.length; i++) {
            let c2 = cells[i]

            if ((c1.x + r == c2.x) && (c1.y == c2.y))
                //cells in same row and touch along vertical side
                //make shared side
                sides.push({
                    x: c1.x + r,
                    y: c1.y,
                    or: 'v',
                    value: this.value(c1[this.valueCol], c2[this.valueCol], r, statValue, zf),
                })
            else {
                //cells do not touch along vertical side
                //make two sides: right one for c1, left for c2
                sides.push({
                    x: c1.x + r,
                    y: c1.y,
                    or: 'v',
                    value: this.value(c1[this.valueCol], undefined, r, statValue, zf),
                })
                sides.push({
                    x: c2.x,
                    y: c2.y,
                    or: 'v',
                    value: this.value(undefined, c2[this.valueCol], r, statValue, zf),
                })
            }

            c1 = c2
        }

        //
        if (sides.length == 0) return

        //compute stats on sides
        const statSides = SideStyle.getSideStatistics(sides, true)

        //draw in geo coordinates
        cg.setCanvasTransform()

        //draw cells, if fillColor specified
        if (this.fillColor)
            for (let c of cells) {
                const fc = this.fillColor(c)
                if (!fc || fc == 'none') continue
                cg.ctx.fillStyle = fc
                cg.ctx.fillRect(c.x, c.y, r, r)
            }

        //draw sides
        cg.ctx.lineCap = 'butt'
        const r2 = r / 2
        for (let s of sides) {
            //color
            /** @type {string|undefined} */
            const col = this.color ? this.color(s, r, statSides, zf) : undefined
            if (!col || col == 'none') continue

            //width
            /** @type {number|undefined} */
            const wG = this.width ? this.width(s, r, statSides, zf) : undefined
            if (!wG || wG <= 0) continue

            //set color and width
            cg.ctx.strokeStyle = col
            cg.ctx.lineWidth = wG

            //draw segment with correct orientation
            cg.ctx.beginPath()
            if (this.orientation == 90) {
                cg.ctx.moveTo(s.x + r2, s.y + r2)
                if (s.or === 'h') cg.ctx.lineTo(s.x + r2, s.y - r2)
                else cg.ctx.lineTo(s.x - r2, s.y + r2)
            } else {
                cg.ctx.moveTo(s.x, s.y)
                cg.ctx.lineTo(s.x + (s.or === 'h' ? r : 0), s.y + (s.or === 'v' ? r : 0))
            }
            cg.ctx.stroke()
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf })
    }

    /**
     * Compute some statistics on a value of some sides.
     * This is used to define how to draw specifically the sides within the view.
     *
     * @param {Array.<Side>} sides
     * @param {boolean} ignoreZeros
     * @returns {import("../Style").Stat | undefined}
     */
    static getSideStatistics(sides, ignoreZeros) {
        if (!sides || sides.length == 0) return undefined
        let min = Infinity
        let max = -Infinity
        //let sum = 0
        //let nb = 0
        for (const s of sides) {
            const v = s.value
            if (ignoreZeros && !v) continue
            if (v < min) min = v
            if (v > max) max = v
            //sum += v
            //nb++
        }
        return { min: min, max: max }
    }
}


/***/ }),

/***/ "./src/style/SquareColorCatWGLStyle.js":
/*!*********************************************!*\
  !*** ./src/style/SquareColorCatWGLStyle.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SquareColorCatWGLStyle": () => (/* binding */ SquareColorCatWGLStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
/* harmony import */ var _utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webGLUtils.js */ "./src/utils/webGLUtils.js");
/* harmony import */ var _utils_WebGLSquareColoringCatAdvanced_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/WebGLSquareColoringCatAdvanced.js */ "./src/utils/WebGLSquareColoringCatAdvanced.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Utils.js */ "./src/utils/Utils.js");
//@ts-check


;




/**
 * Style based on webGL
 * To show cells as colored squares, from categories.
 * Alls squares with the same size
 *
 * @author Julien Gaffuri
 */
class SquareColorCatWGLStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The name of the column/attribute of the tabular data where to retrieve the category of the cell, for coloring.
         * @type {string} */
        this.colorCol = opts.colorCol

        /**
         * The dictionary (string -> color) which give the color of each category.
         * @type {object} */
        opts.color = opts.color || undefined

        /** @type { Array.<string> } @private */
        const keys = Object.keys(opts.color)

        /** @type { object } @private */
        this.catToI = {}
        for (let i = 0; i < keys.length; i++) this.catToI[keys[i]] = i + ''

        /** @type { Array.<string> } @private */
        this.colors = []
        for (let i = 0; i < keys.length; i++) {
            this.colors.push(opts.color['' + keys[i]])
        }

        /**
         * A function returning the size of the cells, in geographical unit. All cells have the same size.
         * @type {function(number,number):number} */
        this.size = opts.size // (resolution, zf) => ...

        /**
         * @private
         * @type { WebGLSquareColoringCatAdvanced } */
        this.wgp = new _utils_WebGLSquareColoringCatAdvanced_js__WEBPACK_IMPORTED_MODULE_2__.WebGLSquareColoringCatAdvanced(this.colors)
    }

    /**
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('*** SquareColorCatWGLStyle draw')

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        //add vertice and fragment data
        const r2 = r / 2
        let c,
            nb = cells.length
        const verticesBuffer = []
        const iBuffer = []
        for (let i = 0; i < nb; i++) {
            c = cells[i]
            const cat = c[this.colorCol]
            if (cat == undefined) {
                console.log('Unexpected category: ' + cat)
                continue
            }
            /** @type {number} */
            const i_ = this.catToI[cat]
            if (isNaN(+i_)) {
                console.log('Unexpected category index: ' + cat + ' ' + i_)
                continue
            }
            verticesBuffer.push(c.x + r2, c.y + r2)
            iBuffer.push(+i_)
        }

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   webgl program inputs preparation')

        //create canvas and webgl renderer
        const cvWGL = (0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.makeWebGLCanvas)(cg.w + '', cg.h + '')
        if (!cvWGL) {
            console.error('No webGL')
            return
        }
        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   web GL canvas creation')

        //draw
        const sizeGeo = this.size ? this.size(r, zf) : r + 0.2 * zf
        this.wgp.draw(cvWGL.gl, verticesBuffer, iBuffer, cg.getWebGLTransform(), sizeGeo / zf)

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   webgl drawing')

        //draw in canvas geo
        cg.initCanvasTransform()
        cg.ctx.drawImage(cvWGL.canvas, 0, 0)

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   canvas drawing')

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf })

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('*** SquareColorCatWGLStyle end draw')
    }
}


/***/ }),

/***/ "./src/style/SquareColorWGLStyle.js":
/*!******************************************!*\
  !*** ./src/style/SquareColorWGLStyle.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SquareColorWGLStyle": () => (/* binding */ SquareColorWGLStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
/* harmony import */ var _utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/webGLUtils.js */ "./src/utils/webGLUtils.js");
/* harmony import */ var _utils_WebGLSquareColoringAdvanced_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/WebGLSquareColoringAdvanced.js */ "./src/utils/WebGLSquareColoringAdvanced.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Utils.js */ "./src/utils/Utils.js");
//@ts-check


;




/**
 * Style based on webGL
 * To show cells as colored squares, with computation of the colors on GPU side (faster than JavaScript side).
 * Alls squares with the same size
 *
 * @author Julien Gaffuri
 */
class SquareColorWGLStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /**
         * The name of the column/attribute of the tabular data where to retrieve the variable for color.
         * @type {string} */
        this.colorCol = opts.colorCol

        /**
         * A function returning the t value (within [0,1]) of the cell.
         * @type {function(number,number,import("../Style").Stat):number} */
        this.tFun = opts.tFun || ((v, r, s) => v / s.max)

        /**
         * Distribution stretching method.
         * The stretching is performed on GPU side (fragment shader).
         * @type {{ fun:string, alpha:number }} */
        this.stretching = opts.stretching

        /**
         * The sample of the color ramp.
         * The color is computed on GPU side (fragment shader) based on those values (linear interpolation).
         * @type {Array.<string>} */
        this.colors =
            opts.colors ||
            [
                'rgb(158, 1, 66)',
                'rgb(248, 142, 83)',
                'rgb(251, 248, 176)',
                'rgb(137, 207, 165)',
                'rgb(94, 79, 162)',
            ].reverse()
        if (opts.color)
            this.colors = [
                opts.color(0),
                opts.color(0.2),
                opts.color(0.4),
                opts.color(0.6),
                opts.color(0.8),
                opts.color(1),
            ]

        /**
         * Define the opacity of the style, within [0,1].
         * If this opacity is defined, the individual color opacity will be ignored.
         * @type {function(number,number):number} */
        this.opacity = opts.opacity // (r,zf) => ...

        /**
         * A function returning the size of the cells, in geographical unit. All cells have the same size.
         * @type {function(number,number):number} */
        this.size = opts.size // (resolution, zf) => ...
    }

    /**
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('*** SquareColorWGLStyle draw')

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        //compute color variable statistics
        const statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   color stats computation')

        if (!statColor) return

        //create canvas and webgl renderer
        //for opacity control, see: https://webglfundamentals.org/webgl/lessons/webgl-and-alpha.html
        const cvWGL = (0,_utils_webGLUtils_js__WEBPACK_IMPORTED_MODULE_1__.makeWebGLCanvas)(
            cg.w + '',
            cg.h + '',
            this.opacity != undefined ? { premultipliedAlpha: false } : undefined
        )
        if (!cvWGL) {
            console.error('No webGL')
            return
        }
        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   web GL canvas creation')

        //add vertice and fragment data
        const r2 = r / 2
        const verticesBuffer = []
        const tBuffer = []
        for (let c of cells) {
            const t = this.tFun(c[this.colorCol], r, statColor)
            if (t == null || t == undefined) continue
            verticesBuffer.push(c.x + r2, c.y + r2)
            tBuffer.push(t > 1 ? 1 : t < 0 ? 0 : t)
        }

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   webgl drawing data preparation')

        //compute pixel size
        const sizeGeo = this.size ? this.size(r, zf) : r + 0.2 * zf

        //compute opacity
        const op = this.opacity ? this.opacity(r, zf) : undefined

        //
        const wgp = new _utils_WebGLSquareColoringAdvanced_js__WEBPACK_IMPORTED_MODULE_2__.WebGLSquareColoringAdvanced(cvWGL.gl, this.colors, this.stretching, sizeGeo / zf, op)

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   webgl program preparation')

        //draw
        wgp.draw(verticesBuffer, tBuffer, cg.getWebGLTransform())

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   webgl drawing')

        //draw in canvas geo
        cg.initCanvasTransform()
        cg.ctx.drawImage(cvWGL.canvas, 0, 0)

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('   canvas drawing')

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sColor: statColor })

        if (_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitor) (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_3__.monitorDuration)('*** SquareColorWGLStyle end draw')
    }
}


/***/ }),

/***/ "./src/style/StrokeStyle.js":
/*!**********************************!*\
  !*** ./src/style/StrokeStyle.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StrokeStyle": () => (/* binding */ StrokeStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
//@ts-check


;

/**
 *
 * @author Julien Gaffuri
 */
class StrokeStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for color.
         * @type {string} */
        this.strokeColorCol = opts.strokeColorCol

        /** A function returning the color of the stroke.
         * @type {function(number,number,import("../Style").Stat|undefined):string} */
        this.strokeColor = opts.strokeColor || (() => '#666')

        /** The name of the column/attribute of the tabular data where to retrieve the variable for size.
         * @type {string} */
        this.sizeCol = opts.sizeCol

        /** A function returning the size of a cell in geographical unit.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.size = opts.size

        /** The stroke line width, in pixels.
         * @type {string} */
        this.strokeWidthCol = opts.strokeWidthCol

        /** The stroke line width in geographical unit.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.strokeWidth = opts.strokeWidth // (v,r,s,z)=>...

        /** A function returning the shape of a cell.
         * @type {function(import("../Dataset").Cell):import("../Style").Shape} */
        this.shape = opts.shape || (() => 'square')
    }

    /**
     * Draw cells as squares, with various colors and size.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statColor
        if (this.strokeColorCol) statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.strokeColorCol], true)

        let statSize
        if (this.sizeCol) statSize = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.sizeCol], true)

        let statWidth
        if (this.strokeWidthCol) statWidth = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.strokeWidthCol], true)

        //draw with HTML canvas
        //in geo coordinates
        cg.setCanvasTransform()

        const r2 = r * 0.5
        for (let cell of cells) {
            //color
            const col = this.strokeColor
                ? this.strokeColor(cell[this.strokeColorCol], r, statColor)
                : undefined
            if (!col || col === 'none') continue
            cg.ctx.strokeStyle = col

            //size
            /** @type {function(number,number,import("../Style").Stat|undefined,number):number} */
            let s_ = this.size || (() => r)
            //size - in geo unit
            const sG = s_(cell[this.sizeCol], r, statSize, zf)

            //width
            const wi = this.strokeWidth
                ? this.strokeWidth(cell[this.strokeWidthCol], r, statWidth, zf)
                : 1 * zf
            if (!wi || wi <= 0) continue
            cg.ctx.lineWidth = wi

            //shape
            const shape = this.shape ? this.shape(cell) : 'square'
            if (shape === 'none') continue

            //get offset
            const offset = this.offset(cell, r, zf)

            if (shape === 'square') {
                //draw square
                const d = r * (1 - sG / r) * 0.5
                cg.ctx.beginPath()
                cg.ctx.rect(cell.x + d + offset.dx, cell.y + d + offset.dy, sG, sG)
                cg.ctx.stroke()
            } else if (shape === 'circle') {
                //draw circle
                cg.ctx.beginPath()
                cg.ctx.arc(cell.x + r2 + offset.dx, cell.y + r2 + offset.dy, sG * 0.5, 0, 2 * Math.PI, false)
                cg.ctx.stroke()
            } else if (shape === 'diamond') {
                const s2 = sG * 0.5
                cg.ctx.beginPath()
                cg.ctx.moveTo(cell.x + r2 - s2, cell.y + r2)
                cg.ctx.lineTo(cell.x + r2, cell.y + r2 + s2)
                cg.ctx.lineTo(cell.x + r2 + s2, cell.y + r2)
                cg.ctx.lineTo(cell.x + r2, cell.y + r2 - s2)
                cg.ctx.lineTo(cell.x + r2 - s2, cell.y + r2)
                cg.ctx.stroke()
            } else if (shape === 'donut') {
                console.error('Not implemented')
            } else {
                throw new Error('Unexpected shape:' + shape)
            }
        }

        //update legends
        //this.updateLegends({ style: this, r: resolution, zf: zf, sSize: statSize, sColor: statColor });
    }
}


/***/ }),

/***/ "./src/style/TanakaStyle.js":
/*!**********************************!*\
  !*** ./src/style/TanakaStyle.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TanakaStyle": () => (/* binding */ TanakaStyle)
/* harmony export */ });
/* harmony import */ var _SquareColorWGLStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SquareColorWGLStyle.js */ "./src/style/SquareColorWGLStyle.js");
/* harmony import */ var _SideStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SideStyle.js */ "./src/style/SideStyle.js");
//@ts-check


;


/**
 *
 * @see https://manifold.net/doc/mfd9/example__tanaka_contours.htm
 *
 * @author Julien Gaffuri
 */
class TanakaStyle {
    /**
     * @param {string} col
     * @param {object} opts
     * @returns {Array.<import("../Style").Style>}
     */
    static get(col, opts) {
        opts = opts || {}

        //get colors from d3 ramps, if 'nb' is specified
        if (opts.nb != undefined) {
            if (opts.nb < 2) {
                console.error('unexpected number of colors in tanaka (<2): ' + opts.nb)
                opts.nb = 2
            }
            if (!opts.color) {
                console.error('color function not defined in tanaka')
                opts.color = () => 'gray'
            }
            opts.colors = []
            for (let i = 0; i < opts.nb; i++) opts.colors.push(opts.color(i / (opts.nb - 1)))
        }

        /**
         * The colors.
         * @type {Array.<string>} */
        opts.colors = opts.colors || ['#a9bb9e', '#c9dcaa', '#fde89f', '#f9a579', '#eb444b']
        const nb = opts.colors.length

        /** A function to compute 't' from the value v
         * @type {function(number,number,import("../Style").Stat):number} */
        opts.tFun = opts.tFun || ((v, r, s) => (v - s.min) / (s.max - s.min))

        //shadow colors
        opts.colDark = opts.colDark || '#111'
        opts.colBright = opts.colBright || '#ddd'

        //width of the segment (share of the resolution)
        opts.widthFactor = opts.widthFactor || 0.08

        //shading
        opts.newShading = opts.newShading
        opts.newShadingWidthPix = opts.newShadingWidthPix || 2
        //transparency value, within [0,1]
        opts.newShadingTr =
            opts.newShadingTr ||
            ((sideValue, sideStat) =>
                Math.abs(sideValue) / Math.max(Math.abs(sideStat.min), Math.abs(sideStat.max)))

        /**
         * @param {number} t A cell t value, within [0,1].
         * @returns the class number for the value
         */
        const getClass = (t) => {
            if (isNaN(t) || t == undefined) {
                console.error('Unexpected t value 1: ' + t)
                return -9
            }
            for (let i = 0; i < nb; i++) if (t <= (i + 1) / nb) return i
            console.error('Unexpected t value 2: ' + t)
            return -9
        }

        const colStyle = new _SquareColorWGLStyle_js__WEBPACK_IMPORTED_MODULE_0__.SquareColorWGLStyle({
            colorCol: col,
            colors: opts.colors,
            tFun: (v, r, s) => {
                const t = opts.tFun(v, r, s)
                const c = getClass(t)
                return c / (nb - 1)
            },
            //stretching: { fun: "expRev", alpha: -7 },
            size: (r, zf) => r + 0.5 * zf, //that is to ensure no gap between same class cells is visible
            filter: opts.filter,
        })

        /*
        if no web gl:    
            const colStyle = new ShapeColorSizeStyle({
                colorCol: col,
                //the color corresponding to the class
                color: (v, r, s, zf) => {
                    if (v == 0 && opts.tFun && isNaN(opts.tFun(v, r, s)))
                        return undefined
                    return opts.colors[getClass(opts.tFun ? opts.tFun(v, r, s) : v)]
                },
                shape: () => "square",
                size: (v, r, s, zf) => r + 0.5 * zf, //that is to ensure no gap between same class cells is visible
            })
        */

        /** The side style, for the shadow effect */
        const sideStyle = new _SideStyle_js__WEBPACK_IMPORTED_MODULE_1__.SideStyle({
            valueCol: col,
            value: (v1, v2, r, s, zf) => {
                //compute the number of classes of difference
                if (v1 === undefined && v2 === undefined) return 0
                else if (v2 === undefined) {
                    const t = opts.tFun(v1, r, s)
                    if (t == undefined || isNaN(t)) throw new Error('Unexpected value: ' + v1 + ' - ' + t)
                    const c = getClass(t)
                    return c + 1
                } else if (v1 === undefined) {
                    const t = opts.tFun(v2, r, s)
                    if (t == undefined || isNaN(t)) throw new Error('Unexpected value: ' + v2 + ' - ' + t)
                    const c = getClass(t)
                    return -c - 1
                }
                const t1 = opts.tFun(v1, r, s)
                if (t1 == undefined || isNaN(t1)) throw new Error('Unexpected value: ' + v1 + ' - ' + t1)
                const t2 = opts.tFun(v2, r, s)
                if (t2 == undefined || isNaN(t2)) throw new Error('Unexpected value: ' + v2 + ' - ' + t2)
                const c1 = getClass(t1)
                const c2 = getClass(t2)
                return -c2 + c1
            },

            color: opts.newShading
                ? //black with transparency depending on difference
                  (side, r, s, z) => {
                      const tr = opts.newShadingTr(side.value, s)
                      return (side.value > 0 && side.or === 'h') || (side.value < 0 && side.or === 'v')
                          ? 'rgba(255,255,100,' + tr + ')'
                          : 'rgba(0,0,0,' + tr + ')'
                  }
                : //white or black, depending on orientation and value
                  (side, r, s, z) => {
                      if (side.value === 0) return
                      //return "gray"
                      if (side.or === 'v') return side.value < 0 ? opts.colBright : opts.colDark
                      return side.value < 0 ? opts.colDark : opts.colBright
                  },

            width: opts.newShading
                ? //fill size
                  (side, r, s, z) => {
                      return opts.newShadingWidthPix * z
                  }
                : //width depends on the value, that is the number of classes of difference
                  (side, r, s, z) =>
                      opts.widthFactor * r * Math.abs(side.value) * (side.or === 'v' ? 0.5 : 1),

            filter: opts.filter,
        })

        return [colStyle, sideStyle]
    }
}


/***/ }),

/***/ "./src/style/TextStyle.js":
/*!********************************!*\
  !*** ./src/style/TextStyle.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextStyle": () => (/* binding */ TextStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
//@ts-check


;

/**
 *
 * @author Julien Gaffuri
 */
class TextStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The name of the column/attribute of the tabular data where to retrieve the variable for text.
         * @type {string} */
        this.textCol = opts.textCol

        /** A function returning the text of a cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):string} */
        this.text = opts.text || ((v, r, s, z) => 'X')

        /** The name of the column/attribute of the tabular data where to retrieve the variable for color.
         * @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the cell.
         * @type {function(number,number,import("../Style").Stat|undefined,number):string} */
        this.color = opts.color || (() => '#EA6BAC')

        /** The name of the column/attribute of the tabular data where to retrieve the variable for font size.
         * @type {string} */
        this.fontSizeCol = opts.fontSizeCol

        /** A function returning the font size of a cell in geo unit.
         * @type {function(number,number,import("../Style").Stat|undefined,number):number} */
        this.fontSize = opts.fontSize || ((v, r, s, z) => r * 0.8)

        /** The text font family.
         * @type {string} */
        this.fontFamily = opts.fontFamily || 'Arial'

        /** The text font weight.
         * @type {string} */
        this.fontWeight = opts.fontWeight || 'bold'
    }

    /**
     * Draw cells as text.
     *
     * @param {Array.<import("../Dataset").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas").GeoCanvas} cg
     */
    draw(cells, r, cg) {
        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statText
        if (this.textCol) {
            //compute text variable statistics
            statText = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.textCol], true)
        }

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        let statFontSize
        if (this.fontSizeCol) {
            //if size is used, sort cells by size so that the biggest are drawn first
            cells.sort((c1, c2) => c2[this.fontSizeCol] - c1[this.fontSizeCol])
            //and compute size variable statistics
            statFontSize = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.fontSizeCol], true)
        }

        //draw with HTML canvas
        //in screen coordinates
        cg.initCanvasTransform()

        for (let cell of cells) {
            //get cell text
            const text = this.text ? this.text(cell[this.textCol], r, statText, zf) : undefined
            if (text == undefined || text == null || text + '' === '') continue

            //color
            const col = this.color ? this.color(cell[this.colorCol], r, statColor, zf) : undefined
            if (!col) continue
            cg.ctx.fillStyle = col

            //font size
            //size - in pixel unit
            const fontSizePix = this.fontSize(cell[this.fontSizeCol], r, statFontSize, zf) / zf

            //set font
            const fontFamily = this.fontFamily || 'Arial'
            const fontWeight = this.fontWeight || 'bold'
            cg.ctx.font = fontWeight + ' ' + fontSizePix + 'px ' + fontFamily

            //get offset
            const offset = this.offset(cell, r, zf)

            //text position
            cg.ctx.textAlign = 'center'
            const tx = cg.geoToPixX(cell.x + r * 0.5 + offset.dx)
            const ty = cg.geoToPixY(cell.y + r * 0.5 + offset.dy) + fontSizePix * 0.3 //it should be 0.5 but 0.3 seems to work better

            //draw the text
            cg.ctx.fillText(text, tx, ty)
        }

        //update legends
        this.updateLegends({ style: this, r: r, zf: zf, sColor: statColor })
    }

    /**
     * Build a function [0,1]->string for characters legend
     *
     * @param {Array.<string>} chars
     * @returns {function(number):string}
     */
    static getCharLegendFun(chars) {
        const nb = chars.length
        return (t) => (t == 0 ? '' : t == 1 ? chars[nb - 1] : chars[Math.floor(t * nb)])
    }
}


/***/ }),

/***/ "./src/style/TimeSeriesStyle.js":
/*!**************************************!*\
  !*** ./src/style/TimeSeriesStyle.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TimeSeriesStyle": () => (/* binding */ TimeSeriesStyle)
/* harmony export */ });
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Style.js */ "./src/Style.js");
//@ts-check


;

/** @typedef {"first"|"bottom"|"center"|"top"|"last"} AnchorModeYEnum */

/**
 * Show cell as timeseries chart
 * Can be used for sparkline map of https://datagistips.hypotheses.org/488
 *
 * @author Julien Gaffuri
 */
class TimeSeriesStyle extends _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style {
    /** @param {object} opts */
    constructor(opts) {
        super(opts)
        opts = opts || {}

        /** The columns of the time series, ordered in chronological order.
         * @type {Array.<string>} */
        this.ts = opts.ts

        /** A function specifying when a value should be considered as "no data" and thus not ignored. The line will have a break at these values.
         * @type {function(string):boolean} */
        this.noData = opts.noData || ((v) => v === undefined || v == "" || v === null || isNaN(+v))

        //x
        /** in geo unit
         * @type {function(import("../Dataset.js").Cell,number,number):number} */
        this.offsetX = opts.offsetX || ((c, r, zf) => 0)
        /** @type {function(import("../Dataset.js").Cell,number,number):number} */
        this.width = opts.width || ((c, r, zf) => r)

        //y
        /** in geo unit
         * @type {function(import("../Dataset.js").Cell,number,number):number} */
        this.offsetY = opts.offsetY || ((c, r, zf) => 0)
        /** @type {function(import("../Dataset.js").Cell,number,number):number} */
        this.height = opts.height || ((c, r, zf) => r)
        /** @type {function(import("../Dataset.js").Cell,number,number):AnchorModeYEnum} */
        this.anchorModeY = opts.anchorModeY || ((c, r, zf) => "center")


        /**
         * @type {string} */
        this.lineWidthCol = opts.lineWidthCol

        /** A function returning the width of the line, in geo unit
         * @type {function(number,number,import("../Style.js").Stat|undefined,number):number} */
        this.lineWidth = opts.lineWidth || ((v, r, s, zf) => 1.5 * zf)

        /**
         * @type {string} */
        this.colorCol = opts.colorCol

        /** A function returning the color of the cell.
         * @type {function(number,number,import("../Style.js").Stat|undefined,number):string} */
        this.color = opts.color || ((v, r, s, zf) => 'black')

    }

    /**
     * Draw cells as text.
     *
     * @param {Array.<import("../Dataset.js").Cell>} cells
     * @param {number} r
     * @param {import("../GeoCanvas.js").GeoCanvas} cg
     */
    draw(cells, r, cg) {

        //filter
        if (this.filter) cells = cells.filter(this.filter)

        //zoom factor
        const zf = cg.getZf()

        let statWidth
        if (this.lineWidthCol) {
            //and compute size variable statistics
            statWidth = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.lineWidthCol], true)
        }

        let statColor
        if (this.colorCol) {
            //compute color variable statistics
            statColor = _Style_js__WEBPACK_IMPORTED_MODULE_0__.Style.getStatistics(cells, (c) => c[this.colorCol], true)
        }

        //compute cell amplitude
        const getAmplitude = c => {
            let min, max
            for (let t of this.ts) {
                const val = c[t];
                if (val == undefined) continue
                if (min == undefined || val < min) min = val
                if (max == undefined || val > max) max = val
            }
            if (min == undefined) return undefined
            return max - min
        }

        //compute max amplitude
        let ampMax
        for (let c of cells) {
            const amp = getAmplitude(c)
            if (amp == undefined) continue
            if (ampMax == undefined || amp > ampMax) ampMax = amp
        }
        if (!ampMax) return

        const nb = this.ts.length

        //draw with HTML canvas
        //in geo coordinates
        cg.setCanvasTransform()

        cg.ctx.lineCap = "butt"
        for (let c of cells) {

            //line width
            /** @type {number|undefined} */
            const wG = this.lineWidth ? this.lineWidth(c[this.lineWidthCol], r, statWidth, zf) : undefined
            if (!wG || wG < 0) continue

            //line color
            /** @type {string|undefined} */
            const col = this.color ? this.color(c[this.colorCol], r, statColor, zf) : undefined
            if (!col) continue


            //x
            const offX = this.offsetX ? this.offsetX(c, r, zf) : 0
            if (offX == undefined || isNaN(offX)) continue
            const w = this.width ? this.width(c, r, zf) : r
            if (w == undefined || isNaN(w)) continue

            //y
            const offY = this.offsetY ? this.offsetY(c, r, zf) : 0
            if (offY == undefined || isNaN(offY)) continue
            const h = this.height ? this.height(c, r, zf) : r
            if (h == undefined || isNaN(h)) continue
            const anchY = this.anchorModeY ? this.anchorModeY(c, r, zf) : "center"
            if (!anchY) continue

            cg.ctx.lineWidth = wG
            cg.ctx.strokeStyle = col

            //compute anchor Y figures
            let val0, y0
            if (anchY === "first") {
                //get first value
                val0 = c[this.ts[0]]
                y0 = 0
            } else if (anchY === "last") {
                //get last value
                val0 = c[this.ts[this.ts.length - 1]]
                y0 = 0
            } else if (anchY === "bottom") {
                //get min
                for (let t of this.ts) {
                    const val = +c[t];
                    if (val == undefined) continue
                    if (val0 == undefined || val < val0) val0 = val
                }
                y0 = 0
            } else if (anchY === "top") {
                //get max
                for (let t of this.ts) {
                    const val = +c[t];
                    if (val == undefined) continue
                    if (val0 == undefined || val > val0) val0 = val
                }
                y0 = r
            } else if (anchY === "center") {
                //get min and max
                let min, max
                for (let t of this.ts) {
                    const val = c[t];
                    if (val == undefined) continue
                    if (min == undefined || val < min) min = val
                    if (max == undefined || val > max) max = val
                }
                val0 = (+max + +min) * 0.5
                y0 = r / 2
            } else {
                console.log("Unexpected anchorModeY: " + anchY)
                continue;
            }

            /*/draw line
            if (val0 == undefined || isNaN(val0)) continue
            cg.ctx.beginPath()
            const sX = w / (nb - 1)
            for (let i = 0; i < nb; i++) {
                const val = c[this.ts[i]]
                if (val == undefined || isNaN(val)) break
                if (i == 0)
                    cg.ctx.moveTo(c.x + i * sX + offX, c.y + y0 + (val - val0) * h / ampMax + offY)
                else
                    cg.ctx.lineTo(c.x + i * sX + offX, c.y + y0 + (val - val0) * h / ampMax + offY)
            }
            cg.ctx.stroke()*/


            //draw line, segment by segment
            const sX = w / (nb - 1)

            //handle first point
            let v0 = c[this.ts[0]]
            if (!this.noData(v0)) {
                cg.ctx.beginPath()
                cg.ctx.moveTo(c.x + offX, c.y + y0 + (v0 - val0) * h / ampMax + offY)
            }
            //console.log(v0, isNaN(v0))

            let v1
            for (let i = 1; i < nb; i++) {
                v1 = c[this.ts[i]]

                //draw segment from v0 to v1

                //both points 'no data'
                if (this.noData(v0) && this.noData(v1)) {

                    //second point 'no data'
                } else if (!this.noData(v0) && this.noData(v1)) {
                    cg.ctx.stroke()

                    //first point 'no data'
                } else if (this.noData(v0) && !this.noData(v1)) {
                    cg.ctx.beginPath()
                    cg.ctx.moveTo(c.x + i * sX + offX, c.y + y0 + (v1 - val0) * h / ampMax + offY)

                    //both points have data: trace line
                } else {
                    cg.ctx.lineTo(c.x + i * sX + offX, c.y + y0 + (v1 - val0) * h / ampMax + offY)
                    //if it is the last point, stroke
                    if (i == nb - 1) cg.ctx.stroke()
                }
                v0 = v1
            }

        }

        //update legend, if any
        this.updateLegends({
            widthFun: this.lineWidth,
            r: r,
            zf: zf,
            sColor: statColor,
            //sLength: statLength,
            sWidth: statWidth,
        })

    }

}



/***/ }),

/***/ "./src/utils/Utils.js":
/*!****************************!*\
  !*** ./src/utils/Utils.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getClass": () => (/* binding */ getClass),
/* harmony export */   "monitor": () => (/* binding */ monitor),
/* harmony export */   "monitorDuration": () => (/* binding */ monitorDuration)
/* harmony export */ });
//@ts-check


/**
 * Get the class id from a value and class break values
 *
 * @param {number} v the value
 * @param {Array.<number>} breaks the breaks
 * @returns The class id, from 0 to breaks.length
 */
function getClass(v, breaks) {
    if (!breaks) return
    if (breaks.length == 0) return 0
    if (v <= breaks[0]) return 0
    for (let i = 1; i < breaks.length; i++) if (breaks[i - 1] < v && v <= breaks[i]) return i
    return breaks.length
}

let monitor = false

let previousDate
function monitorDuration(message) {
    const nowDate = Date.now()

    //first call
    if (!previousDate) {
        previousDate = nowDate
        console.log(previousDate, message)
        return
    }

    const d = nowDate - previousDate
    previousDate = nowDate
    console.log(d, message)
}


/***/ }),

/***/ "./src/utils/WebGLSquareColoring.js":
/*!******************************************!*\
  !*** ./src/utils/WebGLSquareColoring.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebGLSquareColoring": () => (/* binding */ WebGLSquareColoring)
/* harmony export */ });
/* harmony import */ var _webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webGLUtils.js */ "./src/utils/webGLUtils.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * Everything to easily draw colored squares with webGL.
 * All the same size, but different fill color.
 */
class WebGLSquareColoring {
    /**
     *
     * @param {WebGLRenderingContext} gl
     */
    constructor(gl, sizePix) {
        this.gl = gl
        this.sizePix = sizePix || 10.0

        this.program = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.initShaderProgram)(
            gl,
            (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(
                gl,
                gl.VERTEX_SHADER,
                `
            attribute vec2 pos;
            uniform float sizePix;
            uniform mat3 mat;
            attribute vec4 color;
            varying vec4 vColor;
            void main() {
              gl_Position = vec4(mat * vec3(pos, 1.0), 1.0);
              gl_PointSize = sizePix;
              vColor = color;
            }
          `
            ),
            (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(
                gl,
                gl.FRAGMENT_SHADER,
                `
            precision mediump float;
            varying vec4 vColor;
            void main(void) {
                vec4 vColor_ = vColor / 255.0;
                vColor_[3] = 255.0 * vColor_[3];
                gl_FragColor = vColor_;
            }`
            )
        )
        gl.useProgram(this.program)

        //buffer data
        this.verticesBuffer = []
        this.colorsBuffer = []
    }

    /** Add data to vertices/size/color buffers for color squares drawing */
    addPointData(xC, yC, col) {
        //convert color
        const cc = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(col)
        //const cc = {r:45,g:87,b:98,opacity:0.9}
        if (!cc) return

        //vertices
        this.verticesBuffer.push(xC, yC)
        //color
        this.colorsBuffer.push(cc.r, cc.g, cc.b, cc.opacity)
    }

    addPointData2(xC, yC, r, g, b, opacity) {
        //vertices
        this.verticesBuffer.push(xC, yC)
        //color
        this.colorsBuffer.push(r, g, b, opacity)
    }

    /**  */
    draw(transfoMat) {
        const gl = this.gl

        //vertice data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesBuffer), gl.STATIC_DRAW)
        const position = gl.getAttribLocation(this.program, 'pos')
        gl.vertexAttribPointer(
            position,
            2, //numComponents
            gl.FLOAT, //type
            false, //normalise
            0, //stride
            0 //offset
        )
        gl.enableVertexAttribArray(position)

        //color data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.colorsBuffer), gl.STATIC_DRAW)
        var color = gl.getAttribLocation(this.program, 'color')
        gl.vertexAttribPointer(color, 4, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(color)

        //sizePix
        gl.uniform1f(gl.getUniformLocation(this.program, 'sizePix'), 1.0 * this.sizePix)

        //transformation
        gl.uniformMatrix3fv(gl.getUniformLocation(this.program, 'mat'), false, new Float32Array(transfoMat))

        // Enable the depth test
        //gl.enable(gl.DEPTH_TEST);
        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT)
        // Set the view port
        //gl.viewport(0, 0, cg.w, cg.h);

        gl.drawArrays(gl.POINTS, 0, this.verticesBuffer.length / 2)
    }
}


/***/ }),

/***/ "./src/utils/WebGLSquareColoringAdvanced.js":
/*!**************************************************!*\
  !*** ./src/utils/WebGLSquareColoringAdvanced.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebGLSquareColoringAdvanced": () => (/* binding */ WebGLSquareColoringAdvanced)
/* harmony export */ });
/* harmony import */ var _webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webGLUtils.js */ "./src/utils/webGLUtils.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * Everything to easily draw colored squares with webGL.
 * All the same size, but different fill color.
 * The color interpolation is computed in the fragment shader program, by the GPU, thus it is less flexible but faster.
 */
class WebGLSquareColoringAdvanced {
    //see:
    //https://webglfundamentals.org/webgl/lessons/fr/webgl-shaders-and-glsl.html#les-uniforms-dans-les-shaders-de-vertex
    //https://thebookofshaders.com/glossary/?search=mix
    //https://thebookofshaders.com/06/
    //https://thebookofshaders.com/glossary/

    /**
     *
     * @param {*} gl
     * @param {Array.<String>} colors
     * @param {{fun:string,alpha:number}} stretching
     * @param {number} sizePix
     * @param {number|undefined} globalOpacity
     */
    constructor(gl, colors, stretching, sizePix = 10, globalOpacity = undefined) {
        /** @type {WebGLRenderingContext} */
        this.gl = gl
        //gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        /** @type {WebGLShader} */
        const vShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(
            gl,
            gl.VERTEX_SHADER,
            `
        attribute vec2 pos;
        uniform float sizePix;
        uniform mat3 mat;

        attribute float t;
        varying float vt;

        void main() {
          gl_Position = vec4(mat * vec3(pos, 1.0), 1.0);
          gl_PointSize = sizePix;
          vt = t;
        }
      `
        )

        //prepare fragment shader code
        //declare the uniform and other variables
        let fshString =
            '' +
            'precision mediump float;\n' +
            'varying float vt;\n' +
            'uniform float alpha;\n' +
            (() => {
                const out = []
                for (let i = 0; i < colors.length; i++) out.push('uniform vec4 c' + i + ';\n')
                return out.join('')
            })() +
            //start the main function, apply the stretching of t
            'void main(void) {\n'

        if (stretching) {
            if (stretching.fun == 'pow')
                //sPow = (t, alpha = 3) => Math.pow(t, alpha);
                fshString += '   float t = pow(vt, alpha);\n'
            else if (stretching.fun == 'powRev')
                //sPowRev = (t, alpha = 3) => 1 - Math.pow(1 - t, 1 / alpha);
                fshString += '   float t = 1.0-pow(1.0-vt, 1.0/alpha);\n'
            else if (stretching.fun == 'exp')
                //sExp = (t, alpha = 3) => alpha == 0 ? t : (Math.exp(t * alpha) - 1) / (Math.exp(alpha) - 1);
                fshString +=
                    stretching.alpha == 0
                        ? `float t = vt;`
                        : '   float t = (exp(vt * alpha) - 1.0) / (exp(alpha) - 1.0);\n'
            else if (stretching.fun == 'expRev')
                //sExpRev = (t, alpha = 3) => alpha == 0 ? t : 1 - (1 / alpha) * Math.log(Math.exp(alpha) * (1 - t) + t);
                fshString +=
                    stretching.alpha == 0
                        ? `float t = vt;`
                        : '   float t = 1.0 - (1.0 / alpha) * log(exp(alpha) * (1.0 - vt) + vt);\n'
            else if (stretching.fun == 'circleLow') {
                if (stretching.alpha == 0)
                    //if (alpha == 0) return t;
                    fshString += '   float t = vt;\n'
                else if (stretching.alpha == 1)
                    // if (alpha == 1) return Math.sqrt(2 * t - t * t);
                    fshString += '   float t = sqrt(vt * (2.0 - vt));\n'
                else {
                    //const a = alpha / (1 - alpha);
                    //return Math.sqrt(1 / (a * a) + t * (2 / a + 2 - t)) - 1 / a;
                    fshString +=
                        '   float a = alpha / (1.0 - alpha);\n' +
                        '   float t = sqrt(1.0 / (a * a) + vt * ( 2.0/a + 2.0 - vt )) - 1.0 / a;\n'
                }
            } else if (stretching.fun == 'circleHigh') {
                // 1 - sCircleLow(1 - t, alpha)
                if (stretching.alpha == 0)
                    //if (alpha == 0) return t;
                    fshString += '   float t = vt;\n'
                else if (stretching.alpha == 1)
                    // if (alpha == 1) return Math.sqrt(2 * t - t * t);
                    fshString += '   float t = 1.0 - sqrt((1.0 - vt) * (1.0 + vt));\n'
                else {
                    //const a = alpha / (1 - alpha);
                    //return Math.sqrt(1 / (a * a) + (2 * t) / a + 2 * t - t * t) - 1 / a;
                    fshString +=
                        '   float a = alpha / (1.0 - alpha);\n' +
                        '   float t = 1.0 - sqrt(1.0 / (a * a) + (1.0-vt) * ( 2.0/a + 1.0 + vt )) + 1.0 / a;\n'
                }
            } else {
                console.error('Unexpected stretching function code: ' + stretching.fun)
                fshString += '   float t = vt;\n'
            }
        } else {
            fshString += '   float t = vt;\n'
        }

        //choose initial and final colors, and adjust t value
        if (colors.length == 1) fshString += '   vec4 cI=c0;\n   vec4 cF=c0;\n'
        else if (colors.length == 2) fshString += '   vec4 cI=c0;\n   vec4 cF=c1;\n'
        else {
            const nb = colors.length - 1
            const nbs = nb + '.0'
            fshString += '   vec4 cI;\n'
            fshString += '   vec4 cF;\n'
            fshString += '   if(t<1.0/' + nbs + ') { cI=c0; cF=c1; t=t*' + nbs + '; }\n'
            for (let i = 2; i < nb; i++)
                fshString +=
                    '   else if(t<' +
                    i +
                    '.0/' +
                    nbs +
                    ') { cI=c' +
                    (i - 1) +
                    '; cF=c' +
                    i +
                    '; t=' +
                    nbs +
                    '*t-' +
                    (i - 1) +
                    '.0; }\n'
            fshString +=
                '   else { cI=c' + (nb - 1) + '; cF=c' + nb + '; t=' + nbs + '*t-' + (nb - 1) + '.0; }\n'
        }

        //one single color
        if (colors.length == 1) fshString += '   gl_FragColor = vec4(c0[0], c0[1], c0[2], c0[3]);}\n'
        //set interpolated color, between initial and final one
        else fshString += '   gl_FragColor = mix(cI, cF, t);}\n'

        //console.log(fshString)

        /** @type {WebGLShader} */
        const fShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(gl, gl.FRAGMENT_SHADER, fshString)

        /** @type {WebGLProgram} */
        this.program = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.initShaderProgram)(gl, vShader, fShader)
        gl.useProgram(this.program)

        //set uniforms

        //sizePix
        //TODO: bug here. Seems to be limited to some threshold value (around 250).
        gl.uniform1f(gl.getUniformLocation(this.program, 'sizePix'), 1.0 * sizePix)

        //stretching alpha factor
        gl.uniform1f(gl.getUniformLocation(this.program, 'alpha'), stretching ? 1.0 * stretching.alpha : 0.0)

        //colors
        for (let i = 0; i < colors.length; i++) {
            const c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(colors[i])

            let opacity = c.opacity
            if (c.opacity == 1 && globalOpacity != undefined) opacity = globalOpacity

            gl.uniform4fv(gl.getUniformLocation(this.program, 'c' + i), [
                +c.r / 255.0,
                +c.g / 255.0,
                +c.b / 255.0,
                +opacity,
            ])
        }
    }

    /**  */
    draw(verticesBuffer, tBuffer, transfoMat) {
        const gl = this.gl
        const program = this.program

        //vertice data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesBuffer), gl.STATIC_DRAW)
        const position = gl.getAttribLocation(program, 'pos')
        gl.vertexAttribPointer(
            position,
            2, //numComponents
            gl.FLOAT, //type
            false, //normalise
            0, //stride
            0 //offset
        )
        gl.enableVertexAttribArray(position)

        //t data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tBuffer), gl.STATIC_DRAW)
        const t = gl.getAttribLocation(program, 't')
        gl.vertexAttribPointer(t, 1, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(t)

        //transformation
        gl.uniformMatrix3fv(gl.getUniformLocation(program, 'mat'), false, new Float32Array(transfoMat))

        // Enable the depth test
        //gl.enable(gl.DEPTH_TEST);
        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT)
        // Set the view port
        //gl.viewport(0, 0, cg.w, cg.h);

        gl.drawArrays(gl.POINTS, 0, verticesBuffer.length / 2)
    }
}


/***/ }),

/***/ "./src/utils/WebGLSquareColoringCatAdvanced.js":
/*!*****************************************************!*\
  !*** ./src/utils/WebGLSquareColoringCatAdvanced.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebGLSquareColoringCatAdvanced": () => (/* binding */ WebGLSquareColoringCatAdvanced)
/* harmony export */ });
/* harmony import */ var _webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webGLUtils.js */ "./src/utils/webGLUtils.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
//@ts-check


;


/**
 * Everything to easily draw colored squares with webGL.
 * All the same size, but different fill color.
 * Color based on categories.
 */
class WebGLSquareColoringCatAdvanced {
    /**
     * @param {Array.<string>} colors
     */
    constructor(colors) {
        /**
         * @type {Array.<string>} */
        this.colors = colors

        /** Vector shader program
         * @type {string} */
        this.vshString = `
        attribute vec2 pos;
        uniform float sizePix;
        uniform mat3 mat;

        attribute float i;
        varying float vi;

        void main() {
          gl_Position = vec4(mat * vec3(pos, 1.0), 1.0);
          gl_PointSize = sizePix;
          vi = i;
        }
        `

        //prepare fragment shader code
        //declare the uniform and other variables
        const out = []
        out.push('precision mediump float;\nvarying float vi;\n')
        //add color uniforms
        out.push('uniform vec4')
        for (let i = 0; i < colors.length; i++) {
            if (i > 0) out.push(',')
            out.push(' c' + i)
        }
        out.push(';\n')
        //start the main function
        out.push('void main(void) {\n')
        //choose color i
        for (let i = 0; i < colors.length; i++) {
            if (i > 0) out.push('else ')
            out.push('if(vi==')
            out.push(i)
            out.push('.0) gl_FragColor = vec4(c')
            out.push(i)
            out.push('[0], c')
            out.push(i)
            out.push('[1], c')
            out.push(i)
            out.push('[2], c')
            out.push(i)
            out.push('[3]);\n')
        }
        out.push('else gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}')
        /** Fragment shader program
         * @type {string} */
        this.fshString = out.join('')
    }

    /**  */
    draw(gl, verticesBuffer, iBuffer, transfoMat, sizePix = 10) {
        /** @type {WebGLShader} */
        const vShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(gl, gl.VERTEX_SHADER, this.vshString)

        /** @type {WebGLShader} */
        const fShader = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.createShader)(gl, gl.FRAGMENT_SHADER, this.fshString)

        /** @type {WebGLProgram} */
        const program = (0,_webGLUtils_js__WEBPACK_IMPORTED_MODULE_0__.initShaderProgram)(gl, vShader, fShader)
        gl.useProgram(program)

        //set uniforms

        //sizePix
        gl.uniform1f(gl.getUniformLocation(program, 'sizePix'), 1.0 * sizePix)

        //colors
        for (let i = 0; i < this.colors.length; i++) {
            const c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(this.colors[i])
            gl.uniform4fv(gl.getUniformLocation(program, 'c' + i), [
                +c.r / 255.0,
                +c.g / 255.0,
                +c.b / 255.0,
                +c.opacity,
            ])
        }

        //vertice data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesBuffer), gl.STATIC_DRAW)
        const position = gl.getAttribLocation(program, 'pos')
        gl.vertexAttribPointer(
            position,
            2, //numComponents
            gl.FLOAT, //type
            false, //normalise
            0, //stride
            0 //offset
        )
        gl.enableVertexAttribArray(position)

        //i data
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(iBuffer), gl.STATIC_DRAW)
        const i = gl.getAttribLocation(program, 'i')
        gl.vertexAttribPointer(i, 1, gl.FLOAT, false, 0, 0)
        gl.enableVertexAttribArray(i)

        //transformation
        gl.uniformMatrix3fv(gl.getUniformLocation(program, 'mat'), false, new Float32Array(transfoMat))

        // Enable the depth test
        //gl.enable(gl.DEPTH_TEST);
        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT)
        // Set the view port
        //gl.viewport(0, 0, cg.w, cg.h);

        gl.drawArrays(gl.POINTS, 0, verticesBuffer.length / 2)
    }
}


/***/ }),

/***/ "./src/utils/stretching.js":
/*!*********************************!*\
  !*** ./src/utils/stretching.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sCircleHigh": () => (/* binding */ sCircleHigh),
/* harmony export */   "sCircleLow": () => (/* binding */ sCircleLow),
/* harmony export */   "sExp": () => (/* binding */ sExp),
/* harmony export */   "sExpInverse": () => (/* binding */ sExpInverse),
/* harmony export */   "sExpRev": () => (/* binding */ sExpRev),
/* harmony export */   "sExpRevInverse": () => (/* binding */ sExpRevInverse),
/* harmony export */   "sPow": () => (/* binding */ sPow),
/* harmony export */   "sPowInverse": () => (/* binding */ sPowInverse),
/* harmony export */   "sPowRev": () => (/* binding */ sPowRev),
/* harmony export */   "sPowRevInverse": () => (/* binding */ sPowRevInverse)
/* harmony export */ });
//@ts-check


/**
 * Some function [0,1]->[0,1] to stretch range of values.
 * @see https://github.com/eurostat/gridviz/blob/master/docs/reference.md#stretching
 * @see https://observablehq.com/@jgaffuri/stretching
 */

/**
 * Function [0,1]->[0,1] to stretch range of values.
 * Polynomial
 *
 * @param {number} t The value to stretch, within [0,1]
 * @param {number} alpha 1: no stretching. <1: show low values. >1: show high values.
 * @returns {number} The stretched value, within [0,1]
 */
const sPow = (t, alpha = 3) => Math.pow(t, alpha)

/**
 * Function [0,1]->[0,1] to stretch range of values.
 * Polynomial (reverse)
 *
 * @param {number} t The value to stretch, within [0,1]
 * @param {number} alpha 1: no stretching. <1: show low values. >1: show high values.
 * @returns {number} The stretched value, within [0,1]
 */
const sPowRev = (t, alpha = 3) => 1 - Math.pow(1 - t, 1 / alpha)

/**
 * Function [0,1]->[0,1] to stretch range of values.
 * Exponential
 *
 * @param {number} t The value to stretch, within [0,1]
 * @param {number} alpha 0: no stretching. -Inf: show low values. Inf: show high values.
 * @returns {number} The stretched value, within [0,1]
 */
const sExp = (t, alpha = 3) => (alpha == 0 ? t : (Math.exp(t * alpha) - 1) / (Math.exp(alpha) - 1))

/**
 * Function [0,1]->[0,1] to stretch range of values.
 * Exponential (reverse)
 *
 * @param {number} t The value to stretch, within [0,1]
 * @param {number} alpha 0: no stretching. -Inf: show low values. Inf: show high values.
 * @returns {number} The stretched value, within [0,1]
 */
const sExpRev = (t, alpha = 3) =>
    alpha == 0 ? t : 1 - (1 / alpha) * Math.log(Math.exp(alpha) * (1 - t) + t)

/**
 * Function [0,1]->[0,1] to stretch range of values.
 * Circle, show low values
 * NB: sCircleHigh and sCircleLow are inverse functions of each other.
 *
 * @param {number} t The value to stretch, within [0,1]
 * @param {number} alpha 0: no stretching. 1: perfect circle section
 * @returns {number} The stretched value, within [0,1]
 */
const sCircleLow = (t, alpha = 0.8) => {
    if (alpha == 0) return t
    if (alpha == 1) return Math.sqrt(t * (2 - t))
    const a = alpha / (1 - alpha)
    return Math.sqrt(1 / (a * a) + t * (2 / a + 2 - t)) - 1 / a
}

/**
 * Function [0,1]->[0,1] to stretch range of values.
 * Circle, show high values
 * NB: sCircleHigh and sCircleLow are inverse functions of each other.
 *
 * @param {number} t The value to stretch, within [0,1]
 * @param {number} alpha 0: no stretching. 1: perfect circle section
 * @returns {number} The stretched value, within [0,1]
 */
const sCircleHigh = (t, alpha = 0.8) => 1 - sCircleLow(1 - t, alpha)

/**
 * Inverse functions
 */

/**
 * Inverse function of sExp
 * @param {number} y
 * @param {number} alpha
 * @returns {number}
 */
const sExpInverse = (y, alpha = 3) =>
    alpha == 0 ? y : (1 / alpha) * Math.log(1 - y + y * Math.exp(alpha))

/**
 * Inverse function of sExpRev
 * @param {number} y
 * @param {number} alpha
 * @returns {number}
 */
const sExpRevInverse = (y, alpha = 3) => (Math.exp(-alpha * y) - 1) / (Math.exp(-alpha) - 1)

/**
 * Inverse function of sPow
 * @param {number} y
 * @param {number} alpha
 * @returns {number}
 */

const sPowInverse = (y, alpha = 3) => Math.pow(y, 1 / alpha)

/**
 * Inverse function of sPowRev
 * @param {number} y
 * @param {number} alpha
 * @returns {number}
 */
const sPowRevInverse = (y, alpha = 3) => 1 - Math.pow(1 - y, alpha)

//test code
/*
for (let i = 0; i <= 1; i += 0.001) {
  //const v = gviz.sExp(gviz.sExpInverse(i));
  //const v = gviz.sExpInverse(gviz.sExp(i));
  //const v = gviz.sExpRev(gviz.sExpRevInverse(i));
  //const v = gviz.sExpRevInverse(gviz.sExpRev(i));
  //const v = gviz.sPow(gviz.sPowInverse(i));
  //const v = gviz.sPowInverse(gviz.sPow(i));
  //const v = gviz.sPowRev(gviz.sPowRevInverse(i));
  //const v = gviz.sPowRevInverse(gviz.sPowRev(i));
  //const v = gviz.sCircleLow(gviz.sCircleHigh(i));
  //const v = gviz.sCircleHigh(gviz.sCircleLow(i));
  console.log(i - v)
}
*/


/***/ }),

/***/ "./src/utils/webGLUtils.js":
/*!*********************************!*\
  !*** ./src/utils/webGLUtils.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkWebGLSupport": () => (/* binding */ checkWebGLSupport),
/* harmony export */   "createShader": () => (/* binding */ createShader),
/* harmony export */   "initShaderProgram": () => (/* binding */ initShaderProgram),
/* harmony export */   "makeWebGLCanvas": () => (/* binding */ makeWebGLCanvas)
/* harmony export */ });
//@ts-check


/**
 * @param {string} width
 * @param {string} height
 * @param {object} opts
 * @returns {{canvas:HTMLCanvasElement, gl:WebGLRenderingContext}}
 */
function makeWebGLCanvas(width, height, opts) {
    const canvas = document.createElement('canvas')
    canvas.setAttribute('width', width)
    canvas.setAttribute('height', height)
    const gl = canvas.getContext('webgl', opts)
    if (!gl) {
        throw new Error('Unable to initialize WebGL. Your browser or machine may not support it.')
    }
    return { canvas: canvas, gl: gl }
}

/**
 * Initialize a shader program, so WebGL knows how to draw our data
 *
 * @param {WebGLRenderingContext} gl
 * @param  {...WebGLShader} shaders
 * @returns {WebGLProgram}
 */
function initShaderProgram(gl, ...shaders) {
    /** @type {WebGLProgram|null} */
    const program = gl.createProgram()
    if (program == null) throw new Error('Cannot create webGL program')
    for (const shader of shaders) gl.attachShader(program, shader)
    gl.linkProgram(program)
    if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program
    throw new Error(gl.getProgramInfoLog(program) || 'Cannot create webGL program (2)')
}

/**
 * Creates a shader of the given type, uploads the source and compiles it.
 *
 * @param {WebGLRenderingContext} gl
 * @param {number} type
 * @param  {...string} sources
 * @returns {WebGLShader}
 */
function createShader(gl, type, ...sources) {
    /** @type {WebGLShader|null} */
    const shader = gl.createShader(type)
    if (shader == null) throw new Error('Cannot create webGL shader')
    gl.shaderSource(shader, sources.join('\n'))
    gl.compileShader(shader)
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader
    throw new Error(gl.getShaderInfoLog(shader) || 'Cannot create webGL shader (2)')
}

/**
 * Check if webGL is supported
 *
 * @returns {boolean}
 */
function checkWebGLSupport() {
    try {
        const canvas = document.createElement('canvas')
        return !!window.WebGLRenderingContext &&
            (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
            ? true
            : false
    } catch (err) {
        return false
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "App": () => (/* reexport safe */ _App_js__WEBPACK_IMPORTED_MODULE_0__.App),
/* harmony export */   "BackgroundLayer": () => (/* reexport safe */ _BackgroundLayer_js__WEBPACK_IMPORTED_MODULE_29__.BackgroundLayer),
/* harmony export */   "BackgroundLayerWMS": () => (/* reexport safe */ _BackgroundLayerWMS_js__WEBPACK_IMPORTED_MODULE_30__.BackgroundLayerWMS),
/* harmony export */   "BoundaryLayer": () => (/* reexport safe */ _LineLayer_js__WEBPACK_IMPORTED_MODULE_32__.LineLayer),
/* harmony export */   "CSVGrid": () => (/* reexport safe */ _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_8__.CSVGrid),
/* harmony export */   "ColorCategoryLegend": () => (/* reexport safe */ _legend_ColorCategoryLegend_js__WEBPACK_IMPORTED_MODULE_35__.ColorCategoryLegend),
/* harmony export */   "ColorDiscreteLegend": () => (/* reexport safe */ _legend_ColorDiscreteLegend_js__WEBPACK_IMPORTED_MODULE_34__.ColorDiscreteLegend),
/* harmony export */   "ColorLegend": () => (/* reexport safe */ _legend_ColorLegend_js__WEBPACK_IMPORTED_MODULE_33__.ColorLegend),
/* harmony export */   "CompositionStyle": () => (/* reexport safe */ _style_CompositionStyle_js__WEBPACK_IMPORTED_MODULE_13__.CompositionStyle),
/* harmony export */   "ContourStyle": () => (/* reexport safe */ _style_ContourStyle_js__WEBPACK_IMPORTED_MODULE_18__.ContourStyle),
/* harmony export */   "Dataset": () => (/* reexport safe */ _Dataset_js__WEBPACK_IMPORTED_MODULE_4__.Dataset),
/* harmony export */   "DatasetComponent": () => (/* reexport safe */ _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_5__.DatasetComponent),
/* harmony export */   "DotDensityStyle": () => (/* reexport safe */ _style_DotDensityStyle_js__WEBPACK_IMPORTED_MODULE_20__.DotDensityStyle),
/* harmony export */   "GeoCanvas": () => (/* reexport safe */ _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_1__.GeoCanvas),
/* harmony export */   "GridTile": () => (/* reexport safe */ _dataset_GridTile_js__WEBPACK_IMPORTED_MODULE_7__.GridTile),
/* harmony export */   "IsoFenceStyle": () => (/* reexport safe */ _style_IsoFenceStyle_js__WEBPACK_IMPORTED_MODULE_28__.IsoFenceStyle),
/* harmony export */   "JoyPlotStyle": () => (/* reexport safe */ _style_JoyPlotStyle_js__WEBPACK_IMPORTED_MODULE_12__.JoyPlotStyle),
/* harmony export */   "LGrid": () => (/* reexport safe */ _dataset_LGrid_js__WEBPACK_IMPORTED_MODULE_9__.LGrid),
/* harmony export */   "LabelLayer": () => (/* reexport safe */ _LabelLayer_js__WEBPACK_IMPORTED_MODULE_31__.LabelLayer),
/* harmony export */   "Layer": () => (/* reexport safe */ _Layer_js__WEBPACK_IMPORTED_MODULE_3__.Layer),
/* harmony export */   "LegoStyle": () => (/* reexport safe */ _style_LegoStyle_js__WEBPACK_IMPORTED_MODULE_22__.LegoStyle),
/* harmony export */   "MosaicStyle": () => (/* reexport safe */ _style_MosaicStyle_js__WEBPACK_IMPORTED_MODULE_25__.MosaicStyle),
/* harmony export */   "NinjaStarStyle": () => (/* reexport safe */ _style_NinjaStarStyle_js__WEBPACK_IMPORTED_MODULE_26__.NinjaStarStyle),
/* harmony export */   "PillarStyle": () => (/* reexport safe */ _style_PillarStyle_js__WEBPACK_IMPORTED_MODULE_16__.PillarStyle),
/* harmony export */   "SegmentOrientationLegend": () => (/* reexport safe */ _legend_SegmentOrientationLegend_js__WEBPACK_IMPORTED_MODULE_38__.SegmentOrientationLegend),
/* harmony export */   "SegmentStyle": () => (/* reexport safe */ _style_SegmentStyle_js__WEBPACK_IMPORTED_MODULE_14__.SegmentStyle),
/* harmony export */   "SegmentWidthLegend": () => (/* reexport safe */ _legend_SegmentWidthLegend_js__WEBPACK_IMPORTED_MODULE_37__.SegmentWidthLegend),
/* harmony export */   "ShapeColorSizeStyle": () => (/* reexport safe */ _style_ShapeColorSizeStyle_js__WEBPACK_IMPORTED_MODULE_10__.ShapeColorSizeStyle),
/* harmony export */   "SideCatStyle": () => (/* reexport safe */ _style_SideCatStyle_js__WEBPACK_IMPORTED_MODULE_19__.SideCatStyle),
/* harmony export */   "SideStyle": () => (/* reexport safe */ _style_SideStyle_js__WEBPACK_IMPORTED_MODULE_17__.SideStyle),
/* harmony export */   "SizeLegend": () => (/* reexport safe */ _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_36__.SizeLegend),
/* harmony export */   "SquareColorCatWGLStyle": () => (/* reexport safe */ _style_SquareColorCatWGLStyle_js__WEBPACK_IMPORTED_MODULE_24__.SquareColorCatWGLStyle),
/* harmony export */   "SquareColorWGLStyle": () => (/* reexport safe */ _style_SquareColorWGLStyle_js__WEBPACK_IMPORTED_MODULE_23__.SquareColorWGLStyle),
/* harmony export */   "StrokeStyle": () => (/* reexport safe */ _style_StrokeStyle_js__WEBPACK_IMPORTED_MODULE_11__.StrokeStyle),
/* harmony export */   "Style": () => (/* reexport safe */ _Style_js__WEBPACK_IMPORTED_MODULE_2__.Style),
/* harmony export */   "TanakaStyle": () => (/* reexport safe */ _style_TanakaStyle_js__WEBPACK_IMPORTED_MODULE_21__.TanakaStyle),
/* harmony export */   "TextStyle": () => (/* reexport safe */ _style_TextStyle_js__WEBPACK_IMPORTED_MODULE_15__.TextStyle),
/* harmony export */   "TiledGrid": () => (/* reexport safe */ _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_6__.TiledGrid),
/* harmony export */   "TimeSeriesStyle": () => (/* reexport safe */ _style_TimeSeriesStyle_js__WEBPACK_IMPORTED_MODULE_27__.TimeSeriesStyle),
/* harmony export */   "getClass": () => (/* reexport safe */ _utils_Utils_js__WEBPACK_IMPORTED_MODULE_40__.getClass),
/* harmony export */   "getParameterByName": () => (/* binding */ getParameterByName),
/* harmony export */   "sCircleHigh": () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.sCircleHigh),
/* harmony export */   "sCircleLow": () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.sCircleLow),
/* harmony export */   "sExp": () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.sExp),
/* harmony export */   "sExpInverse": () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.sExpInverse),
/* harmony export */   "sExpRev": () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.sExpRev),
/* harmony export */   "sExpRevInverse": () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.sExpRevInverse),
/* harmony export */   "sPow": () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.sPow),
/* harmony export */   "sPowInverse": () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.sPowInverse),
/* harmony export */   "sPowRev": () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.sPowRev),
/* harmony export */   "sPowRevInverse": () => (/* reexport safe */ _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__.sPowRevInverse)
/* harmony export */ });
/* harmony import */ var _App_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.js */ "./src/App.js");
/* harmony import */ var _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeoCanvas.js */ "./src/GeoCanvas.js");
/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Style.js */ "./src/Style.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Layer.js */ "./src/Layer.js");
/* harmony import */ var _Dataset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Dataset.js */ "./src/Dataset.js");
/* harmony import */ var _DatasetComponent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DatasetComponent.js */ "./src/DatasetComponent.js");
/* harmony import */ var _dataset_TiledGrid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dataset/TiledGrid.js */ "./src/dataset/TiledGrid.js");
/* harmony import */ var _dataset_GridTile_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dataset/GridTile.js */ "./src/dataset/GridTile.js");
/* harmony import */ var _dataset_CSVGrid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dataset/CSVGrid.js */ "./src/dataset/CSVGrid.js");
/* harmony import */ var _dataset_LGrid_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dataset/LGrid.js */ "./src/dataset/LGrid.js");
/* harmony import */ var _style_ShapeColorSizeStyle_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style/ShapeColorSizeStyle.js */ "./src/style/ShapeColorSizeStyle.js");
/* harmony import */ var _style_StrokeStyle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./style/StrokeStyle.js */ "./src/style/StrokeStyle.js");
/* harmony import */ var _style_JoyPlotStyle_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./style/JoyPlotStyle.js */ "./src/style/JoyPlotStyle.js");
/* harmony import */ var _style_CompositionStyle_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./style/CompositionStyle.js */ "./src/style/CompositionStyle.js");
/* harmony import */ var _style_SegmentStyle_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./style/SegmentStyle.js */ "./src/style/SegmentStyle.js");
/* harmony import */ var _style_TextStyle_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./style/TextStyle.js */ "./src/style/TextStyle.js");
/* harmony import */ var _style_PillarStyle_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./style/PillarStyle.js */ "./src/style/PillarStyle.js");
/* harmony import */ var _style_SideStyle_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./style/SideStyle.js */ "./src/style/SideStyle.js");
/* harmony import */ var _style_ContourStyle_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./style/ContourStyle.js */ "./src/style/ContourStyle.js");
/* harmony import */ var _style_SideCatStyle_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style/SideCatStyle.js */ "./src/style/SideCatStyle.js");
/* harmony import */ var _style_DotDensityStyle_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./style/DotDensityStyle.js */ "./src/style/DotDensityStyle.js");
/* harmony import */ var _style_TanakaStyle_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./style/TanakaStyle.js */ "./src/style/TanakaStyle.js");
/* harmony import */ var _style_LegoStyle_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./style/LegoStyle.js */ "./src/style/LegoStyle.js");
/* harmony import */ var _style_SquareColorWGLStyle_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./style/SquareColorWGLStyle.js */ "./src/style/SquareColorWGLStyle.js");
/* harmony import */ var _style_SquareColorCatWGLStyle_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./style/SquareColorCatWGLStyle.js */ "./src/style/SquareColorCatWGLStyle.js");
/* harmony import */ var _style_MosaicStyle_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./style/MosaicStyle.js */ "./src/style/MosaicStyle.js");
/* harmony import */ var _style_NinjaStarStyle_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./style/NinjaStarStyle.js */ "./src/style/NinjaStarStyle.js");
/* harmony import */ var _style_TimeSeriesStyle_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./style/TimeSeriesStyle.js */ "./src/style/TimeSeriesStyle.js");
/* harmony import */ var _style_IsoFenceStyle_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./style/IsoFenceStyle.js */ "./src/style/IsoFenceStyle.js");
/* harmony import */ var _BackgroundLayer_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./BackgroundLayer.js */ "./src/BackgroundLayer.js");
/* harmony import */ var _BackgroundLayerWMS_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./BackgroundLayerWMS.js */ "./src/BackgroundLayerWMS.js");
/* harmony import */ var _LabelLayer_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./LabelLayer.js */ "./src/LabelLayer.js");
/* harmony import */ var _LineLayer_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./LineLayer.js */ "./src/LineLayer.js");
/* harmony import */ var _legend_ColorLegend_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./legend/ColorLegend.js */ "./src/legend/ColorLegend.js");
/* harmony import */ var _legend_ColorDiscreteLegend_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./legend/ColorDiscreteLegend.js */ "./src/legend/ColorDiscreteLegend.js");
/* harmony import */ var _legend_ColorCategoryLegend_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./legend/ColorCategoryLegend.js */ "./src/legend/ColorCategoryLegend.js");
/* harmony import */ var _legend_SizeLegend_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./legend/SizeLegend.js */ "./src/legend/SizeLegend.js");
/* harmony import */ var _legend_SegmentWidthLegend_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./legend/SegmentWidthLegend.js */ "./src/legend/SegmentWidthLegend.js");
/* harmony import */ var _legend_SegmentOrientationLegend_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./legend/SegmentOrientationLegend.js */ "./src/legend/SegmentOrientationLegend.js");
/* harmony import */ var _utils_stretching_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./utils/stretching.js */ "./src/utils/stretching.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./utils/Utils.js */ "./src/utils/Utils.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
//@ts-check


// the application







// export dataset types




//export { GeoTIFF } from "./dataset/GeoTIFF"

// export styles




















// export additional layers





// export legends







// export { goToStraight, zoomTo } from "./utils/zoomUtils"






;
const getParameterByName = _GeoCanvas_js__WEBPACK_IMPORTED_MODULE_1__.GeoCanvas.getParameterByName

// set default d3 locale
;
(0,d3_format__WEBPACK_IMPORTED_MODULE_41__["default"])({
    decimal: '.',
    thousands: ' ',
    grouping: [3],
    currency: ['', '€'],
})

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZHZpei5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWMkM7O0FBRXBDOztBQUVBO0FBQ0E7O0FBRVA7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0Isd0NBQXdDLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSTtBQUMxRCx3Q0FBd0MsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJO0FBQzFELDBDQUEwQyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJO0FBQ25FLDBDQUEwQyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJO0FBQ25FLHdDQUF3QyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDMUQsMENBQTBDLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFNLFdBQVcsa0RBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGFBQWEsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZO0FBQ3JEOztBQUVBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3Q0FBd0M7QUFDckU7QUFD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O1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNZO0FBQ1o7QUFDQTtBQUM4QjtBQUNZO0FBQ1I7QUFDQTtBQUNJO0FBQ2tCO0FBQ3hEO0FBQ0E7QUFDa0Q7QUFDRjtBQUNGO0FBQ0o7QUFDMUMsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDb0U7QUFDaEI7QUFDRTtBQUNRO0FBQ1I7QUFDTjtBQUNJO0FBQ0o7QUFDTTtBQUNBO0FBQ007QUFDUjtBQUNKO0FBQ29CO0FBQ007QUFDdEI7QUFDTTtBQUNFO0FBQ0o7QUFDeEQ7QUFDQTtBQUNzRDtBQUNNO0FBQ2hCO0FBQ2U7QUFDM0Q7QUFDQTtBQUNxRDtBQUNnQjtBQUNBO0FBQ2xCO0FBQ2dCO0FBQ1k7QUFDL0U7QUFDQSxZQUFZLHVCQUF1QjtBQUNFO0FBQ3JDO0FBQzJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLENBQTBDO0FBQ25DLDJCQUEyQix1RUFBNEI7QUFDOUQ7QUFDQTtBQUNBLENBQStDO0FBQy9DLHNEQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ndml6L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9jb2xvci5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9zcmMvZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2RyYWcuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1kcmFnL3NyYy9ub2V2ZW50LmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtZHN2L3NyYy9jc3YuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1kc3Yvc3JjL2Rzdi5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWRzdi9zcmMvdHN2LmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtZWFzZS9zcmMvY3ViaWMuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1mZXRjaC9zcmMvZHN2LmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtZmV0Y2gvc3JjL2pzb24uanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1mZXRjaC9zcmMvdGV4dC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZGVmYXVsdExvY2FsZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZXhwb25lbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdERlY2ltYWwuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdEdyb3VwLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXROdW1lcmFscy5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0UHJlZml4QXV0by5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0Um91bmRlZC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0U3BlY2lmaWVyLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRUcmltLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRUeXBlcy5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2xvY2FsZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9iYXNpcy5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9iYXNpc0Nsb3NlZC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb2xvci5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvcmdiLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy90cmFuc2Zvcm0vZGVjb21wb3NlLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9pbmRleC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy90cmFuc2Zvcm0vcGFyc2UuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvem9vbS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXJhbmRvbS9zcmMvZGVmYXVsdFNvdXJjZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXJhbmRvbS9zcmMvbm9ybWFsLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL2NyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL21hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL25hbWVzcGFjZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvbmFtZXNwYWNlcy5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvcG9pbnRlci5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0LmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vYXBwZW5kLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vYXR0ci5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2NhbGwuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9jbGFzc2VkLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vY2xvbmUuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kYXRhLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZGF0dW0uanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9kaXNwYXRjaC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VhY2guanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9lbXB0eS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2VudGVyLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vZXhpdC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2h0bWwuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2luc2VydC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2l0ZXJhdG9yLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vam9pbi5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL2xvd2VyLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9ub2RlLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vbm9kZXMuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9vbi5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL29yZGVyLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9yYWlzZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdEFsbC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NlbGVjdENoaWxkLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc2VsZWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdGlvbi9zaXplLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vc29ydC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3NwYXJzZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0aW9uL3N0eWxlLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zZWxlY3Rpb24vdGV4dC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vc3JjL3NlbGVjdG9yQWxsLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL3NyYy9zb3VyY2VFdmVudC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXNlbGVjdGlvbi9zcmMvd2luZG93LmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL3RpbWVvdXQuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvdGltZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9hY3RpdmUuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL2ludGVycnVwdC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3NlbGVjdGlvbi9pbnRlcnJ1cHQuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy9zZWxlY3Rpb24vdHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vYXR0ci5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vYXR0clR3ZWVuLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtem9vbS9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9kZWxheS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vZHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2Vhc2UuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2Vhc2VWYXJ5aW5nLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtem9vbS9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9lbmQuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL2ludGVycG9sYXRlLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtem9vbS9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9tZXJnZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vb24uanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2NoZWR1bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vc3JjL3RyYW5zaXRpb24vc2VsZWN0QWxsLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtem9vbS9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3N0eWxlLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtem9vbS9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi9zdHlsZVR3ZWVuLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtem9vbS9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90ZXh0LmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtem9vbS9ub2RlX21vZHVsZXMvZDMtdHJhbnNpdGlvbi9zcmMvdHJhbnNpdGlvbi90ZXh0VHdlZW4uanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3RyYW5zaXRpb24uanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL25vZGVfbW9kdWxlcy9kMy10cmFuc2l0aW9uL3NyYy90cmFuc2l0aW9uL3R3ZWVuLmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL25vZGVfbW9kdWxlcy9kMy16b29tL3NyYy9ldmVudC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL2luZGV4LmpzIiwid2VicGFjazovL2d2aXovLi9ub2RlX21vZHVsZXMvZDMtem9vbS9zcmMvbm9ldmVudC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vbm9kZV9tb2R1bGVzL2QzLXpvb20vc3JjL3pvb20uanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9BcHAuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9CYWNrZ3JvdW5kTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9CYWNrZ3JvdW5kTGF5ZXJXTVMuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9EYXRhc2V0LmpzIiwid2VicGFjazovL2d2aXovLi9zcmMvRGF0YXNldENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL0dlb0NhbnZhcy5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL0xhYmVsTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9MYXllci5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL0xlZ2VuZC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL0xpbmVMYXllci5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL1N0eWxlLmpzIiwid2VicGFjazovL2d2aXovLi9zcmMvVG9vbHRpcC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL2J1dHRvbi9CdXR0b24uanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9idXR0b24vRnVsbHNjcmVlbkJ1dHRvbi5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL2J1dHRvbi9ab29tQnV0dG9ucy5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL2RhdGFzZXQvQ1NWR3JpZC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL2RhdGFzZXQvR3JpZFRpbGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9kYXRhc2V0L0xHcmlkLmpzIiwid2VicGFjazovL2d2aXovLi9zcmMvZGF0YXNldC9UaWxlZEdyaWQuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9sZWdlbmQvQ29sb3JDYXRlZ29yeUxlZ2VuZC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL2xlZ2VuZC9Db2xvckRpc2NyZXRlTGVnZW5kLmpzIiwid2VicGFjazovL2d2aXovLi9zcmMvbGVnZW5kL0NvbG9yTGVnZW5kLmpzIiwid2VicGFjazovL2d2aXovLi9zcmMvbGVnZW5kL1NlZ21lbnRPcmllbnRhdGlvbkxlZ2VuZC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL2xlZ2VuZC9TZWdtZW50V2lkdGhMZWdlbmQuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9sZWdlbmQvU2l6ZUxlZ2VuZC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL3N0eWxlL0NvbXBvc2l0aW9uU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9zdHlsZS9Db250b3VyU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9zdHlsZS9Eb3REZW5zaXR5U3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9zdHlsZS9Jc29GZW5jZVN0eWxlLmpzIiwid2VicGFjazovL2d2aXovLi9zcmMvc3R5bGUvSm95UGxvdFN0eWxlLmpzIiwid2VicGFjazovL2d2aXovLi9zcmMvc3R5bGUvTGVnb1N0eWxlLmpzIiwid2VicGFjazovL2d2aXovLi9zcmMvc3R5bGUvTW9zYWljU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9zdHlsZS9OaW5qYVN0YXJTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL3N0eWxlL1BpbGxhclN0eWxlLmpzIiwid2VicGFjazovL2d2aXovLi9zcmMvc3R5bGUvU2VnbWVudFN0eWxlLmpzIiwid2VicGFjazovL2d2aXovLi9zcmMvc3R5bGUvU2hhcGVDb2xvclNpemVTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL3N0eWxlL1NpZGVDYXRTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL3N0eWxlL1NpZGVTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL3N0eWxlL1NxdWFyZUNvbG9yQ2F0V0dMU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9zdHlsZS9TcXVhcmVDb2xvcldHTFN0eWxlLmpzIiwid2VicGFjazovL2d2aXovLi9zcmMvc3R5bGUvU3Ryb2tlU3R5bGUuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy9zdHlsZS9UYW5ha2FTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL3N0eWxlL1RleHRTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL3N0eWxlL1RpbWVTZXJpZXNTdHlsZS5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL3V0aWxzL1V0aWxzLmpzIiwid2VicGFjazovL2d2aXovLi9zcmMvdXRpbHMvV2ViR0xTcXVhcmVDb2xvcmluZy5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL3V0aWxzL1dlYkdMU3F1YXJlQ29sb3JpbmdBZHZhbmNlZC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL3V0aWxzL1dlYkdMU3F1YXJlQ29sb3JpbmdDYXRBZHZhbmNlZC5qcyIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL3V0aWxzL3N0cmV0Y2hpbmcuanMiLCJ3ZWJwYWNrOi8vZ3Zpei8uL3NyYy91dGlscy93ZWJHTFV0aWxzLmpzIiwid2VicGFjazovL2d2aXovd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vZ3Zpei93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vZ3Zpei93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2d2aXovd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9ndml6Ly4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImd2aXpcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZ3ZpelwiXSA9IGZhY3RvcnkoKTtcbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAiLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIENvbG9yKCkge31cblxuZXhwb3J0IHZhciBkYXJrZXIgPSAwLjc7XG5leHBvcnQgdmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxudmFyIHJlSSA9IFwiXFxcXHMqKFsrLV0/XFxcXGQrKVxcXFxzKlwiLFxuICAgIHJlTiA9IFwiXFxcXHMqKFsrLV0/KD86XFxcXGQqXFxcXC4pP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KVxcXFxzKlwiLFxuICAgIHJlUCA9IFwiXFxcXHMqKFsrLV0/KD86XFxcXGQqXFxcXC4pP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KSVcXFxccypcIixcbiAgICByZUhleCA9IC9eIyhbMC05YS1mXXszLDh9KSQvLFxuICAgIHJlUmdiSW50ZWdlciA9IG5ldyBSZWdFeHAoYF5yZ2JcXFxcKCR7cmVJfSwke3JlSX0sJHtyZUl9XFxcXCkkYCksXG4gICAgcmVSZ2JQZXJjZW50ID0gbmV3IFJlZ0V4cChgXnJnYlxcXFwoJHtyZVB9LCR7cmVQfSwke3JlUH1cXFxcKSRgKSxcbiAgICByZVJnYmFJbnRlZ2VyID0gbmV3IFJlZ0V4cChgXnJnYmFcXFxcKCR7cmVJfSwke3JlSX0sJHtyZUl9LCR7cmVOfVxcXFwpJGApLFxuICAgIHJlUmdiYVBlcmNlbnQgPSBuZXcgUmVnRXhwKGBecmdiYVxcXFwoJHtyZVB9LCR7cmVQfSwke3JlUH0sJHtyZU59XFxcXCkkYCksXG4gICAgcmVIc2xQZXJjZW50ID0gbmV3IFJlZ0V4cChgXmhzbFxcXFwoJHtyZU59LCR7cmVQfSwke3JlUH1cXFxcKSRgKSxcbiAgICByZUhzbGFQZXJjZW50ID0gbmV3IFJlZ0V4cChgXmhzbGFcXFxcKCR7cmVOfSwke3JlUH0sJHtyZVB9LCR7cmVOfVxcXFwpJGApO1xuXG52YXIgbmFtZWQgPSB7XG4gIGFsaWNlYmx1ZTogMHhmMGY4ZmYsXG4gIGFudGlxdWV3aGl0ZTogMHhmYWViZDcsXG4gIGFxdWE6IDB4MDBmZmZmLFxuICBhcXVhbWFyaW5lOiAweDdmZmZkNCxcbiAgYXp1cmU6IDB4ZjBmZmZmLFxuICBiZWlnZTogMHhmNWY1ZGMsXG4gIGJpc3F1ZTogMHhmZmU0YzQsXG4gIGJsYWNrOiAweDAwMDAwMCxcbiAgYmxhbmNoZWRhbG1vbmQ6IDB4ZmZlYmNkLFxuICBibHVlOiAweDAwMDBmZixcbiAgYmx1ZXZpb2xldDogMHg4YTJiZTIsXG4gIGJyb3duOiAweGE1MmEyYSxcbiAgYnVybHl3b29kOiAweGRlYjg4NyxcbiAgY2FkZXRibHVlOiAweDVmOWVhMCxcbiAgY2hhcnRyZXVzZTogMHg3ZmZmMDAsXG4gIGNob2NvbGF0ZTogMHhkMjY5MWUsXG4gIGNvcmFsOiAweGZmN2Y1MCxcbiAgY29ybmZsb3dlcmJsdWU6IDB4NjQ5NWVkLFxuICBjb3Juc2lsazogMHhmZmY4ZGMsXG4gIGNyaW1zb246IDB4ZGMxNDNjLFxuICBjeWFuOiAweDAwZmZmZixcbiAgZGFya2JsdWU6IDB4MDAwMDhiLFxuICBkYXJrY3lhbjogMHgwMDhiOGIsXG4gIGRhcmtnb2xkZW5yb2Q6IDB4Yjg4NjBiLFxuICBkYXJrZ3JheTogMHhhOWE5YTksXG4gIGRhcmtncmVlbjogMHgwMDY0MDAsXG4gIGRhcmtncmV5OiAweGE5YTlhOSxcbiAgZGFya2toYWtpOiAweGJkYjc2YixcbiAgZGFya21hZ2VudGE6IDB4OGIwMDhiLFxuICBkYXJrb2xpdmVncmVlbjogMHg1NTZiMmYsXG4gIGRhcmtvcmFuZ2U6IDB4ZmY4YzAwLFxuICBkYXJrb3JjaGlkOiAweDk5MzJjYyxcbiAgZGFya3JlZDogMHg4YjAwMDAsXG4gIGRhcmtzYWxtb246IDB4ZTk5NjdhLFxuICBkYXJrc2VhZ3JlZW46IDB4OGZiYzhmLFxuICBkYXJrc2xhdGVibHVlOiAweDQ4M2Q4YixcbiAgZGFya3NsYXRlZ3JheTogMHgyZjRmNGYsXG4gIGRhcmtzbGF0ZWdyZXk6IDB4MmY0ZjRmLFxuICBkYXJrdHVycXVvaXNlOiAweDAwY2VkMSxcbiAgZGFya3Zpb2xldDogMHg5NDAwZDMsXG4gIGRlZXBwaW5rOiAweGZmMTQ5MyxcbiAgZGVlcHNreWJsdWU6IDB4MDBiZmZmLFxuICBkaW1ncmF5OiAweDY5Njk2OSxcbiAgZGltZ3JleTogMHg2OTY5NjksXG4gIGRvZGdlcmJsdWU6IDB4MWU5MGZmLFxuICBmaXJlYnJpY2s6IDB4YjIyMjIyLFxuICBmbG9yYWx3aGl0ZTogMHhmZmZhZjAsXG4gIGZvcmVzdGdyZWVuOiAweDIyOGIyMixcbiAgZnVjaHNpYTogMHhmZjAwZmYsXG4gIGdhaW5zYm9ybzogMHhkY2RjZGMsXG4gIGdob3N0d2hpdGU6IDB4ZjhmOGZmLFxuICBnb2xkOiAweGZmZDcwMCxcbiAgZ29sZGVucm9kOiAweGRhYTUyMCxcbiAgZ3JheTogMHg4MDgwODAsXG4gIGdyZWVuOiAweDAwODAwMCxcbiAgZ3JlZW55ZWxsb3c6IDB4YWRmZjJmLFxuICBncmV5OiAweDgwODA4MCxcbiAgaG9uZXlkZXc6IDB4ZjBmZmYwLFxuICBob3RwaW5rOiAweGZmNjliNCxcbiAgaW5kaWFucmVkOiAweGNkNWM1YyxcbiAgaW5kaWdvOiAweDRiMDA4MixcbiAgaXZvcnk6IDB4ZmZmZmYwLFxuICBraGFraTogMHhmMGU2OGMsXG4gIGxhdmVuZGVyOiAweGU2ZTZmYSxcbiAgbGF2ZW5kZXJibHVzaDogMHhmZmYwZjUsXG4gIGxhd25ncmVlbjogMHg3Y2ZjMDAsXG4gIGxlbW9uY2hpZmZvbjogMHhmZmZhY2QsXG4gIGxpZ2h0Ymx1ZTogMHhhZGQ4ZTYsXG4gIGxpZ2h0Y29yYWw6IDB4ZjA4MDgwLFxuICBsaWdodGN5YW46IDB4ZTBmZmZmLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogMHhmYWZhZDIsXG4gIGxpZ2h0Z3JheTogMHhkM2QzZDMsXG4gIGxpZ2h0Z3JlZW46IDB4OTBlZTkwLFxuICBsaWdodGdyZXk6IDB4ZDNkM2QzLFxuICBsaWdodHBpbms6IDB4ZmZiNmMxLFxuICBsaWdodHNhbG1vbjogMHhmZmEwN2EsXG4gIGxpZ2h0c2VhZ3JlZW46IDB4MjBiMmFhLFxuICBsaWdodHNreWJsdWU6IDB4ODdjZWZhLFxuICBsaWdodHNsYXRlZ3JheTogMHg3Nzg4OTksXG4gIGxpZ2h0c2xhdGVncmV5OiAweDc3ODg5OSxcbiAgbGlnaHRzdGVlbGJsdWU6IDB4YjBjNGRlLFxuICBsaWdodHllbGxvdzogMHhmZmZmZTAsXG4gIGxpbWU6IDB4MDBmZjAwLFxuICBsaW1lZ3JlZW46IDB4MzJjZDMyLFxuICBsaW5lbjogMHhmYWYwZTYsXG4gIG1hZ2VudGE6IDB4ZmYwMGZmLFxuICBtYXJvb246IDB4ODAwMDAwLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAweDY2Y2RhYSxcbiAgbWVkaXVtYmx1ZTogMHgwMDAwY2QsXG4gIG1lZGl1bW9yY2hpZDogMHhiYTU1ZDMsXG4gIG1lZGl1bXB1cnBsZTogMHg5MzcwZGIsXG4gIG1lZGl1bXNlYWdyZWVuOiAweDNjYjM3MSxcbiAgbWVkaXVtc2xhdGVibHVlOiAweDdiNjhlZSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDB4MDBmYTlhLFxuICBtZWRpdW10dXJxdW9pc2U6IDB4NDhkMWNjLFxuICBtZWRpdW12aW9sZXRyZWQ6IDB4YzcxNTg1LFxuICBtaWRuaWdodGJsdWU6IDB4MTkxOTcwLFxuICBtaW50Y3JlYW06IDB4ZjVmZmZhLFxuICBtaXN0eXJvc2U6IDB4ZmZlNGUxLFxuICBtb2NjYXNpbjogMHhmZmU0YjUsXG4gIG5hdmFqb3doaXRlOiAweGZmZGVhZCxcbiAgbmF2eTogMHgwMDAwODAsXG4gIG9sZGxhY2U6IDB4ZmRmNWU2LFxuICBvbGl2ZTogMHg4MDgwMDAsXG4gIG9saXZlZHJhYjogMHg2YjhlMjMsXG4gIG9yYW5nZTogMHhmZmE1MDAsXG4gIG9yYW5nZXJlZDogMHhmZjQ1MDAsXG4gIG9yY2hpZDogMHhkYTcwZDYsXG4gIHBhbGVnb2xkZW5yb2Q6IDB4ZWVlOGFhLFxuICBwYWxlZ3JlZW46IDB4OThmYjk4LFxuICBwYWxldHVycXVvaXNlOiAweGFmZWVlZSxcbiAgcGFsZXZpb2xldHJlZDogMHhkYjcwOTMsXG4gIHBhcGF5YXdoaXA6IDB4ZmZlZmQ1LFxuICBwZWFjaHB1ZmY6IDB4ZmZkYWI5LFxuICBwZXJ1OiAweGNkODUzZixcbiAgcGluazogMHhmZmMwY2IsXG4gIHBsdW06IDB4ZGRhMGRkLFxuICBwb3dkZXJibHVlOiAweGIwZTBlNixcbiAgcHVycGxlOiAweDgwMDA4MCxcbiAgcmViZWNjYXB1cnBsZTogMHg2NjMzOTksXG4gIHJlZDogMHhmZjAwMDAsXG4gIHJvc3licm93bjogMHhiYzhmOGYsXG4gIHJveWFsYmx1ZTogMHg0MTY5ZTEsXG4gIHNhZGRsZWJyb3duOiAweDhiNDUxMyxcbiAgc2FsbW9uOiAweGZhODA3MixcbiAgc2FuZHlicm93bjogMHhmNGE0NjAsXG4gIHNlYWdyZWVuOiAweDJlOGI1NyxcbiAgc2Vhc2hlbGw6IDB4ZmZmNWVlLFxuICBzaWVubmE6IDB4YTA1MjJkLFxuICBzaWx2ZXI6IDB4YzBjMGMwLFxuICBza3libHVlOiAweDg3Y2VlYixcbiAgc2xhdGVibHVlOiAweDZhNWFjZCxcbiAgc2xhdGVncmF5OiAweDcwODA5MCxcbiAgc2xhdGVncmV5OiAweDcwODA5MCxcbiAgc25vdzogMHhmZmZhZmEsXG4gIHNwcmluZ2dyZWVuOiAweDAwZmY3ZixcbiAgc3RlZWxibHVlOiAweDQ2ODJiNCxcbiAgdGFuOiAweGQyYjQ4YyxcbiAgdGVhbDogMHgwMDgwODAsXG4gIHRoaXN0bGU6IDB4ZDhiZmQ4LFxuICB0b21hdG86IDB4ZmY2MzQ3LFxuICB0dXJxdW9pc2U6IDB4NDBlMGQwLFxuICB2aW9sZXQ6IDB4ZWU4MmVlLFxuICB3aGVhdDogMHhmNWRlYjMsXG4gIHdoaXRlOiAweGZmZmZmZixcbiAgd2hpdGVzbW9rZTogMHhmNWY1ZjUsXG4gIHllbGxvdzogMHhmZmZmMDAsXG4gIHllbGxvd2dyZWVuOiAweDlhY2QzMlxufTtcblxuZGVmaW5lKENvbG9yLCBjb2xvciwge1xuICBjb3B5KGNoYW5uZWxzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IHRoaXMuY29uc3RydWN0b3IsIHRoaXMsIGNoYW5uZWxzKTtcbiAgfSxcbiAgZGlzcGxheWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkuZGlzcGxheWFibGUoKTtcbiAgfSxcbiAgaGV4OiBjb2xvcl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogY29sb3JfZm9ybWF0SGV4LFxuICBmb3JtYXRIZXg4OiBjb2xvcl9mb3JtYXRIZXg4LFxuICBmb3JtYXRIc2w6IGNvbG9yX2Zvcm1hdEhzbCxcbiAgZm9ybWF0UmdiOiBjb2xvcl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiBjb2xvcl9mb3JtYXRSZ2Jcbn0pO1xuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdEhleCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIZXg4KCkge1xuICByZXR1cm4gdGhpcy5yZ2IoKS5mb3JtYXRIZXg4KCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhzbCgpIHtcbiAgcmV0dXJuIGhzbENvbnZlcnQodGhpcykuZm9ybWF0SHNsKCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdFJnYigpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0UmdiKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbG9yKGZvcm1hdCkge1xuICB2YXIgbSwgbDtcbiAgZm9ybWF0ID0gKGZvcm1hdCArIFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKG0gPSByZUhleC5leGVjKGZvcm1hdCkpID8gKGwgPSBtWzFdLmxlbmd0aCwgbSA9IHBhcnNlSW50KG1bMV0sIDE2KSwgbCA9PT0gNiA/IHJnYm4obSkgLy8gI2ZmMDAwMFxuICAgICAgOiBsID09PSAzID8gbmV3IFJnYigobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpLCAxKSAvLyAjZjAwXG4gICAgICA6IGwgPT09IDggPyByZ2JhKG0gPj4gMjQgJiAweGZmLCBtID4+IDE2ICYgMHhmZiwgbSA+PiA4ICYgMHhmZiwgKG0gJiAweGZmKSAvIDB4ZmYpIC8vICNmZjAwMDAwMFxuICAgICAgOiBsID09PSA0ID8gcmdiYSgobSA+PiAxMiAmIDB4ZikgfCAobSA+PiA4ICYgMHhmMCksIChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4ZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpKSAvIDB4ZmYpIC8vICNmMDAwXG4gICAgICA6IG51bGwpIC8vIGludmFsaWQgaGV4XG4gICAgICA6IChtID0gcmVSZ2JJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0sIG1bMl0sIG1bM10sIDEpIC8vIHJnYigyNTUsIDAsIDApXG4gICAgICA6IChtID0gcmVSZ2JQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIDEpIC8vIHJnYigxMDAlLCAwJSwgMCUpXG4gICAgICA6IChtID0gcmVSZ2JhSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKSAvLyByZ2JhKDI1NSwgMCwgMCwgMSlcbiAgICAgIDogKG0gPSByZVJnYmFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIG1bNF0pIC8vIHJnYigxMDAlLCAwJSwgMCUsIDEpXG4gICAgICA6IChtID0gcmVIc2xQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIDEpIC8vIGhzbCgxMjAsIDUwJSwgNTAlKVxuICAgICAgOiAobSA9IHJlSHNsYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgbVs0XSkgLy8gaHNsYSgxMjAsIDUwJSwgNTAlLCAxKVxuICAgICAgOiBuYW1lZC5oYXNPd25Qcm9wZXJ0eShmb3JtYXQpID8gcmdibihuYW1lZFtmb3JtYXRdKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgOiBmb3JtYXQgPT09IFwidHJhbnNwYXJlbnRcIiA/IG5ldyBSZ2IoTmFOLCBOYU4sIE5hTiwgMClcbiAgICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gcmdibihuKSB7XG4gIHJldHVybiBuZXcgUmdiKG4gPj4gMTYgJiAweGZmLCBuID4+IDggJiAweGZmLCBuICYgMHhmZiwgMSk7XG59XG5cbmZ1bmN0aW9uIHJnYmEociwgZywgYiwgYSkge1xuICBpZiAoYSA8PSAwKSByID0gZyA9IGIgPSBOYU47XG4gIHJldHVybiBuZXcgUmdiKHIsIGcsIGIsIGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiQ29udmVydChvKSB7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IFJnYjtcbiAgbyA9IG8ucmdiKCk7XG4gIHJldHVybiBuZXcgUmdiKG8uciwgby5nLCBvLmIsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHJnYkNvbnZlcnQocikgOiBuZXcgUmdiKHIsIGcsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMuciA9ICtyO1xuICB0aGlzLmcgPSArZztcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoUmdiLCByZ2IsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjbGFtcCgpIHtcbiAgICByZXR1cm4gbmV3IFJnYihjbGFtcGkodGhpcy5yKSwgY2xhbXBpKHRoaXMuZyksIGNsYW1waSh0aGlzLmIpLCBjbGFtcGEodGhpcy5vcGFjaXR5KSk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlKCkge1xuICAgIHJldHVybiAoLTAuNSA8PSB0aGlzLnIgJiYgdGhpcy5yIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuZyAmJiB0aGlzLmcgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5iICYmIHRoaXMuYiA8IDI1NS41KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBoZXg6IHJnYl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogcmdiX2Zvcm1hdEhleCxcbiAgZm9ybWF0SGV4ODogcmdiX2Zvcm1hdEhleDgsXG4gIGZvcm1hdFJnYjogcmdiX2Zvcm1hdFJnYixcbiAgdG9TdHJpbmc6IHJnYl9mb3JtYXRSZ2Jcbn0pKTtcblxuZnVuY3Rpb24gcmdiX2Zvcm1hdEhleCgpIHtcbiAgcmV0dXJuIGAjJHtoZXgodGhpcy5yKX0ke2hleCh0aGlzLmcpfSR7aGV4KHRoaXMuYil9YDtcbn1cblxuZnVuY3Rpb24gcmdiX2Zvcm1hdEhleDgoKSB7XG4gIHJldHVybiBgIyR7aGV4KHRoaXMucil9JHtoZXgodGhpcy5nKX0ke2hleCh0aGlzLmIpfSR7aGV4KChpc05hTih0aGlzLm9wYWNpdHkpID8gMSA6IHRoaXMub3BhY2l0eSkgKiAyNTUpfWA7XG59XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRSZ2IoKSB7XG4gIGNvbnN0IGEgPSBjbGFtcGEodGhpcy5vcGFjaXR5KTtcbiAgcmV0dXJuIGAke2EgPT09IDEgPyBcInJnYihcIiA6IFwicmdiYShcIn0ke2NsYW1waSh0aGlzLnIpfSwgJHtjbGFtcGkodGhpcy5nKX0sICR7Y2xhbXBpKHRoaXMuYil9JHthID09PSAxID8gXCIpXCIgOiBgLCAke2F9KWB9YDtcbn1cblxuZnVuY3Rpb24gY2xhbXBhKG9wYWNpdHkpIHtcbiAgcmV0dXJuIGlzTmFOKG9wYWNpdHkpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG9wYWNpdHkpKTtcbn1cblxuZnVuY3Rpb24gY2xhbXBpKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodmFsdWUpIHx8IDApKTtcbn1cblxuZnVuY3Rpb24gaGV4KHZhbHVlKSB7XG4gIHZhbHVlID0gY2xhbXBpKHZhbHVlKTtcbiAgcmV0dXJuICh2YWx1ZSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIHZhbHVlLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gaHNsYShoLCBzLCBsLCBhKSB7XG4gIGlmIChhIDw9IDApIGggPSBzID0gbCA9IE5hTjtcbiAgZWxzZSBpZiAobCA8PSAwIHx8IGwgPj0gMSkgaCA9IHMgPSBOYU47XG4gIGVsc2UgaWYgKHMgPD0gMCkgaCA9IE5hTjtcbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBuZXcgSHNsKG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IEhzbDtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBvO1xuICBvID0gby5yZ2IoKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBoID0gTmFOLFxuICAgICAgcyA9IG1heCAtIG1pbixcbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGlmIChzKSB7XG4gICAgaWYgKHIgPT09IG1heCkgaCA9IChnIC0gYikgLyBzICsgKGcgPCBiKSAqIDY7XG4gICAgZWxzZSBpZiAoZyA9PT0gbWF4KSBoID0gKGIgLSByKSAvIHMgKyAyO1xuICAgIGVsc2UgaCA9IChyIC0gZykgLyBzICsgNDtcbiAgICBzIC89IGwgPCAwLjUgPyBtYXggKyBtaW4gOiAyIC0gbWF4IC0gbWluO1xuICAgIGggKj0gNjA7XG4gIH0gZWxzZSB7XG4gICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaHNsQ29udmVydChoKSA6IG5ldyBIc2woaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBIc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEhzbCwgaHNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXIoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiKCkge1xuICAgIHZhciBoID0gdGhpcy5oICUgMzYwICsgKHRoaXMuaCA8IDApICogMzYwLFxuICAgICAgICBzID0gaXNOYU4oaCkgfHwgaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMsXG4gICAgICAgIGwgPSB0aGlzLmwsXG4gICAgICAgIG0yID0gbCArIChsIDwgMC41ID8gbCA6IDEgLSBsKSAqIHMsXG4gICAgICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGhzbDJyZ2IoaCA+PSAyNDAgPyBoIC0gMjQwIDogaCArIDEyMCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCA8IDEyMCA/IGggKyAyNDAgOiBoIC0gMTIwLCBtMSwgbTIpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfSxcbiAgY2xhbXAoKSB7XG4gICAgcmV0dXJuIG5ldyBIc2woY2xhbXBoKHRoaXMuaCksIGNsYW1wdCh0aGlzLnMpLCBjbGFtcHQodGhpcy5sKSwgY2xhbXBhKHRoaXMub3BhY2l0eSkpO1xuICB9LFxuICBkaXNwbGF5YWJsZSgpIHtcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5zICYmIHRoaXMucyA8PSAxIHx8IGlzTmFOKHRoaXMucykpXG4gICAgICAgICYmICgwIDw9IHRoaXMubCAmJiB0aGlzLmwgPD0gMSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgZm9ybWF0SHNsKCkge1xuICAgIGNvbnN0IGEgPSBjbGFtcGEodGhpcy5vcGFjaXR5KTtcbiAgICByZXR1cm4gYCR7YSA9PT0gMSA/IFwiaHNsKFwiIDogXCJoc2xhKFwifSR7Y2xhbXBoKHRoaXMuaCl9LCAke2NsYW1wdCh0aGlzLnMpICogMTAwfSUsICR7Y2xhbXB0KHRoaXMubCkgKiAxMDB9JSR7YSA9PT0gMSA/IFwiKVwiIDogYCwgJHthfSlgfWA7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24gY2xhbXBoKHZhbHVlKSB7XG4gIHZhbHVlID0gKHZhbHVlIHx8IDApICUgMzYwO1xuICByZXR1cm4gdmFsdWUgPCAwID8gdmFsdWUgKyAzNjAgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2xhbXB0KHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWx1ZSB8fCAwKSk7XG59XG5cbi8qIEZyb20gRnZEIDEzLjM3LCBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDMgKi9cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgbTEsIG0yKSB7XG4gIHJldHVybiAoaCA8IDYwID8gbTEgKyAobTIgLSBtMSkgKiBoIC8gNjBcbiAgICAgIDogaCA8IDE4MCA/IG0yXG4gICAgICA6IGggPCAyNDAgPyBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwXG4gICAgICA6IG0xKSAqIDI1NTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBmYWN0b3J5LCBwcm90b3R5cGUpIHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gZmFjdG9yeS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIHByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHBhcmVudCwgZGVmaW5pdGlvbikge1xuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgZm9yICh2YXIga2V5IGluIGRlZmluaXRpb24pIHByb3RvdHlwZVtrZXldID0gZGVmaW5pdGlvbltrZXldO1xuICByZXR1cm4gcHJvdG90eXBlO1xufVxuIiwidmFyIG5vb3AgPSB7dmFsdWU6ICgpID0+IHt9fTtcblxuZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgXyA9IHt9LCB0OyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEodCA9IGFyZ3VtZW50c1tpXSArIFwiXCIpIHx8ICh0IGluIF8pIHx8IC9bXFxzLl0vLnRlc3QodCkpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0KTtcbiAgICBfW3RdID0gW107XG4gIH1cbiAgcmV0dXJuIG5ldyBEaXNwYXRjaChfKTtcbn1cblxuZnVuY3Rpb24gRGlzcGF0Y2goXykge1xuICB0aGlzLl8gPSBfO1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMsIHR5cGVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICBpZiAodCAmJiAhdHlwZXMuaGFzT3duUHJvcGVydHkodCkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0KTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuRGlzcGF0Y2gucHJvdG90eXBlID0gZGlzcGF0Y2gucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlzcGF0Y2gsXG4gIG9uOiBmdW5jdGlvbih0eXBlbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgXyA9IHRoaXMuXyxcbiAgICAgICAgVCA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiwgXyksXG4gICAgICAgIHQsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IFQubGVuZ3RoO1xuXG4gICAgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmV0dXJuIHRoZSBjYWxsYmFjayBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSAmJiAodCA9IGdldChfW3RdLCB0eXBlbmFtZS5uYW1lKSkpIHJldHVybiB0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGEgdHlwZSB3YXMgc3BlY2lmaWVkLCBzZXQgdGhlIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICAvLyBPdGhlcndpc2UsIGlmIGEgbnVsbCBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZW1vdmUgY2FsbGJhY2tzIG9mIHRoZSBnaXZlbiBuYW1lLlxuICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIiArIGNhbGxiYWNrKTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrID09IG51bGwpIGZvciAodCBpbiBfKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29weSA9IHt9LCBfID0gdGhpcy5fO1xuICAgIGZvciAodmFyIHQgaW4gXykgY29weVt0XSA9IF9bdF0uc2xpY2UoKTtcbiAgICByZXR1cm4gbmV3IERpc3BhdGNoKGNvcHkpO1xuICB9LFxuICBjYWxsOiBmdW5jdGlvbih0eXBlLCB0aGF0KSB7XG4gICAgaWYgKChuID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgYXJncyA9IG5ldyBBcnJheShuKSwgaSA9IDAsIG4sIHQ7IGkgPCBuOyArK2kpIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24odHlwZSwgdGhhdCwgYXJncykge1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh2YXIgdCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0KHR5cGUsIG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aCwgYzsgaSA8IG47ICsraSkge1xuICAgIGlmICgoYyA9IHR5cGVbaV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQodHlwZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmICh0eXBlW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHR5cGVbaV0gPSBub29wLCB0eXBlID0gdHlwZS5zbGljZSgwLCBpKS5jb25jYXQodHlwZS5zbGljZShpICsgMSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB0eXBlLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiBjYWxsYmFja30pO1xuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGlzcGF0Y2g7XG4iLCJpbXBvcnQge3NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IG5vZXZlbnQsIHtub25wYXNzaXZlY2FwdHVyZX0gZnJvbSBcIi4vbm9ldmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2aWV3KSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBzZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBub2V2ZW50LCBub25wYXNzaXZlY2FwdHVyZSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fX25vc2VsZWN0ID0gcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0O1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IFwibm9uZVwiO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5ZXNkcmFnKHZpZXcsIG5vY2xpY2spIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG51bGwpO1xuICBpZiAobm9jbGljaykge1xuICAgIHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbm9ldmVudCwgbm9ucGFzc2l2ZWNhcHR1cmUpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbnVsbCk7IH0sIDApO1xuICB9XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSByb290Ll9fbm9zZWxlY3Q7XG4gICAgZGVsZXRlIHJvb3QuX19ub3NlbGVjdDtcbiAgfVxufVxuIiwiLy8gVGhlc2UgYXJlIHR5cGljYWxseSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggbm9ldmVudCB0byBlbnN1cmUgdGhhdCB3ZSBjYW5cbi8vIHByZXZlbnREZWZhdWx0IG9uIHRoZSBldmVudC5cbmV4cG9ydCBjb25zdCBub25wYXNzaXZlID0ge3Bhc3NpdmU6IGZhbHNlfTtcbmV4cG9ydCBjb25zdCBub25wYXNzaXZlY2FwdHVyZSA9IHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiBmYWxzZX07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3Byb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cbiIsImltcG9ydCBkc3YgZnJvbSBcIi4vZHN2LmpzXCI7XG5cbnZhciBjc3YgPSBkc3YoXCIsXCIpO1xuXG5leHBvcnQgdmFyIGNzdlBhcnNlID0gY3N2LnBhcnNlO1xuZXhwb3J0IHZhciBjc3ZQYXJzZVJvd3MgPSBjc3YucGFyc2VSb3dzO1xuZXhwb3J0IHZhciBjc3ZGb3JtYXQgPSBjc3YuZm9ybWF0O1xuZXhwb3J0IHZhciBjc3ZGb3JtYXRCb2R5ID0gY3N2LmZvcm1hdEJvZHk7XG5leHBvcnQgdmFyIGNzdkZvcm1hdFJvd3MgPSBjc3YuZm9ybWF0Um93cztcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0Um93ID0gY3N2LmZvcm1hdFJvdztcbmV4cG9ydCB2YXIgY3N2Rm9ybWF0VmFsdWUgPSBjc3YuZm9ybWF0VmFsdWU7XG4iLCJ2YXIgRU9MID0ge30sXG4gICAgRU9GID0ge30sXG4gICAgUVVPVEUgPSAzNCxcbiAgICBORVdMSU5FID0gMTAsXG4gICAgUkVUVVJOID0gMTM7XG5cbmZ1bmN0aW9uIG9iamVjdENvbnZlcnRlcihjb2x1bW5zKSB7XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIGNvbHVtbnMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobmFtZSkgKyBcIjogZFtcIiArIGkgKyBcIl0gfHwgXFxcIlxcXCJcIjtcbiAgfSkuam9pbihcIixcIikgKyBcIn1cIik7XG59XG5cbmZ1bmN0aW9uIGN1c3RvbUNvbnZlcnRlcihjb2x1bW5zLCBmKSB7XG4gIHZhciBvYmplY3QgPSBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucyk7XG4gIHJldHVybiBmdW5jdGlvbihyb3csIGkpIHtcbiAgICByZXR1cm4gZihvYmplY3Qocm93KSwgaSwgY29sdW1ucyk7XG4gIH07XG59XG5cbi8vIENvbXB1dGUgdW5pcXVlIGNvbHVtbnMgaW4gb3JkZXIgb2YgZGlzY292ZXJ5LlxuZnVuY3Rpb24gaW5mZXJDb2x1bW5zKHJvd3MpIHtcbiAgdmFyIGNvbHVtblNldCA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBjb2x1bW5zID0gW107XG5cbiAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgIGZvciAodmFyIGNvbHVtbiBpbiByb3cpIHtcbiAgICAgIGlmICghKGNvbHVtbiBpbiBjb2x1bW5TZXQpKSB7XG4gICAgICAgIGNvbHVtbnMucHVzaChjb2x1bW5TZXRbY29sdW1uXSA9IGNvbHVtbik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29sdW1ucztcbn1cblxuZnVuY3Rpb24gcGFkKHZhbHVlLCB3aWR0aCkge1xuICB2YXIgcyA9IHZhbHVlICsgXCJcIiwgbGVuZ3RoID0gcy5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oMCkgKyBzIDogcztcbn1cblxuZnVuY3Rpb24gZm9ybWF0WWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyIDwgMCA/IFwiLVwiICsgcGFkKC15ZWFyLCA2KVxuICAgIDogeWVhciA+IDk5OTkgPyBcIitcIiArIHBhZCh5ZWFyLCA2KVxuICAgIDogcGFkKHllYXIsIDQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpLFxuICAgICAgbWludXRlcyA9IGRhdGUuZ2V0VVRDTWludXRlcygpLFxuICAgICAgc2Vjb25kcyA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgbWlsbGlzZWNvbmRzID0gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgcmV0dXJuIGlzTmFOKGRhdGUpID8gXCJJbnZhbGlkIERhdGVcIlxuICAgICAgOiBmb3JtYXRZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgNCkgKyBcIi1cIiArIHBhZChkYXRlLmdldFVUQ01vbnRoKCkgKyAxLCAyKSArIFwiLVwiICsgcGFkKGRhdGUuZ2V0VVRDRGF0ZSgpLCAyKVxuICAgICAgKyAobWlsbGlzZWNvbmRzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIjpcIiArIHBhZChzZWNvbmRzLCAyKSArIFwiLlwiICsgcGFkKG1pbGxpc2Vjb25kcywgMykgKyBcIlpcIlxuICAgICAgOiBzZWNvbmRzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIjpcIiArIHBhZChzZWNvbmRzLCAyKSArIFwiWlwiXG4gICAgICA6IG1pbnV0ZXMgfHwgaG91cnMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiWlwiXG4gICAgICA6IFwiXCIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkZWxpbWl0ZXIpIHtcbiAgdmFyIHJlRm9ybWF0ID0gbmV3IFJlZ0V4cChcIltcXFwiXCIgKyBkZWxpbWl0ZXIgKyBcIlxcblxccl1cIiksXG4gICAgICBERUxJTUlURVIgPSBkZWxpbWl0ZXIuY2hhckNvZGVBdCgwKTtcblxuICBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBmKSB7XG4gICAgdmFyIGNvbnZlcnQsIGNvbHVtbnMsIHJvd3MgPSBwYXJzZVJvd3ModGV4dCwgZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgICBpZiAoY29udmVydCkgcmV0dXJuIGNvbnZlcnQocm93LCBpIC0gMSk7XG4gICAgICBjb2x1bW5zID0gcm93LCBjb252ZXJ0ID0gZiA/IGN1c3RvbUNvbnZlcnRlcihyb3csIGYpIDogb2JqZWN0Q29udmVydGVyKHJvdyk7XG4gICAgfSk7XG4gICAgcm93cy5jb2x1bW5zID0gY29sdW1ucyB8fCBbXTtcbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUm93cyh0ZXh0LCBmKSB7XG4gICAgdmFyIHJvd3MgPSBbXSwgLy8gb3V0cHV0IHJvd3NcbiAgICAgICAgTiA9IHRleHQubGVuZ3RoLFxuICAgICAgICBJID0gMCwgLy8gY3VycmVudCBjaGFyYWN0ZXIgaW5kZXhcbiAgICAgICAgbiA9IDAsIC8vIGN1cnJlbnQgbGluZSBudW1iZXJcbiAgICAgICAgdCwgLy8gY3VycmVudCB0b2tlblxuICAgICAgICBlb2YgPSBOIDw9IDAsIC8vIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9GP1xuICAgICAgICBlb2wgPSBmYWxzZTsgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0w/XG5cbiAgICAvLyBTdHJpcCB0aGUgdHJhaWxpbmcgbmV3bGluZS5cbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KE4gLSAxKSA9PT0gTkVXTElORSkgLS1OO1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBSRVRVUk4pIC0tTjtcblxuICAgIGZ1bmN0aW9uIHRva2VuKCkge1xuICAgICAgaWYgKGVvZikgcmV0dXJuIEVPRjtcbiAgICAgIGlmIChlb2wpIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MO1xuXG4gICAgICAvLyBVbmVzY2FwZSBxdW90ZXMuXG4gICAgICB2YXIgaSwgaiA9IEksIGM7XG4gICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGopID09PSBRVU9URSkge1xuICAgICAgICB3aGlsZSAoSSsrIDwgTiAmJiB0ZXh0LmNoYXJDb2RlQXQoSSkgIT09IFFVT1RFIHx8IHRleHQuY2hhckNvZGVBdCgrK0kpID09PSBRVU9URSk7XG4gICAgICAgIGlmICgoaSA9IEkpID49IE4pIGVvZiA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKChjID0gdGV4dC5jaGFyQ29kZUF0KEkrKykpID09PSBORVdMSU5FKSBlb2wgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gTkVXTElORSkgKytJOyB9XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGogKyAxLCBpIC0gMSkucmVwbGFjZSgvXCJcIi9nLCBcIlxcXCJcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgbmV4dCBkZWxpbWl0ZXIgb3IgbmV3bGluZS5cbiAgICAgIHdoaWxlIChJIDwgTikge1xuICAgICAgICBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSA9IEkrKykpID09PSBORVdMSU5FKSBlb2wgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gTkVXTElORSkgKytJOyB9XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IERFTElNSVRFUikgY29udGludWU7XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGosIGkpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gbGFzdCB0b2tlbiBiZWZvcmUgRU9GLlxuICAgICAgcmV0dXJuIGVvZiA9IHRydWUsIHRleHQuc2xpY2UoaiwgTik7XG4gICAgfVxuXG4gICAgd2hpbGUgKCh0ID0gdG9rZW4oKSkgIT09IEVPRikge1xuICAgICAgdmFyIHJvdyA9IFtdO1xuICAgICAgd2hpbGUgKHQgIT09IEVPTCAmJiB0ICE9PSBFT0YpIHJvdy5wdXNoKHQpLCB0ID0gdG9rZW4oKTtcbiAgICAgIGlmIChmICYmIChyb3cgPSBmKHJvdywgbisrKSkgPT0gbnVsbCkgY29udGludWU7XG4gICAgICByb3dzLnB1c2gocm93KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiByb3dzLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKHJvd1tjb2x1bW5dKTtcbiAgICAgIH0pLmpvaW4oZGVsaW1pdGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdChyb3dzLCBjb2x1bW5zKSB7XG4gICAgaWYgKGNvbHVtbnMgPT0gbnVsbCkgY29sdW1ucyA9IGluZmVyQ29sdW1ucyhyb3dzKTtcbiAgICByZXR1cm4gW2NvbHVtbnMubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcildLmNvbmNhdChwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSB7XG4gICAgaWYgKGNvbHVtbnMgPT0gbnVsbCkgY29sdW1ucyA9IGluZmVyQ29sdW1ucyhyb3dzKTtcbiAgICByZXR1cm4gcHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um93cyhyb3dzKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKGZvcm1hdFJvdykuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvdyhyb3cpIHtcbiAgICByZXR1cm4gcm93Lm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCJcbiAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyBmb3JtYXREYXRlKHZhbHVlKVxuICAgICAgICA6IHJlRm9ybWF0LnRlc3QodmFsdWUgKz0gXCJcIikgPyBcIlxcXCJcIiArIHZhbHVlLnJlcGxhY2UoL1wiL2csIFwiXFxcIlxcXCJcIikgKyBcIlxcXCJcIlxuICAgICAgICA6IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgcGFyc2VSb3dzOiBwYXJzZVJvd3MsXG4gICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgZm9ybWF0Qm9keTogZm9ybWF0Qm9keSxcbiAgICBmb3JtYXRSb3dzOiBmb3JtYXRSb3dzLFxuICAgIGZvcm1hdFJvdzogZm9ybWF0Um93LFxuICAgIGZvcm1hdFZhbHVlOiBmb3JtYXRWYWx1ZVxuICB9O1xufVxuIiwiaW1wb3J0IGRzdiBmcm9tIFwiLi9kc3YuanNcIjtcblxudmFyIHRzdiA9IGRzdihcIlxcdFwiKTtcblxuZXhwb3J0IHZhciB0c3ZQYXJzZSA9IHRzdi5wYXJzZTtcbmV4cG9ydCB2YXIgdHN2UGFyc2VSb3dzID0gdHN2LnBhcnNlUm93cztcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0ID0gdHN2LmZvcm1hdDtcbmV4cG9ydCB2YXIgdHN2Rm9ybWF0Qm9keSA9IHRzdi5mb3JtYXRCb2R5O1xuZXhwb3J0IHZhciB0c3ZGb3JtYXRSb3dzID0gdHN2LmZvcm1hdFJvd3M7XG5leHBvcnQgdmFyIHRzdkZvcm1hdFJvdyA9IHRzdi5mb3JtYXRSb3c7XG5leHBvcnQgdmFyIHRzdkZvcm1hdFZhbHVlID0gdHN2LmZvcm1hdFZhbHVlO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW4odCkge1xuICByZXR1cm4gdCAqIHQgKiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNPdXQodCkge1xuICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG59XG4iLCJpbXBvcnQge2NzdlBhcnNlLCBkc3ZGb3JtYXQsIHRzdlBhcnNlfSBmcm9tIFwiZDMtZHN2XCI7XG5pbXBvcnQgdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5cbmZ1bmN0aW9uIGRzdlBhcnNlKHBhcnNlKSB7XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaW5pdCwgcm93KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGluaXQgPT09IFwiZnVuY3Rpb25cIikgcm93ID0gaW5pdCwgaW5pdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGV4dChpbnB1dCwgaW5pdCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHBhcnNlKHJlc3BvbnNlLCByb3cpO1xuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkc3YoZGVsaW1pdGVyLCBpbnB1dCwgaW5pdCwgcm93KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBpbml0ID09PSBcImZ1bmN0aW9uXCIpIHJvdyA9IGluaXQsIGluaXQgPSB1bmRlZmluZWQ7XG4gIHZhciBmb3JtYXQgPSBkc3ZGb3JtYXQoZGVsaW1pdGVyKTtcbiAgcmV0dXJuIHRleHQoaW5wdXQsIGluaXQpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gZm9ybWF0LnBhcnNlKHJlc3BvbnNlLCByb3cpO1xuICB9KTtcbn1cblxuZXhwb3J0IHZhciBjc3YgPSBkc3ZQYXJzZShjc3ZQYXJzZSk7XG5leHBvcnQgdmFyIHRzdiA9IGRzdlBhcnNlKHRzdlBhcnNlKTtcbiIsImZ1bmN0aW9uIHJlc3BvbnNlSnNvbihyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgXCIgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA1KSByZXR1cm47XG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gIHJldHVybiBmZXRjaChpbnB1dCwgaW5pdCkudGhlbihyZXNwb25zZUpzb24pO1xufVxuIiwiZnVuY3Rpb24gcmVzcG9uc2VUZXh0KHJlc3BvbnNlKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyBcIiBcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gZmV0Y2goaW5wdXQsIGluaXQpLnRoZW4ocmVzcG9uc2VUZXh0KTtcbn1cbiIsImltcG9ydCBmb3JtYXRMb2NhbGUgZnJvbSBcIi4vbG9jYWxlLmpzXCI7XG5cbnZhciBsb2NhbGU7XG5leHBvcnQgdmFyIGZvcm1hdDtcbmV4cG9ydCB2YXIgZm9ybWF0UHJlZml4O1xuXG5kZWZhdWx0TG9jYWxlKHtcbiAgdGhvdXNhbmRzOiBcIixcIixcbiAgZ3JvdXBpbmc6IFszXSxcbiAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgbG9jYWxlID0gZm9ybWF0TG9jYWxlKGRlZmluaXRpb24pO1xuICBmb3JtYXQgPSBsb2NhbGUuZm9ybWF0O1xuICBmb3JtYXRQcmVmaXggPSBsb2NhbGUuZm9ybWF0UHJlZml4O1xuICByZXR1cm4gbG9jYWxlO1xufVxuIiwiaW1wb3J0IHtmb3JtYXREZWNpbWFsUGFydHN9IGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCA9IGZvcm1hdERlY2ltYWxQYXJ0cyhNYXRoLmFicyh4KSksIHggPyB4WzFdIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gTWF0aC5hYnMoeCA9IE1hdGgucm91bmQoeCkpID49IDFlMjFcbiAgICAgID8geC50b0xvY2FsZVN0cmluZyhcImVuXCIpLnJlcGxhY2UoLywvZywgXCJcIilcbiAgICAgIDogeC50b1N0cmluZygxMCk7XG59XG5cbi8vIENvbXB1dGVzIHRoZSBkZWNpbWFsIGNvZWZmaWNpZW50IGFuZCBleHBvbmVudCBvZiB0aGUgc3BlY2lmaWVkIG51bWJlciB4IHdpdGhcbi8vIHNpZ25pZmljYW50IGRpZ2l0cyBwLCB3aGVyZSB4IGlzIHBvc2l0aXZlIGFuZCBwIGlzIGluIFsxLCAyMV0gb3IgdW5kZWZpbmVkLlxuLy8gRm9yIGV4YW1wbGUsIGZvcm1hdERlY2ltYWxQYXJ0cygxLjIzKSByZXR1cm5zIFtcIjEyM1wiLCAwXS5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREZWNpbWFsUGFydHMoeCwgcCkge1xuICBpZiAoKGkgPSAoeCA9IHAgPyB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyAvLyBOYU4sIMKxSW5maW5pdHlcbiAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcblxuICAvLyBUaGUgc3RyaW5nIHJldHVybmVkIGJ5IHRvRXhwb25lbnRpYWwgZWl0aGVyIGhhcyB0aGUgZm9ybSBcXGRcXC5cXGQrZVstK11cXGQrXG4gIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXG4gIHJldHVybiBbXG4gICAgY29lZmZpY2llbnQubGVuZ3RoID4gMSA/IGNvZWZmaWNpZW50WzBdICsgY29lZmZpY2llbnQuc2xpY2UoMikgOiBjb2VmZmljaWVudCxcbiAgICAreC5zbGljZShpICsgMSlcbiAgXTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGdyb3VwaW5nLCB0aG91c2FuZHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCB3aWR0aCkge1xuICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICB0ID0gW10sXG4gICAgICAgIGogPSAwLFxuICAgICAgICBnID0gZ3JvdXBpbmdbMF0sXG4gICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICB3aGlsZSAoaSA+IDAgJiYgZyA+IDApIHtcbiAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgdC5wdXNoKHZhbHVlLnN1YnN0cmluZyhpIC09IGcsIGkgKyBnKSk7XG4gICAgICBpZiAoKGxlbmd0aCArPSBnICsgMSkgPiB3aWR0aCkgYnJlYWs7XG4gICAgICBnID0gZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBncm91cGluZy5sZW5ndGhdO1xuICAgIH1cblxuICAgIHJldHVybiB0LnJldmVyc2UoKS5qb2luKHRob3VzYW5kcyk7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihudW1lcmFscykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWzAtOV0vZywgZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIG51bWVyYWxzWytpXTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCB2YXIgcHJlZml4RXhwb25lbnQ7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsUGFydHMoeCwgcCk7XG4gIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgZXhwb25lbnQgPSBkWzFdLFxuICAgICAgaSA9IGV4cG9uZW50IC0gKHByZWZpeEV4cG9uZW50ID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQgLyAzKSkpICogMykgKyAxLFxuICAgICAgbiA9IGNvZWZmaWNpZW50Lmxlbmd0aDtcbiAgcmV0dXJuIGkgPT09IG4gPyBjb2VmZmljaWVudFxuICAgICAgOiBpID4gbiA/IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGkgLSBuICsgMSkuam9pbihcIjBcIilcbiAgICAgIDogaSA+IDAgPyBjb2VmZmljaWVudC5zbGljZSgwLCBpKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoaSlcbiAgICAgIDogXCIwLlwiICsgbmV3IEFycmF5KDEgLSBpKS5qb2luKFwiMFwiKSArIGZvcm1hdERlY2ltYWxQYXJ0cyh4LCBNYXRoLm1heCgwLCBwICsgaSAtIDEpKVswXTsgLy8gbGVzcyB0aGFuIDF5IVxufVxuIiwiaW1wb3J0IHtmb3JtYXREZWNpbWFsUGFydHN9IGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgcCkge1xuICB2YXIgZCA9IGZvcm1hdERlY2ltYWxQYXJ0cyh4LCBwKTtcbiAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICBleHBvbmVudCA9IGRbMV07XG4gIHJldHVybiBleHBvbmVudCA8IDAgPyBcIjAuXCIgKyBuZXcgQXJyYXkoLWV4cG9uZW50KS5qb2luKFwiMFwiKSArIGNvZWZmaWNpZW50XG4gICAgICA6IGNvZWZmaWNpZW50Lmxlbmd0aCA+IGV4cG9uZW50ICsgMSA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGV4cG9uZW50ICsgMSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGV4cG9uZW50ICsgMSlcbiAgICAgIDogY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoZXhwb25lbnQgLSBjb2VmZmljaWVudC5sZW5ndGggKyAyKS5qb2luKFwiMFwiKTtcbn1cbiIsIi8vIFtbZmlsbF1hbGlnbl1bc2lnbl1bc3ltYm9sXVswXVt3aWR0aF1bLF1bLnByZWNpc2lvbl1bfl1bdHlwZV1cbnZhciByZSA9IC9eKD86KC4pPyhbPD49Xl0pKT8oWytcXC0oIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KH4pPyhbYS16JV0pPyQvaTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICBpZiAoIShtYXRjaCA9IHJlLmV4ZWMoc3BlY2lmaWVyKSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0OiBcIiArIHNwZWNpZmllcik7XG4gIHZhciBtYXRjaDtcbiAgcmV0dXJuIG5ldyBGb3JtYXRTcGVjaWZpZXIoe1xuICAgIGZpbGw6IG1hdGNoWzFdLFxuICAgIGFsaWduOiBtYXRjaFsyXSxcbiAgICBzaWduOiBtYXRjaFszXSxcbiAgICBzeW1ib2w6IG1hdGNoWzRdLFxuICAgIHplcm86IG1hdGNoWzVdLFxuICAgIHdpZHRoOiBtYXRjaFs2XSxcbiAgICBjb21tYTogbWF0Y2hbN10sXG4gICAgcHJlY2lzaW9uOiBtYXRjaFs4XSAmJiBtYXRjaFs4XS5zbGljZSgxKSxcbiAgICB0cmltOiBtYXRjaFs5XSxcbiAgICB0eXBlOiBtYXRjaFsxMF1cbiAgfSk7XG59XG5cbmZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUgPSBGb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlOyAvLyBpbnN0YW5jZW9mXG5cbmV4cG9ydCBmdW5jdGlvbiBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gIHRoaXMuZmlsbCA9IHNwZWNpZmllci5maWxsID09PSB1bmRlZmluZWQgPyBcIiBcIiA6IHNwZWNpZmllci5maWxsICsgXCJcIjtcbiAgdGhpcy5hbGlnbiA9IHNwZWNpZmllci5hbGlnbiA9PT0gdW5kZWZpbmVkID8gXCI+XCIgOiBzcGVjaWZpZXIuYWxpZ24gKyBcIlwiO1xuICB0aGlzLnNpZ24gPSBzcGVjaWZpZXIuc2lnbiA9PT0gdW5kZWZpbmVkID8gXCItXCIgOiBzcGVjaWZpZXIuc2lnbiArIFwiXCI7XG4gIHRoaXMuc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHNwZWNpZmllci5zeW1ib2wgKyBcIlwiO1xuICB0aGlzLnplcm8gPSAhIXNwZWNpZmllci56ZXJvO1xuICB0aGlzLndpZHRoID0gc3BlY2lmaWVyLndpZHRoID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiArc3BlY2lmaWVyLndpZHRoO1xuICB0aGlzLmNvbW1hID0gISFzcGVjaWZpZXIuY29tbWE7XG4gIHRoaXMucHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogK3NwZWNpZmllci5wcmVjaXNpb247XG4gIHRoaXMudHJpbSA9ICEhc3BlY2lmaWVyLnRyaW07XG4gIHRoaXMudHlwZSA9IHNwZWNpZmllci50eXBlID09PSB1bmRlZmluZWQgPyBcIlwiIDogc3BlY2lmaWVyLnR5cGUgKyBcIlwiO1xufVxuXG5Gb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZpbGxcbiAgICAgICsgdGhpcy5hbGlnblxuICAgICAgKyB0aGlzLnNpZ25cbiAgICAgICsgdGhpcy5zeW1ib2xcbiAgICAgICsgKHRoaXMuemVybyA/IFwiMFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBNYXRoLm1heCgxLCB0aGlzLndpZHRoIHwgMCkpXG4gICAgICArICh0aGlzLmNvbW1hID8gXCIsXCIgOiBcIlwiKVxuICAgICAgKyAodGhpcy5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBcIi5cIiArIE1hdGgubWF4KDAsIHRoaXMucHJlY2lzaW9uIHwgMCkpXG4gICAgICArICh0aGlzLnRyaW0gPyBcIn5cIiA6IFwiXCIpXG4gICAgICArIHRoaXMudHlwZTtcbn07XG4iLCIvLyBUcmltcyBpbnNpZ25pZmljYW50IHplcm9zLCBlLmcuLCByZXBsYWNlcyAxLjIwMDBrIHdpdGggMS4yay5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHMpIHtcbiAgb3V0OiBmb3IgKHZhciBuID0gcy5sZW5ndGgsIGkgPSAxLCBpMCA9IC0xLCBpMTsgaSA8IG47ICsraSkge1xuICAgIHN3aXRjaCAoc1tpXSkge1xuICAgICAgY2FzZSBcIi5cIjogaTAgPSBpMSA9IGk7IGJyZWFrO1xuICAgICAgY2FzZSBcIjBcIjogaWYgKGkwID09PSAwKSBpMCA9IGk7IGkxID0gaTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBpZiAoIStzW2ldKSBicmVhayBvdXQ7IGlmIChpMCA+IDApIGkwID0gMDsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpMCA+IDAgPyBzLnNsaWNlKDAsIGkwKSArIHMuc2xpY2UoaTEgKyAxKSA6IHM7XG59XG4iLCJpbXBvcnQgZm9ybWF0RGVjaW1hbCBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5pbXBvcnQgZm9ybWF0UHJlZml4QXV0byBmcm9tIFwiLi9mb3JtYXRQcmVmaXhBdXRvLmpzXCI7XG5pbXBvcnQgZm9ybWF0Um91bmRlZCBmcm9tIFwiLi9mb3JtYXRSb3VuZGVkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgXCIlXCI6ICh4LCBwKSA9PiAoeCAqIDEwMCkudG9GaXhlZChwKSxcbiAgXCJiXCI6ICh4KSA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDIpLFxuICBcImNcIjogKHgpID0+IHggKyBcIlwiLFxuICBcImRcIjogZm9ybWF0RGVjaW1hbCxcbiAgXCJlXCI6ICh4LCBwKSA9PiB4LnRvRXhwb25lbnRpYWwocCksXG4gIFwiZlwiOiAoeCwgcCkgPT4geC50b0ZpeGVkKHApLFxuICBcImdcIjogKHgsIHApID0+IHgudG9QcmVjaXNpb24ocCksXG4gIFwib1wiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZyg4KSxcbiAgXCJwXCI6ICh4LCBwKSA9PiBmb3JtYXRSb3VuZGVkKHggKiAxMDAsIHApLFxuICBcInJcIjogZm9ybWF0Um91bmRlZCxcbiAgXCJzXCI6IGZvcm1hdFByZWZpeEF1dG8sXG4gIFwiWFwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSxcbiAgXCJ4XCI6ICh4KSA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59XG4iLCJpbXBvcnQgZXhwb25lbnQgZnJvbSBcIi4vZXhwb25lbnQuanNcIjtcbmltcG9ydCBmb3JtYXRHcm91cCBmcm9tIFwiLi9mb3JtYXRHcm91cC5qc1wiO1xuaW1wb3J0IGZvcm1hdE51bWVyYWxzIGZyb20gXCIuL2Zvcm1hdE51bWVyYWxzLmpzXCI7XG5pbXBvcnQgZm9ybWF0U3BlY2lmaWVyIGZyb20gXCIuL2Zvcm1hdFNwZWNpZmllci5qc1wiO1xuaW1wb3J0IGZvcm1hdFRyaW0gZnJvbSBcIi4vZm9ybWF0VHJpbS5qc1wiO1xuaW1wb3J0IGZvcm1hdFR5cGVzIGZyb20gXCIuL2Zvcm1hdFR5cGVzLmpzXCI7XG5pbXBvcnQge3ByZWZpeEV4cG9uZW50fSBmcm9tIFwiLi9mb3JtYXRQcmVmaXhBdXRvLmpzXCI7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxudmFyIG1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXAsXG4gICAgcHJlZml4ZXMgPSBbXCJ5XCIsXCJ6XCIsXCJhXCIsXCJmXCIsXCJwXCIsXCJuXCIsXCLCtVwiLFwibVwiLFwiXCIsXCJrXCIsXCJNXCIsXCJHXCIsXCJUXCIsXCJQXCIsXCJFXCIsXCJaXCIsXCJZXCJdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihsb2NhbGUpIHtcbiAgdmFyIGdyb3VwID0gbG9jYWxlLmdyb3VwaW5nID09PSB1bmRlZmluZWQgfHwgbG9jYWxlLnRob3VzYW5kcyA9PT0gdW5kZWZpbmVkID8gaWRlbnRpdHkgOiBmb3JtYXRHcm91cChtYXAuY2FsbChsb2NhbGUuZ3JvdXBpbmcsIE51bWJlciksIGxvY2FsZS50aG91c2FuZHMgKyBcIlwiKSxcbiAgICAgIGN1cnJlbmN5UHJlZml4ID0gbG9jYWxlLmN1cnJlbmN5ID09PSB1bmRlZmluZWQgPyBcIlwiIDogbG9jYWxlLmN1cnJlbmN5WzBdICsgXCJcIixcbiAgICAgIGN1cnJlbmN5U3VmZml4ID0gbG9jYWxlLmN1cnJlbmN5ID09PSB1bmRlZmluZWQgPyBcIlwiIDogbG9jYWxlLmN1cnJlbmN5WzFdICsgXCJcIixcbiAgICAgIGRlY2ltYWwgPSBsb2NhbGUuZGVjaW1hbCA9PT0gdW5kZWZpbmVkID8gXCIuXCIgOiBsb2NhbGUuZGVjaW1hbCArIFwiXCIsXG4gICAgICBudW1lcmFscyA9IGxvY2FsZS5udW1lcmFscyA9PT0gdW5kZWZpbmVkID8gaWRlbnRpdHkgOiBmb3JtYXROdW1lcmFscyhtYXAuY2FsbChsb2NhbGUubnVtZXJhbHMsIFN0cmluZykpLFxuICAgICAgcGVyY2VudCA9IGxvY2FsZS5wZXJjZW50ID09PSB1bmRlZmluZWQgPyBcIiVcIiA6IGxvY2FsZS5wZXJjZW50ICsgXCJcIixcbiAgICAgIG1pbnVzID0gbG9jYWxlLm1pbnVzID09PSB1bmRlZmluZWQgPyBcIuKIklwiIDogbG9jYWxlLm1pbnVzICsgXCJcIixcbiAgICAgIG5hbiA9IGxvY2FsZS5uYW4gPT09IHVuZGVmaW5lZCA/IFwiTmFOXCIgOiBsb2NhbGUubmFuICsgXCJcIjtcblxuICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyKSB7XG4gICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG5cbiAgICB2YXIgZmlsbCA9IHNwZWNpZmllci5maWxsLFxuICAgICAgICBhbGlnbiA9IHNwZWNpZmllci5hbGlnbixcbiAgICAgICAgc2lnbiA9IHNwZWNpZmllci5zaWduLFxuICAgICAgICBzeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sLFxuICAgICAgICB6ZXJvID0gc3BlY2lmaWVyLnplcm8sXG4gICAgICAgIHdpZHRoID0gc3BlY2lmaWVyLndpZHRoLFxuICAgICAgICBjb21tYSA9IHNwZWNpZmllci5jb21tYSxcbiAgICAgICAgcHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbixcbiAgICAgICAgdHJpbSA9IHNwZWNpZmllci50cmltLFxuICAgICAgICB0eXBlID0gc3BlY2lmaWVyLnR5cGU7XG5cbiAgICAvLyBUaGUgXCJuXCIgdHlwZSBpcyBhbiBhbGlhcyBmb3IgXCIsZ1wiLlxuICAgIGlmICh0eXBlID09PSBcIm5cIikgY29tbWEgPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBUaGUgXCJcIiB0eXBlLCBhbmQgYW55IGludmFsaWQgdHlwZSwgaXMgYW4gYWxpYXMgZm9yIFwiLjEyfmdcIi5cbiAgICBlbHNlIGlmICghZm9ybWF0VHlwZXNbdHlwZV0pIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkICYmIChwcmVjaXNpb24gPSAxMiksIHRyaW0gPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBJZiB6ZXJvIGZpbGwgaXMgc3BlY2lmaWVkLCBwYWRkaW5nIGdvZXMgYWZ0ZXIgc2lnbiBhbmQgYmVmb3JlIGRpZ2l0cy5cbiAgICBpZiAoemVybyB8fCAoZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSkgemVybyA9IHRydWUsIGZpbGwgPSBcIjBcIiwgYWxpZ24gPSBcIj1cIjtcblxuICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgIC8vIEZvciBTSS1wcmVmaXgsIHRoZSBzdWZmaXggaXMgbGF6aWx5IGNvbXB1dGVkLlxuICAgIHZhciBwcmVmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lQcmVmaXggOiBzeW1ib2wgPT09IFwiI1wiICYmIC9bYm94WF0vLnRlc3QodHlwZSkgPyBcIjBcIiArIHR5cGUudG9Mb3dlckNhc2UoKSA6IFwiXCIsXG4gICAgICAgIHN1ZmZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVN1ZmZpeCA6IC9bJXBdLy50ZXN0KHR5cGUpID8gcGVyY2VudCA6IFwiXCI7XG5cbiAgICAvLyBXaGF0IGZvcm1hdCBmdW5jdGlvbiBzaG91bGQgd2UgdXNlP1xuICAgIC8vIElzIHRoaXMgYW4gaW50ZWdlciB0eXBlP1xuICAgIC8vIENhbiB0aGlzIHR5cGUgZ2VuZXJhdGUgZXhwb25lbnRpYWwgbm90YXRpb24/XG4gICAgdmFyIGZvcm1hdFR5cGUgPSBmb3JtYXRUeXBlc1t0eXBlXSxcbiAgICAgICAgbWF5YmVTdWZmaXggPSAvW2RlZmdwcnMlXS8udGVzdCh0eXBlKTtcblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdCBwcmVjaXNpb24gaWYgbm90IHNwZWNpZmllZCxcbiAgICAvLyBvciBjbGFtcCB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbiB0byB0aGUgc3VwcG9ydGVkIHJhbmdlLlxuICAgIC8vIEZvciBzaWduaWZpY2FudCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzEsIDIxXS5cbiAgICAvLyBGb3IgZml4ZWQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFswLCAyMF0uXG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyA2XG4gICAgICAgIDogL1tncHJzXS8udGVzdCh0eXBlKSA/IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKVxuICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgdmFyIHZhbHVlUHJlZml4ID0gcHJlZml4LFxuICAgICAgICAgIHZhbHVlU3VmZml4ID0gc3VmZml4LFxuICAgICAgICAgIGksIG4sIGM7XG5cbiAgICAgIGlmICh0eXBlID09PSBcImNcIikge1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9IGZvcm1hdFR5cGUodmFsdWUpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgc2lnbi4gLTAgaXMgbm90IGxlc3MgdGhhbiAwLCBidXQgMSAvIC0wIGlzIVxuICAgICAgICB2YXIgdmFsdWVOZWdhdGl2ZSA9IHZhbHVlIDwgMCB8fCAxIC8gdmFsdWUgPCAwO1xuXG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGluaXRpYWwgZm9ybWF0dGluZy5cbiAgICAgICAgdmFsdWUgPSBpc05hTih2YWx1ZSkgPyBuYW4gOiBmb3JtYXRUeXBlKE1hdGguYWJzKHZhbHVlKSwgcHJlY2lzaW9uKTtcblxuICAgICAgICAvLyBUcmltIGluc2lnbmlmaWNhbnQgemVyb3MuXG4gICAgICAgIGlmICh0cmltKSB2YWx1ZSA9IGZvcm1hdFRyaW0odmFsdWUpO1xuXG4gICAgICAgIC8vIElmIGEgbmVnYXRpdmUgdmFsdWUgcm91bmRzIHRvIHplcm8gYWZ0ZXIgZm9ybWF0dGluZywgYW5kIG5vIGV4cGxpY2l0IHBvc2l0aXZlIHNpZ24gaXMgcmVxdWVzdGVkLCBoaWRlIHRoZSBzaWduLlxuICAgICAgICBpZiAodmFsdWVOZWdhdGl2ZSAmJiArdmFsdWUgPT09IDAgJiYgc2lnbiAhPT0gXCIrXCIpIHZhbHVlTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgICAgdmFsdWVQcmVmaXggPSAodmFsdWVOZWdhdGl2ZSA/IChzaWduID09PSBcIihcIiA/IHNpZ24gOiBtaW51cykgOiBzaWduID09PSBcIi1cIiB8fCBzaWduID09PSBcIihcIiA/IFwiXCIgOiBzaWduKSArIHZhbHVlUHJlZml4O1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9ICh0eXBlID09PSBcInNcIiA/IHByZWZpeGVzWzggKyBwcmVmaXhFeHBvbmVudCAvIDNdIDogXCJcIikgKyB2YWx1ZVN1ZmZpeCArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAvLyBCcmVhayB0aGUgZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGludGVnZXIg4oCcdmFsdWXigJ0gcGFydCB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBncm91cGVkLCBhbmQgZnJhY3Rpb25hbCBvciBleHBvbmVudGlhbCDigJxzdWZmaXjigJ0gcGFydCB0aGF0IGlzIG5vdC5cbiAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksIDQ4ID4gYyB8fCBjID4gNTcpIHtcbiAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmICF6ZXJvKSB2YWx1ZSA9IGdyb3VwKHZhbHVlLCBJbmZpbml0eSk7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWVQcmVmaXgubGVuZ3RoICsgdmFsdWUubGVuZ3RoICsgdmFsdWVTdWZmaXgubGVuZ3RoLFxuICAgICAgICAgIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiB6ZXJvKSB2YWx1ZSA9IGdyb3VwKHBhZGRpbmcgKyB2YWx1ZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIHZhbHVlU3VmZml4Lmxlbmd0aCA6IEluZmluaXR5KSwgcGFkZGluZyA9IFwiXCI7XG5cbiAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBmaW5hbCBvdXRwdXQgYmFzZWQgb24gdGhlIGRlc2lyZWQgYWxpZ25tZW50LlxuICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICBjYXNlIFwiPFwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmc7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiPVwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgcGFkZGluZyArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiXlwiOiB2YWx1ZSA9IHBhZGRpbmcuc2xpY2UoMCwgbGVuZ3RoID0gcGFkZGluZy5sZW5ndGggPj4gMSkgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nLnNsaWNlKGxlbmd0aCk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB2YWx1ZSA9IHBhZGRpbmcgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtZXJhbHModmFsdWUpO1xuICAgIH1cblxuICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNwZWNpZmllciArIFwiXCI7XG4gICAgfTtcblxuICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgIHZhciBmID0gbmV3Rm9ybWF0KChzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSwgc3BlY2lmaWVyLnR5cGUgPSBcImZcIiwgc3BlY2lmaWVyKSksXG4gICAgICAgIGUgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyxcbiAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzggKyBlIC8gM107XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogbmV3Rm9ybWF0LFxuICAgIGZvcm1hdFByZWZpeDogZm9ybWF0UHJlZml4XG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYmFzaXModDEsIHYwLCB2MSwgdjIsIHYzKSB7XG4gIHZhciB0MiA9IHQxICogdDEsIHQzID0gdDIgKiB0MTtcbiAgcmV0dXJuICgoMSAtIDMgKiB0MSArIDMgKiB0MiAtIHQzKSAqIHYwXG4gICAgICArICg0IC0gNiAqIHQyICsgMyAqIHQzKSAqIHYxXG4gICAgICArICgxICsgMyAqIHQxICsgMyAqIHQyIC0gMyAqIHQzKSAqIHYyXG4gICAgICArIHQzICogdjMpIC8gNjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0IDw9IDAgPyAodCA9IDApIDogdCA+PSAxID8gKHQgPSAxLCBuIC0gMSkgOiBNYXRoLmZsb29yKHQgKiBuKSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaV0sXG4gICAgICAgIHYyID0gdmFsdWVzW2kgKyAxXSxcbiAgICAgICAgdjAgPSBpID4gMCA/IHZhbHVlc1tpIC0gMV0gOiAyICogdjEgLSB2MixcbiAgICAgICAgdjMgPSBpIDwgbiAtIDEgPyB2YWx1ZXNbaSArIDJdIDogMiAqIHYyIC0gdjE7XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuIiwiaW1wb3J0IHtiYXNpc30gZnJvbSBcIi4vYmFzaXMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoKCh0ICU9IDEpIDwgMCA/ICsrdCA6IHQpICogbiksXG4gICAgICAgIHYwID0gdmFsdWVzWyhpICsgbiAtIDEpICUgbl0sXG4gICAgICAgIHYxID0gdmFsdWVzW2kgJSBuXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbKGkgKyAxKSAlIG5dLFxuICAgICAgICB2MyA9IHZhbHVlc1soaSArIDIpICUgbl07XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmZ1bmN0aW9uIGxpbmVhcihhLCBkKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKyB0ICogZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnRpYWwoYSwgYiwgeSkge1xuICByZXR1cm4gYSA9IE1hdGgucG93KGEsIHkpLCBiID0gTWF0aC5wb3coYiwgeSkgLSBhLCB5ID0gMSAvIHksIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coYSArIHQgKiBiLCB5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh1ZShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQgPiAxODAgfHwgZCA8IC0xODAgPyBkIC0gMzYwICogTWF0aC5yb3VuZChkIC8gMzYwKSA6IGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnYW1tYSh5KSB7XG4gIHJldHVybiAoeSA9ICt5KSA9PT0gMSA/IG5vZ2FtbWEgOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIgLSBhID8gZXhwb25lbnRpYWwoYSwgYiwgeSkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9nYW1tYShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCB4ID0+ICgpID0+IHg7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xuICB9O1xufVxuIiwiaW1wb3J0IHtyZ2IgYXMgY29sb3JSZ2J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGJhc2lzIGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5pbXBvcnQgYmFzaXNDbG9zZWQgZnJvbSBcIi4vYmFzaXNDbG9zZWQuanNcIjtcbmltcG9ydCBub2dhbW1hLCB7Z2FtbWF9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiByZ2JHYW1tYSh5KSB7XG4gIHZhciBjb2xvciA9IGdhbW1hKHkpO1xuXG4gIGZ1bmN0aW9uIHJnYihzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBjb2xvcigoc3RhcnQgPSBjb2xvclJnYihzdGFydCkpLnIsIChlbmQgPSBjb2xvclJnYihlbmQpKS5yKSxcbiAgICAgICAgZyA9IGNvbG9yKHN0YXJ0LmcsIGVuZC5nKSxcbiAgICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5yID0gcih0KTtcbiAgICAgIHN0YXJ0LmcgPSBnKHQpO1xuICAgICAgc3RhcnQuYiA9IGIodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIHJnYi5nYW1tYSA9IHJnYkdhbW1hO1xuXG4gIHJldHVybiByZ2I7XG59KSgxKTtcblxuZnVuY3Rpb24gcmdiU3BsaW5lKHNwbGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgdmFyIG4gPSBjb2xvcnMubGVuZ3RoLFxuICAgICAgICByID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBnID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBpLCBjb2xvcjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb2xvciA9IGNvbG9yUmdiKGNvbG9yc1tpXSk7XG4gICAgICByW2ldID0gY29sb3IuciB8fCAwO1xuICAgICAgZ1tpXSA9IGNvbG9yLmcgfHwgMDtcbiAgICAgIGJbaV0gPSBjb2xvci5iIHx8IDA7XG4gICAgfVxuICAgIHIgPSBzcGxpbmUocik7XG4gICAgZyA9IHNwbGluZShnKTtcbiAgICBiID0gc3BsaW5lKGIpO1xuICAgIGNvbG9yLm9wYWNpdHkgPSAxO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb2xvci5yID0gcih0KTtcbiAgICAgIGNvbG9yLmcgPSBnKHQpO1xuICAgICAgY29sb3IuYiA9IGIodCk7XG4gICAgICByZXR1cm4gY29sb3IgKyBcIlwiO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgcmdiQmFzaXMgPSByZ2JTcGxpbmUoYmFzaXMpO1xuZXhwb3J0IHZhciByZ2JCYXNpc0Nsb3NlZCA9IHJnYlNwbGluZShiYXNpc0Nsb3NlZCk7XG4iLCJpbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuXG52YXIgcmVBID0gL1stK10/KD86XFxkK1xcLj9cXGQqfFxcLj9cXGQrKSg/OltlRV1bLStdP1xcZCspPy9nLFxuICAgIHJlQiA9IG5ldyBSZWdFeHAocmVBLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiB6ZXJvKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbmUoYikge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBiKHQpICsgXCJcIjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYmkgPSByZUEubGFzdEluZGV4ID0gcmVCLmxhc3RJbmRleCA9IDAsIC8vIHNjYW4gaW5kZXggZm9yIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGFtLCAvLyBjdXJyZW50IG1hdGNoIGluIGFcbiAgICAgIGJtLCAvLyBjdXJyZW50IG1hdGNoIGluIGJcbiAgICAgIGJzLCAvLyBzdHJpbmcgcHJlY2VkaW5nIGN1cnJlbnQgbnVtYmVyIGluIGIsIGlmIGFueVxuICAgICAgaSA9IC0xLCAvLyBpbmRleCBpbiBzXG4gICAgICBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuXG4gIC8vIENvZXJjZSBpbnB1dHMgdG8gc3RyaW5ncy5cbiAgYSA9IGEgKyBcIlwiLCBiID0gYiArIFwiXCI7XG5cbiAgLy8gSW50ZXJwb2xhdGUgcGFpcnMgb2YgbnVtYmVycyBpbiBhICYgYi5cbiAgd2hpbGUgKChhbSA9IHJlQS5leGVjKGEpKVxuICAgICAgJiYgKGJtID0gcmVCLmV4ZWMoYikpKSB7XG4gICAgaWYgKChicyA9IGJtLmluZGV4KSA+IGJpKSB7IC8vIGEgc3RyaW5nIHByZWNlZGVzIHRoZSBuZXh0IG51bWJlciBpbiBiXG4gICAgICBicyA9IGIuc2xpY2UoYmksIGJzKTtcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBicztcbiAgICB9XG4gICAgaWYgKChhbSA9IGFtWzBdKSA9PT0gKGJtID0gYm1bMF0pKSB7IC8vIG51bWJlcnMgaW4gYSAmIGIgbWF0Y2hcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJtOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBibTtcbiAgICB9IGVsc2UgeyAvLyBpbnRlcnBvbGF0ZSBub24tbWF0Y2hpbmcgbnVtYmVyc1xuICAgICAgc1srK2ldID0gbnVsbDtcbiAgICAgIHEucHVzaCh7aTogaSwgeDogbnVtYmVyKGFtLCBibSl9KTtcbiAgICB9XG4gICAgYmkgPSByZUIubGFzdEluZGV4O1xuICB9XG5cbiAgLy8gQWRkIHJlbWFpbnMgb2YgYi5cbiAgaWYgKGJpIDwgYi5sZW5ndGgpIHtcbiAgICBicyA9IGIuc2xpY2UoYmkpO1xuICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gIH1cblxuICAvLyBTcGVjaWFsIG9wdGltaXphdGlvbiBmb3Igb25seSBhIHNpbmdsZSBtYXRjaC5cbiAgLy8gT3RoZXJ3aXNlLCBpbnRlcnBvbGF0ZSBlYWNoIG9mIHRoZSBudW1iZXJzIGFuZCByZWpvaW4gdGhlIHN0cmluZy5cbiAgcmV0dXJuIHMubGVuZ3RoIDwgMiA/IChxWzBdXG4gICAgICA/IG9uZShxWzBdLngpXG4gICAgICA6IHplcm8oYikpXG4gICAgICA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGI7ICsraSkgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgICAgIH0pO1xufVxuIiwidmFyIGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xuXG5leHBvcnQgdmFyIGlkZW50aXR5ID0ge1xuICB0cmFuc2xhdGVYOiAwLFxuICB0cmFuc2xhdGVZOiAwLFxuICByb3RhdGU6IDAsXG4gIHNrZXdYOiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgc2NhbGVYLCBzY2FsZVksIHNrZXdYO1xuICBpZiAoc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpKSBhIC89IHNjYWxlWCwgYiAvPSBzY2FsZVg7XG4gIGlmIChza2V3WCA9IGEgKiBjICsgYiAqIGQpIGMgLT0gYSAqIHNrZXdYLCBkIC09IGIgKiBza2V3WDtcbiAgaWYgKHNjYWxlWSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKSkgYyAvPSBzY2FsZVksIGQgLz0gc2NhbGVZLCBza2V3WCAvPSBzY2FsZVk7XG4gIGlmIChhICogZCA8IGIgKiBjKSBhID0gLWEsIGIgPSAtYiwgc2tld1ggPSAtc2tld1gsIHNjYWxlWCA9IC1zY2FsZVg7XG4gIHJldHVybiB7XG4gICAgdHJhbnNsYXRlWDogZSxcbiAgICB0cmFuc2xhdGVZOiBmLFxuICAgIHJvdGF0ZTogTWF0aC5hdGFuMihiLCBhKSAqIGRlZ3JlZXMsXG4gICAgc2tld1g6IE1hdGguYXRhbihza2V3WCkgKiBkZWdyZWVzLFxuICAgIHNjYWxlWDogc2NhbGVYLFxuICAgIHNjYWxlWTogc2NhbGVZXG4gIH07XG59XG4iLCJpbXBvcnQgbnVtYmVyIGZyb20gXCIuLi9udW1iZXIuanNcIjtcbmltcG9ydCB7cGFyc2VDc3MsIHBhcnNlU3ZnfSBmcm9tIFwiLi9wYXJzZS5qc1wiO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZSwgcHhDb21tYSwgcHhQYXJlbiwgZGVnUGFyZW4pIHtcblxuICBmdW5jdGlvbiBwb3Aocykge1xuICAgIHJldHVybiBzLmxlbmd0aCA/IHMucG9wKCkgKyBcIiBcIiA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2goXCJ0cmFuc2xhdGUoXCIsIG51bGwsIHB4Q29tbWEsIG51bGwsIHB4UGFyZW4pO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiB8fCB5Yikge1xuICAgICAgcy5wdXNoKFwidHJhbnNsYXRlKFwiICsgeGIgKyBweENvbW1hICsgeWIgKyBweFBhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByb3RhdGUoYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBpZiAoYSAtIGIgPiAxODApIGIgKz0gMzYwOyBlbHNlIGlmIChiIC0gYSA+IDE4MCkgYSArPSAzNjA7IC8vIHNob3J0ZXN0IHBhdGhcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2tld1goYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiAhPT0gMSB8fCB5YiAhPT0gMSkge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIgKyB4YiArIFwiLFwiICsgeWIgKyBcIilcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuICAgIGEgPSBwYXJzZShhKSwgYiA9IHBhcnNlKGIpO1xuICAgIHRyYW5zbGF0ZShhLnRyYW5zbGF0ZVgsIGEudHJhbnNsYXRlWSwgYi50cmFuc2xhdGVYLCBiLnRyYW5zbGF0ZVksIHMsIHEpO1xuICAgIHJvdGF0ZShhLnJvdGF0ZSwgYi5yb3RhdGUsIHMsIHEpO1xuICAgIHNrZXdYKGEuc2tld1gsIGIuc2tld1gsIHMsIHEpO1xuICAgIHNjYWxlKGEuc2NhbGVYLCBhLnNjYWxlWSwgYi5zY2FsZVgsIGIuc2NhbGVZLCBzLCBxKTtcbiAgICBhID0gYiA9IG51bGw7IC8vIGdjXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBxLmxlbmd0aCwgbztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZUNzcywgXCJweCwgXCIsIFwicHgpXCIsIFwiZGVnKVwiKTtcbmV4cG9ydCB2YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZVN2ZywgXCIsIFwiLCBcIilcIiwgXCIpXCIpO1xuIiwiaW1wb3J0IGRlY29tcG9zZSwge2lkZW50aXR5fSBmcm9tIFwiLi9kZWNvbXBvc2UuanNcIjtcblxudmFyIHN2Z05vZGU7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDc3ModmFsdWUpIHtcbiAgY29uc3QgbSA9IG5ldyAodHlwZW9mIERPTU1hdHJpeCA9PT0gXCJmdW5jdGlvblwiID8gRE9NTWF0cml4IDogV2ViS2l0Q1NTTWF0cml4KSh2YWx1ZSArIFwiXCIpO1xuICByZXR1cm4gbS5pc0lkZW50aXR5ID8gaWRlbnRpdHkgOiBkZWNvbXBvc2UobS5hLCBtLmIsIG0uYywgbS5kLCBtLmUsIG0uZik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN2Zyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICBpZiAoIXN2Z05vZGUpIHN2Z05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gIHN2Z05vZGUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHZhbHVlKTtcbiAgaWYgKCEodmFsdWUgPSBzdmdOb2RlLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhbHVlID0gdmFsdWUubWF0cml4O1xuICByZXR1cm4gZGVjb21wb3NlKHZhbHVlLmEsIHZhbHVlLmIsIHZhbHVlLmMsIHZhbHVlLmQsIHZhbHVlLmUsIHZhbHVlLmYpO1xufVxuIiwidmFyIGVwc2lsb24yID0gMWUtMTI7XG5cbmZ1bmN0aW9uIGNvc2goeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpICsgMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gc2luaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgLSAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiB0YW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKDIgKiB4KSkgLSAxKSAvICh4ICsgMSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiB6b29tUmhvKHJobywgcmhvMiwgcmhvNCkge1xuXG4gIC8vIHAwID0gW3V4MCwgdXkwLCB3MF1cbiAgLy8gcDEgPSBbdXgxLCB1eTEsIHcxXVxuICBmdW5jdGlvbiB6b29tKHAwLCBwMSkge1xuICAgIHZhciB1eDAgPSBwMFswXSwgdXkwID0gcDBbMV0sIHcwID0gcDBbMl0sXG4gICAgICAgIHV4MSA9IHAxWzBdLCB1eTEgPSBwMVsxXSwgdzEgPSBwMVsyXSxcbiAgICAgICAgZHggPSB1eDEgLSB1eDAsXG4gICAgICAgIGR5ID0gdXkxIC0gdXkwLFxuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgICBpLFxuICAgICAgICBTO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciB1MCDiiYUgdTEuXG4gICAgaWYgKGQyIDwgZXBzaWxvbjIpIHtcbiAgICAgIFMgPSBNYXRoLmxvZyh3MSAvIHcwKSAvIHJobztcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdXgwICsgdCAqIGR4LFxuICAgICAgICAgIHV5MCArIHQgKiBkeSxcbiAgICAgICAgICB3MCAqIE1hdGguZXhwKHJobyAqIHQgKiBTKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdlbmVyYWwgY2FzZS5cbiAgICBlbHNlIHtcbiAgICAgIHZhciBkMSA9IE1hdGguc3FydChkMiksXG4gICAgICAgICAgYjAgPSAodzEgKiB3MSAtIHcwICogdzAgKyByaG80ICogZDIpIC8gKDIgKiB3MCAqIHJobzIgKiBkMSksXG4gICAgICAgICAgYjEgPSAodzEgKiB3MSAtIHcwICogdzAgLSByaG80ICogZDIpIC8gKDIgKiB3MSAqIHJobzIgKiBkMSksXG4gICAgICAgICAgcjAgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjAgKiBiMCArIDEpIC0gYjApLFxuICAgICAgICAgIHIxID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIxICogYjEgKyAxKSAtIGIxKTtcbiAgICAgIFMgPSAocjEgLSByMCkgLyByaG87XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcyA9IHQgKiBTLFxuICAgICAgICAgICAgY29zaHIwID0gY29zaChyMCksXG4gICAgICAgICAgICB1ID0gdzAgLyAocmhvMiAqIGQxKSAqIChjb3NocjAgKiB0YW5oKHJobyAqIHMgKyByMCkgLSBzaW5oKHIwKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdXgwICsgdSAqIGR4LFxuICAgICAgICAgIHV5MCArIHUgKiBkeSxcbiAgICAgICAgICB3MCAqIGNvc2hyMCAvIGNvc2gocmhvICogcyArIHIwKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGkuZHVyYXRpb24gPSBTICogMTAwMCAqIHJobyAvIE1hdGguU1FSVDI7XG5cbiAgICByZXR1cm4gaTtcbiAgfVxuXG4gIHpvb20ucmhvID0gZnVuY3Rpb24oXykge1xuICAgIHZhciBfMSA9IE1hdGgubWF4KDFlLTMsICtfKSwgXzIgPSBfMSAqIF8xLCBfNCA9IF8yICogXzI7XG4gICAgcmV0dXJuIHpvb21SaG8oXzEsIF8yLCBfNCk7XG4gIH07XG5cbiAgcmV0dXJuIHpvb207XG59KShNYXRoLlNRUlQyLCAyLCA0KTtcbiIsImV4cG9ydCBkZWZhdWx0IE1hdGgucmFuZG9tO1xuIiwiaW1wb3J0IGRlZmF1bHRTb3VyY2UgZnJvbSBcIi4vZGVmYXVsdFNvdXJjZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gc291cmNlUmFuZG9tTm9ybWFsKHNvdXJjZSkge1xuICBmdW5jdGlvbiByYW5kb21Ob3JtYWwobXUsIHNpZ21hKSB7XG4gICAgdmFyIHgsIHI7XG4gICAgbXUgPSBtdSA9PSBudWxsID8gMCA6ICttdTtcbiAgICBzaWdtYSA9IHNpZ21hID09IG51bGwgPyAxIDogK3NpZ21hO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB5O1xuXG4gICAgICAvLyBJZiBhdmFpbGFibGUsIHVzZSB0aGUgc2Vjb25kIHByZXZpb3VzbHktZ2VuZXJhdGVkIHVuaWZvcm0gcmFuZG9tLlxuICAgICAgaWYgKHggIT0gbnVsbCkgeSA9IHgsIHggPSBudWxsO1xuXG4gICAgICAvLyBPdGhlcndpc2UsIGdlbmVyYXRlIGEgbmV3IHggYW5kIHkuXG4gICAgICBlbHNlIGRvIHtcbiAgICAgICAgeCA9IHNvdXJjZSgpICogMiAtIDE7XG4gICAgICAgIHkgPSBzb3VyY2UoKSAqIDIgLSAxO1xuICAgICAgICByID0geCAqIHggKyB5ICogeTtcbiAgICAgIH0gd2hpbGUgKCFyIHx8IHIgPiAxKTtcblxuICAgICAgcmV0dXJuIG11ICsgc2lnbWEgKiB5ICogTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocikgLyByKTtcbiAgICB9O1xuICB9XG5cbiAgcmFuZG9tTm9ybWFsLnNvdXJjZSA9IHNvdXJjZVJhbmRvbU5vcm1hbDtcblxuICByZXR1cm4gcmFuZG9tTm9ybWFsO1xufSkoZGVmYXVsdFNvdXJjZSk7XG4iLCIvLyBHaXZlbiBzb21ldGhpbmcgYXJyYXkgbGlrZSAob3IgbnVsbCksIHJldHVybnMgc29tZXRoaW5nIHRoYXQgaXMgc3RyaWN0bHkgYW5cbi8vIGFycmF5LiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgYXJyYXktbGlrZSBvYmplY3RzIHBhc3NlZCB0byBkMy5zZWxlY3RBbGxcbi8vIG9yIHNlbGVjdGlvbi5zZWxlY3RBbGwgYXJlIGNvbnZlcnRlZCBpbnRvIHByb3BlciBhcnJheXMgd2hlbiBjcmVhdGluZyBhXG4vLyBzZWxlY3Rpb247IHdlIGRvbuKAmXQgZXZlciB3YW50IHRvIGNyZWF0ZSBhIHNlbGVjdGlvbiBiYWNrZWQgYnkgYSBsaXZlXG4vLyBIVE1MQ29sbGVjdGlvbiBvciBOb2RlTGlzdC4gSG93ZXZlciwgbm90ZSB0aGF0IHNlbGVjdGlvbi5zZWxlY3RBbGwgd2lsbCB1c2UgYVxuLy8gc3RhdGljIE5vZGVMaXN0IGFzIGEgZ3JvdXAsIHNpbmNlIGl0IHNhZmVseSBkZXJpdmVkIGZyb20gcXVlcnlTZWxlY3RvckFsbC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFycmF5KHgpIHtcbiAgcmV0dXJuIHggPT0gbnVsbCA/IFtdIDogQXJyYXkuaXNBcnJheSh4KSA/IHggOiBBcnJheS5mcm9tKHgpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQgbmFtZXNwYWNlIGZyb20gXCIuL25hbWVzcGFjZS5qc1wiO1xuaW1wb3J0IHt4aHRtbH0gZnJvbSBcIi4vbmFtZXNwYWNlcy5qc1wiO1xuXG5mdW5jdGlvbiBjcmVhdG9ySW5oZXJpdChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIHVyaSA9IHRoaXMubmFtZXNwYWNlVVJJO1xuICAgIHJldHVybiB1cmkgPT09IHhodG1sICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IHhodG1sXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKVxuICAgICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh1cmksIG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdG9yRml4ZWQoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuICByZXR1cm4gKGZ1bGxuYW1lLmxvY2FsXG4gICAgICA/IGNyZWF0b3JGaXhlZFxuICAgICAgOiBjcmVhdG9ySW5oZXJpdCkoZnVsbG5hbWUpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hpbGRNYXRjaGVyKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH07XG59XG5cbiIsImltcG9ydCBuYW1lc3BhY2VzIGZyb20gXCIuL25hbWVzcGFjZXMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcHJlZml4ID0gbmFtZSArPSBcIlwiLCBpID0gcHJlZml4LmluZGV4T2YoXCI6XCIpO1xuICBpZiAoaSA+PSAwICYmIChwcmVmaXggPSBuYW1lLnNsaWNlKDAsIGkpKSAhPT0gXCJ4bWxuc1wiKSBuYW1lID0gbmFtZS5zbGljZShpICsgMSk7XG4gIHJldHVybiBuYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByZWZpeCkgPyB7c3BhY2U6IG5hbWVzcGFjZXNbcHJlZml4XSwgbG9jYWw6IG5hbWV9IDogbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbn1cbiIsImV4cG9ydCB2YXIgeGh0bWwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgeGh0bWw6IHhodG1sLFxuICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxufTtcbiIsImltcG9ydCBzb3VyY2VFdmVudCBmcm9tIFwiLi9zb3VyY2VFdmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihldmVudCwgbm9kZSkge1xuICBldmVudCA9IHNvdXJjZUV2ZW50KGV2ZW50KTtcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgbm9kZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGlmIChub2RlKSB7XG4gICAgdmFyIHN2ZyA9IG5vZGUub3duZXJTVkdFbGVtZW50IHx8IG5vZGU7XG4gICAgaWYgKHN2Zy5jcmVhdGVTVkdQb2ludCkge1xuICAgICAgdmFyIHBvaW50ID0gc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICBwb2ludC54ID0gZXZlbnQuY2xpZW50WCwgcG9pbnQueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBwb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShub2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgICByZXR1cm4gW3BvaW50LngsIHBvaW50LnldO1xuICAgIH1cbiAgICBpZiAobm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiBbZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCAtIG5vZGUuY2xpZW50TGVmdCwgZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gbm9kZS5jbGllbnRUb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2V2ZW50LnBhZ2VYLCBldmVudC5wYWdlWV07XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbiwgcm9vdH0gZnJvbSBcIi4vc2VsZWN0aW9uL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgOiBuZXcgU2VsZWN0aW9uKFtbc2VsZWN0b3JdXSwgcm9vdCk7XG59XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiLi4vbmFtZXNwYWNlLmpzXCI7XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdik7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgIHJldHVybiBmdWxsbmFtZS5sb2NhbFxuICAgICAgICA/IG5vZGUuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKVxuICAgICAgICA6IG5vZGUuZ2V0QXR0cmlidXRlKGZ1bGxuYW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KSkpKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcbiAgYXJndW1lbnRzWzBdID0gdGhpcztcbiAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJmdW5jdGlvbiBjbGFzc0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzTGlzdChub2RlKSB7XG4gIHJldHVybiBub2RlLmNsYXNzTGlzdCB8fCBuZXcgQ2xhc3NMaXN0KG5vZGUpO1xufVxuXG5mdW5jdGlvbiBDbGFzc0xpc3Qobm9kZSkge1xuICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgdGhpcy5fbmFtZXMgPSBjbGFzc0FycmF5KG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG59XG5cbkNsYXNzTGlzdC5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSkgPj0gMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2xhc3NlZEFkZChub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5hZGQobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkUmVtb3ZlKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LnJlbW92ZShuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRUcnVlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkQWRkKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZhbHNlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkUmVtb3ZlKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKG5hbWVzLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgKHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPyBjbGFzc2VkQWRkIDogY2xhc3NlZFJlbW92ZSkodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgbmFtZXMgPSBjbGFzc0FycmF5KG5hbWUgKyBcIlwiKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbGlzdCA9IGNsYXNzTGlzdCh0aGlzLm5vZGUoKSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFsaXN0LmNvbnRhaW5zKG5hbWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gY2xhc3NlZEZ1bmN0aW9uIDogdmFsdWVcbiAgICAgID8gY2xhc3NlZFRydWVcbiAgICAgIDogY2xhc3NlZEZhbHNlKShuYW1lcywgdmFsdWUpKTtcbn1cbiIsImZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZVNoYWxsb3coKSB7XG4gIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKGZhbHNlKSwgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICByZXR1cm4gcGFyZW50ID8gcGFyZW50Lmluc2VydEJlZm9yZShjbG9uZSwgdGhpcy5uZXh0U2libGluZykgOiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lRGVlcCgpIHtcbiAgdmFyIGNsb25lID0gdGhpcy5jbG9uZU5vZGUodHJ1ZSksIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dFNpYmxpbmcpIDogY2xvbmU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlZXApIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGRlZXAgPyBzZWxlY3Rpb25fY2xvbmVEZWVwIDogc2VsZWN0aW9uX2Nsb25lU2hhbGxvdyk7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7RW50ZXJOb2RlfSBmcm9tIFwiLi9lbnRlci5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuLi9jb25zdGFudC5qc1wiO1xuXG5mdW5jdGlvbiBiaW5kSW5kZXgocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSkge1xuICB2YXIgaSA9IDAsXG4gICAgICBub2RlLFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGZpdCBpbnRvIHVwZGF0ZS5cbiAgLy8gUHV0IGFueSBudWxsIG5vZGVzIGludG8gZW50ZXIuXG4gIC8vIFB1dCBhbnkgcmVtYWluaW5nIGRhdGEgaW50byBlbnRlci5cbiAgZm9yICg7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBkb27igJl0IGZpdCBpbnRvIGV4aXQuXG4gIGZvciAoOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5kS2V5KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEsIGtleSkge1xuICB2YXIgaSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlQnlLZXlWYWx1ZSA9IG5ldyBNYXAsXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGtleVZhbHVlcyA9IG5ldyBBcnJheShncm91cExlbmd0aCksXG4gICAgICBrZXlWYWx1ZTtcblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggbm9kZS5cbiAgLy8gSWYgbXVsdGlwbGUgbm9kZXMgaGF2ZSB0aGUgc2FtZSBrZXksIHRoZSBkdXBsaWNhdGVzIGFyZSBhZGRlZCB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlID0ga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApICsgXCJcIjtcbiAgICAgIGlmIChub2RlQnlLZXlWYWx1ZS5oYXMoa2V5VmFsdWUpKSB7XG4gICAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUJ5S2V5VmFsdWUuc2V0KGtleVZhbHVlLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggZGF0dW0uXG4gIC8vIElmIHRoZXJlIGEgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXksIGpvaW4gYW5kIGFkZCBpdCB0byB1cGRhdGUuXG4gIC8vIElmIHRoZXJlIGlzIG5vdCAob3IgdGhlIGtleSBpcyBhIGR1cGxpY2F0ZSksIGFkZCBpdCB0byBlbnRlci5cbiAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGtleVZhbHVlID0ga2V5LmNhbGwocGFyZW50LCBkYXRhW2ldLCBpLCBkYXRhKSArIFwiXCI7XG4gICAgaWYgKG5vZGUgPSBub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWUpKSB7XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICBub2RlQnlLZXlWYWx1ZS5kZWxldGUoa2V5VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYW55IHJlbWFpbmluZyBub2RlcyB0aGF0IHdlcmUgbm90IGJvdW5kIHRvIGRhdGEgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZXNbaV0pID09PSBub2RlKSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRhdHVtKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX19kYXRhX187XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLCBkYXR1bSk7XG5cbiAgdmFyIGJpbmQgPSBrZXkgPyBiaW5kS2V5IDogYmluZEluZGV4LFxuICAgICAgcGFyZW50cyA9IHRoaXMuX3BhcmVudHMsXG4gICAgICBncm91cHMgPSB0aGlzLl9ncm91cHM7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IGNvbnN0YW50KHZhbHVlKTtcblxuICBmb3IgKHZhciBtID0gZ3JvdXBzLmxlbmd0aCwgdXBkYXRlID0gbmV3IEFycmF5KG0pLCBlbnRlciA9IG5ldyBBcnJheShtKSwgZXhpdCA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tqXSxcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbal0sXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhID0gYXJyYXlsaWtlKHZhbHVlLmNhbGwocGFyZW50LCBwYXJlbnQgJiYgcGFyZW50Ll9fZGF0YV9fLCBqLCBwYXJlbnRzKSksXG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZW50ZXJHcm91cCA9IGVudGVyW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICB1cGRhdGVHcm91cCA9IHVwZGF0ZVtqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgZXhpdEdyb3VwID0gZXhpdFtqXSA9IG5ldyBBcnJheShncm91cExlbmd0aCk7XG5cbiAgICBiaW5kKHBhcmVudCwgZ3JvdXAsIGVudGVyR3JvdXAsIHVwZGF0ZUdyb3VwLCBleGl0R3JvdXAsIGRhdGEsIGtleSk7XG5cbiAgICAvLyBOb3cgY29ubmVjdCB0aGUgZW50ZXIgbm9kZXMgdG8gdGhlaXIgZm9sbG93aW5nIHVwZGF0ZSBub2RlLCBzdWNoIHRoYXRcbiAgICAvLyBhcHBlbmRDaGlsZCBjYW4gaW5zZXJ0IHRoZSBtYXRlcmlhbGl6ZWQgZW50ZXIgbm9kZSBiZWZvcmUgdGhpcyBub2RlLFxuICAgIC8vIHJhdGhlciB0aGFuIGF0IHRoZSBlbmQgb2YgdGhlIHBhcmVudCBub2RlLlxuICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAwLCBwcmV2aW91cywgbmV4dDsgaTAgPCBkYXRhTGVuZ3RoOyArK2kwKSB7XG4gICAgICBpZiAocHJldmlvdXMgPSBlbnRlckdyb3VwW2kwXSkge1xuICAgICAgICBpZiAoaTAgPj0gaTEpIGkxID0gaTAgKyAxO1xuICAgICAgICB3aGlsZSAoIShuZXh0ID0gdXBkYXRlR3JvdXBbaTFdKSAmJiArK2kxIDwgZGF0YUxlbmd0aCk7XG4gICAgICAgIHByZXZpb3VzLl9uZXh0ID0gbmV4dCB8fCBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSA9IG5ldyBTZWxlY3Rpb24odXBkYXRlLCBwYXJlbnRzKTtcbiAgdXBkYXRlLl9lbnRlciA9IGVudGVyO1xuICB1cGRhdGUuX2V4aXQgPSBleGl0O1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG4vLyBHaXZlbiBzb21lIGRhdGEsIHRoaXMgcmV0dXJucyBhbiBhcnJheS1saWtlIHZpZXcgb2YgaXQ6IGFuIG9iamVjdCB0aGF0XG4vLyBleHBvc2VzIGEgbGVuZ3RoIHByb3BlcnR5IGFuZCBhbGxvd3MgbnVtZXJpYyBpbmRleGluZy4gTm90ZSB0aGF0IHVubGlrZVxuLy8gc2VsZWN0QWxsLCB0aGlzIGlzbuKAmXQgd29ycmllZCBhYm91dCDigJxsaXZl4oCdIGNvbGxlY3Rpb25zIGJlY2F1c2UgdGhlIHJlc3VsdGluZ1xuLy8gYXJyYXkgd2lsbCBvbmx5IGJlIHVzZWQgYnJpZWZseSB3aGlsZSBkYXRhIGlzIGJlaW5nIGJvdW5kLiAoSXQgaXMgcG9zc2libGUgdG9cbi8vIGNhdXNlIHRoZSBkYXRhIHRvIGNoYW5nZSB3aGlsZSBpdGVyYXRpbmcgYnkgdXNpbmcgYSBrZXkgZnVuY3Rpb24sIGJ1dCBwbGVhc2Vcbi8vIGRvbuKAmXQ7IHdl4oCZZCByYXRoZXIgYXZvaWQgYSBncmF0dWl0b3VzIGNvcHkuKVxuZnVuY3Rpb24gYXJyYXlsaWtlKGRhdGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIFwibGVuZ3RoXCIgaW4gZGF0YVxuICAgID8gZGF0YSAvLyBBcnJheSwgVHlwZWRBcnJheSwgTm9kZUxpc3QsIGFycmF5LWxpa2VcbiAgICA6IEFycmF5LmZyb20oZGF0YSk7IC8vIE1hcCwgU2V0LCBpdGVyYWJsZSwgc3RyaW5nLCBvciBhbnl0aGluZyBlbHNlXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xufVxuIiwiaW1wb3J0IGRlZmF1bHRWaWV3IGZyb20gXCIuLi93aW5kb3cuanNcIjtcblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIHdpbmRvdyA9IGRlZmF1bHRWaWV3KG5vZGUpLFxuICAgICAgZXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXZlbnQgPSBuZXcgZXZlbnQodHlwZSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGlmIChwYXJhbXMpIGV2ZW50LmluaXRFdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUpLCBldmVudC5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBkaXNwYXRjaEZ1bmN0aW9uXG4gICAgICA6IGRpc3BhdGNoQ29uc3RhbnQpKHR5cGUsIHBhcmFtcykpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbn1cbiIsImltcG9ydCBzcGFyc2UgZnJvbSBcIi4vc3BhcnNlLmpzXCI7XG5pbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFbnRlck5vZGUocGFyZW50LCBkYXR1bSkge1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQub3duZXJEb2N1bWVudDtcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XG59XG5cbkVudGVyTm9kZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFbnRlck5vZGUsXG4gIGFwcGVuZENoaWxkOiBmdW5jdGlvbihjaGlsZCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgdGhpcy5fbmV4dCk7IH0sXG4gIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY2hpbGQsIG5leHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpOyB9LFxuICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9LFxuICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOyB9XG59O1xuIiwiaW1wb3J0IHNwYXJzZSBmcm9tIFwiLi9zcGFyc2UuanNcIjtcbmltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuIiwiaW1wb3J0IHtTZWxlY3Rpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgbWF0Y2hlciBmcm9tIFwiLi4vbWF0Y2hlci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImZ1bmN0aW9uIGh0bWxSZW1vdmUoKSB7XG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaHRtbENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gaHRtbFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gaHRtbEZ1bmN0aW9uXG4gICAgICAgICAgOiBodG1sQ29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xufVxuIiwiaW1wb3J0IHNlbGVjdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3NlbGVjdEFsbCBmcm9tIFwiLi9zZWxlY3RBbGwuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2VsZWN0Q2hpbGQgZnJvbSBcIi4vc2VsZWN0Q2hpbGQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fc2VsZWN0Q2hpbGRyZW4gZnJvbSBcIi4vc2VsZWN0Q2hpbGRyZW4uanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXRhIGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW50ZXIgZnJvbSBcIi4vZW50ZXIuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZXhpdCBmcm9tIFwiLi9leGl0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2pvaW4gZnJvbSBcIi4vam9pbi5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9tZXJnZSBmcm9tIFwiLi9tZXJnZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9vcmRlciBmcm9tIFwiLi9vcmRlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zb3J0IGZyb20gXCIuL3NvcnQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fY2FsbCBmcm9tIFwiLi9jYWxsLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGVzIGZyb20gXCIuL25vZGVzLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX25vZGUgZnJvbSBcIi4vbm9kZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zaXplIGZyb20gXCIuL3NpemUuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZW1wdHkgZnJvbSBcIi4vZW1wdHkuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fZWFjaCBmcm9tIFwiLi9lYWNoLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2F0dHIgZnJvbSBcIi4vYXR0ci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9wcm9wZXJ0eSBmcm9tIFwiLi9wcm9wZXJ0eS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbGFzc2VkIGZyb20gXCIuL2NsYXNzZWQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fdGV4dCBmcm9tIFwiLi90ZXh0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2h0bWwgZnJvbSBcIi4vaHRtbC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9yYWlzZSBmcm9tIFwiLi9yYWlzZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9sb3dlciBmcm9tIFwiLi9sb3dlci5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9hcHBlbmQgZnJvbSBcIi4vYXBwZW5kLmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX2luc2VydCBmcm9tIFwiLi9pbnNlcnQuanNcIjtcbmltcG9ydCBzZWxlY3Rpb25fcmVtb3ZlIGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9jbG9uZSBmcm9tIFwiLi9jbG9uZS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kYXR1bSBmcm9tIFwiLi9kYXR1bS5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9vbiBmcm9tIFwiLi9vbi5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9kaXNwYXRjaCBmcm9tIFwiLi9kaXNwYXRjaC5qc1wiO1xuaW1wb3J0IHNlbGVjdGlvbl9pdGVyYXRvciBmcm9tIFwiLi9pdGVyYXRvci5qc1wiO1xuXG5leHBvcnQgdmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zZWxlY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzO1xufVxuXG5TZWxlY3Rpb24ucHJvdG90eXBlID0gc2VsZWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNlbGVjdGlvbixcbiAgc2VsZWN0OiBzZWxlY3Rpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHNlbGVjdGlvbl9zZWxlY3RBbGwsXG4gIHNlbGVjdENoaWxkOiBzZWxlY3Rpb25fc2VsZWN0Q2hpbGQsXG4gIHNlbGVjdENoaWxkcmVuOiBzZWxlY3Rpb25fc2VsZWN0Q2hpbGRyZW4sXG4gIGZpbHRlcjogc2VsZWN0aW9uX2ZpbHRlcixcbiAgZGF0YTogc2VsZWN0aW9uX2RhdGEsXG4gIGVudGVyOiBzZWxlY3Rpb25fZW50ZXIsXG4gIGV4aXQ6IHNlbGVjdGlvbl9leGl0LFxuICBqb2luOiBzZWxlY3Rpb25fam9pbixcbiAgbWVyZ2U6IHNlbGVjdGlvbl9tZXJnZSxcbiAgc2VsZWN0aW9uOiBzZWxlY3Rpb25fc2VsZWN0aW9uLFxuICBvcmRlcjogc2VsZWN0aW9uX29yZGVyLFxuICBzb3J0OiBzZWxlY3Rpb25fc29ydCxcbiAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fbm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX2VhY2gsXG4gIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICBzdHlsZTogc2VsZWN0aW9uX3N0eWxlLFxuICBwcm9wZXJ0eTogc2VsZWN0aW9uX3Byb3BlcnR5LFxuICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgdGV4dDogc2VsZWN0aW9uX3RleHQsXG4gIGh0bWw6IHNlbGVjdGlvbl9odG1sLFxuICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICBsb3dlcjogc2VsZWN0aW9uX2xvd2VyLFxuICBhcHBlbmQ6IHNlbGVjdGlvbl9hcHBlbmQsXG4gIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgcmVtb3ZlOiBzZWxlY3Rpb25fcmVtb3ZlLFxuICBjbG9uZTogc2VsZWN0aW9uX2Nsb25lLFxuICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxuICBvbjogc2VsZWN0aW9uX29uLFxuICBkaXNwYXRjaDogc2VsZWN0aW9uX2Rpc3BhdGNoLFxuICBbU3ltYm9sLml0ZXJhdG9yXTogc2VsZWN0aW9uX2l0ZXJhdG9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZWxlY3Rpb247XG4iLCJpbXBvcnQgY3JlYXRvciBmcm9tIFwiLi4vY3JlYXRvci5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3Rvci5qc1wiO1xuXG5mdW5jdGlvbiBjb25zdGFudE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgIHNlbGVjdCA9IGJlZm9yZSA9PSBudWxsID8gY29uc3RhbnROdWxsIDogdHlwZW9mIGJlZm9yZSA9PT0gXCJmdW5jdGlvblwiID8gYmVmb3JlIDogc2VsZWN0b3IoYmVmb3JlKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24qKCkge1xuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgeWllbGQgbm9kZTtcbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9uZW50ZXIsIG9udXBkYXRlLCBvbmV4aXQpIHtcbiAgdmFyIGVudGVyID0gdGhpcy5lbnRlcigpLCB1cGRhdGUgPSB0aGlzLCBleGl0ID0gdGhpcy5leGl0KCk7XG4gIGlmICh0eXBlb2Ygb25lbnRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZW50ZXIgPSBvbmVudGVyKGVudGVyKTtcbiAgICBpZiAoZW50ZXIpIGVudGVyID0gZW50ZXIuc2VsZWN0aW9uKCk7XG4gIH0gZWxzZSB7XG4gICAgZW50ZXIgPSBlbnRlci5hcHBlbmQob25lbnRlciArIFwiXCIpO1xuICB9XG4gIGlmIChvbnVwZGF0ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlID0gb251cGRhdGUodXBkYXRlKTtcbiAgICBpZiAodXBkYXRlKSB1cGRhdGUgPSB1cGRhdGUuc2VsZWN0aW9uKCk7XG4gIH1cbiAgaWYgKG9uZXhpdCA9PSBudWxsKSBleGl0LnJlbW92ZSgpOyBlbHNlIG9uZXhpdChleGl0KTtcbiAgcmV0dXJuIGVudGVyICYmIHVwZGF0ZSA/IGVudGVyLm1lcmdlKHVwZGF0ZSkub3JkZXIoKSA6IHVwZGF0ZTtcbn1cbiIsImZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChsb3dlcik7XG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICB2YXIgc2VsZWN0aW9uID0gY29udGV4dC5zZWxlY3Rpb24gPyBjb250ZXh0LnNlbGVjdGlvbigpIDogY29udGV4dDtcblxuICBmb3IgKHZhciBncm91cHMwID0gdGhpcy5fZ3JvdXBzLCBncm91cHMxID0gc2VsZWN0aW9uLl9ncm91cHMsIG0wID0gZ3JvdXBzMC5sZW5ndGgsIG0xID0gZ3JvdXBzMS5sZW5ndGgsIG0gPSBNYXRoLm1pbihtMCwgbTEpLCBtZXJnZXMgPSBuZXcgQXJyYXkobTApLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICBtZXJnZVtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIG5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChub2RlKSByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbn1cbiIsImZ1bmN0aW9uIGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50LCB0aGlzLl9fZGF0YV9fKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbjtcbiAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgZm9yICh2YXIgaiA9IDAsIGkgPSAtMSwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8ub3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblsrK2ldID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IGNvbnRleHRMaXN0ZW5lcih2YWx1ZSk7XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgaWYgKChvID0gb25bal0pLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8ub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIgPSBsaXN0ZW5lciwgby5vcHRpb25zID0gb3B0aW9ucyk7XG4gICAgICAgIG8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZW5hbWUudHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIG8gPSB7dHlwZTogdHlwZW5hbWUudHlwZSwgbmFtZTogdHlwZW5hbWUubmFtZSwgdmFsdWU6IHZhbHVlLCBsaXN0ZW5lcjogbGlzdGVuZXIsIG9wdGlvbnM6IG9wdGlvbnN9O1xuICAgIGlmICghb24pIHRoaXMuX19vbiA9IFtvXTtcbiAgICBlbHNlIG9uLnB1c2gobyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHR5cGVuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgdHlwZW5hbWVzID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiKSwgaSwgbiA9IHR5cGVuYW1lcy5sZW5ndGgsIHQ7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG9uID0gdGhpcy5ub2RlKCkuX19vbjtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKGkgPSAwLCBvID0gb25bal07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKCh0ID0gdHlwZW5hbWVzW2ldKS50eXBlID09PSBvLnR5cGUgJiYgdC5uYW1lID09PSBvLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBvbiA9IHZhbHVlID8gb25BZGQgOiBvblJlbW92ZTtcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgdGhpcy5lYWNoKG9uKHR5cGVuYW1lc1tpXSwgdmFsdWUsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAtMSwgbSA9IGdyb3Vwcy5sZW5ndGg7ICsraiA8IG07KSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSBncm91cC5sZW5ndGggLSAxLCBuZXh0ID0gZ3JvdXBbaV0sIG5vZGU7IC0taSA+PSAwOykge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBpZiAobmV4dCAmJiBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5leHQpIF4gNCkgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcbiAgICAgICAgbmV4dCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJmdW5jdGlvbiBwcm9wZXJ0eVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgZWxzZSB0aGlzW25hbWVdID0gdjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gcHJvcGVydHlSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gcHJvcGVydHlGdW5jdGlvblxuICAgICAgICAgIDogcHJvcGVydHlDb25zdGFudCkobmFtZSwgdmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKVtuYW1lXTtcbn1cbiIsImZ1bmN0aW9uIHJhaXNlKCkge1xuICBpZiAodGhpcy5uZXh0U2libGluZykgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyYWlzZSk7XG59XG4iLCJmdW5jdGlvbiByZW1vdmUoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmVtb3ZlKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yIGZyb20gXCIuLi9zZWxlY3Rvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3Ioc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IGFycmF5IGZyb20gXCIuLi9hcnJheS5qc1wiO1xuaW1wb3J0IHNlbGVjdG9yQWxsIGZyb20gXCIuLi9zZWxlY3RvckFsbC5qc1wiO1xuXG5mdW5jdGlvbiBhcnJheUFsbChzZWxlY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcnJheShzZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCA9PT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBhcnJheUFsbChzZWxlY3QpO1xuICBlbHNlIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc3ViZ3JvdXBzLnB1c2goc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgcGFyZW50cyk7XG59XG4iLCJpbXBvcnQge2NoaWxkTWF0Y2hlcn0gZnJvbSBcIi4uL21hdGNoZXIuanNcIjtcblxudmFyIGZpbmQgPSBBcnJheS5wcm90b3R5cGUuZmluZDtcblxuZnVuY3Rpb24gY2hpbGRGaW5kKG1hdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmluZC5jYWxsKHRoaXMuY2hpbGRyZW4sIG1hdGNoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hpbGRGaXJzdCgpIHtcbiAgcmV0dXJuIHRoaXMuZmlyc3RFbGVtZW50Q2hpbGQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChtYXRjaCA9PSBudWxsID8gY2hpbGRGaXJzdFxuICAgICAgOiBjaGlsZEZpbmQodHlwZW9mIG1hdGNoID09PSBcImZ1bmN0aW9uXCIgPyBtYXRjaCA6IGNoaWxkTWF0Y2hlcihtYXRjaCkpKTtcbn1cbiIsImltcG9ydCB7Y2hpbGRNYXRjaGVyfSBmcm9tIFwiLi4vbWF0Y2hlci5qc1wiO1xuXG52YXIgZmlsdGVyID0gQXJyYXkucHJvdG90eXBlLmZpbHRlcjtcblxuZnVuY3Rpb24gY2hpbGRyZW4oKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiBjaGlsZHJlbkZpbHRlcihtYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKHRoaXMuY2hpbGRyZW4sIG1hdGNoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0QWxsKG1hdGNoID09IG51bGwgPyBjaGlsZHJlblxuICAgICAgOiBjaGlsZHJlbkZpbHRlcih0eXBlb2YgbWF0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IG1hdGNoIDogY2hpbGRNYXRjaGVyKG1hdGNoKSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIGxldCBzaXplID0gMDtcbiAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMpICsrc2l6ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gc2l6ZTtcbn1cbiIsImltcG9ydCB7U2VsZWN0aW9ufSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb21wYXJlKSB7XG4gIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICBmdW5jdGlvbiBjb21wYXJlTm9kZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc29ydGdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc29ydGdyb3VwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ydGdyb3VwLnNvcnQoY29tcGFyZU5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odXBkYXRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG59XG4iLCJpbXBvcnQgZGVmYXVsdFZpZXcgZnJvbSBcIi4uL3dpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gc3R5bGVSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBzdHlsZUZ1bmN0aW9uXG4gICAgICAgICAgICA6IHN0eWxlQ29uc3RhbnQpKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSlcbiAgICAgIDogc3R5bGVWYWx1ZSh0aGlzLm5vZGUoKSwgbmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHlsZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKVxuICAgICAgfHwgZGVmYXVsdFZpZXcobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xufVxuIiwiZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyB0ZXh0UmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyB0ZXh0RnVuY3Rpb25cbiAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn1cbiIsImZ1bmN0aW9uIG5vbmUoKSB7fVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gZW1wdHkgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGxldCBzb3VyY2VFdmVudDtcbiAgd2hpbGUgKHNvdXJjZUV2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQpIGV2ZW50ID0gc291cmNlRXZlbnQ7XG4gIHJldHVybiBldmVudDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgfHwgKG5vZGUuZG9jdW1lbnQgJiYgbm9kZSkgLy8gbm9kZSBpcyBhIFdpbmRvd1xuICAgICAgfHwgbm9kZS5kZWZhdWx0VmlldzsgLy8gbm9kZSBpcyBhIERvY3VtZW50XG59XG4iLCJpbXBvcnQge1RpbWVyfSBmcm9tIFwiLi90aW1lci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIGRlbGF5ID0gZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXk7XG4gIHQucmVzdGFydChlbGFwc2VkID0+IHtcbiAgICB0LnN0b3AoKTtcbiAgICBjYWxsYmFjayhlbGFwc2VkICsgZGVsYXkpO1xuICB9LCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuIiwidmFyIGZyYW1lID0gMCwgLy8gaXMgYW4gYW5pbWF0aW9uIGZyYW1lIHBlbmRpbmc/XG4gICAgdGltZW91dCA9IDAsIC8vIGlzIGEgdGltZW91dCBwZW5kaW5nP1xuICAgIGludGVydmFsID0gMCwgLy8gYXJlIGFueSB0aW1lcnMgYWN0aXZlP1xuICAgIHBva2VEZWxheSA9IDEwMDAsIC8vIGhvdyBmcmVxdWVudGx5IHdlIGNoZWNrIGZvciBjbG9jayBza2V3XG4gICAgdGFza0hlYWQsXG4gICAgdGFza1RhaWwsXG4gICAgY2xvY2tMYXN0ID0gMCxcbiAgICBjbG9ja05vdyA9IDAsXG4gICAgY2xvY2tTa2V3ID0gMCxcbiAgICBjbG9jayA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJvYmplY3RcIiAmJiBwZXJmb3JtYW5jZS5ub3cgPyBwZXJmb3JtYW5jZSA6IERhdGUsXG4gICAgc2V0RnJhbWUgPSB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uKGYpIHsgc2V0VGltZW91dChmLCAxNyk7IH07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiBjbG9ja05vdyB8fCAoc2V0RnJhbWUoY2xlYXJOb3cpLCBjbG9ja05vdyA9IGNsb2NrLm5vdygpICsgY2xvY2tTa2V3KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJOb3coKSB7XG4gIGNsb2NrTm93ID0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFRpbWVyKCkge1xuICB0aGlzLl9jYWxsID1cbiAgdGhpcy5fdGltZSA9XG4gIHRoaXMuX25leHQgPSBudWxsO1xufVxuXG5UaW1lci5wcm90b3R5cGUgPSB0aW1lci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUaW1lcixcbiAgcmVzdGFydDogZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgdGltZSA9ICh0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lKSArIChkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheSk7XG4gICAgaWYgKCF0aGlzLl9uZXh0ICYmIHRhc2tUYWlsICE9PSB0aGlzKSB7XG4gICAgICBpZiAodGFza1RhaWwpIHRhc2tUYWlsLl9uZXh0ID0gdGhpcztcbiAgICAgIGVsc2UgdGFza0hlYWQgPSB0aGlzO1xuICAgICAgdGFza1RhaWwgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9jYWxsID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgc2xlZXAoKTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2NhbGwpIHtcbiAgICAgIHRoaXMuX2NhbGwgPSBudWxsO1xuICAgICAgdGhpcy5fdGltZSA9IEluZmluaXR5O1xuICAgICAgc2xlZXAoKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lcihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyRmx1c2goKSB7XG4gIG5vdygpOyAvLyBHZXQgdGhlIGN1cnJlbnQgdGltZSwgaWYgbm90IGFscmVhZHkgc2V0LlxuICArK2ZyYW1lOyAvLyBQcmV0ZW5kIHdl4oCZdmUgc2V0IGFuIGFsYXJtLCBpZiB3ZSBoYXZlbuKAmXQgYWxyZWFkeS5cbiAgdmFyIHQgPSB0YXNrSGVhZCwgZTtcbiAgd2hpbGUgKHQpIHtcbiAgICBpZiAoKGUgPSBjbG9ja05vdyAtIHQuX3RpbWUpID49IDApIHQuX2NhbGwuY2FsbCh1bmRlZmluZWQsIGUpO1xuICAgIHQgPSB0Ll9uZXh0O1xuICB9XG4gIC0tZnJhbWU7XG59XG5cbmZ1bmN0aW9uIHdha2UoKSB7XG4gIGNsb2NrTm93ID0gKGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpKSArIGNsb2NrU2tldztcbiAgZnJhbWUgPSB0aW1lb3V0ID0gMDtcbiAgdHJ5IHtcbiAgICB0aW1lckZsdXNoKCk7XG4gIH0gZmluYWxseSB7XG4gICAgZnJhbWUgPSAwO1xuICAgIG5hcCgpO1xuICAgIGNsb2NrTm93ID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2tlKCkge1xuICB2YXIgbm93ID0gY2xvY2subm93KCksIGRlbGF5ID0gbm93IC0gY2xvY2tMYXN0O1xuICBpZiAoZGVsYXkgPiBwb2tlRGVsYXkpIGNsb2NrU2tldyAtPSBkZWxheSwgY2xvY2tMYXN0ID0gbm93O1xufVxuXG5mdW5jdGlvbiBuYXAoKSB7XG4gIHZhciB0MCwgdDEgPSB0YXNrSGVhZCwgdDIsIHRpbWUgPSBJbmZpbml0eTtcbiAgd2hpbGUgKHQxKSB7XG4gICAgaWYgKHQxLl9jYWxsKSB7XG4gICAgICBpZiAodGltZSA+IHQxLl90aW1lKSB0aW1lID0gdDEuX3RpbWU7XG4gICAgICB0MCA9IHQxLCB0MSA9IHQxLl9uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0MiA9IHQxLl9uZXh0LCB0MS5fbmV4dCA9IG51bGw7XG4gICAgICB0MSA9IHQwID8gdDAuX25leHQgPSB0MiA6IHRhc2tIZWFkID0gdDI7XG4gICAgfVxuICB9XG4gIHRhc2tUYWlsID0gdDA7XG4gIHNsZWVwKHRpbWUpO1xufVxuXG5mdW5jdGlvbiBzbGVlcCh0aW1lKSB7XG4gIGlmIChmcmFtZSkgcmV0dXJuOyAvLyBTb29uZXN0IGFsYXJtIGFscmVhZHkgc2V0LCBvciB3aWxsIGJlLlxuICBpZiAodGltZW91dCkgdGltZW91dCA9IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgdmFyIGRlbGF5ID0gdGltZSAtIGNsb2NrTm93OyAvLyBTdHJpY3RseSBsZXNzIHRoYW4gaWYgd2UgcmVjb21wdXRlZCBjbG9ja05vdy5cbiAgaWYgKGRlbGF5ID4gMjQpIHtcbiAgICBpZiAodGltZSA8IEluZmluaXR5KSB0aW1lb3V0ID0gc2V0VGltZW91dCh3YWtlLCB0aW1lIC0gY2xvY2subm93KCkgLSBjbG9ja1NrZXcpO1xuICAgIGlmIChpbnRlcnZhbCkgaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWludGVydmFsKSBjbG9ja0xhc3QgPSBjbG9jay5ub3coKSwgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChwb2tlLCBwb2tlRGVsYXkpO1xuICAgIGZyYW1lID0gMSwgc2V0RnJhbWUod2FrZSk7XG4gIH1cbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vdHJhbnNpdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHtTQ0hFRFVMRUR9IGZyb20gXCIuL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcblxudmFyIHJvb3QgPSBbbnVsbF07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBpO1xuXG4gIGlmIChzY2hlZHVsZXMpIHtcbiAgICBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIGlmICgoc2NoZWR1bGUgPSBzY2hlZHVsZXNbaV0pLnN0YXRlID4gU0NIRURVTEVEICYmIHNjaGVkdWxlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKFtbbm9kZV1dLCByb290LCBuYW1lLCAraSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJpbXBvcnQgXCIuL3NlbGVjdGlvbi9pbmRleC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRyYW5zaXRpb259IGZyb20gXCIuL3RyYW5zaXRpb24vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBhY3RpdmV9IGZyb20gXCIuL2FjdGl2ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycnVwdH0gZnJvbSBcIi4vaW50ZXJydXB0LmpzXCI7XG4iLCJpbXBvcnQge1NUQVJUSU5HLCBFTkRJTkcsIEVOREVEfSBmcm9tIFwiLi90cmFuc2l0aW9uL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBhY3RpdmUsXG4gICAgICBlbXB0eSA9IHRydWUsXG4gICAgICBpO1xuXG4gIGlmICghc2NoZWR1bGVzKSByZXR1cm47XG5cbiAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcblxuICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkubmFtZSAhPT0gbmFtZSkgeyBlbXB0eSA9IGZhbHNlOyBjb250aW51ZTsgfVxuICAgIGFjdGl2ZSA9IHNjaGVkdWxlLnN0YXRlID4gU1RBUlRJTkcgJiYgc2NoZWR1bGUuc3RhdGUgPCBFTkRJTkc7XG4gICAgc2NoZWR1bGUuc3RhdGUgPSBFTkRFRDtcbiAgICBzY2hlZHVsZS50aW1lci5zdG9wKCk7XG4gICAgc2NoZWR1bGUub24uY2FsbChhY3RpdmUgPyBcImludGVycnVwdFwiIDogXCJjYW5jZWxcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2NoZWR1bGUuaW5kZXgsIHNjaGVkdWxlLmdyb3VwKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICB9XG5cbiAgaWYgKGVtcHR5KSBkZWxldGUgbm9kZS5fX3RyYW5zaXRpb247XG59XG4iLCJpbXBvcnQge3NlbGVjdGlvbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHNlbGVjdGlvbl9pbnRlcnJ1cHQgZnJvbSBcIi4vaW50ZXJydXB0LmpzXCI7XG5pbXBvcnQgc2VsZWN0aW9uX3RyYW5zaXRpb24gZnJvbSBcIi4vdHJhbnNpdGlvbi5qc1wiO1xuXG5zZWxlY3Rpb24ucHJvdG90eXBlLmludGVycnVwdCA9IHNlbGVjdGlvbl9pbnRlcnJ1cHQ7XG5zZWxlY3Rpb24ucHJvdG90eXBlLnRyYW5zaXRpb24gPSBzZWxlY3Rpb25fdHJhbnNpdGlvbjtcbiIsImltcG9ydCBpbnRlcnJ1cHQgZnJvbSBcIi4uL2ludGVycnVwdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgaW50ZXJydXB0KHRoaXMsIG5hbWUpO1xuICB9KTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbiwgbmV3SWR9IGZyb20gXCIuLi90cmFuc2l0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUgZnJvbSBcIi4uL3RyYW5zaXRpb24vc2NoZWR1bGUuanNcIjtcbmltcG9ydCB7ZWFzZUN1YmljSW5PdXR9IGZyb20gXCJkMy1lYXNlXCI7XG5pbXBvcnQge25vd30gZnJvbSBcImQzLXRpbWVyXCI7XG5cbnZhciBkZWZhdWx0VGltaW5nID0ge1xuICB0aW1lOiBudWxsLCAvLyBTZXQgb24gdXNlLlxuICBkZWxheTogMCxcbiAgZHVyYXRpb246IDI1MCxcbiAgZWFzZTogZWFzZUN1YmljSW5PdXRcbn07XG5cbmZ1bmN0aW9uIGluaGVyaXQobm9kZSwgaWQpIHtcbiAgdmFyIHRpbWluZztcbiAgd2hpbGUgKCEodGltaW5nID0gbm9kZS5fX3RyYW5zaXRpb24pIHx8ICEodGltaW5nID0gdGltaW5nW2lkXSkpIHtcbiAgICBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmFuc2l0aW9uICR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGltaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBpZCxcbiAgICAgIHRpbWluZztcblxuICBpZiAobmFtZSBpbnN0YW5jZW9mIFRyYW5zaXRpb24pIHtcbiAgICBpZCA9IG5hbWUuX2lkLCBuYW1lID0gbmFtZS5fbmFtZTtcbiAgfSBlbHNlIHtcbiAgICBpZCA9IG5ld0lkKCksICh0aW1pbmcgPSBkZWZhdWx0VGltaW5nKS50aW1lID0gbm93KCksIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZCwgaSwgZ3JvdXAsIHRpbWluZyB8fCBpbmhlcml0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuIiwiaW1wb3J0IHtpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyBhcyBpbnRlcnBvbGF0ZVRyYW5zZm9ybX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge25hbWVzcGFjZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuaW1wb3J0IGludGVycG9sYXRlIGZyb20gXCIuL2ludGVycG9sYXRlLmpzXCI7XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCwgdmFsdWUxID0gdmFsdWUodGhpcyksIHN0cmluZzE7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSByZXR1cm4gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpLCBzdHJpbmcxO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCI7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSksIGkgPSBmdWxsbmFtZSA9PT0gXCJ0cmFuc2Zvcm1cIiA/IGludGVycG9sYXRlVHJhbnNmb3JtIDogaW50ZXJwb2xhdGU7XG4gIHJldHVybiB0aGlzLmF0dHJUd2VlbihuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbikoZnVsbG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJhdHRyLlwiICsgbmFtZSwgdmFsdWUpKVxuICAgICAgOiB2YWx1ZSA9PSBudWxsID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkoZnVsbG5hbWUpXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KShmdWxsbmFtZSwgaSwgdmFsdWUpKTtcbn1cbiIsImltcG9ydCB7bmFtZXNwYWNlfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbmZ1bmN0aW9uIGF0dHJJbnRlcnBvbGF0ZShuYW1lLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgaS5jYWxsKHRoaXMsIHQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckludGVycG9sYXRlTlMoZnVsbG5hbWUsIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgaS5jYWxsKHRoaXMsIHQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clR3ZWVuTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgYXR0ckludGVycG9sYXRlTlMoZnVsbG5hbWUsIGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW4obmFtZSwgdmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiBhdHRySW50ZXJwb2xhdGUobmFtZSwgaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcImF0dHIuXCIgKyBuYW1lO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCAoZnVsbG5hbWUubG9jYWwgPyBhdHRyVHdlZW5OUyA6IGF0dHJUd2VlbikoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG4iLCJpbXBvcnQge2dldCwgaW5pdH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gZGVsYXlGdW5jdGlvbihpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlbGF5Q29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgaW5pdCh0aGlzLCBpZCkuZGVsYXkgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZGVsYXlGdW5jdGlvblxuICAgICAgICAgIDogZGVsYXlDb25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZGVsYXk7XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBkdXJhdGlvbkZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5kdXJhdGlvbiA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkdXJhdGlvbkNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZHVyYXRpb24gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZHVyYXRpb25GdW5jdGlvblxuICAgICAgICAgIDogZHVyYXRpb25Db25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZHVyYXRpb247XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5lYXNlID0gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaChlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZWFzZTtcbn1cbiIsImltcG9ydCB7c2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiBlYXNlVmFyeWluZyhpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodHlwZW9mIHYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICAgIHNldCh0aGlzLCBpZCkuZWFzZSA9IHY7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy5lYWNoKGVhc2VWYXJ5aW5nKHRoaXMuX2lkLCB2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgb24wLCBvbjEsIHRoYXQgPSB0aGlzLCBpZCA9IHRoYXQuX2lkLCBzaXplID0gdGhhdC5zaXplKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgY2FuY2VsID0ge3ZhbHVlOiByZWplY3R9LFxuICAgICAgICBlbmQgPSB7dmFsdWU6IGZ1bmN0aW9uKCkgeyBpZiAoLS1zaXplID09PSAwKSByZXNvbHZlKCk7IH19O1xuXG4gICAgdGhhdC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgICBvbiA9IHNjaGVkdWxlLm9uO1xuXG4gICAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgICAgaWYgKG9uICE9PSBvbjApIHtcbiAgICAgICAgb24xID0gKG9uMCA9IG9uKS5jb3B5KCk7XG4gICAgICAgIG9uMS5fLmNhbmNlbC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmludGVycnVwdC5wdXNoKGNhbmNlbCk7XG4gICAgICAgIG9uMS5fLmVuZC5wdXNoKGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIHNlbGVjdGlvbiB3YXMgZW1wdHksIHJlc29sdmUgZW5kIGltbWVkaWF0ZWx5XG4gICAgaWYgKHNpemUgPT09IDApIHJlc29sdmUoKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge21hdGNoZXJ9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcbmltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9hdHRyIGZyb20gXCIuL2F0dHIuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2F0dHJUd2VlbiBmcm9tIFwiLi9hdHRyVHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2RlbGF5IGZyb20gXCIuL2RlbGF5LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9kdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZWFzZSBmcm9tIFwiLi9lYXNlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9lYXNlVmFyeWluZyBmcm9tIFwiLi9lYXNlVmFyeWluZy5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fZmlsdGVyIGZyb20gXCIuL2ZpbHRlci5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fbWVyZ2UgZnJvbSBcIi4vbWVyZ2UuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX29uIGZyb20gXCIuL29uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9yZW1vdmUgZnJvbSBcIi4vcmVtb3ZlLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3QgZnJvbSBcIi4vc2VsZWN0LmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3RBbGwgZnJvbSBcIi4vc2VsZWN0QWxsLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zZWxlY3Rpb24gZnJvbSBcIi4vc2VsZWN0aW9uLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl9zdHlsZSBmcm9tIFwiLi9zdHlsZS5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fc3R5bGVUd2VlbiBmcm9tIFwiLi9zdHlsZVR3ZWVuLmpzXCI7XG5pbXBvcnQgdHJhbnNpdGlvbl90ZXh0IGZyb20gXCIuL3RleHQuanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3RleHRUd2VlbiBmcm9tIFwiLi90ZXh0VHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX3RyYW5zaXRpb24gZnJvbSBcIi4vdHJhbnNpdGlvbi5qc1wiO1xuaW1wb3J0IHRyYW5zaXRpb25fdHdlZW4gZnJvbSBcIi4vdHdlZW4uanNcIjtcbmltcG9ydCB0cmFuc2l0aW9uX2VuZCBmcm9tIFwiLi9lbmQuanNcIjtcblxudmFyIGlkID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zaXRpb24oZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCkge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgdGhpcy5faWQgPSBpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNpdGlvbihuYW1lKSB7XG4gIHJldHVybiBzZWxlY3Rpb24oKS50cmFuc2l0aW9uKG5hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmV3SWQoKSB7XG4gIHJldHVybiArK2lkO1xufVxuXG52YXIgc2VsZWN0aW9uX3Byb3RvdHlwZSA9IHNlbGVjdGlvbi5wcm90b3R5cGU7XG5cblRyYW5zaXRpb24ucHJvdG90eXBlID0gdHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2l0aW9uLFxuICBzZWxlY3Q6IHRyYW5zaXRpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHRyYW5zaXRpb25fc2VsZWN0QWxsLFxuICBzZWxlY3RDaGlsZDogc2VsZWN0aW9uX3Byb3RvdHlwZS5zZWxlY3RDaGlsZCxcbiAgc2VsZWN0Q2hpbGRyZW46IHNlbGVjdGlvbl9wcm90b3R5cGUuc2VsZWN0Q2hpbGRyZW4sXG4gIGZpbHRlcjogdHJhbnNpdGlvbl9maWx0ZXIsXG4gIG1lcmdlOiB0cmFuc2l0aW9uX21lcmdlLFxuICBzZWxlY3Rpb246IHRyYW5zaXRpb25fc2VsZWN0aW9uLFxuICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uX3RyYW5zaXRpb24sXG4gIGNhbGw6IHNlbGVjdGlvbl9wcm90b3R5cGUuY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX3Byb3RvdHlwZS5lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX3Byb3RvdHlwZS5lYWNoLFxuICBvbjogdHJhbnNpdGlvbl9vbixcbiAgYXR0cjogdHJhbnNpdGlvbl9hdHRyLFxuICBhdHRyVHdlZW46IHRyYW5zaXRpb25fYXR0clR3ZWVuLFxuICBzdHlsZTogdHJhbnNpdGlvbl9zdHlsZSxcbiAgc3R5bGVUd2VlbjogdHJhbnNpdGlvbl9zdHlsZVR3ZWVuLFxuICB0ZXh0OiB0cmFuc2l0aW9uX3RleHQsXG4gIHRleHRUd2VlbjogdHJhbnNpdGlvbl90ZXh0VHdlZW4sXG4gIHJlbW92ZTogdHJhbnNpdGlvbl9yZW1vdmUsXG4gIHR3ZWVuOiB0cmFuc2l0aW9uX3R3ZWVuLFxuICBkZWxheTogdHJhbnNpdGlvbl9kZWxheSxcbiAgZHVyYXRpb246IHRyYW5zaXRpb25fZHVyYXRpb24sXG4gIGVhc2U6IHRyYW5zaXRpb25fZWFzZSxcbiAgZWFzZVZhcnlpbmc6IHRyYW5zaXRpb25fZWFzZVZhcnlpbmcsXG4gIGVuZDogdHJhbnNpdGlvbl9lbmQsXG4gIFtTeW1ib2wuaXRlcmF0b3JdOiBzZWxlY3Rpb25fcHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl1cbn07XG4iLCJpbXBvcnQge2NvbG9yfSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVOdW1iZXIsIGludGVycG9sYXRlUmdiLCBpbnRlcnBvbGF0ZVN0cmluZ30gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGM7XG4gIHJldHVybiAodHlwZW9mIGIgPT09IFwibnVtYmVyXCIgPyBpbnRlcnBvbGF0ZU51bWJlclxuICAgICAgOiBiIGluc3RhbmNlb2YgY29sb3IgPyBpbnRlcnBvbGF0ZVJnYlxuICAgICAgOiAoYyA9IGNvbG9yKGIpKSA/IChiID0gYywgaW50ZXJwb2xhdGVSZ2IpXG4gICAgICA6IGludGVycG9sYXRlU3RyaW5nKShhLCBiKTtcbn1cbiIsImltcG9ydCB7VHJhbnNpdGlvbn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHJhbnNpdGlvbikge1xuICBpZiAodHJhbnNpdGlvbi5faWQgIT09IHRoaXMuX2lkKSB0aHJvdyBuZXcgRXJyb3I7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHRyYW5zaXRpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufVxuIiwiaW1wb3J0IHtnZXQsIHNldCwgaW5pdH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZnVuY3Rpb24gc3RhcnQobmFtZSkge1xuICByZXR1cm4gKG5hbWUgKyBcIlwiKS50cmltKCkuc3BsaXQoL158XFxzKy8pLmV2ZXJ5KGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuICF0IHx8IHQgPT09IFwic3RhcnRcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uRnVuY3Rpb24oaWQsIG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBvbjAsIG9uMSwgc2l0ID0gc3RhcnQobmFtZSkgPyBpbml0IDogc2V0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2l0KHRoaXMsIGlkKSxcbiAgICAgICAgb24gPSBzY2hlZHVsZS5vbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAob24gIT09IG9uMCkgKG9uMSA9IChvbjAgPSBvbikuY29weSgpKS5vbihuYW1lLCBsaXN0ZW5lcik7XG5cbiAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyXG4gICAgICA/IGdldCh0aGlzLm5vZGUoKSwgaWQpLm9uLm9uKG5hbWUpXG4gICAgICA6IHRoaXMuZWFjaChvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikpO1xufVxuIiwiZnVuY3Rpb24gcmVtb3ZlRnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLl9fdHJhbnNpdGlvbikgaWYgKCtpICE9PSBpZCkgcmV0dXJuO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9uKFwiZW5kLnJlbW92ZVwiLCByZW1vdmVGdW5jdGlvbih0aGlzLl9pZCkpO1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge3RpbWVyLCB0aW1lb3V0fSBmcm9tIFwiZDMtdGltZXJcIjtcblxudmFyIGVtcHR5T24gPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiZW5kXCIsIFwiY2FuY2VsXCIsIFwiaW50ZXJydXB0XCIpO1xudmFyIGVtcHR5VHdlZW4gPSBbXTtcblxuZXhwb3J0IHZhciBDUkVBVEVEID0gMDtcbmV4cG9ydCB2YXIgU0NIRURVTEVEID0gMTtcbmV4cG9ydCB2YXIgU1RBUlRJTkcgPSAyO1xuZXhwb3J0IHZhciBTVEFSVEVEID0gMztcbmV4cG9ydCB2YXIgUlVOTklORyA9IDQ7XG5leHBvcnQgdmFyIEVORElORyA9IDU7XG5leHBvcnQgdmFyIEVOREVEID0gNjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgbmFtZSwgaWQsIGluZGV4LCBncm91cCwgdGltaW5nKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZXMpIG5vZGUuX190cmFuc2l0aW9uID0ge307XG4gIGVsc2UgaWYgKGlkIGluIHNjaGVkdWxlcykgcmV0dXJuO1xuICBjcmVhdGUobm9kZSwgaWQsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGluZGV4OiBpbmRleCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIGdyb3VwOiBncm91cCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIG9uOiBlbXB0eU9uLFxuICAgIHR3ZWVuOiBlbXB0eVR3ZWVuLFxuICAgIHRpbWU6IHRpbWluZy50aW1lLFxuICAgIGRlbGF5OiB0aW1pbmcuZGVsYXksXG4gICAgZHVyYXRpb246IHRpbWluZy5kdXJhdGlvbixcbiAgICBlYXNlOiB0aW1pbmcuZWFzZSxcbiAgICB0aW1lcjogbnVsbCxcbiAgICBzdGF0ZTogQ1JFQVRFRFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gZ2V0KG5vZGUsIGlkKTtcbiAgaWYgKHNjaGVkdWxlLnN0YXRlID4gQ1JFQVRFRCkgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxhdGU7IGFscmVhZHkgc2NoZWR1bGVkXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gZ2V0KG5vZGUsIGlkKTtcbiAgaWYgKHNjaGVkdWxlLnN0YXRlID4gU1RBUlRFRCkgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxhdGU7IGFscmVhZHkgcnVubmluZ1wiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlIHx8ICEoc2NoZWR1bGUgPSBzY2hlZHVsZVtpZF0pKSB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2l0aW9uIG5vdCBmb3VuZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUobm9kZSwgaWQsIHNlbGYpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgdHdlZW47XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgc2VsZiB0aW1lciB3aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGNyZWF0ZWQuXG4gIC8vIE5vdGUgdGhlIGFjdHVhbCBkZWxheSBpcyBub3Qga25vd24gdW50aWwgdGhlIGZpcnN0IGNhbGxiYWNrIVxuICBzY2hlZHVsZXNbaWRdID0gc2VsZjtcbiAgc2VsZi50aW1lciA9IHRpbWVyKHNjaGVkdWxlLCAwLCBzZWxmLnRpbWUpO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGVsYXBzZWQpIHtcbiAgICBzZWxmLnN0YXRlID0gU0NIRURVTEVEO1xuICAgIHNlbGYudGltZXIucmVzdGFydChzdGFydCwgc2VsZi5kZWxheSwgc2VsZi50aW1lKTtcblxuICAgIC8vIElmIHRoZSBlbGFwc2VkIGRlbGF5IGlzIGxlc3MgdGhhbiBvdXIgZmlyc3Qgc2xlZXAsIHN0YXJ0IGltbWVkaWF0ZWx5LlxuICAgIGlmIChzZWxmLmRlbGF5IDw9IGVsYXBzZWQpIHN0YXJ0KGVsYXBzZWQgLSBzZWxmLmRlbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0KGVsYXBzZWQpIHtcbiAgICB2YXIgaSwgaiwgbiwgbztcblxuICAgIC8vIElmIHRoZSBzdGF0ZSBpcyBub3QgU0NIRURVTEVELCB0aGVuIHdlIHByZXZpb3VzbHkgZXJyb3JlZCBvbiBzdGFydC5cbiAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gU0NIRURVTEVEKSByZXR1cm4gc3RvcCgpO1xuXG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgbyA9IHNjaGVkdWxlc1tpXTtcbiAgICAgIGlmIChvLm5hbWUgIT09IHNlbGYubmFtZSkgY29udGludWU7XG5cbiAgICAgIC8vIFdoaWxlIHRoaXMgZWxlbWVudCBhbHJlYWR5IGhhcyBhIHN0YXJ0aW5nIHRyYW5zaXRpb24gZHVyaW5nIHRoaXMgZnJhbWUsXG4gICAgICAvLyBkZWZlciBzdGFydGluZyBhbiBpbnRlcnJ1cHRpbmcgdHJhbnNpdGlvbiB1bnRpbCB0aGF0IHRyYW5zaXRpb24gaGFzIGFcbiAgICAgIC8vIGNoYW5jZSB0byB0aWNrIChhbmQgcG9zc2libHkgZW5kKTsgc2VlIGQzL2QzLXRyYW5zaXRpb24jNTQhXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gU1RBUlRFRCkgcmV0dXJuIHRpbWVvdXQoc3RhcnQpO1xuXG4gICAgICAvLyBJbnRlcnJ1cHQgdGhlIGFjdGl2ZSB0cmFuc2l0aW9uLCBpZiBhbnkuXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gUlVOTklORykge1xuICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgIG8udGltZXIuc3RvcCgpO1xuICAgICAgICBvLm9uLmNhbGwoXCJpbnRlcnJ1cHRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgby5pbmRleCwgby5ncm91cCk7XG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gICAgICB9XG5cbiAgICAgIC8vIENhbmNlbCBhbnkgcHJlLWVtcHRlZCB0cmFuc2l0aW9ucy5cbiAgICAgIGVsc2UgaWYgKCtpIDwgaWQpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiY2FuY2VsXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmVyIHRoZSBmaXJzdCB0aWNrIHRvIGVuZCBvZiB0aGUgY3VycmVudCBmcmFtZTsgc2VlIGQzL2QzIzE1NzYuXG4gICAgLy8gTm90ZSB0aGUgdHJhbnNpdGlvbiBtYXkgYmUgY2FuY2VsZWQgYWZ0ZXIgc3RhcnQgYW5kIGJlZm9yZSB0aGUgZmlyc3QgdGljayFcbiAgICAvLyBOb3RlIHRoaXMgbXVzdCBiZSBzY2hlZHVsZWQgYmVmb3JlIHRoZSBzdGFydCBldmVudDsgc2VlIGQzL2QzLXRyYW5zaXRpb24jMTYhXG4gICAgLy8gQXNzdW1pbmcgdGhpcyBpcyBzdWNjZXNzZnVsLCBzdWJzZXF1ZW50IGNhbGxiYWNrcyBnbyBzdHJhaWdodCB0byB0aWNrLlxuICAgIHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gU1RBUlRFRCkge1xuICAgICAgICBzZWxmLnN0YXRlID0gUlVOTklORztcbiAgICAgICAgc2VsZi50aW1lci5yZXN0YXJ0KHRpY2ssIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG4gICAgICAgIHRpY2soZWxhcHNlZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgc3RhcnQgZXZlbnQuXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgZG9uZSBiZWZvcmUgdGhlIHR3ZWVuIGFyZSBpbml0aWFsaXplZC5cbiAgICBzZWxmLnN0YXRlID0gU1RBUlRJTkc7XG4gICAgc2VsZi5vbi5jYWxsKFwic3RhcnRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNUQVJUSU5HKSByZXR1cm47IC8vIGludGVycnVwdGVkXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJURUQ7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSB0d2VlbiwgZGVsZXRpbmcgbnVsbCB0d2Vlbi5cbiAgICB0d2VlbiA9IG5ldyBBcnJheShuID0gc2VsZi50d2Vlbi5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGogPSAtMTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG8gPSBzZWxmLnR3ZWVuW2ldLnZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCkpIHtcbiAgICAgICAgdHdlZW5bKytqXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIHR3ZWVuLmxlbmd0aCA9IGogKyAxO1xuICB9XG5cbiAgZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgdmFyIHQgPSBlbGFwc2VkIDwgc2VsZi5kdXJhdGlvbiA/IHNlbGYuZWFzZS5jYWxsKG51bGwsIGVsYXBzZWQgLyBzZWxmLmR1cmF0aW9uKSA6IChzZWxmLnRpbWVyLnJlc3RhcnQoc3RvcCksIHNlbGYuc3RhdGUgPSBFTkRJTkcsIDEpLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB0d2Vlbi5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgdHdlZW5baV0uY2FsbChub2RlLCB0KTtcbiAgICB9XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgZW5kIGV2ZW50LlxuICAgIGlmIChzZWxmLnN0YXRlID09PSBFTkRJTkcpIHtcbiAgICAgIHNlbGYub24uY2FsbChcImVuZFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKTtcbiAgICAgIHN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHNlbGYuc3RhdGUgPSBFTkRFRDtcbiAgICBzZWxmLnRpbWVyLnN0b3AoKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2lkXTtcbiAgICBmb3IgKHZhciBpIGluIHNjaGVkdWxlcykgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xuICB9XG59XG4iLCJpbXBvcnQge3NlbGVjdG9yfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZCA9IHRoaXMuX2lkO1xuXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgICBzY2hlZHVsZShzdWJncm91cFtpXSwgbmFtZSwgaWQsIGksIHN1Ymdyb3VwLCBnZXQobm9kZSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZCk7XG59XG4iLCJpbXBvcnQge3NlbGVjdG9yQWxsfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge1RyYW5zaXRpb259IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgc2NoZWR1bGUsIHtnZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlbGVjdCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZCA9IHRoaXMuX2lkO1xuXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgZm9yICh2YXIgY2hpbGRyZW4gPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCksIGNoaWxkLCBpbmhlcml0ID0gZ2V0KG5vZGUsIGlkKSwgayA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGsgPCBsOyArK2spIHtcbiAgICAgICAgICBpZiAoY2hpbGQgPSBjaGlsZHJlbltrXSkge1xuICAgICAgICAgICAgc2NoZWR1bGUoY2hpbGQsIG5hbWUsIGlkLCBrLCBjaGlsZHJlbiwgaW5oZXJpdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKGNoaWxkcmVuKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHBhcmVudHMsIG5hbWUsIGlkKTtcbn1cbiIsImltcG9ydCB7c2VsZWN0aW9ufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5cbnZhciBTZWxlY3Rpb24gPSBzZWxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgYXMgaW50ZXJwb2xhdGVUcmFuc2Zvcm19IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtzdHlsZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xuaW1wb3J0IHtzZXR9IGZyb20gXCIuL3NjaGVkdWxlLmpzXCI7XG5pbXBvcnQge3R3ZWVuVmFsdWV9IGZyb20gXCIuL3R3ZWVuLmpzXCI7XG5pbXBvcnQgaW50ZXJwb2xhdGUgZnJvbSBcIi4vaW50ZXJwb2xhdGUuanNcIjtcblxuZnVuY3Rpb24gc3R5bGVOdWxsKG5hbWUsIGludGVycG9sYXRlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBzdHlsZSh0aGlzLCBuYW1lKSxcbiAgICAgICAgc3RyaW5nMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBzdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHN0cmluZzEwID0gc3RyaW5nMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gc3R5bGUodGhpcywgbmFtZSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBzdHlsZSh0aGlzLCBuYW1lKSxcbiAgICAgICAgdmFsdWUxID0gdmFsdWUodGhpcyksXG4gICAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgc3RyaW5nMSA9IHZhbHVlMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBzdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZU1heWJlUmVtb3ZlKGlkLCBuYW1lKSB7XG4gIHZhciBvbjAsIG9uMSwgbGlzdGVuZXIwLCBrZXkgPSBcInN0eWxlLlwiICsgbmFtZSwgZXZlbnQgPSBcImVuZC5cIiArIGtleSwgcmVtb3ZlO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgb24gPSBzY2hlZHVsZS5vbixcbiAgICAgICAgbGlzdGVuZXIgPSBzY2hlZHVsZS52YWx1ZVtrZXldID09IG51bGwgPyByZW1vdmUgfHwgKHJlbW92ZSA9IHN0eWxlUmVtb3ZlKG5hbWUpKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAob24gIT09IG9uMCB8fCBsaXN0ZW5lcjAgIT09IGxpc3RlbmVyKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKGV2ZW50LCBsaXN0ZW5lcjAgPSBsaXN0ZW5lcik7XG5cbiAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciBpID0gKG5hbWUgKz0gXCJcIikgPT09IFwidHJhbnNmb3JtXCIgPyBpbnRlcnBvbGF0ZVRyYW5zZm9ybSA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlTnVsbChuYW1lLCBpKSlcbiAgICAgIC5vbihcImVuZC5zdHlsZS5cIiArIG5hbWUsIHN0eWxlUmVtb3ZlKG5hbWUpKVxuICAgIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZUZ1bmN0aW9uKG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJzdHlsZS5cIiArIG5hbWUsIHZhbHVlKSkpXG4gICAgICAuZWFjaChzdHlsZU1heWJlUmVtb3ZlKHRoaXMuX2lkLCBuYW1lKSlcbiAgICA6IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlQ29uc3RhbnQobmFtZSwgaSwgdmFsdWUpLCBwcmlvcml0eSlcbiAgICAgIC5vbihcImVuZC5zdHlsZS5cIiArIG5hbWUsIG51bGwpO1xufVxuIiwiZnVuY3Rpb24gc3R5bGVJbnRlcnBvbGF0ZShuYW1lLCBpLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgaS5jYWxsKHRoaXMsIHQpLCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciB0LCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdCA9IChpMCA9IGkpICYmIHN0eWxlSW50ZXJwb2xhdGUobmFtZSwgaSwgcHJpb3JpdHkpO1xuICAgIHJldHVybiB0O1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIga2V5ID0gXCJzdHlsZS5cIiArIChuYW1lICs9IFwiXCIpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpO1xufVxuIiwiaW1wb3J0IHt0d2VlblZhbHVlfSBmcm9tIFwiLi90d2Vlbi5qc1wiO1xuXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUxID0gdmFsdWUodGhpcyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlMSA9PSBudWxsID8gXCJcIiA6IHZhbHVlMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMudHdlZW4oXCJ0ZXh0XCIsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IHRleHRGdW5jdGlvbih0d2VlblZhbHVlKHRoaXMsIFwidGV4dFwiLCB2YWx1ZSkpXG4gICAgICA6IHRleHRDb25zdGFudCh2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIikpO1xufVxuIiwiZnVuY3Rpb24gdGV4dEludGVycG9sYXRlKGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gaS5jYWxsKHRoaXMsIHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0VHdlZW4odmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiB0ZXh0SW50ZXJwb2xhdGUoaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcInRleHRcIjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHRleHRUd2Vlbih2YWx1ZSkpO1xufVxuIiwiaW1wb3J0IHtUcmFuc2l0aW9uLCBuZXdJZH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCBzY2hlZHVsZSwge2dldH0gZnJvbSBcIi4vc2NoZWR1bGUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkMCA9IHRoaXMuX2lkLFxuICAgICAgaWQxID0gbmV3SWQoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICB2YXIgaW5oZXJpdCA9IGdldChub2RlLCBpZDApO1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZDEsIGksIGdyb3VwLCB7XG4gICAgICAgICAgdGltZTogaW5oZXJpdC50aW1lICsgaW5oZXJpdC5kZWxheSArIGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgICAgZHVyYXRpb246IGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgICAgZWFzZTogaW5oZXJpdC5lYXNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkMSk7XG59XG4iLCJpbXBvcnQge2dldCwgc2V0fSBmcm9tIFwiLi9zY2hlZHVsZS5qc1wiO1xuXG5mdW5jdGlvbiB0d2VlblJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgdHdlZW4wLCB0d2VlbjE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlLnR3ZWVuO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAodHdlZW4gIT09IHR3ZWVuMCkge1xuICAgICAgdHdlZW4xID0gdHdlZW4wID0gdHdlZW47XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdHdlZW4xID0gdHdlZW4xLnNsaWNlKCk7XG4gICAgICAgICAgdHdlZW4xLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNjaGVkdWxlLnR3ZWVuID0gdHdlZW4xO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0d2VlbkZ1bmN0aW9uKGlkLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHdlZW4wLCB0d2VlbjE7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgdHdlZW4gYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9ICh0d2VlbjAgPSB0d2Vlbikuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIHQgPSB7bmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlfSwgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMVtpXSA9IHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBuKSB0d2VlbjEucHVzaCh0KTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgbmFtZSArPSBcIlwiO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciB0d2VlbiA9IGdldCh0aGlzLm5vZGUoKSwgaWQpLnR3ZWVuO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4ubGVuZ3RoLCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHQgPSB0d2VlbltpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gdC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsID8gdHdlZW5SZW1vdmUgOiB0d2VlbkZ1bmN0aW9uKShpZCwgbmFtZSwgdmFsdWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR3ZWVuVmFsdWUodHJhbnNpdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdHJhbnNpdGlvbi5faWQ7XG5cbiAgdHJhbnNpdGlvbi5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCk7XG4gICAgKHNjaGVkdWxlLnZhbHVlIHx8IChzY2hlZHVsZS52YWx1ZSA9IHt9KSlbbmFtZV0gPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBnZXQobm9kZSwgaWQpLnZhbHVlW25hbWVdO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiAoKSA9PiB4O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gWm9vbUV2ZW50KHR5cGUsIHtcbiAgc291cmNlRXZlbnQsXG4gIHRhcmdldCxcbiAgdHJhbnNmb3JtLFxuICBkaXNwYXRjaFxufSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgdHlwZToge3ZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHNvdXJjZUV2ZW50OiB7dmFsdWU6IHNvdXJjZUV2ZW50LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9LFxuICAgIHRhcmdldDoge3ZhbHVlOiB0YXJnZXQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0sXG4gICAgdHJhbnNmb3JtOiB7dmFsdWU6IHRyYW5zZm9ybSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSxcbiAgICBfOiB7dmFsdWU6IGRpc3BhdGNofVxuICB9KTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyB6b29tfSBmcm9tIFwiLi96b29tLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgem9vbVRyYW5zZm9ybSwgaWRlbnRpdHkgYXMgem9vbUlkZW50aXR5LCBUcmFuc2Zvcm0gYXMgWm9vbVRyYW5zZm9ybX0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG4iLCJleHBvcnQgZnVuY3Rpb24gbm9wcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gVHJhbnNmb3JtKGssIHgsIHkpIHtcbiAgdGhpcy5rID0gaztcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybSxcbiAgc2NhbGU6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayA9PT0gMSA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuayAqIGssIHRoaXMueCwgdGhpcy55KTtcbiAgfSxcbiAgdHJhbnNsYXRlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHggPT09IDAgJiB5ID09PSAwID8gdGhpcyA6IG5ldyBUcmFuc2Zvcm0odGhpcy5rLCB0aGlzLnggKyB0aGlzLmsgKiB4LCB0aGlzLnkgKyB0aGlzLmsgKiB5KTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIFtwb2ludFswXSAqIHRoaXMuayArIHRoaXMueCwgcG9pbnRbMV0gKiB0aGlzLmsgKyB0aGlzLnldO1xuICB9LFxuICBhcHBseVg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCAqIHRoaXMuayArIHRoaXMueDtcbiAgfSxcbiAgYXBwbHlZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkgKiB0aGlzLmsgKyB0aGlzLnk7XG4gIH0sXG4gIGludmVydDogZnVuY3Rpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gWyhsb2NhdGlvblswXSAtIHRoaXMueCkgLyB0aGlzLmssIChsb2NhdGlvblsxXSAtIHRoaXMueSkgLyB0aGlzLmtdO1xuICB9LFxuICBpbnZlcnRYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuICh4IC0gdGhpcy54KSAvIHRoaXMuaztcbiAgfSxcbiAgaW52ZXJ0WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiAoeSAtIHRoaXMueSkgLyB0aGlzLms7XG4gIH0sXG4gIHJlc2NhbGVYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHguY29weSgpLmRvbWFpbih4LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WCwgdGhpcykubWFwKHguaW52ZXJ0LCB4KSk7XG4gIH0sXG4gIHJlc2NhbGVZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkuY29weSgpLmRvbWFpbih5LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WSwgdGhpcykubWFwKHkuaW52ZXJ0LCB5KSk7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnggKyBcIixcIiArIHRoaXMueSArIFwiKSBzY2FsZShcIiArIHRoaXMuayArIFwiKVwiO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIGlkZW50aXR5ID0gbmV3IFRyYW5zZm9ybSgxLCAwLCAwKTtcblxudHJhbnNmb3JtLnByb3RvdHlwZSA9IFRyYW5zZm9ybS5wcm90b3R5cGU7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlKSB7XG4gIHdoaWxlICghbm9kZS5fX3pvb20pIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHJldHVybiBub2RlLl9fem9vbTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHtkcmFnRGlzYWJsZSwgZHJhZ0VuYWJsZX0gZnJvbSBcImQzLWRyYWdcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVab29tfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7c2VsZWN0LCBwb2ludGVyfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XG5pbXBvcnQge2ludGVycnVwdH0gZnJvbSBcImQzLXRyYW5zaXRpb25cIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IFpvb21FdmVudCBmcm9tIFwiLi9ldmVudC5qc1wiO1xuaW1wb3J0IHtUcmFuc2Zvcm0sIGlkZW50aXR5fSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbmltcG9ydCBub2V2ZW50LCB7bm9wcm9wYWdhdGlvbn0gZnJvbSBcIi4vbm9ldmVudC5qc1wiO1xuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbi8vIGV4Y2VwdCBmb3IgcGluY2gtdG8tem9vbSwgd2hpY2ggaXMgc2VudCBhcyBhIHdoZWVsK2N0cmxLZXkgZXZlbnRcbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIoZXZlbnQpIHtcbiAgcmV0dXJuICghZXZlbnQuY3RybEtleSB8fCBldmVudC50eXBlID09PSAnd2hlZWwnKSAmJiAhZXZlbnQuYnV0dG9uO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0RXh0ZW50KCkge1xuICB2YXIgZSA9IHRoaXM7XG4gIGlmIChlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgIGUgPSBlLm93bmVyU1ZHRWxlbWVudCB8fCBlO1xuICAgIGlmIChlLmhhc0F0dHJpYnV0ZShcInZpZXdCb3hcIikpIHtcbiAgICAgIGUgPSBlLnZpZXdCb3guYmFzZVZhbDtcbiAgICAgIHJldHVybiBbW2UueCwgZS55XSwgW2UueCArIGUud2lkdGgsIGUueSArIGUuaGVpZ2h0XV07XG4gICAgfVxuICAgIHJldHVybiBbWzAsIDBdLCBbZS53aWR0aC5iYXNlVmFsLnZhbHVlLCBlLmhlaWdodC5iYXNlVmFsLnZhbHVlXV07XG4gIH1cbiAgcmV0dXJuIFtbMCwgMF0sIFtlLmNsaWVudFdpZHRoLCBlLmNsaWVudEhlaWdodF1dO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VHJhbnNmb3JtKCkge1xuICByZXR1cm4gdGhpcy5fX3pvb20gfHwgaWRlbnRpdHk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXaGVlbERlbHRhKGV2ZW50KSB7XG4gIHJldHVybiAtZXZlbnQuZGVsdGFZICogKGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDAuMDUgOiBldmVudC5kZWx0YU1vZGUgPyAxIDogMC4wMDIpICogKGV2ZW50LmN0cmxLZXkgPyAxMCA6IDEpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VG91Y2hhYmxlKCkge1xuICByZXR1cm4gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IChcIm9udG91Y2hzdGFydFwiIGluIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29uc3RyYWluKHRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpIHtcbiAgdmFyIGR4MCA9IHRyYW5zZm9ybS5pbnZlcnRYKGV4dGVudFswXVswXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMF0sXG4gICAgICBkeDEgPSB0cmFuc2Zvcm0uaW52ZXJ0WChleHRlbnRbMV1bMF0pIC0gdHJhbnNsYXRlRXh0ZW50WzFdWzBdLFxuICAgICAgZHkwID0gdHJhbnNmb3JtLmludmVydFkoZXh0ZW50WzBdWzFdKSAtIHRyYW5zbGF0ZUV4dGVudFswXVsxXSxcbiAgICAgIGR5MSA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFsxXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMV1bMV07XG4gIHJldHVybiB0cmFuc2Zvcm0udHJhbnNsYXRlKFxuICAgIGR4MSA+IGR4MCA/IChkeDAgKyBkeDEpIC8gMiA6IE1hdGgubWluKDAsIGR4MCkgfHwgTWF0aC5tYXgoMCwgZHgxKSxcbiAgICBkeTEgPiBkeTAgPyAoZHkwICsgZHkxKSAvIDIgOiBNYXRoLm1pbigwLCBkeTApIHx8IE1hdGgubWF4KDAsIGR5MSlcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgZXh0ZW50ID0gZGVmYXVsdEV4dGVudCxcbiAgICAgIGNvbnN0cmFpbiA9IGRlZmF1bHRDb25zdHJhaW4sXG4gICAgICB3aGVlbERlbHRhID0gZGVmYXVsdFdoZWVsRGVsdGEsXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlLFxuICAgICAgc2NhbGVFeHRlbnQgPSBbMCwgSW5maW5pdHldLFxuICAgICAgdHJhbnNsYXRlRXh0ZW50ID0gW1stSW5maW5pdHksIC1JbmZpbml0eV0sIFtJbmZpbml0eSwgSW5maW5pdHldXSxcbiAgICAgIGR1cmF0aW9uID0gMjUwLFxuICAgICAgaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZVpvb20sXG4gICAgICBsaXN0ZW5lcnMgPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiem9vbVwiLCBcImVuZFwiKSxcbiAgICAgIHRvdWNoc3RhcnRpbmcsXG4gICAgICB0b3VjaGZpcnN0LFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICB0b3VjaERlbGF5ID0gNTAwLFxuICAgICAgd2hlZWxEZWxheSA9IDE1MCxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMCxcbiAgICAgIHRhcERpc3RhbmNlID0gMTA7XG5cbiAgZnVuY3Rpb24gem9vbShzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pXG4gICAgICAgIC5vbihcIndoZWVsLnpvb21cIiwgd2hlZWxlZCwge3Bhc3NpdmU6IGZhbHNlfSlcbiAgICAgICAgLm9uKFwibW91c2Vkb3duLnpvb21cIiwgbW91c2Vkb3duZWQpXG4gICAgICAgIC5vbihcImRibGNsaWNrLnpvb21cIiwgZGJsY2xpY2tlZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0Lnpvb21cIiwgdG91Y2hzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuem9vbVwiLCB0b3VjaG1vdmVkKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC56b29tIHRvdWNoY2FuY2VsLnpvb21cIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIHpvb20udHJhbnNmb3JtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gY29sbGVjdGlvbi5zZWxlY3Rpb24gPyBjb2xsZWN0aW9uLnNlbGVjdGlvbigpIDogY29sbGVjdGlvbjtcbiAgICBzZWxlY3Rpb24ucHJvcGVydHkoXCJfX3pvb21cIiwgZGVmYXVsdFRyYW5zZm9ybSk7XG4gICAgaWYgKGNvbGxlY3Rpb24gIT09IHNlbGVjdGlvbikge1xuICAgICAgc2NoZWR1bGUoY29sbGVjdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uaW50ZXJydXB0KCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgLmV2ZW50KGV2ZW50KVxuICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgLnpvb20obnVsbCwgdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0cmFuc2Zvcm0pXG4gICAgICAgICAgLmVuZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHpvb20uc2NhbGVCeSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgaywgcCwgZXZlbnQpIHtcbiAgICB6b29tLnNjYWxlVG8oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrMCA9IHRoaXMuX196b29tLmssXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBrMCAqIGsxO1xuICAgIH0sIHAsIGV2ZW50KTtcbiAgfTtcblxuICB6b29tLnNjYWxlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHAsIGV2ZW50KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdDAgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgICBwMCA9IHAgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHAgPT09IFwiZnVuY3Rpb25cIiA/IHAuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHAsXG4gICAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxuICAgICAgICAgIGsxID0gdHlwZW9mIGsgPT09IFwiZnVuY3Rpb25cIiA/IGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGs7XG4gICAgICByZXR1cm4gY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0MCwgazEpLCBwMCwgcDEpLCBlLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0sIHAsIGV2ZW50KTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUJ5ID0gZnVuY3Rpb24oc2VsZWN0aW9uLCB4LCB5LCBldmVudCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29uc3RyYWluKHRoaXMuX196b29tLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHguYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyB5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB5XG4gICAgICApLCBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBudWxsLCBldmVudCk7XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVUbyA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgeCwgeSwgcCwgZXZlbnQpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbihpZGVudGl0eS50cmFuc2xhdGUocDBbMF0sIHAwWzFdKS5zY2FsZSh0LmspLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IC14LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteCxcbiAgICAgICAgdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IC15LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteVxuICAgICAgKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwLCBldmVudCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2NhbGUodHJhbnNmb3JtLCBrKSB7XG4gICAgayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgaykpO1xuICAgIHJldHVybiBrID09PSB0cmFuc2Zvcm0uayA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0oaywgdHJhbnNmb3JtLngsIHRyYW5zZm9ybS55KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHAwLCBwMSkge1xuICAgIHZhciB4ID0gcDBbMF0gLSBwMVswXSAqIHRyYW5zZm9ybS5rLCB5ID0gcDBbMV0gLSBwMVsxXSAqIHRyYW5zZm9ybS5rO1xuICAgIHJldHVybiB4ID09PSB0cmFuc2Zvcm0ueCAmJiB5ID09PSB0cmFuc2Zvcm0ueSA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0odHJhbnNmb3JtLmssIHgsIHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VudHJvaWQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIFsoK2V4dGVudFswXVswXSArICtleHRlbnRbMV1bMF0pIC8gMiwgKCtleHRlbnRbMF1bMV0gKyArZXh0ZW50WzFdWzFdKSAvIDJdO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUodHJhbnNpdGlvbiwgdHJhbnNmb3JtLCBwb2ludCwgZXZlbnQpIHtcbiAgICB0cmFuc2l0aW9uXG4gICAgICAgIC5vbihcInN0YXJ0Lnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5ldmVudChldmVudCkuc3RhcnQoKTsgfSlcbiAgICAgICAgLm9uKFwiaW50ZXJydXB0Lnpvb20gZW5kLnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5ldmVudChldmVudCkuZW5kKCk7IH0pXG4gICAgICAgIC50d2VlbihcInpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBnID0gZ2VzdHVyZSh0aGF0LCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgICAgICAgIGUgPSBleHRlbnQuYXBwbHkodGhhdCwgYXJncyksXG4gICAgICAgICAgICAgIHAgPSBwb2ludCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcG9pbnQgPT09IFwiZnVuY3Rpb25cIiA/IHBvaW50LmFwcGx5KHRoYXQsIGFyZ3MpIDogcG9pbnQsXG4gICAgICAgICAgICAgIHcgPSBNYXRoLm1heChlWzFdWzBdIC0gZVswXVswXSwgZVsxXVsxXSAtIGVbMF1bMV0pLFxuICAgICAgICAgICAgICBhID0gdGhhdC5fX3pvb20sXG4gICAgICAgICAgICAgIGIgPSB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhhdCwgYXJncykgOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgIGkgPSBpbnRlcnBvbGF0ZShhLmludmVydChwKS5jb25jYXQodyAvIGEuayksIGIuaW52ZXJ0KHApLmNvbmNhdCh3IC8gYi5rKSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGlmICh0ID09PSAxKSB0ID0gYjsgLy8gQXZvaWQgcm91bmRpbmcgZXJyb3Igb24gZW5kLlxuICAgICAgICAgICAgZWxzZSB7IHZhciBsID0gaSh0KSwgayA9IHcgLyBsWzJdOyB0ID0gbmV3IFRyYW5zZm9ybShrLCBwWzBdIC0gbFswXSAqIGssIHBbMV0gLSBsWzFdICogayk7IH1cbiAgICAgICAgICAgIGcuem9vbShudWxsLCB0KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlc3R1cmUodGhhdCwgYXJncywgY2xlYW4pIHtcbiAgICByZXR1cm4gKCFjbGVhbiAmJiB0aGF0Ll9fem9vbWluZykgfHwgbmV3IEdlc3R1cmUodGhhdCwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiBHZXN0dXJlKHRoYXQsIGFyZ3MpIHtcbiAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgIHRoaXMuc291cmNlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgIHRoaXMudGFwcyA9IDA7XG4gIH1cblxuICBHZXN0dXJlLnByb3RvdHlwZSA9IHtcbiAgICBldmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCkgdGhpcy5zb3VyY2VFdmVudCA9IGV2ZW50O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKyt0aGlzLmFjdGl2ZSA9PT0gMSkge1xuICAgICAgICB0aGlzLnRoYXQuX196b29taW5nID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0KFwic3RhcnRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHpvb206IGZ1bmN0aW9uKGtleSwgdHJhbnNmb3JtKSB7XG4gICAgICBpZiAodGhpcy5tb3VzZSAmJiBrZXkgIT09IFwibW91c2VcIikgdGhpcy5tb3VzZVsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy5tb3VzZVswXSk7XG4gICAgICBpZiAodGhpcy50b3VjaDAgJiYga2V5ICE9PSBcInRvdWNoXCIpIHRoaXMudG91Y2gwWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLnRvdWNoMFswXSk7XG4gICAgICBpZiAodGhpcy50b3VjaDEgJiYga2V5ICE9PSBcInRvdWNoXCIpIHRoaXMudG91Y2gxWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLnRvdWNoMVswXSk7XG4gICAgICB0aGlzLnRoYXQuX196b29tID0gdHJhbnNmb3JtO1xuICAgICAgdGhpcy5lbWl0KFwiem9vbVwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRoYXQuX196b29taW5nO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBkID0gc2VsZWN0KHRoaXMudGhhdCkuZGF0dW0oKTtcbiAgICAgIGxpc3RlbmVycy5jYWxsKFxuICAgICAgICB0eXBlLFxuICAgICAgICB0aGlzLnRoYXQsXG4gICAgICAgIG5ldyBab29tRXZlbnQodHlwZSwge1xuICAgICAgICAgIHNvdXJjZUV2ZW50OiB0aGlzLnNvdXJjZUV2ZW50LFxuICAgICAgICAgIHRhcmdldDogem9vbSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy50aGF0Ll9fem9vbSxcbiAgICAgICAgICBkaXNwYXRjaDogbGlzdGVuZXJzXG4gICAgICAgIH0pLFxuICAgICAgICBkXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB3aGVlbGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHQgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgdC5rICogTWF0aC5wb3coMiwgd2hlZWxEZWx0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSkpLFxuICAgICAgICBwID0gcG9pbnRlcihldmVudCk7XG5cbiAgICAvLyBJZiB0aGUgbW91c2UgaXMgaW4gdGhlIHNhbWUgbG9jYXRpb24gYXMgYmVmb3JlLCByZXVzZSBpdC5cbiAgICAvLyBJZiB0aGVyZSB3ZXJlIHJlY2VudCB3aGVlbCBldmVudHMsIHJlc2V0IHRoZSB3aGVlbCBpZGxlIHRpbWVvdXQuXG4gICAgaWYgKGcud2hlZWwpIHtcbiAgICAgIGlmIChnLm1vdXNlWzBdWzBdICE9PSBwWzBdIHx8IGcubW91c2VbMF1bMV0gIT09IHBbMV0pIHtcbiAgICAgICAgZy5tb3VzZVsxXSA9IHQuaW52ZXJ0KGcubW91c2VbMF0gPSBwKTtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dChnLndoZWVsKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIHdoZWVsIGV2ZW50IHdvbuKAmXQgdHJpZ2dlciBhIHRyYW5zZm9ybSBjaGFuZ2UsIGlnbm9yZSBpdC5cbiAgICBlbHNlIGlmICh0LmsgPT09IGspIHJldHVybjtcblxuICAgIC8vIE90aGVyd2lzZSwgY2FwdHVyZSB0aGUgbW91c2UgcG9pbnQgYW5kIGxvY2F0aW9uIGF0IHRoZSBzdGFydC5cbiAgICBlbHNlIHtcbiAgICAgIGcubW91c2UgPSBbcCwgdC5pbnZlcnQocCldO1xuICAgICAgaW50ZXJydXB0KHRoaXMpO1xuICAgICAgZy5zdGFydCgpO1xuICAgIH1cblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGcud2hlZWwgPSBzZXRUaW1lb3V0KHdoZWVsaWRsZWQsIHdoZWVsRGVsYXkpO1xuICAgIGcuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodCwgayksIGcubW91c2VbMF0sIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG5cbiAgICBmdW5jdGlvbiB3aGVlbGlkbGVkKCkge1xuICAgICAgZy53aGVlbCA9IG51bGw7XG4gICAgICBnLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKHRvdWNoZW5kaW5nIHx8ICFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgZyA9IGdlc3R1cmUodGhpcywgYXJncywgdHJ1ZSkuZXZlbnQoZXZlbnQpLFxuICAgICAgICB2ID0gc2VsZWN0KGV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLnpvb21cIiwgbW91c2Vtb3ZlZCwgdHJ1ZSkub24oXCJtb3VzZXVwLnpvb21cIiwgbW91c2V1cHBlZCwgdHJ1ZSksXG4gICAgICAgIHAgPSBwb2ludGVyKGV2ZW50LCBjdXJyZW50VGFyZ2V0KSxcbiAgICAgICAgeDAgPSBldmVudC5jbGllbnRYLFxuICAgICAgICB5MCA9IGV2ZW50LmNsaWVudFk7XG5cbiAgICBkcmFnRGlzYWJsZShldmVudC52aWV3KTtcbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBnLm1vdXNlID0gW3AsIHRoaXMuX196b29tLmludmVydChwKV07XG4gICAgaW50ZXJydXB0KHRoaXMpO1xuICAgIGcuc3RhcnQoKTtcblxuICAgIGZ1bmN0aW9uIG1vdXNlbW92ZWQoZXZlbnQpIHtcbiAgICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgICAgaWYgKCFnLm1vdmVkKSB7XG4gICAgICAgIHZhciBkeCA9IGV2ZW50LmNsaWVudFggLSB4MCwgZHkgPSBldmVudC5jbGllbnRZIC0geTA7XG4gICAgICAgIGcubW92ZWQgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgICAgfVxuICAgICAgZy5ldmVudChldmVudClcbiAgICAgICAuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoZy50aGF0Ll9fem9vbSwgZy5tb3VzZVswXSA9IHBvaW50ZXIoZXZlbnQsIGN1cnJlbnRUYXJnZXQpLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNldXBwZWQoZXZlbnQpIHtcbiAgICAgIHYub24oXCJtb3VzZW1vdmUuem9vbSBtb3VzZXVwLnpvb21cIiwgbnVsbCk7XG4gICAgICBkcmFnRW5hYmxlKGV2ZW50LnZpZXcsIGcubW92ZWQpO1xuICAgICAgbm9ldmVudChldmVudCk7XG4gICAgICBnLmV2ZW50KGV2ZW50KS5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkYmxjbGlja2VkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0MCA9IHRoaXMuX196b29tLFxuICAgICAgICBwMCA9IHBvaW50ZXIoZXZlbnQuY2hhbmdlZFRvdWNoZXMgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50LCB0aGlzKSxcbiAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxuICAgICAgICBrMSA9IHQwLmsgKiAoZXZlbnQuc2hpZnRLZXkgPyAwLjUgOiAyKSxcbiAgICAgICAgdDEgPSBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGV4dGVudC5hcHBseSh0aGlzLCBhcmdzKSwgdHJhbnNsYXRlRXh0ZW50KTtcblxuICAgIG5vZXZlbnQoZXZlbnQpO1xuICAgIGlmIChkdXJhdGlvbiA+IDApIHNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoc2NoZWR1bGUsIHQxLCBwMCwgZXZlbnQpO1xuICAgIGVsc2Ugc2VsZWN0KHRoaXMpLmNhbGwoem9vbS50cmFuc2Zvcm0sIHQxLCBwMCwgZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLFxuICAgICAgICBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzLCBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT09IG4pLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgc3RhcnRlZCwgaSwgdCwgcDtcblxuICAgIG5vcHJvcGFnYXRpb24oZXZlbnQpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gcG9pbnRlcih0LCB0aGlzKTtcbiAgICAgIHAgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApLCB0LmlkZW50aWZpZXJdO1xuICAgICAgaWYgKCFnLnRvdWNoMCkgZy50b3VjaDAgPSBwLCBzdGFydGVkID0gdHJ1ZSwgZy50YXBzID0gMSArICEhdG91Y2hzdGFydGluZztcbiAgICAgIGVsc2UgaWYgKCFnLnRvdWNoMSAmJiBnLnRvdWNoMFsyXSAhPT0gcFsyXSkgZy50b3VjaDEgPSBwLCBnLnRhcHMgPSAwO1xuICAgIH1cblxuICAgIGlmICh0b3VjaHN0YXJ0aW5nKSB0b3VjaHN0YXJ0aW5nID0gY2xlYXJUaW1lb3V0KHRvdWNoc3RhcnRpbmcpO1xuXG4gICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgIGlmIChnLnRhcHMgPCAyKSB0b3VjaGZpcnN0ID0gcFswXSwgdG91Y2hzdGFydGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoc3RhcnRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcbiAgICAgIGludGVycnVwdCh0aGlzKTtcbiAgICAgIGcuc3RhcnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLl9fem9vbWluZykgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmdzKS5ldmVudChldmVudCksXG4gICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0LCBwLCBsO1xuXG4gICAgbm9ldmVudChldmVudCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV0sIHAgPSBwb2ludGVyKHQsIHRoaXMpO1xuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGcudG91Y2gwWzBdID0gcDtcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGcudG91Y2gxWzBdID0gcDtcbiAgICB9XG4gICAgdCA9IGcudGhhdC5fX3pvb207XG4gICAgaWYgKGcudG91Y2gxKSB7XG4gICAgICB2YXIgcDAgPSBnLnRvdWNoMFswXSwgbDAgPSBnLnRvdWNoMFsxXSxcbiAgICAgICAgICBwMSA9IGcudG91Y2gxWzBdLCBsMSA9IGcudG91Y2gxWzFdLFxuICAgICAgICAgIGRwID0gKGRwID0gcDFbMF0gLSBwMFswXSkgKiBkcCArIChkcCA9IHAxWzFdIC0gcDBbMV0pICogZHAsXG4gICAgICAgICAgZGwgPSAoZGwgPSBsMVswXSAtIGwwWzBdKSAqIGRsICsgKGRsID0gbDFbMV0gLSBsMFsxXSkgKiBkbDtcbiAgICAgIHQgPSBzY2FsZSh0LCBNYXRoLnNxcnQoZHAgLyBkbCkpO1xuICAgICAgcCA9IFsocDBbMF0gKyBwMVswXSkgLyAyLCAocDBbMV0gKyBwMVsxXSkgLyAyXTtcbiAgICAgIGwgPSBbKGwwWzBdICsgbDFbMF0pIC8gMiwgKGwwWzFdICsgbDFbMV0pIC8gMl07XG4gICAgfVxuICAgIGVsc2UgaWYgKGcudG91Y2gwKSBwID0gZy50b3VjaDBbMF0sIGwgPSBnLnRvdWNoMFsxXTtcbiAgICBlbHNlIHJldHVybjtcblxuICAgIGcuem9vbShcInRvdWNoXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUodCwgcCwgbCksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuX196b29taW5nKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3MpLmV2ZW50KGV2ZW50KSxcbiAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIHQ7XG5cbiAgICBub3Byb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldO1xuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMDtcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICB9XG4gICAgaWYgKGcudG91Y2gxICYmICFnLnRvdWNoMCkgZy50b3VjaDAgPSBnLnRvdWNoMSwgZGVsZXRlIGcudG91Y2gxO1xuICAgIGlmIChnLnRvdWNoMCkgZy50b3VjaDBbMV0gPSB0aGlzLl9fem9vbS5pbnZlcnQoZy50b3VjaDBbMF0pO1xuICAgIGVsc2Uge1xuICAgICAgZy5lbmQoKTtcbiAgICAgIC8vIElmIHRoaXMgd2FzIGEgZGJsdGFwLCByZXJvdXRlIHRvIHRoZSAob3B0aW9uYWwpIGRibGNsaWNrLnpvb20gaGFuZGxlci5cbiAgICAgIGlmIChnLnRhcHMgPT09IDIpIHtcbiAgICAgICAgdCA9IHBvaW50ZXIodCwgdGhpcyk7XG4gICAgICAgIGlmIChNYXRoLmh5cG90KHRvdWNoZmlyc3RbMF0gLSB0WzBdLCB0b3VjaGZpcnN0WzFdIC0gdFsxXSkgPCB0YXBEaXN0YW5jZSkge1xuICAgICAgICAgIHZhciBwID0gc2VsZWN0KHRoaXMpLm9uKFwiZGJsY2xpY2suem9vbVwiKTtcbiAgICAgICAgICBpZiAocCkgcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgem9vbS53aGVlbERlbHRhID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHdoZWVsRGVsdGEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgem9vbSkgOiB3aGVlbERlbHRhO1xuICB9O1xuXG4gIHpvb20uZmlsdGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZpbHRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiBmaWx0ZXI7XG4gIH07XG5cbiAgem9vbS50b3VjaGFibGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodG91Y2hhYmxlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCB6b29tKSA6IHRvdWNoYWJsZTtcbiAgfTtcblxuICB6b29tLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFtbK19bMF1bMF0sICtfWzBdWzFdXSwgWytfWzFdWzBdLCArX1sxXVsxXV1dKSwgem9vbSkgOiBleHRlbnQ7XG4gIH07XG5cbiAgem9vbS5zY2FsZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZUV4dGVudFswXSA9ICtfWzBdLCBzY2FsZUV4dGVudFsxXSA9ICtfWzFdLCB6b29tKSA6IFtzY2FsZUV4dGVudFswXSwgc2NhbGVFeHRlbnRbMV1dO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZUV4dGVudFswXVswXSA9ICtfWzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMF0gPSArX1sxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdID0gK19bMF1bMV0sIHRyYW5zbGF0ZUV4dGVudFsxXVsxXSA9ICtfWzFdWzFdLCB6b29tKSA6IFtbdHJhbnNsYXRlRXh0ZW50WzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMF1bMV1dLCBbdHJhbnNsYXRlRXh0ZW50WzFdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV1dXTtcbiAgfTtcblxuICB6b29tLmNvbnN0cmFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb25zdHJhaW4gPSBfLCB6b29tKSA6IGNvbnN0cmFpbjtcbiAgfTtcblxuICB6b29tLmR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR1cmF0aW9uID0gK18sIHpvb20pIDogZHVyYXRpb247XG4gIH07XG5cbiAgem9vbS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0ZSA9IF8sIHpvb20pIDogaW50ZXJwb2xhdGU7XG4gIH07XG5cbiAgem9vbS5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyB6b29tIDogdmFsdWU7XG4gIH07XG5cbiAgem9vbS5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCB6b29tKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG5cbiAgem9vbS50YXBEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0YXBEaXN0YW5jZSA9ICtfLCB6b29tKSA6IHRhcERpc3RhbmNlO1xuICB9O1xuXG4gIHJldHVybiB6b29tO1xufVxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG4vLyBpbnRlcm5hbCBpbXBvcnRzXHJcbmltcG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gJy4vR2VvQ2FudmFzLmpzJ1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4vTGF5ZXIuanMnXHJcbmltcG9ydCB7IERhdGFzZXQgfSBmcm9tICcuL0RhdGFzZXQuanMnXHJcbmltcG9ydCB7IFRvb2x0aXAgfSBmcm9tICcuL1Rvb2x0aXAuanMnXHJcbmltcG9ydCB7IENTVkdyaWQgfSBmcm9tICcuL2RhdGFzZXQvQ1NWR3JpZC5qcydcclxuaW1wb3J0IHsgTEdyaWQgfSBmcm9tICcuL2RhdGFzZXQvTEdyaWQuanMnXHJcbmltcG9ydCB7IFRpbGVkR3JpZCB9IGZyb20gJy4vZGF0YXNldC9UaWxlZEdyaWQuanMnXHJcbmltcG9ydCB7IEJhY2tncm91bmRMYXllciB9IGZyb20gJy4vQmFja2dyb3VuZExheWVyLmpzJ1xyXG5pbXBvcnQgeyBCYWNrZ3JvdW5kTGF5ZXJXTVMgfSBmcm9tICcuL0JhY2tncm91bmRMYXllcldNUy5qcydcclxuaW1wb3J0IHsgTGFiZWxMYXllciB9IGZyb20gJy4vTGFiZWxMYXllci5qcydcclxuaW1wb3J0IHsgTGluZUxheWVyIH0gZnJvbSAnLi9MaW5lTGF5ZXIuanMnXHJcbmltcG9ydCB7IG1vbml0b3IsIG1vbml0b3JEdXJhdGlvbiB9IGZyb20gJy4vdXRpbHMvVXRpbHMuanMnXHJcbmltcG9ydCB7IFpvb21CdXR0b25zIH0gZnJvbSAnLi9idXR0b24vWm9vbUJ1dHRvbnMuanMnXHJcbmltcG9ydCB7IEZ1bGxzY3JlZW5CdXR0b24gfSBmcm9tICcuL2J1dHRvbi9GdWxsc2NyZWVuQnV0dG9uLmpzJ1xyXG5cclxuLy8gZXh0ZXJuYWwgaW1wb3J0c1xyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcblxyXG4vKipcclxuICogQSBncmlkdml6IGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXBwIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gY29udGFpbmVyXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIG9wdHMpIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGF5ZXJzLlxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48TGF5ZXI+fVxyXG4gICAgICAgICAqICovXHJcbiAgICAgICAgdGhpcy5sYXllcnMgPSBbXVxyXG5cclxuICAgICAgICAvL2dldCBjb250YWluZXIgZWxlbWVudFxyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyIHx8IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdncmlkdml6JylcclxuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBmaW5kIGdyaWR2aXogY29udGFpbmVyIGVsZW1lbnQuJylcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2h0dHBzOi8vY3NzLXRyaWNrcy5jb20vYWJzb2x1dGUtcG9zaXRpb25pbmctaW5zaWRlLXJlbGF0aXZlLXBvc2l0aW9uaW5nL1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiOyAvLyBjb250YWluZXIgZWxlbWVudCBtdXN0IGhhdmUgcmVsYXRpdmUgcG9zaXRpb25pbmdcclxuXHJcbiAgICAgICAgLy9zZXQgZGltZW5zaW9uc1xyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMudyA9IG9wdHMudyB8fCB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aFxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuaCA9IG9wdHMuaCB8fCB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHRcclxuXHJcbiAgICAgICAgLy9jcmVhdGUgY2FudmFzIGVsZW1lbnQgaWYgdXNlciBkb2VzbnQgc3BlY2lmeSBvbmVcclxuICAgICAgICAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSAqL1xyXG4gICAgICAgIGxldCBjYW52YXMgPSBvcHRzLmNhbnZhcyB8fCBudWxsXHJcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcclxuICAgICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcclxuICAgICAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnJyArIHRoaXMudylcclxuICAgICAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJycgKyB0aGlzLmgpXHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKiBNYWtlIGdlbyBjYW52YXNcclxuICAgICAgICAgKiBAdHlwZSB7R2VvQ2FudmFzfVxyXG4gICAgICAgICAqIEBwcml2YXRlICovXHJcbiAgICAgICAgdGhpcy5jZyA9IG5ldyBHZW9DYW52YXMoY2FudmFzLCB1bmRlZmluZWQsIDEsIG9wdHMpXHJcbiAgICAgICAgdGhpcy5jZy5yZWRyYXcgPSAoc3Ryb25nID0gdHJ1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCdTdGFydCByZWRyYXcnKVxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiP3g9XCIgKyB0aGlzLmNnLmdldENlbnRlcigpLnggKyBcIiZ5PVwiICsgdGhpcy5jZy5nZXRDZW50ZXIoKS55ICsgXCImej1cIiArIHRoaXMuY2cuZ2V0WmYoKSlcclxuXHJcbiAgICAgICAgICAgIC8vcmVtb3ZlIGxlZ2VuZCBlbGVtZW50c1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWdlbmQgJiYgc3Ryb25nKSB0aGlzLmxlZ2VuZC5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAgICAgLy9jbGVhclxyXG4gICAgICAgICAgICB0aGlzLmNnLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxyXG4gICAgICAgICAgICB0aGlzLmNnLmNsZWFyKHRoaXMuY2cuYmFja2dyb3VuZENvbG9yKVxyXG5cclxuICAgICAgICAgICAgY29uc3QgemYgPSB0aGlzLmdldFpvb21GYWN0b3IoKVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXHJcblxyXG4gICAgICAgICAgICAvL2dvIHRocm91Z2ggdGhlIGJhY2tncm91bmQgbGF5ZXJzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dCZ0xheWVycylcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5iZ0xheWVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgbGF5ZXIgaXMgdmlzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGF5ZXIudmlzaWJsZSkgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoemYgPiBsYXllci5tYXhab29tKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh6ZiA8IGxheWVyLm1pblpvb20pIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZHJhdyBsYXllclxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmRyYXcodGhpcy5jZylcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZ28gdGhyb3VnaCB0aGUgbGF5ZXJzXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcclxuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgbGF5ZXIgaXMgdmlzaWJsZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci52aXNpYmxlKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHpmID4gbGF5ZXIubWF4Wm9vbSkgY29udGludWVcclxuICAgICAgICAgICAgICAgIGlmICh6ZiA8IGxheWVyLm1pblpvb20pIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAgICAgLy9nZXQgbGF5ZXIgZGF0YXNldCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL0RhdGFzZXRDb21wb25lbnQnKS5EYXRhc2V0Q29tcG9uZW50fHVuZGVmaW5lZH0gKi9cclxuICAgICAgICAgICAgICAgIGNvbnN0IGRzYyA9IGxheWVyLmdldERhdGFzZXRDb21wb25lbnQoemYpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWRzYykgY29udGludWVcclxuXHJcbiAgICAgICAgICAgICAgICAvL2xhdW5jaCBkYXRhIGRvd25sb2FkLCBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgIGlmIChzdHJvbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgZHNjLmdldERhdGEodGhpcy5jZy5leHRHZW8sICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jZy5yZWRyYXcoKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgLy91cGRhdGUgZGF0YXNldCB2aWV3IGNhY2hlXHJcbiAgICAgICAgICAgICAgICBpZiAoc3Ryb25nKSBkc2MudXBkYXRlVmlld0NhY2hlKHRoaXMuY2cuZXh0R2VvKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vc2V0IGxheWVyIGFscGhhIGFuZCBibGVuZCBtb2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNnLmN0eC5nbG9iYWxBbHBoYSA9IGxheWVyLmFscGhhID8gbGF5ZXIuYWxwaGEoemYpIDogMS4wXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNnLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBsYXllci5ibGVuZE9wZXJhdGlvbih6ZilcclxuXHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgY2VsbHMsIHN0eWxlIGJ5IHN0eWxlXHJcbiAgICAgICAgICAgICAgICBpZiAoc3Ryb25nKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiBsYXllci5zdHlsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBzdHlsZSBpcyB2aXNpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcy52aXNpYmxlKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoemYgPiBzLm1heFpvb20pIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6ZiA8IHMubWluWm9vbSkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IHN0eWxlIGFscGhhIGFuZCBibGVuZCBtb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETzogbXVsdGlwbHkgYnkgbGF5ZXIgYWxwaGEgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNnLmN0eC5nbG9iYWxBbHBoYSA9IHMuYWxwaGEgPyBzLmFscGhhKHpmKSA6IDEuMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNnLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBzLmJsZW5kT3BlcmF0aW9uKHpmKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcy5kcmF3KGRzYy5nZXRWaWV3Q2FjaGUoKSwgZHNjLmdldFJlc29sdXRpb24oKSwgdGhpcy5jZylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9hZGQgbGVnZW5kIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZ2VuZCAmJiBzdHJvbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgbGF5ZXIuc3R5bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6ZiA+IHMubWF4Wm9vbSkgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHpmIDwgcy5taW5ab29tKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxnIG9mIHMubGVnZW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzLCBsZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5sZWdlbmQuYXBwZW5kKGxnLmRpdilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vczEubm9kZSgpLmFwcGVuZENoaWxkKHMyLm5vZGUoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVnZW5kLm5vZGUoKS5hcHBlbmQobGcuZGl2Lm5vZGUoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jYXNlIGZvciBzdHlsZXMgb2Ygc3R5bGVzLCBsaWtlIGtlcm5lbCBzbW9vdGhpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIGRvIGJldHRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc1snc3R5bGVzJ10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgczIgb2Ygcy5zdHlsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoemYgPiBzMi5tYXhab29tKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6ZiA8IHMyLm1pblpvb20pIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBsZyBvZiBzMi5sZWdlbmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocywgbGcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5sZWdlbmQuYXBwZW5kKGxnLmRpdilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zMS5ub2RlKCkuYXBwZW5kQ2hpbGQoczIubm9kZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZ2VuZC5ub2RlKCkuYXBwZW5kKGxnLmRpdi5ub2RlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vcmVzdG9yZSBkZWZhdWx0IGFscGhhIGFuZCBibGVuZCBvcGVyYXRpb25cclxuICAgICAgICAgICAgICAgIHRoaXMuY2cuY3R4Lmdsb2JhbEFscGhhID0gMS4wXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNnLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmRlZmF1bHRHbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IGJvdW5kYXJ5IGxheWVyXHJcbiAgICAgICAgICAgIC8vaWYgKHN0cm9uZylcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0JvdW5kYXJpZXMgJiYgdGhpcy5ib3VuZGFyeUxheWVyKSB0aGlzLmJvdW5kYXJ5TGF5ZXIuZHJhdyh0aGlzLmNnKVxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IGxhYmVsIGxheWVyXHJcbiAgICAgICAgICAgIC8vaWYgKHN0cm9uZylcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0xhYmVscyAmJiB0aGlzLmxhYmVsTGF5ZXIpIHRoaXMubGFiZWxMYXllci5kcmF3KHRoaXMuY2cpXHJcblxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUgPSBudWxsXHJcblxyXG4gICAgICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCdFbmQgcmVkcmF3JylcclxuXHJcbiAgICAgICAgICAgIC8vIGxpc3RlbiBmb3IgcmVzaXplIGV2ZW50cyBvbiB0aGUgQXBwJ3MgY29udGFpbmVyIGFuZCBoYW5kbGUgdGhlbVxyXG4gICAgICAgICAgICB0aGlzLmRlZmluZVJlc2l6ZU9ic2VydmVyKHRoaXMuY29udGFpbmVyLCBjYW52YXMpXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48QmFja2dyb3VuZExheWVyfEJhY2tncm91bmRMYXllcldNUz59ICovXHJcbiAgICAgICAgdGhpcy5iZ0xheWVycyA9IFtdXHJcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xyXG4gICAgICAgIHRoaXMuc2hvd0JnTGF5ZXJzID0gdHJ1ZVxyXG5cclxuICAgICAgICAvKiogQHR5cGUge0xhYmVsTGF5ZXIgfCB1bmRlZmluZWR9ICovXHJcbiAgICAgICAgdGhpcy5sYWJlbExheWVyID0gdW5kZWZpbmVkXHJcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xyXG4gICAgICAgIHRoaXMuc2hvd0xhYmVscyA9IHRydWVcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtMaW5lTGF5ZXIgfCB1bmRlZmluZWR9ICovXHJcbiAgICAgICAgdGhpcy5ib3VuZGFyeUxheWVyID0gdW5kZWZpbmVkXHJcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xyXG4gICAgICAgIHRoaXMuc2hvd0JvdW5kYXJpZXMgPSB0cnVlXHJcblxyXG4gICAgICAgIC8vIGxlZ2VuZCBkaXZcclxuICAgICAgICB0aGlzLmxlZ2VuZERpdklkID0gb3B0cy5sZWdlbmREaXZJZCB8fCAnZ3ZpekxlZ2VuZCdcclxuICAgICAgICB0aGlzLmxlZ2VuZCA9IHNlbGVjdCgnIycgKyB0aGlzLmxlZ2VuZERpdklkKVxyXG4gICAgICAgIGlmICh0aGlzLmxlZ2VuZC5lbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVnZW5kID0gc2VsZWN0KFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuaWQgJiYgdGhpcy5jb250YWluZXIuaWQgIT0gJycgPyAnIycgKyB0aGlzLmNvbnRhaW5lci5pZCA6ICdib2R5J1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgdGhpcy5sZWdlbmREaXZJZClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd3aWR0aCcsICdhdXRvJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnaGVpZ2h0JywgJ2F1dG8nKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kJywgJyNGRkZGRkYnKVxyXG4gICAgICAgICAgICAgICAgLy8uc3R5bGUoXCJwYWRkaW5nXCIsIHRoaXMucGFkZGluZylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYm9yZGVyJywgJzBweCcpXHJcbiAgICAgICAgICAgICAgICAvLy5zdHlsZSgnYm9yZGVyLXJhZGl1cycsICc1cHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3gtc2hhZG93JywgJzNweCAzcHggM3B4IGdyZXksIC0zcHggLTNweCAzcHggI2RkZCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtZmFtaWx5JywgJ0hlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWYnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdib3R0b20nLCAnMTVweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3JpZ2h0JywgJzE1cHgnKVxyXG4gICAgICAgICAgICAvL2hpZGVcclxuICAgICAgICAgICAgLy8uc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3Rvb2x0aXBcclxuXHJcbiAgICAgICAgLy8gc2V0IEFwcCBjb250YWluZXIgYXMgZGVmYXVsdCBwYXJlbnQgZWxlbWVudCBmb3IgdG9vbHRpcFxyXG4gICAgICAgIGlmICghb3B0cy50b29sdGlwKSBvcHRzLnRvb2x0aXAgPSB7fVxyXG4gICAgICAgIGlmICghb3B0cy50b29sdGlwLnBhcmVudEVsZW1lbnQpIG9wdHMudG9vbHRpcC5wYXJlbnRFbGVtZW50ID0gdGhpcy5jb250YWluZXJcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7VG9vbHRpcH0gKi9cclxuICAgICAgICB0aGlzLnRvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRzLnRvb2x0aXApXHJcblxyXG4gICAgICAgIC8qKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgKi9cclxuICAgICAgICBjb25zdCBmb2N1c0NlbGwgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAvL2NvbXB1dGUgbW91c2UgZ2VvIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlUG9zaXRpb25HZW8gPSB7XHJcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmNnLnBpeFRvR2VvWChlLm9mZnNldFggKyB0aGlzLnRvb2x0aXAueE1vdXNlT2Zmc2V0KSxcclxuICAgICAgICAgICAgICAgIHk6IHRoaXMuY2cucGl4VG9HZW9ZKGUub2Zmc2V0WSArIHRoaXMudG9vbHRpcC55TW91c2VPZmZzZXQpLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7e2NlbGw6aW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsLGh0bWw6c3RyaW5nLHJlc29sdXRpb246bnVtYmVyfSB8IHVuZGVmaW5lZH0gKi9cclxuICAgICAgICAgICAgY29uc3QgZm9jdXMgPSB0aGlzLmdldENlbGxGb2N1c0luZm8obW91c2VQb3NpdGlvbkdlbylcclxuXHJcbiAgICAgICAgICAgIC8vIHRyYW5zcGFyZW50IGJhY2tncm91bmQgKGUuZy4gbGVhZmxldCkgJ3JlZCBwYWludGluZycgZml4XHJcbiAgICAgICAgICAgIGlmIChvcHRzLnRyYW5zcGFyZW50QmFja2dyb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b29sdGlwLmh0bWwoZm9jdXMuaHRtbClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAuc2V0UG9zaXRpb24oZSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAuc2hvdygpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcC5oaWRlKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcnICsgdGhpcy53KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJycgKyB0aGlzLmgpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodGhpcy5jZy5jYW52YXMsIDAsIDApXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNnLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChmb2N1cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwLmh0bWwoZm9jdXMuaHRtbClcclxuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zZXRQb3NpdGlvbihlKVxyXG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwLnNob3coKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vc2hvdyBjZWxsIHBvc2l0aW9uIGFzIGEgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2FudmFzU2F2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnJyArIHRoaXMudylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnJyArIHRoaXMuaClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodGhpcy5jZy5jYW52YXMsIDAsIDApXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2cuY3R4LmRyYXdJbWFnZSh0aGlzLmNhbnZhc1NhdmUsIDAsIDApXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9kcmF3IGltYWdlIHNhdmVkICsgZHJhdyByZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3RXUGl4ID0gdGhpcy5zZWxlY3Rpb25SZWN0YW5nbGVXaWR0aFBpeFxyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5zZWxlY3Rpb25SZWN0YW5nbGVXaWR0aFBpeChmb2N1cy5yZXNvbHV0aW9uLCB0aGlzLmdldFpvb21GYWN0b3IoKSlcclxuICAgICAgICAgICAgICAgICAgICA6IDRcclxuICAgICAgICAgICAgICAgIHRoaXMuY2cuaW5pdENhbnZhc1RyYW5zZm9ybSgpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNnLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc2VsZWN0aW9uUmVjdGFuZ2xlQ29sb3JcclxuICAgICAgICAgICAgICAgIHRoaXMuY2cuY3R4LmxpbmVXaWR0aCA9IHJlY3RXUGl4XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNnLmN0eC5iZWdpblBhdGgoKVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuY2cuY3R4LnJlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZy5nZW9Ub1BpeFgoZm9jdXMuY2VsbC54KSAtIHJlY3RXUGl4IC8gMixcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNnLmdlb1RvUGl4WShmb2N1cy5jZWxsLnkpICsgcmVjdFdQaXggLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzLnJlc29sdXRpb24gLyB0aGlzLmdldFpvb21GYWN0b3IoKSArIHJlY3RXUGl4LFxyXG4gICAgICAgICAgICAgICAgICAgIC1mb2N1cy5yZXNvbHV0aW9uIC8gdGhpcy5nZXRab29tRmFjdG9yKCkgLSByZWN0V1BpeFxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jZy5jdHguc3Ryb2tlKClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcC5oaWRlKClcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhc1NhdmUpIHRoaXMuY2cuY3R4LmRyYXdJbWFnZSh0aGlzLmNhbnZhc1NhdmUsIDAsIDApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lcnMgdG8gY29udGFpbmVyXHJcbiAgICAgICAgdGhpcy5tb3VzZU92ZXJIYW5kbGVyID0gKGUpID0+IGZvY3VzQ2VsbChlKVxyXG4gICAgICAgIHRoaXMubW91c2VNb3ZlSGFuZGxlciA9IChlKSA9PiBmb2N1c0NlbGwoZSlcclxuICAgICAgICB0aGlzLm1vdXNlT3V0SGFuZGxlciA9IChlKSA9PiB0aGlzLnRvb2x0aXAuaGlkZSgpXHJcbiAgICAgICAgdGhpcy5jZy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5tb3VzZU92ZXJIYW5kbGVyKVxyXG4gICAgICAgIHRoaXMuY2cuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcilcclxuICAgICAgICB0aGlzLmNnLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMubW91c2VPdXRIYW5kbGVyKVxyXG5cclxuICAgICAgICAvLyBhZGQgZXh0cmEgbG9naWMgdG8gb25ab29tU3RhcnRGdW5cclxuICAgICAgICB0aGlzLmNnLm9uWm9vbVN0YXJ0RnVuID0gKGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9wdHMub25ab29tU3RhcnRGdW4pIG9wdHMub25ab29tU3RhcnRGdW4oZSlcclxuICAgICAgICAgICAgdGhpcy50b29sdGlwLmhpZGUoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9mb3IgbW91c2Ugb3ZlclxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fG51bGx9ICovXHJcbiAgICAgICAgdGhpcy5jYW52YXNTYXZlID0gbnVsbFxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGlvblJlY3RhbmdsZUNvbG9yID0gb3B0cy5zZWxlY3Rpb25SZWN0YW5nbGVDb2xvciB8fCAncmVkJ1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmVjdGFuZ2xlV2lkdGhQaXggPSBvcHRzLnNlbGVjdGlvblJlY3RhbmdsZVdpZHRoUGl4IHx8ICgoKSA9PiA0KSAvLyhyLHpmKSA9PiB7fVxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGUgPT4geyBjb25zb2xlLmxvZyhhcmd1bWVudHMpIH0pO1xyXG5cclxuICAgICAgICAvL3NldCBkZWZhdWx0IGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxyXG4gICAgICAgIHRoaXMuZGVmYXVsdEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9XHJcbiAgICAgICAgICAgIG9wdHMuZGVmYXVsdEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiB8fCB0aGlzLmNnLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXJnaW5QeFxyXG4gICAgICogQHJldHVybnMge2ltcG9ydCgnLi9EYXRhc2V0JykuRW52ZWxvcGV9XHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUV4dGVudEdlbyhtYXJnaW5QeCA9IDIwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2cudXBkYXRlRXh0ZW50R2VvKG1hcmdpblB4KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBjZWxsIEhUTUwgaW5mbyBhdCBhIGdpdmVuIGdlbyBwb3NpdGlvbi5cclxuICAgICAqIFRoaXMgaXMgdXNlZnVsbCBmb3IgdXNlciBpbnRlcmFjdGlvbnMsIHRvIHNob3cgdGhpcyBpbmZvIHdoZXJlIHRoZSB1c2VyIGNsaWNrcyBmb3IgZXhhbXBsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3t4Om51bWJlcix5Om51bWJlcn19IHBvc0dlb1xyXG4gICAgICogQHJldHVybnMge3tjZWxsOmltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCxodG1sOnN0cmluZyxyZXNvbHV0aW9uOm51bWJlcn0gfCB1bmRlZmluZWR9XHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIGdldENlbGxGb2N1c0luZm8ocG9zR2VvKSB7XHJcbiAgICAgICAgLy9nbyB0aHJvdWdoIHRoZSBsYXllcnMsIHN0YXJ0aW5nIGZyb20gdG9wXHJcbiAgICAgICAgY29uc3QgemYgPSB0aGlzLmdldFpvb21GYWN0b3IoKVxyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAvKiogQHR5cGUge0xheWVyfSAqL1xyXG4gICAgICAgICAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzW2ldXHJcbiAgICAgICAgICAgIGlmICghbGF5ZXIudmlzaWJsZSkgY29udGludWVcclxuICAgICAgICAgICAgaWYgKCFsYXllci5jZWxsSW5mb0hUTUwpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIC8vaWYgKGxheWVyLmNlbGxJbmZvSFRNTCA9PT0gJ25vbmUnKSBjb250aW51ZVxyXG4gICAgICAgICAgICBjb25zdCBkc2MgPSBsYXllci5nZXREYXRhc2V0Q29tcG9uZW50KHpmKVxyXG4gICAgICAgICAgICBpZiAoIWRzYykgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8vZ2V0IGNlbGwgYXQgbW91c2UgcG9zaXRpb25cclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGx8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZHNjLmdldENlbGxGcm9tUG9zaXRpb24ocG9zR2VvLCBkc2MuZ2V0Vmlld0NhY2hlKCkpXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coY2VsbCwgZHNjLnJlc29sdXRpb24pXHJcbiAgICAgICAgICAgIGlmICghY2VsbCkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBjb25zdCBodG1sID0gbGF5ZXIuY2VsbEluZm9IVE1MKGNlbGwsIGRzYy5nZXRSZXNvbHV0aW9uKCkpXHJcbiAgICAgICAgICAgIGlmICghaHRtbCkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICByZXR1cm4geyBjZWxsOiBjZWxsLCBodG1sOiBodG1sLCByZXNvbHV0aW9uOiBkc2MuZ2V0UmVzb2x1dGlvbigpIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9nZXR0ZXJzIGFuZCBzZXR0ZXJzXHJcblxyXG4gICAgLyoqIEByZXR1cm5zIHt7eDpudW1iZXIseTpudW1iZXJ9fSAqL1xyXG4gICAgZ2V0R2VvQ2VudGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNnLmdldENlbnRlcigpXHJcbiAgICB9XHJcbiAgICAvKiogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSB2YWwgQHJldHVybnMge3RoaXN9ICovXHJcbiAgICBzZXRHZW9DZW50ZXIodmFsKSB7XHJcbiAgICAgICAgdGhpcy5jZy5zZXRDZW50ZXIodmFsKVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEByZXR1cm5zIHtudW1iZXJ9ICovXHJcbiAgICBnZXRab29tRmFjdG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNnLmdldFpmKClcclxuICAgIH1cclxuICAgIC8qKiBAcGFyYW0ge251bWJlcn0gdmFsIEByZXR1cm5zIHt0aGlzfSAqL1xyXG4gICAgc2V0Wm9vbUZhY3Rvcih2YWwpIHtcclxuICAgICAgICB0aGlzLmNnLnNldFpmKHZhbClcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59ICovXHJcbiAgICBnZXRab29tRmFjdG9yRXh0ZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNnLmdldFpmRXh0ZW50KClcclxuICAgIH1cclxuICAgIC8qKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWwgQHJldHVybnMge3RoaXN9ICovXHJcbiAgICBzZXRab29tRmFjdG9yRXh0ZW50KHZhbCkge1xyXG4gICAgICAgIHRoaXMuY2cuc2V0WmZFeHRlbnQodmFsKVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEByZXR1cm5zIHtzdHJpbmd9ICovXHJcbiAgICBnZXRCYWNrZ3JvdW5kQ29sb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2cuYmFja2dyb3VuZENvbG9yXHJcbiAgICB9XHJcbiAgICAvKiogQHBhcmFtIHtzdHJpbmd9IHZhbCBAcmV0dXJucyB7dGhpc30gKi9cclxuICAgIHNldEJhY2tncm91bmRDb2xvcih2YWwpIHtcclxuICAgICAgICB0aGlzLmNnLmJhY2tncm91bmRDb2xvciA9IHZhbFxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEByZXR1cm5zIHtMaW5lTGF5ZXIgfCB1bmRlZmluZWR9ICovXHJcbiAgICBnZXRCb3VuZGFyeUxheWVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kYXJ5TGF5ZXJcclxuICAgIH1cclxuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyBAcmV0dXJucyB7dGhpc30gKi9cclxuICAgIHNldEJvdW5kYXJ5TGF5ZXIob3B0cykge1xyXG4gICAgICAgIHRoaXMuYm91bmRhcnlMYXllciA9IG5ldyBMaW5lTGF5ZXIob3B0cylcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcmV0dXJucyB7TGFiZWxMYXllciB8IHVuZGVmaW5lZH0gKi9cclxuICAgIGdldExhYmVsTGF5ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxMYXllclxyXG4gICAgfVxyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIEByZXR1cm5zIHt0aGlzfSAqL1xyXG4gICAgc2V0TGFiZWxMYXllcihvcHRzKSB7XHJcbiAgICAgICAgdGhpcy5sYWJlbExheWVyID0gbmV3IExhYmVsTGF5ZXIob3B0cylcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcmV0dXJucyB7dGhpc30gKi9cclxuICAgIHJlZHJhdygpIHtcclxuICAgICAgICB0aGlzLmNnLnJlZHJhdygpXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGxheWVyIHRvIHRoZSBhcHAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtEYXRhc2V0fSBkYXRhc2V0IFRoZSBkYXRhc2V0IG9mIHRoZSBsYXllclxyXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KCcuL1N0eWxlJykuU3R5bGU+fSBzdHlsZXMgVGhlIHN0eWxlcyBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEBwYXJhbSB7e3Zpc2libGU/OmJvb2xlYW4sbWluWm9vbT86bnVtYmVyLG1heFpvb20/Om51bWJlcixwaXhOYj86bnVtYmVyLGNlbGxJbmZvSFRNTD86ZnVuY3Rpb24oaW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsKTpzdHJpbmd9fSBvcHRzIFRoZSBsYXllciBvcHRpb25zLlxyXG4gICAgICogQHJldHVybnMge3RoaXN9XHJcbiAgICAgKi9cclxuICAgIGFkZExheWVyRnJvbURhdGFzZXQoZGF0YXNldCwgc3R5bGVzLCBvcHRzKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ID0gbmV3IExheWVyKGRhdGFzZXQsIHN0eWxlcywgb3B0cylcclxuICAgICAgICB0aGlzLmxheWVycy5wdXNoKGxheSlcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8vZGF0YXNldCBjcmVhdGlvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZSBhIGxvY2FsIGdyaWQgZGF0YXNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBUaGUgZGF0YXNldCByZXNvbHV0aW9uIGluIGdlb2dyYXBoaWNhbCB1bml0LlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2VsbHMgVGhlIGNlbGxzLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRzIFRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBkYXRhc2V0LlxyXG4gICAgICogQHJldHVybnMge0RhdGFzZXR9XHJcbiAgICAgKi9cclxuICAgIG1ha2VMR3JpZERhdGFzZXQocmVzb2x1dGlvbiwgY2VsbHMsIG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFzZXQoW25ldyBMR3JpZChyZXNvbHV0aW9uLCBjZWxscyldLCBbXSwgb3B0cylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2UgYSBDU1YgZ3JpZCBkYXRhc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgZGF0YXNldC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSBkYXRhc2V0IHJlc29sdXRpb24gaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdD19IG9wdHMgVGhlIHBhcmFtZXRlcnMgb2YgdGhlIGRhdGFzZXQuXHJcbiAgICAgKiBAcmV0dXJucyB7RGF0YXNldH1cclxuICAgICAqL1xyXG4gICAgbWFrZUNTVkdyaWREYXRhc2V0KHVybCwgcmVzb2x1dGlvbiwgb3B0cykge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YXNldChcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgbmV3IENTVkdyaWQodXJsLCByZXNvbHV0aW9uLCBvcHRzKS5nZXREYXRhKHVuZGVmaW5lZCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2cucmVkcmF3KClcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbXSxcclxuICAgICAgICAgICAgb3B0c1xyXG4gICAgICAgIClcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2UgYSB0aWxlZCBncmlkIGRhdGFzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxyXG4gICAgICogQHBhcmFtIHt7cHJlcHJvY2Vzcz86ZnVuY3Rpb24oaW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsKTpib29sZWFufX0gb3B0c1xyXG4gICAgICogQHJldHVybnMge0RhdGFzZXR9XHJcbiAgICAgKi9cclxuICAgIG1ha2VUaWxlZEdyaWREYXRhc2V0KHVybCwgb3B0cykge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YXNldChcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgbmV3IFRpbGVkR3JpZCh1cmwsIHRoaXMsIG9wdHMpLmxvYWRJbmZvKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNnLnJlZHJhdygpXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW10sXHJcbiAgICAgICAgICAgIG9wdHNcclxuICAgICAgICApXHJcbiAgICB9XHJcblxyXG4gICAgLy9tdWx0aSBzY2FsZSBkYXRhc2V0IGNyZWF0aW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlIGEgbXVsdGkgc2NhbGUgQ1NWIGdyaWQgZGF0YXNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZXNvbHV0aW9uc1xyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOnN0cmluZ30gcmVzVG9VUkxcclxuICAgICAqIEBwYXJhbSB7e3ByZXByb2Nlc3M/OmZ1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCk6Ym9vbGVhbn19IG9wdHNcclxuICAgICAqIEByZXR1cm5zIHtEYXRhc2V0fVxyXG4gICAgICovXHJcbiAgICBtYWtlTXVsdGlTY2FsZUNTVkdyaWREYXRhc2V0KHJlc29sdXRpb25zLCByZXNUb1VSTCwgb3B0cykge1xyXG4gICAgICAgIHJldHVybiBEYXRhc2V0Lm1ha2UoXHJcbiAgICAgICAgICAgIHJlc29sdXRpb25zLFxyXG4gICAgICAgICAgICAocmVzKSA9PlxyXG4gICAgICAgICAgICAgICAgbmV3IENTVkdyaWQocmVzVG9VUkwocmVzKSwgcmVzLCBvcHRzKS5nZXREYXRhKHVuZGVmaW5lZCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2cucmVkcmF3KClcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBvcHRzXHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG5cclxuICAgIC8vdGlsZWQgbXVsdGlzY2FsZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZSBhIG11bHRpIHNjYWxlIHRpbGVkIGdyaWQgZGF0YXNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZXNvbHV0aW9uc1xyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOnN0cmluZ30gcmVzVG9VUkxcclxuICAgICAqIEBwYXJhbSB7e3ByZXByb2Nlc3M/OmZ1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCk6Ym9vbGVhbn19IG9wdHNcclxuICAgICAqIEByZXR1cm5zIHtEYXRhc2V0fVxyXG4gICAgICovXHJcbiAgICBtYWtlTXVsdGlTY2FsZVRpbGVkR3JpZERhdGFzZXQocmVzb2x1dGlvbnMsIHJlc1RvVVJMLCBvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIERhdGFzZXQubWFrZShcclxuICAgICAgICAgICAgcmVzb2x1dGlvbnMsXHJcbiAgICAgICAgICAgIChyZXMpID0+XHJcbiAgICAgICAgICAgICAgICBuZXcgVGlsZWRHcmlkKHJlc1RvVVJMKHJlcyksIHRoaXMsIG9wdHMpLmxvYWRJbmZvKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNnLnJlZHJhdygpXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgb3B0c1xyXG4gICAgICAgIClcclxuICAgIH1cclxuXHJcbiAgICAvLyBkaXJlY3QgbGF5ZXIgY3JlYXRpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGxheWVyIGZyb20gYSBDU1YgZ3JpZCBkYXRhc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgZGF0YXNldC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSBkYXRhc2V0IHJlc29sdXRpb24gaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoJy4vU3R5bGUnKS5TdHlsZT59IHN0eWxlcyBUaGUgc3R5bGVzLCBvcmRlcmVkIGluIGRyYXdpbmcgb3JkZXIuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdD19IG9wdHMgVGhlIHBhcmFtZXRlcnMgb2YgdGhlIGRhdGFzZXQgYW5kIGxheWVyLlxyXG4gICAgICogQHJldHVybnMge3RoaXN9XHJcbiAgICAgKi9cclxuICAgIGFkZENTVkdyaWRMYXllcih1cmwsIHJlc29sdXRpb24sIHN0eWxlcywgb3B0cykge1xyXG4gICAgICAgIGNvbnN0IGRzID0gdGhpcy5tYWtlQ1NWR3JpZERhdGFzZXQodXJsLCByZXNvbHV0aW9uLCBvcHRzKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZExheWVyRnJvbURhdGFzZXQoZHMsIHN0eWxlcywgb3B0cylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoJy4vU3R5bGUnKS5TdHlsZT59IHN0eWxlc1xyXG4gICAgICogQHBhcmFtIHt7dmlzaWJsZT86Ym9vbGVhbixtaW5ab29tPzpudW1iZXIsbWF4Wm9vbT86bnVtYmVyLHBpeE5iPzpudW1iZXIsY2VsbEluZm9IVE1MPzpmdW5jdGlvbihpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGwpOnN0cmluZywgcHJlcHJvY2Vzcz86ZnVuY3Rpb24oaW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsKTpib29sZWFufX0gb3B0c1xyXG4gICAgICogQHJldHVybnMge3RoaXN9XHJcbiAgICAgKi9cclxuICAgIGFkZFRpbGVkR3JpZExheWVyKHVybCwgc3R5bGVzLCBvcHRzKSB7XHJcbiAgICAgICAgY29uc3QgZHMgPSB0aGlzLm1ha2VUaWxlZEdyaWREYXRhc2V0KHVybCwgb3B0cylcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGRMYXllckZyb21EYXRhc2V0KGRzLCBzdHlsZXMsIG9wdHMpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBsYXllciBmcm9tIGEgQ1NWIGdyaWQgZGF0YXNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZXNvbHV0aW9uc1xyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOnN0cmluZ30gcmVzVG9VUkxcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydCgnLi9TdHlsZScpLlN0eWxlPn0gc3R5bGVzIFRoZSBzdHlsZXMsIG9yZGVyZWQgaW4gZHJhd2luZyBvcmRlci5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0cyBUaGUgcGFyYW1ldGVycyBvZiB0aGUgZGF0YXNldCBhbmQgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cclxuICAgICAqL1xyXG4gICAgYWRkTXVsdGlTY2FsZUNTVkdyaWRMYXllcihyZXNvbHV0aW9ucywgcmVzVG9VUkwsIHN0eWxlcywgb3B0cykge1xyXG4gICAgICAgIGNvbnN0IGRzID0gdGhpcy5tYWtlTXVsdGlTY2FsZUNTVkdyaWREYXRhc2V0KHJlc29sdXRpb25zLCByZXNUb1VSTCwgb3B0cylcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGRMYXllckZyb21EYXRhc2V0KGRzLCBzdHlsZXMsIG9wdHMpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZXNvbHV0aW9uc1xyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOnN0cmluZ30gcmVzVG9VUkxcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydCgnLi9TdHlsZScpLlN0eWxlPn0gc3R5bGVzXHJcbiAgICAgKiBAcGFyYW0ge3t2aXNpYmxlPzpib29sZWFuLG1pblpvb20/Om51bWJlcixtYXhab29tPzpudW1iZXIscGl4TmI/Om51bWJlcixjZWxsSW5mb0hUTUw/OmZ1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCk6c3RyaW5nLCBwcmVwcm9jZXNzPzpmdW5jdGlvbihpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGwpOmJvb2xlYW59fSBvcHRzXHJcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cclxuICAgICAqL1xyXG4gICAgYWRkTXVsdGlTY2FsZVRpbGVkR3JpZExheWVyKHJlc29sdXRpb25zLCByZXNUb1VSTCwgc3R5bGVzLCBvcHRzKSB7XHJcbiAgICAgICAgY29uc3QgZHMgPSB0aGlzLm1ha2VNdWx0aVNjYWxlVGlsZWRHcmlkRGF0YXNldChyZXNvbHV0aW9ucywgcmVzVG9VUkwsIG9wdHMpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGF5ZXJGcm9tRGF0YXNldChkcywgc3R5bGVzLCBvcHRzKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgYmFja2dyb3VuZCBsYXllciB0byB0aGUgYXBwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cclxuICAgICAqL1xyXG4gICAgYWRkQmFja2dyb3VuZExheWVyKG9wdHMpIHtcclxuICAgICAgICB0aGlzLmJnTGF5ZXJzLnB1c2gobmV3IEJhY2tncm91bmRMYXllcihvcHRzKSlcclxuICAgICAgICB0aGlzLnJlZHJhdygpXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIFdNUyBiYWNrZ3JvdW5kIGxheWVyIHRvIHRoZSBhcHAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcclxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxyXG4gICAgICovXHJcbiAgICBhZGRCYWNrZ3JvdW5kTGF5ZXJXTVMob3B0cykge1xyXG4gICAgICAgIHRoaXMuYmdMYXllcnMucHVzaChuZXcgQmFja2dyb3VuZExheWVyV01TKG9wdHMpKVxyXG4gICAgICAgIHRoaXMucmVkcmF3KClcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcclxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxyXG4gICAgICovXHJcbiAgICBhZGRab29tU2xpZGVyKGlkLCBvcHRzKSB7XHJcbiAgICAgICAgdGhpcy5jZy5hZGRab29tU2xpZGVyKGlkLCBvcHRzKVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgc2V0IG9mIHpvb20gYnV0dG9ucyB0byB0aGUgYXBwXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcclxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxyXG4gICAgICovXHJcbiAgICBhZGRab29tQnV0dG9ucyhvcHRzKSB7XHJcbiAgICAgICAgLy8gKiBvcHRzLmlkXHJcbiAgICAgICAgLy8gKiBvcHRzLm9uWm9vbSAtIGN1c3RvbSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXHJcbiAgICAgICAgLy8gKiBvcHRzLnhcclxuICAgICAgICAvLyAqIG9wdHMueVxyXG4gICAgICAgIC8vICogb3B0cy5kZWx0YSAtIHpvb20gZGVsdGEgYXBwbGllZCBvbiBlYWNoIGNsaWNrXHJcblxyXG4gICAgICAgIHRoaXMuem9vbUJ1dHRvbnMgPSBuZXcgWm9vbUJ1dHRvbnMoe1xyXG4gICAgICAgICAgICBhcHA6IHRoaXMsXHJcbiAgICAgICAgICAgIGlkOiBvcHRzPy5pZCB8fCAnZ3JpZHZpei16b29tLWJ1dHRvbnMnLFxyXG4gICAgICAgICAgICBjbGFzczogb3B0cz8uY2xhc3MsXHJcbiAgICAgICAgICAgIHg6IG9wdHM/LngsXHJcbiAgICAgICAgICAgIHk6IG9wdHM/LnksXHJcbiAgICAgICAgICAgIG9uWm9vbTogb3B0cz8ub25ab29tLFxyXG4gICAgICAgICAgICBkZWx0YTogb3B0cz8uZGVsdGEgfHwgMC4yXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBmdWxsc2NyZWVuIHRvZ2dsZSBidXR0b24gdG8gdGhlIGFwcFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cclxuICAgICAqL1xyXG4gICAgYWRkRnVsbHNjcmVlbkJ1dHRvbihvcHRzKSB7XHJcbiAgICAgICAgLy8gKiBvcHRzLmFwcCAtIHRoZSBncmlkdml6IGFwcFxyXG4gICAgICAgIC8vICogb3B0cy5pZFxyXG4gICAgICAgIC8vICogb3B0cy54XHJcbiAgICAgICAgLy8gKiBvcHRzLnlcclxuXHJcbiAgICAgICAgdGhpcy5mdWxsc2NyZWVuQnV0dG9uID0gbmV3IEZ1bGxzY3JlZW5CdXR0b24oe1xyXG4gICAgICAgICAgICBhcHA6IHRoaXMsXHJcbiAgICAgICAgICAgIGlkOiBvcHRzPy5pZCB8fCAnZ3JpZHZpei1mdWxsc2NyZWVuLWJ1dHRvbicsXHJcbiAgICAgICAgICAgIGNsYXNzOiBvcHRzPy5jbGFzcyxcclxuICAgICAgICAgICAgeDogb3B0cz8ueCxcclxuICAgICAgICAgICAgeTogb3B0cz8ueVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEByZXR1cm5zIHt0aGlzfSAqL1xyXG4gICAgc2V0Vmlld0Zyb21VUkwoKSB7XHJcbiAgICAgICAgdGhpcy5jZy5zZXRWaWV3RnJvbVVSTCgpXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGQgYSByZXNpemUgZXZlbnQgb2JzZXJ2ZXIgdG8gdGhlIEFwcHMgY29udGFpbmVyIGFuZCB1cGRhdGUgdGhlIGNhbnZhcyBhY2NvcmRpbmdseVxyXG4gICAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gY29udGFpbmVyIFRoZSBBcHAncyBjb250YWluZXIgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIFRoZSBBcHAgY2FudmFzIGVsZW1lbnRcclxuICAgICAqIEBtZW1iZXJvZiBBcHBcclxuICAgICAqL1xyXG4gICAgZGVmaW5lUmVzaXplT2JzZXJ2ZXIoY29udGFpbmVyLCBjYW52YXMpIHtcclxuICAgICAgICAvLyBsaXN0ZW4gdG8gcmVzaXplIGV2ZW50c1xyXG4gICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjYW52YXMgaGFzIGJlZW4gYnVpbHRcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5jbGllbnRXaWR0aCA+IDAgJiYgY29udGFpbmVyLmNsaWVudEhlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBkb250IGV4Y2VlZCBsb29wIGxpbWl0IGZpcnN0XHJcbiAgICAgICAgICAgICAgICAvLyBzZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5Mzg0MTIwL3Jlc2l6ZW9ic2VydmVyLWxvb3AtbGltaXQtZXhjZWVkZWRcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRyaWVzKSB8fCAhZW50cmllcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYXBwIGFuZCBjYW52YXMgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmggIT09IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgdGhpcy53ICE9PSBjb250YWluZXIuY2xpZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oID0gY29udGFpbmVyLmNsaWVudEhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLncgPSBjb250YWluZXIuY2xpZW50V2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jZy5oID0gY29udGFpbmVyLmNsaWVudEhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNnLncgPSBjb250YWluZXIuY2xpZW50V2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnJyArIHRoaXMudylcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJycgKyB0aGlzLmgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVkcmF3KClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlIGJ1dHRvbiBwb3NpdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuem9vbUJ1dHRvbnMpIHRoaXMuem9vbUJ1dHRvbnMubm9kZS5zdHlsZS5sZWZ0ID0gdGhpcy53IC0gNTAgKyAncHgnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLmZ1bGxzY3JlZW5CdXR0b24pIHRoaXMuZnVsbHNjcmVlbkJ1dHRvbi5ub2RlLnN0eWxlLmxlZnQgPSB0aGlzLncgLSA1MCArICdweCdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gRGVzdHJveSB0aGUgYXBwIGFuZCBpdCdzIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICogVGhpcyBzaG91bGQgc2lnbmlmaWNhbnRseSByZWR1Y2UgdGhlIG1lbW9yeSB1c2VkIHdoZW4gY3JlYXRpbmcgYW5kIGRlc3Ryb3lpbmcgZ3JpZHZpeiBhcHAgaW5zdGFuY2VzIChmb3IgZXhhbXBsZSBpbiBsZWFmbGV0LWdyaWR2aXopXHJcbiAgICAgKiBAbWVtYmVyb2YgQXBwXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgLy8gY2xlYXIgbGF5ZXJzXHJcbiAgICAgICAgdGhpcy5sYXllcnMgPSBbXVxyXG4gICAgICAgIHRoaXMuYmdMYXllcnMgPSBbXVxyXG5cclxuICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGZyb20gY29udGFpbmVyXHJcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5tb3VzZU92ZXJIYW5kbGVyKVxyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcilcclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMubW91c2VPdXRIYW5kbGVyKVxyXG5cclxuICAgICAgICAvLyByZW1vdmUgY2FudmFzXHJcbiAgICAgICAgdGhpcy5jZy5jYW52YXMucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIGxlZ2VuZFxyXG4gICAgICAgIHRoaXMubGVnZW5kPy5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvLyByZW1vdmUgdG9vbHRpcFxyXG4gICAgICAgIHRoaXMudG9vbHRpcC50b29sdGlwPy5yZW1vdmUoKVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEEgbWFwIGJhY2tncm91bmQgbGF5ZXIgaW4gXCJTbGlwcHkgbWFwXCIgWFlaIHN0YW5kYXJkLlxyXG4gKiBTZWUgaHR0cHM6Ly93aWtpLm9wZW5zdHJlZXRtYXAub3JnL3dpa2kvU2xpcHB5X21hcF90aWxlbmFtZXNcclxuICogaHR0cHM6Ly93d3cubWFwdGlsZXIuY29tL2dvb2dsZS1tYXBzLWNvb3JkaW5hdGVzLXRpbGUtYm91bmRzLXByb2plY3Rpb24vIzYvMjcuODgvNDQuNDhcclxuICogXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCYWNrZ3JvdW5kTGF5ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqIEFuIGF0dHJpYnV0ZSB0byBzcGVjaWZ5IGlmIGEgbGF5ZXIgc2hvdWxkIGJlIGRyYXduIG9yIG5vdFxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSAqL1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IG9wdHMudmlzaWJsZSA9PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZVxyXG5cclxuICAgICAgICAvKiogVGhlIG1pbmltdW0gem9vbSBmYWN0b3I6IEJlbG93IHRoaXMgbGV2ZWwsIHRoZSBsYXllciBpcyBub3Qgc2hvd24uXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLm1pblpvb20gPSBvcHRzLm1pblpvb20gfHwgMFxyXG5cclxuICAgICAgICAvKiogVGhlIG1heGltdW0gem9vbSBmYWN0b3I6IEFib3ZlIHRoaXMgbGV2ZWwsIHRoZSBsYXllciBpcyBub3Qgc2hvd24uXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLm1heFpvb20gPSBvcHRzLm1heFpvb20gfHwgSW5maW5pdHlcclxuXHJcbiAgICAgICAgLy9lbnN1cmUgYWNjZXB0YWJsZSB2YWx1ZXMgZm9yIHRoZSB6b29tIGxpbWl0cy5cclxuICAgICAgICBpZiAodGhpcy5taW5ab29tID49IHRoaXMubWF4Wm9vbSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHpvb20gbGltaXRzIGZvciBsYXllci4gWm9vbSBtaW4gc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiB6b29tIG1heC4nKVxyXG5cclxuICAgICAgICAvKiogVGhlIGltYWdlIGNhY2hlLCBpbmRleGVkIGJ5IHoveS94ICovXHJcbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy51cmwgPSBvcHRzLnVybFxyXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixudW1iZXIpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnVybEZ1biA9IG9wdHMudXJsRnVuIHx8ICgoeCwgeSwgeikgPT4gdGhpcy51cmwgKyB6ICsgJy8nICsgeCArICcvJyArIHkgKyAnLnBuZycpXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9ucyA9IG9wdHMucmVzb2x1dGlvbnNcclxuICAgICAgICBpZiAoIXRoaXMucmVzb2x1dGlvbnMgfHwgdGhpcy5yZXNvbHV0aW9ucy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNvbHV0aW9ucyBwcm92aWRlZCBmb3IgYmFja2dyb3VuZCBsYXllcicpXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMubmJQaXggPSBvcHRzLm5iUGl4IHx8IDI1NlxyXG4gICAgICAgIC8qKiBDUlMgY29vcmRpbmF0ZXMgb2YgdG9wIGxlZnQgY29ybmVyXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xyXG4gICAgICAgIHRoaXMub3JpZ2luID0gb3B0cy5vcmlnaW4gfHwgWzAsIDBdXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy56MCA9IG9wdHMuejAgfHwgMFxyXG5cclxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKG51bWJlcik6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuZmlsdGVyQ29sb3IgPSBvcHRzLmZpbHRlckNvbG9yIC8vICh6ZikgPT4gXCIjZWVlN1wiXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgei94L3kgY2FjaGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgICAqIEByZXR1cm5zIHtIVE1MSW1hZ2VFbGVtZW50fHN0cmluZ3x1bmRlZmluZWR9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXQoeiwgeCwgeSkge1xyXG4gICAgICAgIGxldCBkID0gdGhpcy5jYWNoZVt6XVxyXG4gICAgICAgIGlmICghZCkgcmV0dXJuXHJcbiAgICAgICAgZCA9IGRbeF1cclxuICAgICAgICBpZiAoIWQpIHJldHVyblxyXG4gICAgICAgIHJldHVybiBkW3ldXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgei94L3kgY2FjaGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxzdHJpbmd9IGltZ1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHB1dChpbWcsIHosIHgsIHkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2FjaGVbel0pIHRoaXMuY2FjaGVbel0gPSB7fVxyXG4gICAgICAgIGlmICghdGhpcy5jYWNoZVt6XVt4XSkgdGhpcy5jYWNoZVt6XVt4XSA9IHt9XHJcbiAgICAgICAgdGhpcy5jYWNoZVt6XVt4XVt5XSA9IGltZ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGNnIFRoZSBjYW52YXMgd2hlcmUgdG8gZHJhdyB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZHJhdyhjZykge1xyXG4gICAgICAgIGlmICghdGhpcy5yZXNvbHV0aW9ucyB8fCB0aGlzLnJlc29sdXRpb25zLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHJlc29sdXRpb25zIHByb3ZpZGVkIGZvciBiYWNrZ3JvdW5kIGxheWVyJylcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGNvbnN0IHpmID0gY2cuZ2V0WmYoKVxyXG4gICAgICAgIGNvbnN0IHgwID0gdGhpcy5vcmlnaW5bMF0sXHJcbiAgICAgICAgICAgIHkwID0gdGhpcy5vcmlnaW5bMV1cclxuXHJcbiAgICAgICAgLy9nZXQgem9vbSBsZXZlbCBhbmQgcmVzb2x1dGlvblxyXG4gICAgICAgIGxldCB6ID0gMFxyXG4gICAgICAgIGZvciAoeiA9IDA7IHogPCB0aGlzLnJlc29sdXRpb25zLmxlbmd0aDsgeisrKSBpZiAodGhpcy5yZXNvbHV0aW9uc1t6XSA8IHpmKSBicmVha1xyXG4gICAgICAgIHogLT0gMVxyXG4gICAgICAgIHogPSBNYXRoLm1heCgwLCB6KVxyXG4gICAgICAgIHogPSBNYXRoLm1pbih6LCB0aGlzLnJlc29sdXRpb25zLmxlbmd0aCAtIDEpXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLnJlc29sdXRpb25zLmxlbmd0aCwgeilcclxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLnJlc29sdXRpb25zW3pdXHJcblxyXG4gICAgICAgIHogKz0gdGhpcy56MFxyXG5cclxuICAgICAgICBjb25zdCBzaXplRyA9IHRoaXMubmJQaXggKiByZXNcclxuICAgICAgICBjb25zdCBzaXplID0gc2l6ZUcgLyB6ZlxyXG5cclxuICAgICAgICAvL2dldCB0aWxlIG51bWJlcnNcclxuICAgICAgICBjb25zdCB4R2VvVG9UTVMgPSAoeCkgPT4gTWF0aC5jZWlsKCh4IC0geDApIC8gc2l6ZUcpXHJcbiAgICAgICAgY29uc3QgeUdlb1RvVE1TID0gKHkpID0+IE1hdGguY2VpbCgtKHkgLSB5MCkgLyBzaXplRylcclxuICAgICAgICBjb25zdCB4TWluID0geEdlb1RvVE1TKGNnLmV4dEdlby54TWluKSAtIDFcclxuICAgICAgICBjb25zdCB4TWF4ID0geEdlb1RvVE1TKGNnLmV4dEdlby54TWF4KVxyXG4gICAgICAgIGNvbnN0IHlNYXggPSB5R2VvVG9UTVMoY2cuZXh0R2VvLnlNaW4pXHJcbiAgICAgICAgY29uc3QgeU1pbiA9IHlHZW9Ub1RNUyhjZy5leHRHZW8ueU1heCkgLSAxXHJcblxyXG4gICAgICAgIC8vVE9ETyA/XHJcbiAgICAgICAgLy9jZy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxyXG5cclxuICAgICAgICAvL2hhbmRsZSBpbWFnZXNcclxuICAgICAgICBmb3IgKGxldCB4ID0geE1pbjsgeCA8IHhNYXg7IHgrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0geU1pbjsgeSA8IHlNYXg7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgaW1hZ2VcclxuICAgICAgICAgICAgICAgIGxldCBpbWcgPSB0aGlzLmdldCh6LCB4LCB5KVxyXG5cclxuICAgICAgICAgICAgICAgIC8vbG9hZCBpbWFnZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpbWcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHV0KGltZywgeiwgeCwgeSlcclxuICAgICAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5yZWRyYXcoKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbWcub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jYXNlIHdoZW4gbm8gaW1hZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXQoJ2ZhaWxlZCcsIHosIHgsIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSB0aGlzLnVybEZ1bih4LCB5LCB6KVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jYXNlIHdoZW4gbm8gaW1hZ2VcclxuICAgICAgICAgICAgICAgIGlmIChpbWcgPT09ICdmYWlsZWQnKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgaWYgKCEoaW1nIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbWcpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpbWcud2lkdGggPT0gMCB8fCBpbWcuaGVpZ2h0ID09IDApIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAgICAgLy9kcmF3IGltYWdlXHJcbiAgICAgICAgICAgICAgICBjb25zdCB4R2VvID0geDAgKyB4ICogc2l6ZUdcclxuICAgICAgICAgICAgICAgIGNvbnN0IHlHZW8gPSB5MCAtIHkgKiBzaXplR1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHguZHJhd0ltYWdlKGltZywgY2cuZ2VvVG9QaXhYKHhHZW8pLCBjZy5nZW9Ub1BpeFkoeUdlbyksIHNpemUsIHNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jZy5jdHguZHJhd0ltYWdlKGltZywgeEdlbywgeUdlbywgc2l6ZUcsIC1zaXplRylcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9hcHBseSBmaWx0ZXJcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXJDb2xvcikge1xyXG4gICAgICAgICAgICBjb25zdCBmYyA9IHRoaXMuZmlsdGVyQ29sb3IoemYpXHJcbiAgICAgICAgICAgIGlmIChmYyAmJiBmYyAhPSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsU3R5bGUgPSBmY1xyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxSZWN0KDAsIDAsIGNnLncsIGNnLmgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG4vKipcclxuICpcclxuICogQSBtYXAgV01TIGJhY2tncm91bmQgbGF5ZXIuXHJcbiAqIFxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmFja2dyb3VuZExheWVyV01TIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBBbiBhdHRyaWJ1dGUgdG8gc3BlY2lmeSBpZiBhIGxheWVyIHNob3VsZCBiZSBkcmF3biBvciBub3RcclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gKi9cclxuICAgICAgICB0aGlzLnZpc2libGUgPSBvcHRzLnZpc2libGUgPT0gZmFsc2UgPyBmYWxzZSA6IHRydWVcclxuXHJcbiAgICAgICAgLyoqIFRoZSBtaW5pbXVtIHpvb20gZmFjdG9yOiBCZWxvdyB0aGlzIGxldmVsLCB0aGUgbGF5ZXIgaXMgbm90IHNob3duLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5taW5ab29tID0gb3B0cy5taW5ab29tIHx8IDBcclxuXHJcbiAgICAgICAgLyoqIFRoZSBtYXhpbXVtIHpvb20gZmFjdG9yOiBBYm92ZSB0aGlzIGxldmVsLCB0aGUgbGF5ZXIgaXMgbm90IHNob3duLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5tYXhab29tID0gb3B0cy5tYXhab29tIHx8IEluZmluaXR5XHJcblxyXG4gICAgICAgIC8vZW5zdXJlIGFjY2VwdGFibGUgdmFsdWVzIGZvciB0aGUgem9vbSBsaW1pdHMuXHJcbiAgICAgICAgaWYgKHRoaXMubWluWm9vbSA+PSB0aGlzLm1heFpvb20pXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB6b29tIGxpbWl0cyBmb3IgbGF5ZXIuIFpvb20gbWluIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gem9vbSBtYXguJylcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnVybCA9IG9wdHMudXJsXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyKTpzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5maWx0ZXJDb2xvciA9IG9wdHMuZmlsdGVyQ29sb3IgLy8gKHpmKSA9PiBcIiNlZWU3XCJcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fHVuZGVmaW5lZH0gKi9cclxuICAgICAgICB0aGlzLmltZyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgIHRoaXMueE1pbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgdGhpcy54TWF4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICB0aGlzLnlNaW4gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgIHRoaXMueU1heCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2hlY2sgaWYgdGhlIHZpZXcgaGFzIG1vdmVkIGFuZCBhIG5ldyBpbWFnZSBuZWVkcyB0byBiZSByZXRyaWV2ZWQuXHJcbiAgICAgKiBAcHJpdmF0ZSAqL1xyXG4gICAgaGFzTW92ZWQoZXh0R2VvKSB7XHJcbiAgICAgICAgaWYgKChleHRHZW8ueE1pbikgIT0gdGhpcy54TWluKSByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIGVsc2UgaWYgKChleHRHZW8ueE1heCkgIT0gdGhpcy54TWF4KSByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIGVsc2UgaWYgKChleHRHZW8ueU1pbikgIT0gdGhpcy55TWluKSByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIGVsc2UgaWYgKChleHRHZW8ueU1heCkgIT0gdGhpcy55TWF4KSByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGNnIFRoZSBjYW52YXMgd2hlcmUgdG8gZHJhdyB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZHJhdyhjZykge1xyXG5cclxuICAgICAgICAvL3VwZGF0ZSBtYXAgZXh0ZW50XHJcbiAgICAgICAgY2cudXBkYXRlRXh0ZW50R2VvKDApXHJcblxyXG4gICAgICAgIGlmICghdGhpcy5oYXNNb3ZlZChjZy5leHRHZW8pICYmIHRoaXMuaW1nKSB7XHJcbiAgICAgICAgICAgIC8vdGhlIG1hcCBkaWQgbm90IG1vdmUgYW5kIHRoZSBpbWFnZSB3YXMgYWxyZWFkeSBkb3dubG9hZGVkOiBkcmF3IHRoZSBpbWFnZVxyXG4gICAgICAgICAgICBjZy5jdHguZHJhd0ltYWdlKHRoaXMuaW1nLCAwLCAwLCBjZy53LCBjZy5oKVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL3RoZSBtYXAgbW92ZWQ6IHJldHJpZXZlIG5ldyBpbWFnZVxyXG5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgdGhpcy54TWluID0gY2cuZXh0R2VvLnhNaW5cclxuICAgICAgICAgICAgdGhpcy54TWF4ID0gY2cuZXh0R2VvLnhNYXhcclxuICAgICAgICAgICAgdGhpcy55TWluID0gY2cuZXh0R2VvLnlNaW5cclxuICAgICAgICAgICAgdGhpcy55TWF4ID0gY2cuZXh0R2VvLnlNYXhcclxuXHJcbiAgICAgICAgICAgIC8vYnVpbGQgV01TIFVSTFxyXG4gICAgICAgICAgICBjb25zdCB1cmwgPSBbXVxyXG4gICAgICAgICAgICB1cmwucHVzaCh0aGlzLnVybClcclxuICAgICAgICAgICAgdXJsLnB1c2goXCImd2lkdGg9XCIpXHJcbiAgICAgICAgICAgIHVybC5wdXNoKGNnLncpXHJcbiAgICAgICAgICAgIHVybC5wdXNoKFwiJmhlaWdodD1cIilcclxuICAgICAgICAgICAgdXJsLnB1c2goY2cuaClcclxuICAgICAgICAgICAgLy9iYm94OiB4bWluIHltaW4geG1heCB5bWF4XHJcbiAgICAgICAgICAgIHVybC5wdXNoKFwiJmJib3g9XCIpXHJcbiAgICAgICAgICAgIHVybC5wdXNoKGNnLmV4dEdlby54TWluKVxyXG4gICAgICAgICAgICB1cmwucHVzaChcIixcIilcclxuICAgICAgICAgICAgdXJsLnB1c2goY2cuZXh0R2VvLnlNaW4pXHJcbiAgICAgICAgICAgIHVybC5wdXNoKFwiLFwiKVxyXG4gICAgICAgICAgICB1cmwucHVzaChjZy5leHRHZW8ueE1heClcclxuICAgICAgICAgICAgdXJsLnB1c2goXCIsXCIpXHJcbiAgICAgICAgICAgIHVybC5wdXNoKGNnLmV4dEdlby55TWF4KVxyXG5cclxuICAgICAgICAgICAgY29uc3QgdXJsUyA9IHVybC5qb2luKFwiXCIpXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codXJsUylcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pbWcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1nID0gbmV3IEltYWdlKClcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1nLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjZy5yZWRyYXcoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbWcub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvL2Nhc2Ugd2hlbiBubyBpbWFnZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCByZXRyaWV2ZSBXTVMgYmFja2dyb3VuZCBpbWFnZSBmcm9tXCIsIHVybFMpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vc2V0IFVSTCB0byBsYXVuY2ggdGhlIGRvd25sb2FkXHJcbiAgICAgICAgICAgIHRoaXMuaW1nLnNyYyA9IHVybFNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vYXBwbHkgZmlsdGVyXHJcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyQ29sb3IpIHtcclxuICAgICAgICAgICAgY29uc3QgZmMgPSB0aGlzLmZpbHRlckNvbG9yKHpmKVxyXG4gICAgICAgICAgICBpZiAoZmMgJiYgZmMgIT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gZmNcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsUmVjdCgwLCAwLCBjZy53LCBjZy5oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuLyoqXHJcbiAqIEEgZ3JpZCBjZWxsLlxyXG4gKiBAdHlwZWRlZiB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gQ2VsbCAqL1xyXG4vKipcclxuICogQW4gZW52ZWxvcGUuXHJcbiAqIEB0eXBlZGVmIHsge3hNaW46IG51bWJlciwgeE1heDogbnVtYmVyLCB5TWluOiBudW1iZXIsIHlNYXg6IG51bWJlcn0gfSBFbnZlbG9wZSAqL1xyXG5cclxuLyoqXHJcbiAqIEEgbXVsdGkgcmVzb2x1dGlvbiBkYXRhc2V0IG9mIGdyaWQgY2VsbHMuXHJcbiAqIEl0IGNvbnNpc3RzIG9mIGRpZmZlcmVudCB7QGxpbmsgRGF0YXNldENvbXBvbmVudH1zIGZvciBlYWNoIHJlc29sdXRpb24uXHJcbiAqXHJcbiAqIEBhYnN0cmFjdFxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRGF0YXNldCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4vRGF0YXNldENvbXBvbmVudFwiKS5EYXRhc2V0Q29tcG9uZW50Pn0gZGF0YXNldENvbXBvbmVudHMgVGhlIGRhdGFzZXQgY29tcG9uZW50c1xyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmVzb2x1dGlvbnMgVGhlIHJlc29sdXRpb25zIG9mIHRoZSBkYXRhc2V0IGNvbXBvbmVudHMsIGluIENSUyBnZW9ncmFwaGljYWwgdW5pdFxyXG4gICAgICogQHBhcmFtIHsge3ByZXByb2Nlc3M/OmZ1bmN0aW9uKENlbGwpOmJvb2xlYW59IH0gb3B0cyBPcHRpb25zLiBwcmVwcm9jZXNzOiBBIGZ1bmN0aW9uIHRvIGFwcGx5IG9uIGVhY2ggZGF0YXNldCBjZWxsIHRvIHByZXBhcmUgaXRzIHZhbHVlcy4gQ2FuIGJlIHVzZWQgYWxzbyB0byBzZWxlY3QgY2VsbHMgdG8ga2VlcC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZGF0YXNldENvbXBvbmVudHMsIHJlc29sdXRpb25zLCBvcHRzID0ge30pIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogVGhlIGRhdGFzZXQgY29tcG9uZW50cy5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPGltcG9ydChcIi4vRGF0YXNldENvbXBvbmVudFwiKS5EYXRhc2V0Q29tcG9uZW50Pn0gKi9cclxuICAgICAgICB0aGlzLmRhdGFzZXRDb21wb25lbnRzID0gZGF0YXNldENvbXBvbmVudHNcclxuXHJcbiAgICAgICAgLyoqIFRoZSByZXNvbHV0aW9ucyBvZiB0aGUgZGF0YXNldCBjb21wb25lbnRzLCBpbiBDUlMgZ2VvZ3JhcGhpY2FsIHVuaXQuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbnMgPSByZXNvbHV0aW9uc1xyXG5cclxuICAgICAgICAvL3RoZXJlIG11c3QgYmUgYXMgbWFueSBkYXRhc2V0IGNvbXBvbmVudHMgYXMgcmVzb2x1dGlvbnNcclxuICAgICAgICBpZiAodGhpcy5kYXRhc2V0Q29tcG9uZW50cy5sZW5ndGggPiAxICYmIHRoaXMuZGF0YXNldENvbXBvbmVudHMubGVuZ3RoICE9IHRoaXMucmVzb2x1dGlvbnMubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAnVW5jb21wYXRpYmxlIG51bWJlciBvZiBkYXRhc2V0cyBhbmQgcmVzb2x1dGlvbnM6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YXNldENvbXBvbmVudHMubGVuZ3RoICtcclxuICAgICAgICAgICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbnMubGVuZ3RoXHJcbiAgICAgICAgICAgIClcclxuXHJcbiAgICAgICAgLy9zZXQgZGF0YXNldCBwcmVwcm9jZXNzZXMgaWYgc3BlY2lmaWVkXHJcbiAgICAgICAgaWYgKG9wdHMucHJlcHJvY2VzcykgdGhpcy5zZXRQcmVwb2Nlc3NlcyhvcHRzLnByZXByb2Nlc3MpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBwcmVwcm9jZXNzIGZ1bmN0aW9uIGZvciBhbGwgZGF0YXNldCBjb21wb25lbnRzLlxyXG4gICAgICogVGhpcyBpcyBhIGZ1bmN0aW9uIGFwcGxpZWQgb24gZWFjaCBjZWxsIGFmdGVyIGl0IGhhcyBiZWVuIGxvYWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKENlbGwpOmJvb2xlYW59IHByZXByb2Nlc3NcclxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxyXG4gICAgICovXHJcbiAgICBzZXRQcmVwb2Nlc3NlcyhwcmVwcm9jZXNzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgZHMgb2YgdGhpcy5kYXRhc2V0Q29tcG9uZW50cykgZHMucHJlcHJvY2VzcyA9IHByZXByb2Nlc3NcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmdW5jdGlvbiB0byBlYXNlIHRoZSBjcmVhdGlvbiBvZiBkYXRhc2V0cyBmcm9tIHRoZWlyIGNvbXBvbmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmVzb2x1dGlvbnMgVGhlIHJlc29sdXRpb25zIG9mIHRoZSBkYXRhc2V0IGNvbXBvbmVudHMsIGluIENSUyBnZW9ncmFwaGljYWwgdW5pdFxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOmltcG9ydChcIi4vRGF0YXNldENvbXBvbmVudFwiKS5EYXRhc2V0Q29tcG9uZW50fSByZXNUb0RhdGFzZXRDb21wb25lbnQgRnVuY3Rpb24gcmV0dXJuaW5nIGEgZGF0YXNldCBjb21wb25lbnQgZnJvbSBhIHJlc29sdXRpb25cclxuICAgICAqIEBwYXJhbSB7IHtwcmVwcm9jZXNzPzpmdW5jdGlvbihDZWxsKTpib29sZWFufSB9IG9wdHMgT3B0aW9ucy4gcHJlcHJvY2VzczogQSBmdW5jdGlvbiB0byBhcHBseSBvbiBlYWNoIGRhdGFzZXQgY2VsbCB0byBwcmVwYXJlIGl0cyB2YWx1ZXNcclxuICAgICAqIEByZXR1cm5zIHtEYXRhc2V0fVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbWFrZShyZXNvbHV0aW9ucywgcmVzVG9EYXRhc2V0Q29tcG9uZW50LCBvcHRzKSB7XHJcbiAgICAgICAgLy9tYWtlIGRhdGFzZXQgY29tcG9uZW50c1xyXG4gICAgICAgIGNvbnN0IGRzYyA9IFtdXHJcbiAgICAgICAgZm9yIChjb25zdCByZXMgb2YgcmVzb2x1dGlvbnMpIGRzYy5wdXNoKHJlc1RvRGF0YXNldENvbXBvbmVudChyZXMpKVxyXG4gICAgICAgIC8vbWFrZSBkYXRhc2V0XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhc2V0KGRzYywgcmVzb2x1dGlvbnMsIG9wdHMpXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG4vKipcclxuICogQSBkYXRhc2V0IGNvbXBvbmVudCwgb2YgZ3JpZCBjZWxscy5cclxuICogQGFic3RyYWN0XHJcbiAqXHJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBEYXRhc2V0Q29tcG9uZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIG9mIHRoZSBkYXRhc2V0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGhlIGRhdGFzZXQgcmVzb2x1dGlvbiwgaW4gdGhlIENSUyBnZW9ncmFwaGljYWwgdW5pdC5cclxuICAgICAqIEBwYXJhbSB7e3ByZXByb2Nlc3M/OmZ1bmN0aW9uKGltcG9ydChcIi4vRGF0YXNldFwiKS5DZWxsKTpib29sZWFufX0gb3B0c1xyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHVybCwgcmVzb2x1dGlvbiwgb3B0cyA9IHt9KSB7XHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHVybCBvZiB0aGUgZGF0YXNldC5cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnVybCA9IHVybFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGF0YXNldCByZXNvbHV0aW9uIGluIGdlb2dyYXBoaWNhbCB1bml0LlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb25cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBwcmVwcm9jZXNzIHRvIHJ1biBvbiBlYWNoIGNlbGwgYWZ0ZXIgbG9hZGluZy4gSXQgY2FuIGJlIHVzZWQgdG8gYXBwbHkgc29tZSBzcGVjaWZpYyB0cmVhdG1lbnQgYmVmb3JlIG9yIGNvbXB1dGUgYSBuZXcgY29sdW1uLiBBbmQgYWxzbyB0byBkZXRlcm1pbmUgd2hpY2ggY2VsbHMgdG8ga2VlcCBhZnRlciBsb2FkaW5nLlxyXG4gICAgICAgICAqIEB0eXBlIHsoZnVuY3Rpb24oaW1wb3J0KFwiLi9EYXRhc2V0XCIpLkNlbGwpOmJvb2xlYW4gKXwgdW5kZWZpbmVkIH0gKi9cclxuICAgICAgICB0aGlzLnByZXByb2Nlc3MgPSBvcHRzLnByZXByb2Nlc3MgfHwgdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8qKiBUaGUgY2VsbHMgd2l0aGluIHRoZSB2aWV3XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48aW1wb3J0KFwiLi9EYXRhc2V0XCIpLkNlbGw+fSAqL1xyXG4gICAgICAgIHRoaXMuY2VsbHNWaWV3Q2FjaGUgPSBbXVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdCBkYXRhIHdpdGhpbiBhIGdlb2dyYXBoaWMgZW52ZWxvcGUuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRGF0YXNldFwiKS5FbnZlbG9wZXx1bmRlZmluZWR9IGV4dEdlb1xyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cclxuICAgICAqL1xyXG4gICAgZ2V0RGF0YShleHRHZW8sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgZ2V0RGF0YSBub3QgaW1wbGVtZW50ZWQuJylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGwgdGhlIHZpZXcgY2FjaGUgd2l0aCBhbGwgY2VsbHMgd2hpY2ggYXJlIHdpdGhpbiBhIGdlb2dyYXBoaWNhbCBlbnZlbG9wZS5cclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0RhdGFzZXRcIikuRW52ZWxvcGV9IGV4dEdlbyBUaGUgdmlldyBnZW9ncmFwaGljYWwgZW52ZWxvcGUuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgdXBkYXRlVmlld0NhY2hlKGV4dEdlbykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIHVwZGF0ZVZpZXdDYWNoZSBub3QgaW1wbGVtZW50ZWQuJylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIGNlbGwgdW5kZXIgYSBnaXZlbiBwb3NpdGlvbiwgaWYgYW55LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyfX0gcG9zR2VvXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzIFNvbWUgY2VsbHMgZnJvbSB0aGUgZGF0YXNldCAoYSBzdWJzZXQgaWYgbmVjZXNzYXJ5LCB1c3VhbGx5IHRoZSB2aWV3IGNhY2hlKS5cclxuICAgICAqIEByZXR1cm5zIHtpbXBvcnQoXCIuL0RhdGFzZXRcIikuQ2VsbHx1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIGdldENlbGxGcm9tUG9zaXRpb24ocG9zR2VvLCBjZWxscykge1xyXG4gICAgICAgIC8vY29tcHV0ZSBjYW5kaWRhdGUgY2VsbCBwb3NpdGlvblxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIC8vY29uc3QgciA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgLy9jb25zdCBjZWxsWCA9IHIgKiBNYXRoLmZsb29yKHBvc0dlby54IC8gcilcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICAvL2NvbnN0IGNlbGxZID0gciAqIE1hdGguZmxvb3IocG9zR2VvLnkgLyByKVxyXG5cclxuICAgICAgICAvKi9nZXQgY2VsbFxyXG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICBpZiAoY2VsbC54ICE9IGNlbGxYKSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoY2VsbC55ICE9IGNlbGxZKSBjb250aW51ZVxyXG4gICAgICAgICAgICByZXR1cm4gY2VsbFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkKi9cclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgY29uc3QgciA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpXHJcbiAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIGNlbGxzKSB7XHJcbiAgICAgICAgICAgIGlmIChwb3NHZW8ueCA8IGNlbGwueCkgY29udGludWVcclxuICAgICAgICAgICAgZWxzZSBpZiAoY2VsbC54ICsgciA8IHBvc0dlby54KSBjb250aW51ZVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwb3NHZW8ueSA8IGNlbGwueSkgY29udGludWVcclxuICAgICAgICAgICAgZWxzZSBpZiAoY2VsbC55ICsgciA8IHBvc0dlby55KSBjb250aW51ZVxyXG4gICAgICAgICAgICBlbHNlIHJldHVybiBjZWxsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy9nZXR0ZXJzIGFuZCBzZXR0ZXJzXHJcblxyXG4gICAgLyoqIEByZXR1cm5zIHtudW1iZXJ9ICovXHJcbiAgICBnZXRSZXNvbHV0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdXRpb25cclxuICAgIH1cclxuXHJcbiAgICAvKiogQHJldHVybnMge0FycmF5LjxpbXBvcnQoXCIuL0RhdGFzZXRcIikuQ2VsbD59ICovXHJcbiAgICBnZXRWaWV3Q2FjaGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbHNWaWV3Q2FjaGVcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbi8qKiBAdHlwZWRlZiB7IHt4TWluOiBudW1iZXIsIHhNYXg6IG51bWJlciwgeU1pbjogbnVtYmVyLCB5TWF4OiBudW1iZXJ9IH0gRW52ZWxvcGUgKi9cclxuXHJcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuaW1wb3J0IHsgem9vbSwgem9vbUlkZW50aXR5IH0gZnJvbSAnZDMtem9vbSdcclxuXHJcbi8qKlxyXG4gKiBBIEhUTUwgY2FudmFzIGZvciBnZW8gZGF0YSBkaXNwbGF5LCBlbmhhbmNlZCB3aXRoIHpvb20gYW5kIHBhbiBjYXBhYmlsaXRpZXMuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHZW9DYW52YXMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNlbnRlciBHZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpmIFRoZSB6b29tIGZhY3RvciAocGl4ZWwgc2l6ZSwgaW4gZ3JvdW5kIG0pXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjYW52YXMsIGNlbnRlciwgemYsIG9wdHMpIHtcclxuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovXHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXNcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy53ID0gdGhpcy5jYW52YXMub2Zmc2V0V2lkdGhcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLmggPSB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHRcclxuXHJcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndcclxuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmhcclxuXHJcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxyXG4gICAgICAgIGlmICghY3R4KSB0aHJvdyAnSW1wb3NzaWJsZSB0byBjcmVhdGUgY2FudmFzIDJEIGNvbnRleHQnXHJcbiAgICAgICAgLyoqQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gKi9cclxuICAgICAgICB0aGlzLmN0eCA9IGN0eFxyXG5cclxuICAgICAgICAvLyBzZXQgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjZW50ZXJcclxuICAgICAgICB0aGlzLmNlbnRlciA9IGNlbnRlciB8fCB7IHg6IHRoaXMudyAqIDAuNSwgeTogdGhpcy5oICogMC41IH1cclxuXHJcbiAgICAgICAgLy8gem9vbSBmYWN0b3I6IHBpeGVsIHNpemUsIGluIG0vcGl4XHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy56ZiA9IHpmXHJcblxyXG4gICAgICAgIC8qKiBCYWNrZ3JvdW5kIGNvbG9yLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRzLmJhY2tncm91bmRDb2xvciB8fCAnd2hpdGUnXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oKTp2b2lkfSAqL1xyXG4gICAgICAgIHRoaXMub25ab29tU3RhcnRGdW4gPSBvcHRzLm9uWm9vbVN0YXJ0RnVuXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oKTp2b2lkfSAqL1xyXG4gICAgICAgIHRoaXMub25ab29tRW5kRnVuID0gb3B0cy5vblpvb21FbmRGdW5cclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbigpOnZvaWR9ICovXHJcbiAgICAgICAgdGhpcy5vblpvb21GdW4gPSBvcHRzLm9uWm9vbUZ1blxyXG5cclxuICAgICAgICAvL2N1cnJlbnQgZXh0ZW50XHJcbiAgICAgICAgLyoqIEB0eXBlIHtFbnZlbG9wZX0gKi9cclxuICAgICAgICB0aGlzLmV4dEdlbyA9IHsgeE1pbjogTmFOLCB4TWF4OiBOYU4sIHlNaW46IE5hTiwgeU1heDogTmFOIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXHJcblxyXG4gICAgICAgIC8vcmVseSBvbiBkMyB6b29tIGZvciBwYW4vem9vbVxyXG4gICAgICAgIGlmICghb3B0cy5kaXNhYmxlWm9vbSkge1xyXG4gICAgICAgICAgICBsZXQgdFAgPSB6b29tSWRlbnRpdHlcclxuICAgICAgICAgICAgY29uc3QgeiA9IHpvb20oKVxyXG4gICAgICAgICAgICAgICAgLy90byBtYWtlIHRoZSB6b29taW5nIGEgYml0IGZhc3RlclxyXG4gICAgICAgICAgICAgICAgLndoZWVsRGVsdGEoKGUpID0+IC1lLmRlbHRhWSAqIChlLmRlbHRhTW9kZSA9PT0gMSA/IDAuMDcgOiBlLmRlbHRhTW9kZSA/IDEgOiAwLjAwNCkpXHJcbiAgICAgICAgICAgICAgICAub24oJ3pvb20nLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlLnRyYW5zZm9ybVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGYgPSB0UC5rIC8gdC5rXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3BhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkeCA9IHRQLnggLSB0LnhcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHkgPSB0UC55IC0gdC55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFuKGR4ICogdGhpcy5nZXRaZigpLCAtZHkgKiB0aGlzLmdldFpmKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2UgPSBlLnNvdXJjZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZSBpbnN0YW5jZW9mIFdoZWVsRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vem9vbSBhdCB0aGUgbW91c2UgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuem9vbShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGl4VG9HZW9YKGUuc291cmNlRXZlbnQub2Zmc2V0WCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5waXhUb0dlb1koZS5zb3VyY2VFdmVudC5vZmZzZXRZKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlIGluc3RhbmNlb2YgVG91Y2hFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21wdXRlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIHRvdWNoZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHkgPSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0dCBvZiBzZS50YXJnZXRUb3VjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHggKz0gdHQuY2xpZW50WFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5ICs9IHR0LmNsaWVudFlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4IC89IHNlLnRhcmdldFRvdWNoZXMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eSAvPSBzZS50YXJnZXRUb3VjaGVzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy96b29tIGF0IHRoaXMgYXZlcmFnZSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tKGYsIHRoaXMucGl4VG9HZW9YKHR4KSwgdGhpcy5waXhUb0dlb1kodHkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRQID0gdFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vblpvb21GdW4pIHRoaXMub25ab29tRnVuKGUpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdzdGFydCcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5jLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnJyArIHRoaXMudylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuYy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcnICsgdGhpcy5oKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5jLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKHRoaXMuY2FudmFzLCAwLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5keCA9IDBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZHkgPSAwXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmYgPSAxXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uWm9vbVN0YXJ0RnVuKSB0aGlzLm9uWm9vbVN0YXJ0RnVuKGUpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdlbmQnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkcmF3KHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlID0geyBjOiBudWxsLCBkeDogMCwgZHk6IDAsIGY6IDEgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vblpvb21FbmRGdW4pIHRoaXMub25ab29tRW5kRnVuKGUpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB6KHNlbGVjdCh0aGlzLmNhbnZhcykpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vc2VsZWN0KHRoaXMuY2FudmFzKS5jYWxsKHopO1xyXG5cclxuICAgICAgICAvKiogWm9vbSBleHRlbnQsIHRvIGxpbWl0IHpvb20gaW4gYW5kIG91dFxyXG4gICAgICAgICAqICBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXHJcbiAgICAgICAgdGhpcy56ZkV4dGVudCA9IFswLCBJbmZpbml0eV1cclxuXHJcbiAgICAgICAgLyoqIENhbnZhcyBzdGF0ZSwgdG8gYmUgdXNlZCB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZWRyYXdzIG9uIHpvb20vcGFuXHJcbiAgICAgICAgICogIEB0eXBlIHt7YzpIVE1MQ2FudmFzRWxlbWVudHxudWxsLGR4Om51bWJlcixkeTpudW1iZXIsZjpudW1iZXJ9fSAqL1xyXG4gICAgICAgIHRoaXMuY2FudmFzU2F2ZSA9IHsgYzogbnVsbCwgZHg6IDAsIGR5OiAwLCBmOiAxIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSB2IEdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyICovXHJcbiAgICBzZXRDZW50ZXIodikge1xyXG4gICAgICAgIHRoaXMuY2VudGVyID0gdlxyXG4gICAgfVxyXG4gICAgLyoqIEByZXR1cm5zIHt7eDpudW1iZXIseTpudW1iZXJ9fSBHZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlciAqL1xyXG4gICAgZ2V0Q2VudGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlclxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcGFyYW0ge251bWJlcn0gdiBUaGUgem9vbSBmYWN0b3IgKHBpeGVsIHNpemUsIGluIGdyb3VuZCBtKSAqL1xyXG4gICAgc2V0WmYodikge1xyXG4gICAgICAgIHRoaXMuemYgPSB2XHJcbiAgICAgICAgaWYgKHRoaXMuc2xpZGVyKSB0aGlzLnNsaWRlci5hdHRyKCd2YWx1ZScsICt0aGlzLnpmKVxyXG4gICAgfVxyXG4gICAgLyoqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB6b29tIGZhY3RvciAocGl4ZWwgc2l6ZSwgaW4gZ3JvdW5kIG0pICovXHJcbiAgICBnZXRaZigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy56ZlxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ICovXHJcbiAgICBzZXRaZkV4dGVudCh2KSB7XHJcbiAgICAgICAgdGhpcy56ZkV4dGVudCA9IHZcclxuICAgIH1cclxuICAgIC8qKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59ICovXHJcbiAgICBnZXRaZkV4dGVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy56ZkV4dGVudFxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJbml0aWFsaXNlIGNhbnZhcyB0cmFuc2Zvcm0gd2l0aCBpZGVudGl0eSB0cmFuc2Zvcm1hdGlvbi4gKi9cclxuICAgIGluaXRDYW52YXNUcmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEluaXRpYWxpc2UgY2FudmFzIHRyYW5zZm9ybSB3aXRoIGdlbyB0byBzY3JlZW4gdHJhbnNmb3JtYXRpb24sIHNvIHRoYXQgZ2VvIG9iamVjdHMgY2FuIGJlIGRyYXduIGRpcmVjdGx5IGluIGdlbyBjb29yZGluYXRlcy4gKi9cclxuICAgIHNldENhbnZhc1RyYW5zZm9ybSgpIHtcclxuICAgICAgICBjb25zdCBrID0gMSAvIHRoaXMuZ2V0WmYoKVxyXG4gICAgICAgIGNvbnN0IHR4ID0gLXRoaXMuY2VudGVyLnggLyB0aGlzLmdldFpmKCkgKyB0aGlzLncgKiAwLjVcclxuICAgICAgICBjb25zdCB0eSA9IHRoaXMuY2VudGVyLnkgLyB0aGlzLmdldFpmKCkgKyB0aGlzLmggKiAwLjVcclxuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oaywgMCwgMCwgLWssIHR4LCB0eSlcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gd2ViR0wgc2NyZWVuIGNvb3JkaW5hdGVzLCB3aXRoaW4gWy0xLDFdKlstMSwxXSAqL1xyXG4gICAgZ2V0V2ViR0xUcmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgY29uc3Qga3ggPSAyLjAgLyAodGhpcy53ICogdGhpcy5nZXRaZigpKVxyXG4gICAgICAgIGNvbnN0IGt5ID0gMi4wIC8gKHRoaXMuaCAqIHRoaXMuZ2V0WmYoKSlcclxuICAgICAgICByZXR1cm4gW2t4LCAwLjAsIDAuMCwgMC4wLCBreSwgMC4wLCAta3ggKiB0aGlzLmNlbnRlci54LCAta3kgKiB0aGlzLmNlbnRlci55LCAxLjBdXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBmdW5jdGlvbiBzcGVjaWZ5aW5nIGhvdyB0byBkcmF3IHRoZSBtYXAuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0cm9uZyAqL1xyXG4gICAgcmVkcmF3KHN0cm9uZyA9IHRydWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCByZWRyYXcgbm90IGltcGxlbWVudGVkLicpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhci4gVG8gYmUgdXNlZCBiZWZvcmUgYSByZWRyYXcgZm9yIGV4YW1wbGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcclxuICAgICAqL1xyXG4gICAgY2xlYXIoY29sb3IgPSAnd2hpdGUnKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0cy50cmFuc3BhcmVudEJhY2tncm91bmQpIHtcclxuICAgICAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMudywgdGhpcy5oKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN0eCkgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3JcclxuICAgICAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53LCB0aGlzLmgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR4R2VvXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHlHZW9cclxuICAgICAqL1xyXG4gICAgcGFuKGR4R2VvID0gMCwgZHlHZW8gPSAwKSB7XHJcbiAgICAgICAgLy9UT0RPIGZvcmNlIGV4dGVuZCB0byByZW1haW5cclxuICAgICAgICB0aGlzLmNlbnRlci54ICs9IGR4R2VvXHJcbiAgICAgICAgdGhpcy5jZW50ZXIueSArPSBkeUdlb1xyXG4gICAgICAgIHRoaXMudXBkYXRlRXh0ZW50R2VvKClcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzU2F2ZS5jKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5keCAtPSBkeEdlbyAvIHRoaXMuZ2V0WmYoKVxyXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZHkgKz0gZHlHZW8gLyB0aGlzLmdldFpmKClcclxuICAgICAgICAgICAgdGhpcy5jbGVhcih0aGlzLmJhY2tncm91bmRDb2xvcilcclxuICAgICAgICAgICAgLy8gdGhpcyBkb2VzbnQgd29yayBvbiBtb2JpbGUgaHR0cHM6Ly9naXRodWIuY29tL2V1cm9zdGF0L2dyaWR2aXovaXNzdWVzLzk4XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLmNhbnZhc1NhdmUuYywgdGhpcy5jYW52YXNTYXZlLmR4LCB0aGlzLmNhbnZhc1NhdmUuZHkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogWm9vbS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmIFRoZSB6b29tIGZhY3Rvciwgd2l0aGluIF0wLCBJbmZpbml0eV0uIDEgaXMgZm9yIG5vIGNoYW5nZS4gPDEgdG8gem9vbS1pbiwgPjEgdG8gem9vbS1vdXQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geEdlbyBUaGUgeCBnZW8gcG9zaXRpb24gZml4ZWQgaW4gdGhlIHNjcmVlbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5R2VvIFRoZSB5IGdlbyBwb3NpdGlvbiBmaXhlZCBpbiB0aGUgc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICB6b29tKGYgPSAxLCB4R2VvID0gdGhpcy5jZW50ZXIueCwgeUdlbyA9IHRoaXMuY2VudGVyLnkpIHtcclxuICAgICAgICAvL1RPRE8gZm9yY2UgZ2VvIGV4dGVuZCB0byByZW1haW5cclxuXHJcbiAgICAgICAgLy90cnlpbmcgdG8gem9vbSBpbi9vdXQgYmV5b25kIGxpbWl0XHJcbiAgICAgICAgaWYgKHRoaXMuemZFeHRlbnRbMF0gPT0gdGhpcy5nZXRaZigpICYmIGYgPD0gMSkgcmV0dXJuXHJcbiAgICAgICAgaWYgKHRoaXMuemZFeHRlbnRbMV0gPT0gdGhpcy5nZXRaZigpICYmIGYgPj0gMSkgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vZW5zdXJlIHpvb20gZXh0ZW50IHByZXNlcnZlZFxyXG4gICAgICAgIGNvbnN0IG5ld1pmID0gZiAqIHRoaXMuZ2V0WmYoKVxyXG4gICAgICAgIGlmIChuZXdaZiA8IHRoaXMuemZFeHRlbnRbMF0pIGYgPSB0aGlzLnpmRXh0ZW50WzBdIC8gdGhpcy5nZXRaZigpXHJcbiAgICAgICAgaWYgKG5ld1pmID4gdGhpcy56ZkV4dGVudFsxXSkgZiA9IHRoaXMuemZFeHRlbnRbMV0gLyB0aGlzLmdldFpmKClcclxuXHJcbiAgICAgICAgdGhpcy5zZXRaZihmICogdGhpcy5nZXRaZigpKVxyXG4gICAgICAgIGNvbnN0IGR4R2VvID0gKHhHZW8gLSB0aGlzLmNlbnRlci54KSAqICgxIC0gZilcclxuICAgICAgICB0aGlzLmNlbnRlci54ICs9IGR4R2VvXHJcbiAgICAgICAgY29uc3QgZHlHZW8gPSAoeUdlbyAtIHRoaXMuY2VudGVyLnkpICogKDEgLSBmKVxyXG4gICAgICAgIHRoaXMuY2VudGVyLnkgKz0gZHlHZW9cclxuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEdlbygpXHJcblxyXG4gICAgICAgIC8vVE9ET1xyXG4gICAgICAgIC8vdGhpcy5yZWRyYXcoZmFsc2UpXHJcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzU2F2ZS5jKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXIodGhpcy5iYWNrZ3JvdW5kQ29sb3IpXHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5mIC89IGZcclxuICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmR4ID0gdGhpcy5nZW9Ub1BpeFgoeEdlbykgKiAoMSAtIHRoaXMuY2FudmFzU2F2ZS5mKVxyXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1NhdmUuZHkgPSB0aGlzLmdlb1RvUGl4WSh5R2VvKSAqICgxIC0gdGhpcy5jYW52YXNTYXZlLmYpXHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXIodGhpcy5iYWNrZ3JvdW5kQ29sb3IpXHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5jLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmR4LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmR5LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTYXZlLmYgKiB0aGlzLmNhbnZhc1NhdmUuYy53aWR0aCxcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2F2ZS5mICogdGhpcy5jYW52YXNTYXZlLmMuaGVpZ2h0XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFyZ2luUHhcclxuICAgICAqIEByZXR1cm5zIHtFbnZlbG9wZX0gVGhlIGVudmVsb3BlIG9mIHRoZSB2aWV3LCBpbiBnZW8gY29vcmRpbmF0ZXMuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUV4dGVudEdlbyhtYXJnaW5QeCA9IDIwKSB7XHJcbiAgICAgICAgdGhpcy5leHRHZW8gPSB7XHJcbiAgICAgICAgICAgIHhNaW46IHRoaXMucGl4VG9HZW9YKC1tYXJnaW5QeCksXHJcbiAgICAgICAgICAgIHhNYXg6IHRoaXMucGl4VG9HZW9YKHRoaXMudyArIG1hcmdpblB4KSxcclxuICAgICAgICAgICAgeU1pbjogdGhpcy5waXhUb0dlb1kodGhpcy5oICsgbWFyZ2luUHgpLFxyXG4gICAgICAgICAgICB5TWF4OiB0aGlzLnBpeFRvR2VvWSgtbWFyZ2luUHgpLFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5leHRHZW9cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBvYmplY3QgaGFzIHRvIGJlIGRyYXduXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXJ9fSBvYmpcclxuICAgICAqL1xyXG4gICAgdG9EcmF3KG9iaikge1xyXG4gICAgICAgIGlmIChvYmoueCA8IHRoaXMuZXh0R2VvLnhNaW4pIHJldHVybiBmYWxzZVxyXG4gICAgICAgIGlmIChvYmoueCA+IHRoaXMuZXh0R2VvLnhNYXgpIHJldHVybiBmYWxzZVxyXG4gICAgICAgIGlmIChvYmoueSA8IHRoaXMuZXh0R2VvLnlNaW4pIHJldHVybiBmYWxzZVxyXG4gICAgICAgIGlmIChvYmoueSA+IHRoaXMuZXh0R2VvLnlNYXgpIHJldHVybiBmYWxzZVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcblxyXG4gICAgLy9jb252ZXJzaW9uIGZ1bmN0aW9uc1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geEdlbyBHZW8geCBjb29yZGluYXRlLCBpbiBtLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2NyZWVuIHggY29vcmRpbmF0ZSwgaW4gcGl4LlxyXG4gICAgICovXHJcbiAgICBnZW9Ub1BpeFgoeEdlbykge1xyXG4gICAgICAgIHJldHVybiAoeEdlbyAtIHRoaXMuY2VudGVyLngpIC8gdGhpcy5nZXRaZigpICsgdGhpcy53ICogMC41XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5R2VvIEdlbyB5IGNvb3JkaW5hdGUsIGluIG0uXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTY3JlZW4geSBjb29yZGluYXRlLCBpbiBwaXguXHJcbiAgICAgKi9cclxuICAgIGdlb1RvUGl4WSh5R2VvKSB7XHJcbiAgICAgICAgcmV0dXJuIC0oeUdlbyAtIHRoaXMuY2VudGVyLnkpIC8gdGhpcy5nZXRaZigpICsgdGhpcy5oICogMC41XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFNjcmVlbiB4IGNvb3JkaW5hdGUsIGluIHBpeC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEdlbyB4IGNvb3JkaW5hdGUsIGluIG0uXHJcbiAgICAgKi9cclxuICAgIHBpeFRvR2VvWCh4KSB7XHJcbiAgICAgICAgcmV0dXJuICh4IC0gdGhpcy53ICogMC41KSAqIHRoaXMuZ2V0WmYoKSArIHRoaXMuY2VudGVyLnhcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgU2NyZWVuIHkgY29vcmRpbmF0ZSwgaW4gcGl4LlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gR2VvIHkgY29vcmRpbmF0ZSwgaW4gbS5cclxuICAgICAqL1xyXG4gICAgcGl4VG9HZW9ZKHkpIHtcclxuICAgICAgICByZXR1cm4gLSh5IC0gdGhpcy5oICogMC41KSAqIHRoaXMuZ2V0WmYoKSArIHRoaXMuY2VudGVyLnlcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHgseSx6IGVsZW1lbnRzIGZyb20gVVJMIGFuZCBhc3NpZ24gdGhlbSB0byB0aGUgdmlldyBjZW50ZXIgYW5kIHpvb20gbGV2ZWwuICovXHJcbiAgICBzZXRWaWV3RnJvbVVSTCgpIHtcclxuICAgICAgICBjb25zdCB4ID0gR2VvQ2FudmFzLmdldFBhcmFtZXRlckJ5TmFtZSgneCcpLFxyXG4gICAgICAgICAgICB5ID0gR2VvQ2FudmFzLmdldFBhcmFtZXRlckJ5TmFtZSgneScpLFxyXG4gICAgICAgICAgICB6ID0gR2VvQ2FudmFzLmdldFBhcmFtZXRlckJ5TmFtZSgneicpXHJcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0Q2VudGVyKClcclxuICAgICAgICBpZiAoeCAhPSBudWxsICYmIHggIT0gdW5kZWZpbmVkICYmICFpc05hTigreCkpIGMueCA9ICt4XHJcbiAgICAgICAgaWYgKHkgIT0gbnVsbCAmJiB5ICE9IHVuZGVmaW5lZCAmJiAhaXNOYU4oK3kpKSBjLnkgPSAreVxyXG4gICAgICAgIGlmICh6ICE9IG51bGwgJiYgeiAhPSB1bmRlZmluZWQgJiYgIWlzTmFOKCt6KSkgdGhpcy5zZXRaZigreilcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cclxuICAgICAqL1xyXG4gICAgYWRkWm9vbVNsaWRlcihpZCwgb3B0cykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcbiAgICAgICAgb3B0cy53aWR0aCA9IG9wdHMud2lkdGggfHwgJzMwcHgnXHJcbiAgICAgICAgb3B0cy5oZWlnaHQgPSBvcHRzLmhlaWdodCB8fCAnMzAwcHgnXHJcblxyXG4gICAgICAgIC8vdGhlIGRpdiBlbGVtZW50XHJcbiAgICAgICAgY29uc3QgZGl2ID0gc2VsZWN0KCcjJyArIGlkKVxyXG4gICAgICAgIGlmIChkaXYuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb3VsZCBub3QgZmluZCBkaXYgZWxlbWVudCB0byBidWlsZCB6b29tIHNsaWRlci4gSWQ6ICcgKyBpZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRoID0gdGhpc1xyXG4gICAgICAgIC8qKiAqL1xyXG4gICAgICAgIHRoaXMuc2xpZGVyID0gZGl2XHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2lucHV0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAncmFuZ2UnKVxyXG4gICAgICAgICAgICAuYXR0cignbWluJywgdGhpcy5nZXRaZkV4dGVudCgpWzBdKVxyXG4gICAgICAgICAgICAuYXR0cignbWF4JywgdGhpcy5nZXRaZkV4dGVudCgpWzFdKVxyXG4gICAgICAgICAgICAuYXR0cigndmFsdWUnLCB0aGlzLmdldFpmKCkpXHJcbiAgICAgICAgICAgIC5vbignaW5wdXQnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICF0aGlzLnZhbHVlKSByZXR1cm5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSArdGhpcy52YWx1ZVxyXG4gICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLmF0dHIoJ3ZhbHVlJywgdilcclxuICAgICAgICAgICAgICAgIHRoLnNldFpmKHYpXHJcbiAgICAgICAgICAgICAgICAvL3JlZHJhd1xyXG4gICAgICAgICAgICAgICAgdGgucmVkcmF3KClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0eWxlKCd3aWR0aCcsIG9wdHMud2lkdGgpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnaGVpZ2h0Jywgb3B0cy5oZWlnaHQpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDAuNylcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwLjcpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnLXdlYmtpdC1hcHBlYXJhbmNlJywgJ3NsaWRlci12ZXJ0aWNhbCcpIC8vZm9yIGNocm9tZVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3dyaXRpbmctbW9kZScsICdidC1scicpIC8vZm9yIElFL2VkZ2VcclxuICAgICAgICAgICAgLmF0dHIoJ29yaWVudCcsICd2ZXJ0aWNhbCcpIC8vZm9yIGZpcmVmb3hcclxuICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kJywgJ2xpZ2h0Z3JheScpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnb3V0bGluZScsICdub25lJylcclxuICAgICAgICAgICAgLnN0eWxlKCctd2Via2l0LXRyYW5zaXRpb24nLCAnLjJzJylcclxuICAgICAgICAgICAgLnN0eWxlKCd0cmFuc2l0aW9uJywgJ29wYWNpdHkgLjJzJylcclxuXHJcbiAgICAgICAgLy9UT0RPXHJcbiAgICAgICAgLypzZWxlY3QoXCIuc2xpZGVyOjotd2Via2l0LXNsaWRlci10aHVtYlwiKVxyXG4gICAgICAgICAgICAuc3R5bGUoXCItd2Via2l0LWFwcGVhcmFuY2VcIiwgXCJub25lXCIpXHJcbiAgICAgICAgICAgIC5zdHlsZShcImFwcGVhcmFuY2VcIiwgXCJub25lXCIpXHJcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIFwiMzBweFwiKVxyXG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgXCI0MHB4XCIpXHJcbiAgICAgICAgICAgIC5zdHlsZShcImJhY2tncm91bmRcIiwgXCJibGFja1wiKVxyXG4gICAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpKi9cclxuXHJcbiAgICAgICAgLypzZWxlY3QoXCJzbGlkZXI6Oi1tb3otcmFuZ2UtdGh1bWJcIilcclxuICAgICAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC1hcHBlYXJhbmNlXCIsIFwibm9uZVwiKVxyXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCBcIjMwcHhcIilcclxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIFwiNDBweFwiKVxyXG4gICAgICAgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kXCIsIFwiIzA0QUE2RFwiKVxyXG4gICAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpKi9cclxuICAgICAgICAvKlxyXG4gICAgICAgICAgICAuc2xpZGVyOjptcy10aHVtYixcclxuICAgICAgICAuc2xpZGVyOjotbW96LXJhbmdlLXRodW1iIHtcclxuICAgICAgICB9Ki9cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIFVSTCBwYXJhbWV0ZXIgYnkgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAgICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRQYXJhbWV0ZXJCeU5hbWUobmFtZSkge1xyXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFtdLywgJ1xcXFxbJykucmVwbGFjZSgvW1xcXV0vLCAnXFxcXF0nKVxyXG4gICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1tcXFxcPyZdJyArIG5hbWUgKyAnPShbXiYjXSopJyksXHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZWdleC5leGVjKGxvY2F0aW9uLnNlYXJjaClcclxuICAgICAgICByZXR1cm4gIXJlc3VsdHMgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMV0ucmVwbGFjZSgvXFwrL2csICcgJykpXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBjc3YgfSBmcm9tICdkMy1mZXRjaCdcclxuXHJcbi8qKiBBIGxhYmVsLiBUaGUgbmFtZSBpcyB0aGUgdGV4dCB0byBzaG93LiAoeCx5KSBhcmUgdGhlIGNvb3JkaW5hdGVzIGluIHRoZSBzYW1lIENSUyBhcyB0aGUgZ3JpZC5cclxuICogQHR5cGVkZWYge3tuYW1lOiBzdHJpbmcsIHg6bnVtYmVyLCB5Om51bWJlciB9fSBMYWJlbCAqL1xyXG5cclxuLyoqXHJcbiAqIEEgKGdlbmVyaWMpIGxheWVyIGZvciBwbGFjZW5hbWUgbGFiZWxzLCB0byBiZSBzaG93biBvbiB0b3Agb2YgdGhlIGdyaWQgbGF5ZXJzLlxyXG4gKiBUaGUgaW5wdXQgaXMgYSBDU1YgZmlsZSB3aXRoIHRoZSBwb3NpdGlvbiAoeCwgeSkgb2YgdGhlIGxhYmVscyBhbmQgbmFtZSArIHNvbWUgb3RoZXIgaW5mbyBvbiB0aGUgbGFiZWwgaW1wb3J0YW5jZS5cclxuICogSWYgdGhlIGxhYmVsIGRhdGEgaXMgbm90IGluIHRoZSBleHBlY3RlZCBmb3JtYXQgb3IgaW4gdGhlIHNhbWUgQ1JTIGFzIHRoZSBncmlkLCBpdCBjYW4gYmUgY29ycmVjdGVkIHdpdGggdGhlIFwicHJlcHJvY2Vzc1wiIGZ1bmN0aW9uLlxyXG4gKiBUaGUgc2VsZWN0aW9uIG9mIHRoZSBsYWJlbCwgdGhlaXIgc3R5bGUgKGZvbnQsIHdlaWdodCwgZXRjLikgYW5kIGNvbG9yIGNhbiBiZSBzcGVjaWZpZWQgZGVwZW5kaW5nIG9uIHRoZWlyIGltcG9ydGFuY2UgYW5kIHRoZSB6b29tIGxldmVsLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGFiZWxMYXllciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgVVJMIG9mIHRoZSBsYWJlbCBkYXRhLCBhcyBDU1YgZmlsZS5cclxuICAgICAgICAgKiBUaGUgZmlsZSBzaG91bGQgY29udGFpbiB0aGUgaW5mb3JtYXRpb24gZm9yIGVhY2ggbGFiZWwgc3VjaCBhcyB0aGUgdGV4dCwgdGhlIHBvc2l0aW9uIGFuZCBvdGhlciBpbmZvcm1hdGlvbiBmb3IgdGhlIGRpc3BsYXkgb2YgdGhlIGxhYmVsIGFjY29yZGluZyB0byB0aGUgem9vbSBsZXZlbC5cclxuICAgICAgICAgKiBJZiBuZWNlc3NhcnksIHRoaXMgZGF0YSBjYW4gYmUgcmVmb3JtYXRlZCB3aXRoIHRoZSAncHJlcHJvY2VzcycgcGFyYW1ldGVyLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnVybCA9IG9wdHMudXJsXHJcblxyXG4gICAgICAgIC8qKiBTcGVjaWZ5IGlmIGFuZCBob3cgYSBsYWJlbCBzaG91bGQgYmUgZHJhd24sIGRlcGVuZGluZyBvbiBpdHMgaW1wb3J0YW5jZSBhbmQgdGhlIHpvb20gbGV2ZWwuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oTGFiZWwsbnVtYmVyKTpzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5zdHlsZSA9IG9wdHMuc3R5bGUgfHwgKCgpID0+ICdib2xkIDFlbSBBcmlhbCcpXHJcblxyXG4gICAgICAgIC8qKiBTcGVjaWZ5IHRoZSBsYWJlbCBjb2xvciwgZGVwZW5kaW5nIG9uIGl0cyBpbXBvcnRhbmNlIGFuZCB0aGUgem9vbSBsZXZlbC5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihMYWJlbCxudW1iZXIpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAob3B0cy5kYXJrID8gKCkgPT4gJyNkZGQnIDogKCkgPT4gJyMyMjInKVxyXG5cclxuICAgICAgICAvKiogU3BlY2lmeSB0aGUgbGFiZWwgaGFsbyBjb2xvciwgZGVwZW5kaW5nIG9uIGl0cyBpbXBvcnRhbmNlIGFuZCB0aGUgem9vbSBsZXZlbC5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihMYWJlbCxudW1iZXIpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmhhbG9Db2xvciA9IG9wdHMuaGFsb0NvbG9yIHx8IChvcHRzLmRhcmsgPyAoKSA9PiAnIzAwMDAwMEJCJyA6ICgpID0+ICcjRkZGRkZGQkInKVxyXG5cclxuICAgICAgICAvKiogU3BlY2lmeSB0aGUgbGFiZWwgaGFsbyB3aWR0aCwgZGVwZW5kaW5nIG9uIGl0cyBpbXBvcnRhbmNlIGFuZCB0aGUgem9vbSBsZXZlbC5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihMYWJlbCxudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLmhhbG9XaWR0aCA9IG9wdHMuaGFsb1dpZHRoIHx8ICgoKSA9PiA0KVxyXG5cclxuICAgICAgICAvKiogVGhlIGFuY2hvciB3aGVyZSB0byBkcmF3IHRoZSB0ZXh0LCBmcm9tIGxhYmVsIHBvc2l0aW9uLiBTZWUgSFRNTC1jYW52YXMgdGV4dEFsaWduIHByb3BlcnR5LlxyXG4gICAgICAgICAqIFwibGVmdFwiIHx8IFwicmlnaHRcIiB8fCBcImNlbnRlclwiIHx8IFwic3RhcnRcIiB8fCBcImVuZFwiXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufSAqL1xyXG4gICAgICAgIHRoaXMudGV4dEFsaWduID0gb3B0cy50ZXh0QWxpZ24gfHwgJ3N0YXJ0J1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn0gKi9cclxuICAgICAgICB0aGlzLm9mZnNldFBpeCA9IG9wdHMub2Zmc2V0UGl4IHx8IFs1LCA1XVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHByZXByb2Nlc3MgdG8gcnVuIG9uIGVhY2ggbGFiZWwgYWZ0ZXIgbG9hZGluZy5cclxuICAgICAgICAgKiBJdCBjYW4gYmUgdXNlZCB0byBhcHBseSBzb21lIHNwZWNpZmljIHRyZWF0bWVudCBiZWZvcmUsIGZvcm1hdCB0aGUgbGFiZWwgZGF0YSwgcHJvamVjdCBjb29yZGluYXRlcywgZXRjLlxyXG4gICAgICAgICAqIFJldHVybiBmYWxzZSBpZiB0aGUgbGFiZWwgc2hvdWxkIG5vdCBiZSBrZXB0LlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKExhYmVsKTpib29sZWFufSAqL1xyXG4gICAgICAgIHRoaXMucHJlcHJvY2VzcyA9IG9wdHMucHJlcHJvY2Vzc1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48TGFiZWw+IHwgdW5kZWZpbmVkfSAqL1xyXG4gICAgICAgIHRoaXMubGFiZWxzID0gdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSAnbm90TG9hZGVkJ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGUgbGFiZWwgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGNnIFRoZSBjYW52YXMgd2hlcmUgdG8gZHJhdyB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZHJhdyhjZykge1xyXG4gICAgICAgIC8vbG9hZCBsYWJlbHMsIGlmIG5vdCBkb25lIHlldC5cclxuICAgICAgICBpZiAoIXRoaXMubGFiZWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZChjZy5yZWRyYXcpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy96b29tIGZhY3RvclxyXG4gICAgICAgIGNvbnN0IHpmID0gY2cuZ2V0WmYoKVxyXG5cclxuICAgICAgICAvL3RleHQgYWxpZ25cclxuICAgICAgICBjZy5jdHgudGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ24gfHwgJ3N0YXJ0J1xyXG5cclxuICAgICAgICAvL2xpbmUgam9pbiBhbmQgY2FwXHJcbiAgICAgICAgY2cuY3R4LmxpbmVKb2luID0gJ2JldmVsJyAvL3x8IFwicm91bmRcIiB8fCBcIm1pdGVyXCI7XHJcbiAgICAgICAgY2cuY3R4LmxpbmVDYXAgPSAnYnV0dCcgLy98fCBcInJvdW5kXCIgfHwgXCJzcXVhcmVcIjtcclxuXHJcbiAgICAgICAgLy9kcmF3IGluIHBpeCBjb29yZGluYXRlc1xyXG4gICAgICAgIGNnLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxyXG5cclxuICAgICAgICAvL2RyYXcgbGFiZWxzLCBvbmUgYnkgb25lXHJcbiAgICAgICAgZm9yIChjb25zdCBsYiBvZiB0aGlzLmxhYmVscykge1xyXG4gICAgICAgICAgICAvL2dldCBsYWJlbCBzdHlsZVxyXG4gICAgICAgICAgICBjb25zdCBzdCA9IHRoaXMuc3R5bGUobGIsIHpmKVxyXG4gICAgICAgICAgICBpZiAoIXN0KSBjb250aW51ZVxyXG4gICAgICAgICAgICBjZy5jdHguZm9udCA9IHN0XHJcblxyXG4gICAgICAgICAgICAvL2NoZWNrIGxhYmVsIHdpdGhpbiB0aGUgdmlldywgdG8gYmUgZHJhd25cclxuICAgICAgICAgICAgaWYgKCFjZy50b0RyYXcobGIpKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9wb3NpdGlvblxyXG4gICAgICAgICAgICBjb25zdCB4UCA9IGNnLmdlb1RvUGl4WChsYi54KSArIHRoaXMub2Zmc2V0UGl4WzBdXHJcbiAgICAgICAgICAgIGNvbnN0IHlQID0gY2cuZ2VvVG9QaXhZKGxiLnkpIC0gdGhpcy5vZmZzZXRQaXhbMV1cclxuXHJcbiAgICAgICAgICAgIC8vbGFiZWwgc3Ryb2tlLCBmb3IgdGhlIGhhbG9cclxuICAgICAgICAgICAgaWYgKHRoaXMuaGFsb0NvbG9yICYmIHRoaXMuaGFsb1dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYyA9IHRoaXMuaGFsb0NvbG9yKGxiLCB6ZilcclxuICAgICAgICAgICAgICAgIGNvbnN0IGh3ID0gdGhpcy5oYWxvV2lkdGgobGIsIHpmKVxyXG4gICAgICAgICAgICAgICAgaWYgKGhjICYmIGh3ICYmIGh3ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2VTdHlsZSA9IGhjXHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVXaWR0aCA9IGh3XHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZVRleHQobGIubmFtZSwgeFAsIHlQKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2xhYmVsIGZpbGxcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sb3IobGIsIHpmKVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsU3R5bGUgPSBjb2xcclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFRleHQobGIubmFtZSwgeFAsIHlQKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBkYXRhIGZvciBsYWJlbHMsIGZyb20gVVJMIHRoaXMudXJsXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gY2FsbGJhY2tcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGxvYWQoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoIXRoaXMudXJsKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgbG9hZGluZyBsYWJlbHM6IE5vIFVSTCBzcGVjaWZpZWQuICcgKyB0aGlzLnVybClcclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gJ2ZhaWxlZCdcclxuICAgICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2hlY2sgaWYgZGF0YSBhbHJlYWR5IGxvYWRlZFxyXG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmdTdGF0dXMgIT0gJ25vdExvYWRlZCcpIHJldHVyblxyXG5cclxuICAgICAgICAvL2xvYWQgZGF0YVxyXG4gICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdsb2FkaW5nJ1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgeyBBcnJheS48TGFiZWw+IH0gKi9cclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNzdih0aGlzLnVybClcclxuXHJcbiAgICAgICAgICAgIC8vcHJlcHJvY2Vzcy9maWx0ZXJcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJlcHJvY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXVxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gdGhpcy5wcmVwcm9jZXNzKGMpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT0gZmFsc2UpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMucHVzaChjKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9zdG9yZSBsYWJlbHNcclxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxzID0gZGF0YVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSAnbG9hZGVkJ1xyXG5cclxuICAgICAgICAgICAgLy9yZWRyYXdcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBsb2FkaW5nIGxhYmVscyBmcm9tICcgKyB0aGlzLnVybClcclxuICAgICAgICAgICAgdGhpcy5sYWJlbHMgPSBbXVxyXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSAnZmFpbGVkJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbi8qKlxyXG4gKiBBIGxheWVyLCB3aGljaCBzcGVjaWZpZXMgYSBkYXRhc2V0IHRvIGJlIHNob3duIHdpdGggc3BlY2lmaWVkIHN0eWxlcy5cclxuICpcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExheWVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0RhdGFzZXRcIikuRGF0YXNldH0gZGF0YXNldCBUaGUgbXVsdGkgcmVzb2x1dGlvbiBkYXRhc2V0IHRvIHNob3cuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuL1N0eWxlXCIpLlN0eWxlPn0gc3R5bGVzIFRoZSBzdHlsZXMsIG9yZGVyZWQgaW4gZHJhd2luZyBvcmRlci5cclxuICAgICAqIEBwYXJhbSB7e3Zpc2libGU/OmJvb2xlYW4sYWxwaGE/Om51bWJlcixibGVuZE9wZXJhdGlvbj86R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLG1pblpvb20/Om51bWJlcixtYXhab29tPzpudW1iZXIscGl4TmI/Om51bWJlcixjZWxsSW5mb0hUTUw/OmZ1bmN0aW9uKGltcG9ydChcIi4vRGF0YXNldFwiKS5DZWxsKTpzdHJpbmd9fSBvcHRzXHJcbiAgICAgKiAgICAgIG1pblpvb206IFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgd2hlbiB0byBzaG93IHRoZSBsYXllci4gbWF4Wm9vbTogVGhlIG1heGltdW0gem9vbSBsZXZlbCB3aGVuIHRvIHNob3cgdGhlIGxheWVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGRhdGFzZXQsIHN0eWxlcywgb3B0cyA9IHt9KSB7XHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0RhdGFzZXRcIikuRGF0YXNldH0gKi9cclxuICAgICAgICB0aGlzLmRhdGFzZXQgPSBkYXRhc2V0XHJcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48aW1wb3J0KFwiLi9TdHlsZVwiKS5TdHlsZT59ICovXHJcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXNcclxuXHJcbiAgICAgICAgLyoqIEFuIGF0dHJpYnV0ZSB0byBzcGVjaWZ5IGlmIGEgbGF5ZXIgc2hvdWxkIGJlIGRyYXduIG9yIG5vdFxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSAqL1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IG9wdHMudmlzaWJsZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWVcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBhbHBoYSAodHJhbnNwYXJlbmN5L29wYWNpdHkpLCBiZXR3ZWVuIDAuMCAoZnVsbHkgdHJhbnNwYXJlbnQpIGFuZCAxLjAgKGZ1bGx5IG9wYXF1ZSkuXHJcbiAgICAgICAgICogIFRoZSBmdW5jdGlvbiBwYXJhbWV0ZXIgaXMgdGhlIHpvb20gZmFjdG9yLlxyXG4gICAgICAgICAqIChzZWUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiBnbG9iYWxBbHBoYSBwcm9wZXJ0eSlcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSBvcHRzLmFscGhhXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgYmxlbmQgb3BlcmF0aW9uLiBUaGUgZnVuY3Rpb24gcGFyYW1ldGVyIGlzIHRoZSB6b29tIGZhY3Rvci5cclxuICAgICAgICAgKiAoc2VlIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDogZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHByb3BlcnR5KVxyXG4gICAgICAgICAqIEB0eXBlIHtHbG9iYWxDb21wb3NpdGVPcGVyYXRpb259ICovXHJcbiAgICAgICAgdGhpcy5ibGVuZE9wZXJhdGlvbiA9IG9wdHMuYmxlbmRPcGVyYXRpb24gfHwgKHpmID0+IFwic291cmNlLW92ZXJcIilcclxuXHJcbiAgICAgICAgLyoqIFRoZSBtaW5pbXVtIHpvb20gZmFjdG9yOiBCZWxvdyB0aGlzIGxldmVsLCB0aGUgbGF5ZXIgaXMgbm90IHNob3duLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5taW5ab29tID0gb3B0cy5taW5ab29tIHx8IDBcclxuXHJcbiAgICAgICAgLyoqIFRoZSBtYXhpbXVtIHpvb20gZmFjdG9yOiBBYm92ZSB0aGlzIGxldmVsLCB0aGUgbGF5ZXIgaXMgbm90IHNob3duLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5tYXhab29tID0gb3B0cy5tYXhab29tIHx8IEluZmluaXR5XHJcblxyXG4gICAgICAgIC8vZW5zdXJlIGFjY2VwdGFibGUgdmFsdWVzIGZvciB0aGUgem9vbSBsaW1pdHMuXHJcbiAgICAgICAgaWYgKHRoaXMubWluWm9vbSA+PSB0aGlzLm1heFpvb20pXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB6b29tIGxpbWl0cyBmb3IgbGF5ZXIuIFpvb20gbWluIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gem9vbSBtYXguJylcclxuXHJcbiAgICAgICAgLyoqIFVuaXQ6IG51bWJlciBvZiBwaXhlbHNcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMucGl4TmIgPSBvcHRzLnBpeE5iIHx8IDNcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGZ1bmN0aW9uIHJldHVybmluZyBjZWxsIGluZm9ybWF0aW9uIGFzIEhUTUwuXHJcbiAgICAgICAgICogVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCBmb3IgdG9vbHRpcCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9EYXRhc2V0XCIpLkNlbGwsIG51bWJlcik6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuY2VsbEluZm9IVE1MID0gb3B0cy5jZWxsSW5mb0hUTUwgfHwgTGF5ZXIuZGVmYXVsdENlbGxJbmZvSFRNTFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSByZWxldmFudCBkYXRhc2V0IGNvbXBvbmVudCBmb3IgYSBzcGVjaWZpZWQgem9vbSBmYWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpmXHJcbiAgICAgKiBAcmV0dXJucyB7aW1wb3J0KFwiLi9EYXRhc2V0Q29tcG9uZW50XCIpLkRhdGFzZXRDb21wb25lbnR8dW5kZWZpbmVkfVxyXG4gICAgICogKi9cclxuICAgIGdldERhdGFzZXRDb21wb25lbnQoemYpIHtcclxuICAgICAgICBpZiAoemYgPCB0aGlzLm1pblpvb20gfHwgemYgPiB0aGlzLm1heFpvb20pIHJldHVyblxyXG5cclxuICAgICAgICAvL3NwZWNpYWwgY2FzZSB3aGl0aCBzaW5nbGUgY29tcG9uZW50IGRhdGFzZXRcclxuICAgICAgICBpZiAodGhpcy5kYXRhc2V0LmRhdGFzZXRDb21wb25lbnRzLmxlbmd0aCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhc2V0LmRhdGFzZXRDb21wb25lbnRzWzBdXHJcblxyXG4gICAgICAgIGNvbnN0IHJzID0gdGhpcy5kYXRhc2V0LnJlc29sdXRpb25zXHJcbiAgICAgICAgbGV0IGkgPSAwXHJcbiAgICAgICAgbGV0IHogPSByc1tpXSAvIHRoaXMucGl4TmJcclxuICAgICAgICB3aGlsZSAoeiA8IHpmICYmIGkgPCBycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaSsrXHJcbiAgICAgICAgICAgIHogPSByc1tpXSAvIHRoaXMucGl4TmJcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9pZiAoaSA9PSAwKSByZXR1cm4gdGhpcy5kYXRhc2V0LmRhdGFzZXRDb21wb25lbnRzWzBdO1xyXG4gICAgICAgIC8vcmV0dXJuIHRoaXMuZGF0YXNldC5kYXRhc2V0Q29tcG9uZW50c1tpIC0gMV07XHJcbiAgICAgICAgaWYgKGkgPT0gcnMubGVuZ3RoKSByZXR1cm4gdGhpcy5kYXRhc2V0LmRhdGFzZXRDb21wb25lbnRzW3JzLmxlbmd0aCAtIDFdXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YXNldC5kYXRhc2V0Q29tcG9uZW50c1tpXVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgZnVuY3Rpb24gcmV0dXJuaW5nIGNlbGwgaW5mb3JtYXRpb24gYXMgSFRNTC5cclxuICAgICAqIFRoaXMgaXMgdHlwaWNhbGx5IHVzZWQgZm9yIHRvb2x0aXAgaW5mb3JtYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0RhdGFzZXRcIikuQ2VsbH0gY2VsbFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlZmF1bHRDZWxsSW5mb0hUTUwoY2VsbCkge1xyXG4gICAgICAgIGNvbnN0IGJ1ZiA9IFtdXHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY2VsbCkpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3gnKSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAneScpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGJ1Zi5wdXNoKCc8Yj4nLCBrZXksICc8L2I+JywgJyA6ICcsIGNlbGxba2V5XSwgJzxicj4nKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnVmLmpvaW4oJycpXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcblxyXG4vKipcclxuICogQSBsZWdlbmQgY29udGFpbmVyLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGVnZW5kIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuaWQgPSBvcHRzLmlkXHJcblxyXG4gICAgICAgIC8vVE9ETyBzdG9wIHVzaW5nIGl0LiBVc2Ugc3R5bGUgbWV0aG9kIGJlbG93IGluc3RlYWQuXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBAZGVwcmVjYXRlZCAqL1xyXG4gICAgICAgIHRoaXMudG9wID0gb3B0cy50b3BcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gQGRlcHJlY2F0ZWQgKi9cclxuICAgICAgICB0aGlzLmJvdHRvbSA9IG9wdHMuYm90dG9tXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IEBkZXByZWNhdGVkICovXHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gb3B0cy5sZWZ0XHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IEBkZXByZWNhdGVkICovXHJcbiAgICAgICAgdGhpcy5yaWdodCA9IG9wdHMucmlnaHRcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gQGRlcHJlY2F0ZWQgKi9cclxuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBvcHRzLmJhY2tncm91bmQgfHwgJ25vbmUnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXHJcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gb3B0cy5wYWRkaW5nIHx8ICc1cHgnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXHJcbiAgICAgICAgdGhpcy5ib3JkZXIgPSBvcHRzLmJvcmRlciB8fCAnMHB4J1xyXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBAZGVwcmVjYXRlZCAqL1xyXG4gICAgICAgIHRoaXNbJ2JvcmRlci1yYWRpdXMnXSA9IG9wdHNbJ2JvcmRlci1yYWRpdXMnXSB8fCAnbm9uZSdcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gQGRlcHJlY2F0ZWQgKi9cclxuICAgICAgICB0aGlzWydib3gtc2hhZG93J10gPSBvcHRzWydib3gtc2hhZG93J10gfHwgJ25vbmUnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXHJcbiAgICAgICAgdGhpc1snZm9udC1mYW1pbHknXSA9IG9wdHNbJ2ZvbnQtZmFtaWx5J10gfHwgJ0hlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWYnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEBkZXByZWNhdGVkICovXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdHMud2lkdGhcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gQGRlcHJlY2F0ZWQgKi9cclxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0XHJcblxyXG4gICAgICAgIC8vdGhlIGRpdiBlbGVtZW50XHJcbiAgICAgICAgaWYgKHRoaXMuaWQpIHRoaXMuZGl2ID0gc2VsZWN0KCcjJyArIHRoaXMuaWQpXHJcblxyXG4gICAgICAgIGlmICghdGhpcy5kaXYgfHwgdGhpcy5kaXYuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpdiA9IHNlbGVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSlcclxuICAgICAgICAgICAgaWYgKHRoaXMuaWQpIHRoaXMuZGl2LmF0dHIoJ2lkJywgdGhpcy5pZClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2V0IHN0eWxlXHJcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUoJ2JhY2tncm91bmQnLCB0aGlzLmJhY2tncm91bmQpXHJcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUoJ3BhZGRpbmcnLCB0aGlzLnBhZGRpbmcpXHJcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUoJ2JvcmRlcicsIHRoaXMuYm9yZGVyKVxyXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlKCdib3JkZXItcmFkaXVzJywgdGhpc1snYm9yZGVyLXJhZGl1cyddKVxyXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlKCdib3gtc2hhZG93JywgdGhpc1snYm94LXNoYWRvdyddKVxyXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlKCdmb250LWZhbWlseScsIHRoaXNbJ2ZvbnQtZmFtaWx5J10pXHJcblxyXG4gICAgICAgIGlmICh0aGlzLndpZHRoKSB0aGlzLmRpdi5zdHlsZSgnd2lkdGgnLCB0aGlzLndpZHRoKVxyXG4gICAgICAgIGlmICh0aGlzLmhlaWdodCkgdGhpcy5kaXYuc3R5bGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgYSBzdHlsZSB0byB0aGUgbGVnZW5kIGRpdi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdlxyXG4gICAgICogQHJldHVybnMge3RoaXN9XHJcbiAgICAgKi9cclxuICAgIHN0eWxlKGssIHYpIHtcclxuICAgICAgICB0aGlzLmRpdi5zdHlsZShrLCB2KVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShvcHRzKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignTGVnZW5kIHVwZGF0ZSBub3QgaW1wbGVtZW50ZWQgeWV0LicpXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBqc29uIH0gZnJvbSAnZDMtZmV0Y2gnXHJcblxyXG4vKipcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExpbmVMYXllciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy51cmwgPSBvcHRzLnVybFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHByZXByb2Nlc3MgdG8gcnVuIG9uIGVhY2ggZmVhdHVyZSBhZnRlciBsb2FkaW5nLlxyXG4gICAgICAgICAqIEl0IGNhbiBiZSB1c2VkIHRvIGFwcGx5IHNvbWUgc3BlY2lmaWMgdHJlYXRtZW50IGJlZm9yZSwgZm9ybWF0IHRoZSBsYWJlbCBkYXRhLCBwcm9qZWN0IGNvb3JkaW5hdGVzLCBldGMuXHJcbiAgICAgICAgICogUmV0dXJuIGZhbHNlIGlmIHRoZSBsYWJlbCBzaG91bGQgbm90IGJlIGtlcHQuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24ob2JqZWN0KTpib29sZWFufSAqL1xyXG4gICAgICAgIHRoaXMucHJlcHJvY2VzcyA9IG9wdHMucHJlcHJvY2Vzc1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihvYmplY3QsbnVtYmVyKTpzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKChmLCB6ZikgPT4gJ2dyYXknKVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG9iamVjdCxudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAoKGYsIHpmKSA9PiAyKVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG9iamVjdCxudW1iZXIpOkFycmF5LjxudW1iZXI+fHVuZGVmaW5lZH0gKi9cclxuICAgICAgICB0aGlzLmxpbmVEYXNoID0gb3B0cy5saW5lRGFzaCB8fCAoKGYsIHpmKSA9PiB1bmRlZmluZWQpXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxvYmplY3Q+IHwgdW5kZWZpbmVkfSAqL1xyXG4gICAgICAgIHRoaXMuZnMgPSB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9ICdub3RMb2FkZWQnXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoZSBsYXllci5cclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9DYW52YXNcIikuR2VvQ2FudmFzfSBjZyBUaGUgY2FudmFzIHdoZXJlIHRvIGRyYXcgdGhlIGxheWVyLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGRyYXcoY2cpIHtcclxuICAgICAgICAvL2xvYWQgZGF0YSwgaWYgbm90IGRvbmUgeWV0LlxyXG4gICAgICAgIGlmICghdGhpcy5mcykge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWQoY2cucmVkcmF3KVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETyBzb3J0IGxpbmVzIGJ5IHdpZHRoID9cclxuXHJcbiAgICAgICAgLy96b29tIGZhY3RvclxyXG4gICAgICAgIGNvbnN0IHpmID0gY2cuZ2V0WmYoKVxyXG5cclxuICAgICAgICAvL2RyYXcgaW4gZ2VvIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgY2cuc2V0Q2FudmFzVHJhbnNmb3JtKClcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMuZnMpIHtcclxuICAgICAgICAgICAgY29uc3QgY3MgPSBmLmdlb21ldHJ5LmNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGlmIChjcy5sZW5ndGggPCAyKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9zZXQgY29sb3JcclxuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvcihmLCB6ZilcclxuICAgICAgICAgICAgaWYgKCFjb2wgfHwgY29sID09ICdub25lJykgY29udGludWVcclxuICAgICAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gY29sXHJcblxyXG4gICAgICAgICAgICAvL3NldCBsaW5ld2lkdGhcclxuICAgICAgICAgICAgY29uc3Qgd1AgPSB0aGlzLndpZHRoKGYsIHpmKVxyXG4gICAgICAgICAgICBpZiAoIXdQIHx8IHdQIDwgMCkgY29udGludWVcclxuICAgICAgICAgICAgY2cuY3R4LmxpbmVXaWR0aCA9IHdQICogemZcclxuXHJcbiAgICAgICAgICAgIC8vc2V0IGxpbmUgZGFzaFxyXG4gICAgICAgICAgICBjb25zdCBsZFAgPSB0aGlzLmxpbmVEYXNoKGYsIHpmKVxyXG4gICAgICAgICAgICBpZiAobGRQKSBjZy5jdHguc2V0TGluZURhc2gobGRQKVxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IGxpbmVcclxuICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oY3NbMF1bMF0sIGNzWzBdWzFdKVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNzLmxlbmd0aDsgaSsrKSBjZy5jdHgubGluZVRvKGNzW2ldWzBdLCBjc1tpXVsxXSlcclxuICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy4uLlxyXG4gICAgICAgIGNnLmN0eC5zZXRMaW5lRGFzaChbXSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgZGF0YSBmb3IgbGFiZWxzLCBmcm9tIFVSTCB0aGlzLnVybFxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IGNhbGxiYWNrXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBhc3luYyBsb2FkKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVybCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIGxvYWRpbmcgYm91bmRhcmllczogTm8gVVJMIHNwZWNpZmllZC4gJyArIHRoaXMudXJsKVxyXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSAnZmFpbGVkJ1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVscyA9IFtdXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jaGVjayBpZiBkYXRhIGFscmVhZHkgbG9hZGVkXHJcbiAgICAgICAgaWYgKHRoaXMubG9hZGluZ1N0YXR1cyAhPSAnbm90TG9hZGVkJykgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vbG9hZCBkYXRhXHJcbiAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gJ2xvYWRpbmcnXHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGFfID0gYXdhaXQganNvbih0aGlzLnVybClcclxuXHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7IEFycmF5LjxvYmplY3Q+IH0gKi9cclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGRhdGFfLmZlYXR1cmVzXHJcblxyXG4gICAgICAgICAgICAvL3ByZXByb2Nlc3MvZmlsdGVyXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXByb2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnMgPSBbXVxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gdGhpcy5wcmVwcm9jZXNzKGMpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT0gZmFsc2UpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcy5wdXNoKGMpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL3N0b3JlIGxhYmVsc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcyA9IGRhdGFcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gJ2xvYWRlZCdcclxuXHJcbiAgICAgICAgICAgIC8vcmVkcmF3XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgbG9hZGluZyBib3VuZGFyaWVzIGZyb20gJyArIHRoaXMudXJsKVxyXG4gICAgICAgICAgICB0aGlzLmZzID0gW11cclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gJ2ZhaWxlZCdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG4vKipcclxuICogU3RhdGlzdGljcyBvZiBhIHNldCBvZiB2YWx1ZXNcclxuICogQHR5cGVkZWYge3ttaW46bnVtYmVyLG1heDpudW1iZXJ9fSBTdGF0ICovXHJcblxyXG4vKiogQHR5cGVkZWYge1wic3F1YXJlXCJ8XCJjaXJjbGVcInxcImRpYW1vbmRcInxcImRvbnV0XCJ8XCJub25lXCJ9IFNoYXBlICovXHJcblxyXG4vKipcclxuICogQSBzdHlsZSwgdG8gc2hvdyBhIGdyaWQgZGF0YXNldC5cclxuICpcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFN0eWxlIHtcclxuICAgIC8qKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0ge3tmaWx0ZXI/OmZ1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCk6Ym9vbGVhbixvZmZzZXQ/OmZ1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCxudW1iZXIsbnVtYmVyKTp7ZHg6bnVtYmVyLGR5Om51bWJlcn0sdmlzaWJsZT86Ym9vbGVhbixhbHBoYT86ZnVuY3Rpb24obnVtYmVyKTpudW1iZXIsYmxlbmRPcGVyYXRpb24/OmZ1bmN0aW9uKG51bWJlcik6R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLG1pblpvb20/Om51bWJlcixtYXhab29tPzpudW1iZXIsZHJhd0Z1bj86ZnVuY3Rpb259fSBvcHRzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogQSBmaWx0ZXIgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIGNlbGwgbGlzdCwgdG8gZmlsdGVyIG91dCBzb21lIGNlbGxzIG5vdCB0byBiZSBkcmF3biAoc3VjaCBhcyBmb3IgZXhhbXBsZSB0aGUgY2VsbHMgd2l0aCB2YWx1ZT0wKS5cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbCk6Ym9vbGVhbn0gKi9cclxuICAgICAgICB0aGlzLmZpbHRlciA9IG9wdHMuZmlsdGVyIHx8ICgoKSA9PiB0cnVlKVxyXG5cclxuICAgICAgICAvKiogQW4gb2Zmc2V0LiBUaGlzIGlzIHRvIGFsdGVyIHRoZSBwb3NpdGlvbiBvZiBhbGwgc3ltYm9scyBpbiBhIGdpdmVuIGRpcmVjdGlvbi4gSW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGwsbnVtYmVyLG51bWJlcik6e2R4Om51bWJlcixkeTpudW1iZXJ9fSAqL1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb3B0cy5vZmZzZXQgfHwgKChjLCByLCB6ZikgPT4gKHsgZHg6IDAsIGR5OiAwIH0pKVxyXG5cclxuICAgICAgICAvKiogQW4gYXR0cmlidXRlIHRvIHNwZWNpZnkgaWYgYSBzdHlsZSBzaG91bGQgYmUgZHJhd24gb3Igbm90XHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59ICovXHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gb3B0cy52aXNpYmxlID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZVxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGFscGhhICh0cmFuc3BhcmVuY3kvb3BhY2l0eSksIGJldHdlZW4gMC4wIChmdWxseSB0cmFuc3BhcmVudCkgYW5kIDEuMCAoZnVsbHkgb3BhcXVlKS5cclxuICAgICAgICAgKiAgVGhlIGZ1bmN0aW9uIHBhcmFtZXRlciBpcyB0aGUgem9vbSBmYWN0b3IuXHJcbiAgICAgICAgICogKHNlZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ6IGdsb2JhbEFscGhhIHByb3BlcnR5KVxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIpOm51bWJlcnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgdGhpcy5hbHBoYSA9IG9wdHMuYWxwaGFcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBibGVuZCBvcGVyYXRpb24uIFRoZSBmdW5jdGlvbiBwYXJhbWV0ZXIgaXMgdGhlIHpvb20gZmFjdG9yLlxyXG4gICAgICAgICAqIChzZWUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gcHJvcGVydHkpXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcik6R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9ufSAqL1xyXG4gICAgICAgIHRoaXMuYmxlbmRPcGVyYXRpb24gPSBvcHRzLmJsZW5kT3BlcmF0aW9uIHx8ICh6ZiA9PiBcInNvdXJjZS1vdmVyXCIpXHJcblxyXG4gICAgICAgIC8qKiBUaGUgbWluaW11bSB6b29tIGZhY3RvcjogQmVsb3cgdGhpcyBsZXZlbCwgdGhlIGxheWVyIGlzIG5vdCBzaG93bi5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqICovXHJcbiAgICAgICAgdGhpcy5taW5ab29tID0gb3B0cy5taW5ab29tIHx8IDBcclxuXHJcbiAgICAgICAgLyoqIFRoZSBtYXhpbXVtIHpvb20gZmFjdG9yOiBBYm92ZSB0aGlzIGxldmVsLCB0aGUgbGF5ZXIgaXMgbm90IHNob3duLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogKi9cclxuICAgICAgICB0aGlzLm1heFpvb20gPSBvcHRzLm1heFpvb20gfHwgSW5maW5pdHlcclxuXHJcbiAgICAgICAgLyoqIEEgZHJhdyBmdW5jdGlvbiBmb3IgdGhlIHN0eWxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbn0gKi9cclxuICAgICAgICB0aGlzLmRyYXdGdW4gPSBvcHRzLmRyYXdGdW5cclxuXHJcbiAgICAgICAgLy9lbnN1cmUgYWNjZXB0YWJsZSB2YWx1ZXMgZm9yIHRoZSB6b29tIGxpbWl0cy5cclxuICAgICAgICBpZiAodGhpcy5taW5ab29tID49IHRoaXMubWF4Wm9vbSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHpvb20gbGltaXRzIGZvciBsYXllci4gWm9vbSBtaW4gc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiB6b29tIG1heC4nKVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHVibGljXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxpbXBvcnQoXCIuL0xlZ2VuZFwiKS5MZWdlbmQ+fSAqL1xyXG4gICAgICAgIHRoaXMubGVnZW5kcyA9IFtdXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGNlbGxzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydCgnLi9EYXRhc2V0JykuQ2VsbD59IGNlbGxzIFRoZSBjZWxscyB0byBkcmF3LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGhlaXIgcmVzb2x1dGlvbiAoaW4gZ2VvZ3JhcGhpYyB1bml0KVxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGNnIFRoZSBjYW52YXMgd2hlcmUgdG8gZHJhdyB0aGVtLlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKi9cclxuICAgIGRyYXcoY2VsbHMsIHJlc29sdXRpb24sIGNnKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZHJhd0Z1bikgdGhpcy5kcmF3RnVuKGNlbGxzLCByZXNvbHV0aW9uLCBjZylcclxuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignTWV0aG9kIGRyYXcgbm90IGltcGxlbWVudGVkLicpXHJcbiAgICB9XHJcblxyXG4gICAgLy9nZXR0ZXJzIGFuZCBzZXR0ZXJzXHJcblxyXG4gICAgLyoqIEByZXR1cm5zIHtmdW5jdGlvbihpbXBvcnQoJy4vRGF0YXNldCcpLkNlbGwsbnVtYmVyLG51bWJlcik6e2R4Om51bWJlcixkeTpudW1iZXJ9fSAqL1xyXG4gICAgZ2V0T2Zmc2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldFxyXG4gICAgfVxyXG4gICAgLyoqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsLG51bWJlcixudW1iZXIpOntkeDpudW1iZXIsZHk6bnVtYmVyfX0gdmFsIEByZXR1cm5zIHt0aGlzfSAqL1xyXG4gICAgc2V0T2Zmc2V0KHZhbCkge1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gdmFsXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKiogSGlkZSBhbGwgbGVnZW5kIGVsZW1lbnRzIG9mIHRoZSBzdHlsZSwgaWYgYW55XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xyXG4gICAgICogQHJldHVybnMge3RoaXN9ICovXHJcbiAgICB1cGRhdGVMZWdlbmRzKG9wdHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGxnIG9mIHRoaXMubGVnZW5kcykgbGcudXBkYXRlKG9wdHMpXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgc29tZSBzdGF0aXN0aWNzIG9uIGEgdmFsdWUgb2Ygc29tZSBjZWxscy5cclxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBkZWZpbmUgaG93IHRvIGRyYXcgc3BlY2lmaWNhbGx5IHRoZSBjZWxscyB3aXRoaW4gdGhlIHZpZXcuXHJcbiAgICAgKiBUT0RPOiBjb21wdXRlIG1lZGlhbiA/XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsPn0gY2VsbHNcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KCcuL0RhdGFzZXQnKS5DZWxsKTpudW1iZXJ9IHZhbEZ1blxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVaZXJvc1xyXG4gICAgICogQHJldHVybnMge1N0YXQgfCB1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRTdGF0aXN0aWNzKGNlbGxzLCB2YWxGdW4sIGlnbm9yZVplcm9zKSB7XHJcbiAgICAgICAgaWYgKCFjZWxscyB8fCBjZWxscy5sZW5ndGggPT0gMCkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgIGxldCBtaW4gPSBJbmZpbml0eVxyXG4gICAgICAgIGxldCBtYXggPSAtSW5maW5pdHlcclxuICAgICAgICAvL2xldCBzdW0gPSAwXHJcbiAgICAgICAgLy9sZXQgbmIgPSAwXHJcbiAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIGNlbGxzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHYgPSArdmFsRnVuKGNlbGwpXHJcbiAgICAgICAgICAgIGlmIChpZ25vcmVaZXJvcyAmJiAhdikgY29udGludWVcclxuICAgICAgICAgICAgaWYgKHYgPCBtaW4pIG1pbiA9IHZcclxuICAgICAgICAgICAgaWYgKHYgPiBtYXgpIG1heCA9IHZcclxuICAgICAgICAgICAgLy9zdW0gKz0gdlxyXG4gICAgICAgICAgICAvL25iKytcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgbWluOiBtaW4sIG1heDogbWF4IH1cclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbidcclxuLy9pbXBvcnQgeyB0cmFuc2l0aW9uIH0gZnJvbSBcImQzLXRyYW5zaXRpb25cIjtcclxuXHJcbi8qKlxyXG4gKiBBIGdlbmVyaWMgY2xhc3MgdG8gbWFrZSBhIHRvb2x0aXAuXHJcbiAqIEl0IGlzIGEgZGl2IGVsZW1lbnQsIHdoaWNoIGNhbiBiZSBtb3ZlZCB1bmRlciB0aGUgbW91c2UgcG9pbnRlciBhbmQgZmlsbGVkIHdpdGggc29tZSBpbmZvcm1hdGlvbiBpbiBodG1sLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRvb2x0aXAge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5kaXYgPSBvcHRzLmRpdiB8fCAndG9vbHRpcF9ldXJvc3RhdCdcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLm1heFdpZHRoID0gb3B0cy5tYXhXaWR0aCB8fCAnMjBlbSdcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmZvbnRTaXplID0gb3B0cy5mb250U2l6ZSB8fCAnMS4yZW0nXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gb3B0cy5iYWNrZ3JvdW5kIHx8ICd3aGl0ZSdcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnBhZGRpbmcgPSBvcHRzLnBhZGRpbmcgfHwgJzVweCdcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmJvcmRlciA9IG9wdHMuYm9yZGVyIHx8ICcwcHgnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpc1snYm9yZGVyLXJhZGl1cyddID0gb3B0c1snYm9yZGVyLXJhZGl1cyddIHx8ICcwcHgnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpc1snYm94LXNoYWRvdyddID0gb3B0c1snYm94LXNoYWRvdyddIHx8ICc1cHggNXB4IDVweCBncmV5J1xyXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXNbJ2ZvbnQtZmFtaWx5J10gPSBvcHRzWydmb250LWZhbWlseSddIHx8ICdIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmJ1xyXG5cclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbiA9IG9wdHMudHJhbnNpdGlvbkR1cmF0aW9uIHx8IDEwMFxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMueE9mZnNldCA9IG9wdHMueE9mZnNldCB8fCAzMFxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMueU9mZnNldCA9IG9wdHMueU9mZnNldCB8fCAyMFxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAvLyBlLmcuIHRvIHByZXZlbnQgbW91c2UgY3Vyc29yIGNvdmVyaW5nIGNlbGwgYmVpbmcgaGlnaGxpZ2h0ZWRcclxuICAgICAgICB0aGlzLnlNb3VzZU9mZnNldCA9IG9wdHMueU1vdXNlT2Zmc2V0IHx8IDBcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnhNb3VzZU9mZnNldCA9IG9wdHMueE1vdXNlT2Zmc2V0IHx8IDBcclxuICAgICAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xyXG4gICAgICAgIHRoaXMucGFyZW50RWxlbWVudCA9IG9wdHMucGFyZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwdWJsaWNcclxuICAgICAgICAgKiBAdHlwZSB7aW1wb3J0KFwiZDMtc2VsZWN0aW9uXCIpLlNlbGVjdGlvbn0gKi9cclxuICAgICAgICB0aGlzLnRvb2x0aXAgPSBzZWxlY3QoJyMnICsgdGhpcy5kaXYpXHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRvb2x0aXAuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICAvL2NyZWF0ZSB0b29sdGlwIERPTSBub2RlXHJcbiAgICAgICAgICAgIC8vIHRoaXMudG9vbHRpcCA9IHNlbGVjdChcclxuICAgICAgICAgICAgLy8gICAgICcjJyArIHRoaXMucGFyZW50RWxlbWVudC5pZCAmJiB0aGlzLnBhcmVudEVsZW1lbnQuaWQgIT0gJydcclxuICAgICAgICAgICAgLy8gICAgICAgICA/ICcjJyArIHRoaXMucGFyZW50RWxlbWVudC5pZFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIDogJ2JvZHknXHJcbiAgICAgICAgICAgIC8vIClcclxuICAgICAgICAgICAgdGhpcy50b29sdGlwID0gc2VsZWN0KCdib2R5JykuYXBwZW5kKCdkaXYnKS5hdHRyKCdpZCcsIHRoaXMuZGl2KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9pbml0aWFsaXNlXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdtYXgtd2lkdGgnLCB0aGlzLm1heFdpZHRoKVxyXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgnb3ZlcmZsb3cnLCAnaGlkZGVuJylcclxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ2ZvbnQtc2l6ZScsIHRoaXMuZm9udFNpemUpXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdiYWNrZ3JvdW5kJywgdGhpcy5iYWNrZ3JvdW5kKVxyXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgncGFkZGluZycsIHRoaXMucGFkZGluZylcclxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ2JvcmRlcicsIHRoaXMuYm9yZGVyKVxyXG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZSgnYm9yZGVyLXJhZGl1cycsIHRoaXNbJ2JvcmRlci1yYWRpdXMnXSlcclxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ2JveC1zaGFkb3cnLCB0aGlzWydib3gtc2hhZG93J10pXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdmb250LWZhbWlseScsIHRoaXNbJ2ZvbnQtZmFtaWx5J10pXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdub25lJylcclxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ29wYWNpdHknLCAnMCcpXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKCd0ZXh0LXdyYXAnLCAnbm93cmFwJylcclxuXHJcbiAgICAgICAgLy8gYXJpYS1sYWJlbHMgKHRoYW5rcyB0byB3YWhsYXRsYXMpXHJcbiAgICAgICAgdGhpcy50b29sdGlwLmF0dHIoJ3JvbGUnLCAndG9vbHRpcCcpLmF0dHIoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTaG93IHRoZSB0b29sdGlwICovXHJcbiAgICBzaG93KCkge1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICB0aGlzLnRvb2x0aXAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uKS5zdHlsZSgnb3BhY2l0eScsIDEpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEhpZGUgdGhlIHRvb2x0aXAgKi9cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHRoaXMudG9vbHRpcC50cmFuc2l0aW9uKCkuZHVyYXRpb24odGhpcy50cmFuc2l0aW9uRHVyYXRpb24pLnN0eWxlKCdvcGFjaXR5JywgMClcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXHJcbiAgICAgKi9cclxuICAgIGh0bWwoaHRtbCkge1xyXG4gICAgICAgIHRoaXMudG9vbHRpcC5odG1sKGh0bWwpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwIGF0IHRoZSBtb3VzZSBldmVudCBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcclxuICAgICAqL1xyXG4gICAgc2V0UG9zaXRpb24oZXZlbnQpIHtcclxuICAgICAgICBsZXQgcGFyZW50UmVjdCA9IHRoaXMucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG5cclxuICAgICAgICBsZXQgeCA9IGV2ZW50LnBhZ2VYICsgdGhpcy54T2Zmc2V0XHJcbiAgICAgICAgbGV0IHkgPSBldmVudC5wYWdlWSAtIHRoaXMueU9mZnNldFxyXG5cclxuICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUoJ2xlZnQnLCB4ICsgJ3B4Jykuc3R5bGUoJ3RvcCcsIHkgKyAncHgnKVxyXG5cclxuICAgICAgICB0aGlzLmVuc3VyZVRvb2x0aXBJbnNpZGVDb250YWluZXIoZXZlbnQsIHBhcmVudFJlY3QpXHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuXHRteS5tb3VzZW92ZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGh0bWwpIHtcclxuXHRcdGlmIChodG1sKSBteS5odG1sKGh0bWwpO1xyXG5cdFx0bXkuc2V0UG9zaXRpb24oZXZlbnQpO1xyXG5cdFx0bXkuc2hvdygpXHJcblx0XHQvL3RoaXMuZW5zdXJlVG9vbHRpcEluc2lkZUNvbnRhaW5lcigpO1xyXG5cdH07XHJcblx0XHJcblx0bXkubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRteS5zZXRQb3NpdGlvbihldmVudCk7XHJcblx0XHQvL3RoaXMuZW5zdXJlVG9vbHRpcEluc2lkZUNvbnRhaW5lcigpO1xyXG5cdH07XHJcblx0XHJcblx0bXkubW91c2VvdXQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRteS5oaWRlKCk7XHJcblx0fTsqL1xyXG5cclxuICAgIHN0eWxlKGssIHYpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSByZXR1cm4gdGhpcy50b29sdGlwLnN0eWxlKGspXHJcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlKGssIHYpXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICBhdHRyKGssIHYpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSByZXR1cm4gdGhpcy50b29sdGlwLmF0dHIoaylcclxuICAgICAgICB0aGlzLnRvb2x0aXAuYXR0cihrLCB2KVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gZW5zdXJlVG9vbHRpcEluc2lkZUNvbnRhaW5lclxyXG4gICAgICogQGRlc2NyaXB0aW9uIFByZXZlbnRzIHRoZSB0b29sdGlwIGZyb20gb3ZlcmZsb3dpbmcgb3V0IG9mIHRoZSBBcHAgY29udGFpbmVyIChlbnN1cmVzIHRoYXQgdGhlIHRvb2x0aXAgaXMgaW5zaWRlIHRoZSBncmlkdml6IGNvbnRhaW5lcilcclxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcclxuICAgICAqIEBwYXJhbSB7RE9NUmVjdH0gcGFyZW50UmVjdFxyXG4gICAgICovXHJcbiAgICBlbnN1cmVUb29sdGlwSW5zaWRlQ29udGFpbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBwYXJlbnRSZWN0KSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnRvb2x0aXAubm9kZSgpXHJcbiAgICAgICAgbGV0IHBhcmVudFdpZHRoID0gcGFyZW50UmVjdC53aWR0aFxyXG4gICAgICAgIGxldCBwYXJlbnRIZWlnaHQgPSBwYXJlbnRSZWN0LmhlaWdodFxyXG5cclxuICAgICAgICAvL3RvbyBmYXIgcmlnaHRcclxuICAgICAgICBpZiAobm9kZS5vZmZzZXRMZWZ0ID4gcGFyZW50UmVjdC5sZWZ0ICsgcGFyZW50V2lkdGggLSBub2RlLmNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gZXZlbnQueCAtIG5vZGUuY2xpZW50V2lkdGggLSB0aGlzLnhPZmZzZXRcclxuICAgICAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCdcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgbW91c2UgY292ZXJzIHRvb2x0aXBcclxuICAgICAgICAgICAgaWYgKG5vZGUub2Zmc2V0TGVmdCArIG5vZGUuY2xpZW50V2lkdGggPiBldmVudC54KSB7XHJcbiAgICAgICAgICAgICAgICAvL21vdmUgdG9vbHRpcCBsZWZ0IHNvIGl0IGRvZXNudCBjb3ZlciBtb3VzZVxyXG4gICAgICAgICAgICAgICAgbGV0IGxlZnQyID0gZXZlbnQueCAtIG5vZGUuY2xpZW50V2lkdGggLSB0aGlzLnhPZmZzZXRcclxuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGxlZnQyICsgJ3B4J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vZGUuc3R5bGUudG9wID0gbm9kZS5vZmZzZXRUb3AgKyBjb25maWcueU9mZnNldCArIFwicHhcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdG9vIGZhciBkb3duXHJcbiAgICAgICAgaWYgKG5vZGUub2Zmc2V0VG9wICsgbm9kZS5jbGllbnRIZWlnaHQgPiBwYXJlbnRSZWN0LnRvcCArIHBhcmVudEhlaWdodCkge1xyXG4gICAgICAgICAgICBub2RlLnN0eWxlLnRvcCA9IG5vZGUub2Zmc2V0VG9wIC0gbm9kZS5jbGllbnRIZWlnaHQgKyAncHgnXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3RvbyBmYXIgdXBcclxuICAgICAgICBpZiAobm9kZS5vZmZzZXRUb3AgPCBwYXJlbnRSZWN0LnRvcCkge1xyXG4gICAgICAgICAgICBub2RlLnN0eWxlLnRvcCA9IHBhcmVudFJlY3QudG9wICsgdGhpcy55T2Zmc2V0ICsgJ3B4J1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nXHJcblxyXG4vKipcclxuICogUGFyZW50IGNsYXNzIGZvciBidXR0b24gZWxlbWVudHMgdXNlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBncmlkdml6IHZpZXdlci5cclxuICpcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJ1dHRvbiB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAgKiBvcHRzLnBhcmVudE5vZGVcclxuICAgICAqIG9wdHMuaWRcclxuICAgICAqIG9wdHMudGl0bGVcclxuICAgICAqIG9wdHMuY2xhc3NcclxuICAgICAqIG9wdHMub25DbGlja0Z1bmN0aW9uXHJcbiAgICAgKiBvcHRzLnhcclxuICAgICAqIG9wdHMueVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgdGhpcy5hcHAgPSBvcHRzLmFwcFxyXG4gICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IG9wdHMucGFyZW50Tm9kZSB8fCBvcHRzLmFwcC5jb250YWluZXJcclxuXHJcbiAgICAgICAgLy8gdGhlIGRpdiBlbGVtZW50XHJcbiAgICAgICAgaWYgKHRoaXMuaWQpIHRoaXMuZGl2ID0gc2VsZWN0KCcjJyArIHRoaXMuaWQpXHJcblxyXG4gICAgICAgIGlmICghdGhpcy5kaXYgfHwgdGhpcy5kaXYuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpdiA9IHNlbGVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSlcclxuICAgICAgICAgICAgaWYgKHRoaXMuaWQpIHRoaXMuZGl2LmF0dHIoJ2lkJywgdGhpcy5pZClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRzLnRpdGxlKSB0aGlzLmRpdi5hdHRyKCd0aXRsZScsb3B0cy50aXRsZSlcclxuICAgICAgICBpZiAob3B0cy5jbGFzcykgdGhpcy5kaXYuYXR0cignY2xhc3MnLG9wdHMuY2xhc3MpXHJcblxyXG4gICAgICAgIC8vIGFkZCBldmVudHNcclxuICAgICAgICBpZiAob3B0cy5vbkNsaWNrRnVuY3Rpb24pIHRoaXMuZGl2Lm9uKCdjbGljaycsIG9wdHMub25DbGlja0Z1bmN0aW9uKVxyXG5cclxuICAgICAgICAvL3NldCBzdHlsZXNcclxuICAgICAgICB0aGlzLnN0eWxlKCdib3gtc2hhZG93JywnMCA3cHggOHB4IHJnYmEoMCw0NywxMDMsLjA4KSwgMCAwIDIycHggcmdiYSgwLDQ3LDEwMywuMDQpLCAwIDEycHggMTdweCByZ2JhKDAsNDcsMTAzLC4wNCksIDAgLTRweCA0cHggcmdiYSgwLDQ3LDEwMywuMDQpJykgLy8uZWNsLXUtc2hhZG93LTNcclxuICAgICAgICB0aGlzLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywnI2ZmZmZmZicpXHJcbiAgICAgICAgdGhpcy5zdHlsZSgncG9zaXRpb24nICwgJ2Fic29sdXRlJylcclxuICAgICAgICB0aGlzLnN0eWxlKCdjdXJzb3InICwgJ3BvaW50ZXInKVxyXG4gICAgICAgIHRoaXMuc3R5bGUoJ2Rpc3BsYXknICwgJ2ZsZXgnKVxyXG4gICAgICAgIHRoaXMuc3R5bGUoJ2p1c3RpZnktY29udGVudCcgLCAnY2VudGVyJylcclxuICAgICAgICB0aGlzLnN0eWxlKCdhbGlnbi1pdGVtcycgLCAnY2VudGVyJylcclxuICAgICAgICB0aGlzLnN0eWxlKCd3aWR0aCcgLCAnMzBweCcpXHJcbiAgICAgICAgdGhpcy5zdHlsZSgnaGVpZ2h0JyAsICczMHB4JylcclxuICAgICAgICAvLyB0aGlzLnN0eWxlKHBhZGRpbmcgLCAnNHB4J1xyXG5cclxuXHJcbiAgICAgICAgLy8gYXBwZW5kIHRvIHBhcmVudFxyXG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmRpdi5ub2RlKCkpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBhIHN0eWxlIHRvIHRoZSBidXR0b24gZGl2LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2XHJcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cclxuICAgICAqL1xyXG4gICAgc3R5bGUoaywgdikge1xyXG4gICAgICAgIHRoaXMuZGl2LnN0eWxlKGssIHYpXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBCdXR0b24gfSBmcm9tICcuL0J1dHRvbi5qcydcclxuXHJcbi8qKlxyXG4gKiBCdXR0b24gZm9yIHRvZ2dsaW5nIGZ1bGxzY3JlZW4gbW9kZVxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRnVsbHNjcmVlbkJ1dHRvbiBleHRlbmRzIEJ1dHRvbiB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAgKiBvcHRzLnBhcmVudE5vZGUgLSB0aGUgbm9kZSB0aGF0IHRoZSBidXR0b24gaXMgYXBwZW5kZWQgdG9cclxuICAgICAqIG9wdHMuY2FudmFzIC0gdGhlIGdyaWR2aXogY2FudmFzXHJcbiAgICAgKiBvcHRzLmlkXHJcbiAgICAgKiBvcHRzLnRpdGxlIC0gSFRNTCB0aXRsZSBhdHRyaWJ1dGVcclxuICAgICAqIG9wdHMuY2xhc3MgLSBjc3MgY2xhc3NcclxuICAgICAqIG9wdHMub25DbGlja0Z1bmN0aW9uXHJcbiAgICAgKiBvcHRzLnggLSB4IHBvc2l0aW9uIG9mIHRoZSBidXR0b25cclxuICAgICAqIG9wdHMueSAtIHkgcG9zaXRpb24gb2YgdGhlIGJ1dHRvblxyXG4gICAgICovXHJcblxyXG4gICAgLy8gZGVmYXVsdCBzdGF0ZVxyXG4gICAgaXNGdWxsc2NyZWVuID0gZmFsc2VcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuXHJcbiAgICAgICAgLy8gYXBwZW5kIGZ1bGxzY3JlZW4gaWNvbiB0byBidXR0b24gY29udGFpbmVyXHJcbiAgICAgICAgdGhpcy5kaXYubm9kZSgpLmlubmVySFRNTCA9IGBcclxuICAgICAgICA8c3ZnXHJcbiAgICAgICAgICAgIHN0eWxlPVwiaGVpZ2h0OiAxLjJyZW07IHdpZHRoOiAxLjJyZW07IGZpbGw6YmxhY2s7IG1hcmdpbjowO1wiXHJcbiAgICAgICAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcclxuICAgICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxzdmcgZmlsbD1cIiMwMDAwMDBcIiB2aWV3Qm94PVwiMCAwIDk2IDk2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxyXG4gICAgICAgICAgICA8dGl0bGUvPlxyXG4gICAgICAgICAgICA8Zz5cclxuICAgICAgICAgICAgPHBhdGggZD1cIk0zMCwwSDZBNS45OTY2LDUuOTk2NiwwLDAsMCwwLDZWMzBhNiw2LDAsMCwwLDEyLDBWMTJIMzBBNiw2LDAsMCwwLDMwLDBaXCIvPlxyXG4gICAgICAgICAgICA8cGF0aCBkPVwiTTkwLDBINjZhNiw2LDAsMCwwLDAsMTJIODRWMzBhNiw2LDAsMCwwLDEyLDBWNkE1Ljk5NjYsNS45OTY2LDAsMCwwLDkwLDBaXCIvPlxyXG4gICAgICAgICAgICA8cGF0aCBkPVwiTTMwLDg0SDEyVjY2QTYsNiwwLDAsMCwwLDY2VjkwYTUuOTk2Niw1Ljk5NjYsMCwwLDAsNiw2SDMwYTYsNiwwLDAsMCwwLTEyWlwiLz5cclxuICAgICAgICAgICAgPHBhdGggZD1cIk05MCw2MGE1Ljk5NjYsNS45OTY2LDAsMCwwLTYsNlY4NEg2NmE2LDYsMCwwLDAsMCwxMkg5MGE1Ljk5NjYsNS45OTY2LDAsMCwwLDYtNlY2NkE1Ljk5NjYsNS45OTY2LDAsMCwwLDkwLDYwWlwiLz5cclxuICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgICA8L3N2Zz5cclxuICAgICAgICA8L3N2Zz5cclxuICAgICAgICBgXHJcblxyXG4gICAgICAgIC8vc2F2ZSBpbml0aWFsIGFwcCBkaW1lbnNpb25zXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0SGVpZ2h0ID0gdGhpcy5hcHAuaFxyXG4gICAgICAgIHRoaXMuZGVmYXVsdFdpZHRoID0gdGhpcy5hcHAud1xyXG5cclxuICAgICAgICAvLyBldmVudCBoYW5kbGVyXHJcbiAgICAgICAgdGhpcy5kaXYub24oJ2NsaWNrJywgKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vbkNsaWNrRnVuY3Rpb24oZSlcclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuZGl2Lm9uKCdtb3VzZW92ZXInLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgJ2xpZ2h0Z3JleScpXHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLmRpdi5vbignbW91c2VvdXQnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgJyNmZmZmZmYnKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vc2V0IHBvc2l0aW9uXHJcbiAgICAgICAgaWYgKG9wdHMueCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlKCdsZWZ0Jywgb3B0cy54ICsgJ3B4JylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlKCdyaWdodCcsICcxMHB4JylcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdHMueSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlKCd0b3AnLCBvcHRzLnkgKyAncHgnKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGUoJ3RvcCcsICc5MHB4JylcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25DbGlja0Z1bmN0aW9uKGUpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZUZ1bGxzY3JlZW4odGhpcy5hcHAuY29udGFpbmVyKVxyXG4gICAgICAgICAgICAvL3Jlc2l6ZSBjYW52YXMgdG8gZGVmYXVsdFxyXG4gICAgICAgICAgICB0aGlzLmFwcC5oID0gdGhpcy5kZWZhdWx0SGVpZ2h0XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLncgPSB0aGlzLmRlZmF1bHRXaWR0aFxyXG4gICAgICAgICAgICB0aGlzLmFwcC5jZy5oID0gdGhpcy5kZWZhdWx0SGVpZ2h0XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLmNnLncgPSB0aGlzLmRlZmF1bHRXaWR0aFxyXG4gICAgICAgICAgICB0aGlzLmFwcC5jZy5jYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcnICsgdGhpcy5kZWZhdWx0V2lkdGgpXHJcbiAgICAgICAgICAgIHRoaXMuYXBwLmNnLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcnICsgdGhpcy5kZWZhdWx0SGVpZ2h0KVxyXG4gICAgICAgICAgICB0aGlzLmFwcC5yZWRyYXcoKVxyXG4gICAgICAgICAgICB0aGlzLmlzRnVsbHNjcmVlbiA9IGZhbHNlXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuRnVsbHNjcmVlbih0aGlzLmFwcC5jb250YWluZXIpXHJcbiAgICAgICAgICAgIC8vcmVzaXplIGNhbnZhcyB0byBmdWxsc2NyZWVuXHJcbiAgICAgICAgICAgIHRoaXMuYXBwLmggPSB3aW5kb3cuc2NyZWVuLmhlaWdodFxyXG4gICAgICAgICAgICB0aGlzLmFwcC53ID0gd2luZG93LnNjcmVlbi53aWR0aFxyXG4gICAgICAgICAgICB0aGlzLmlzRnVsbHNjcmVlbiA9IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyogT3BlbiBmdWxsc2NyZWVuICovXHJcbiAgICBvcGVuRnVsbHNjcmVlbihlbGVtKSB7XHJcbiAgICAgICAgaWYgKGVsZW0ucmVxdWVzdEZ1bGxzY3JlZW4pIHtcclxuICAgICAgICAgICAgZWxlbS5yZXF1ZXN0RnVsbHNjcmVlbigpXHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKSB7XHJcbiAgICAgICAgICAgIC8qIFNhZmFyaSAqL1xyXG4gICAgICAgICAgICBlbGVtLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKClcclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW0ubXNSZXF1ZXN0RnVsbHNjcmVlbikge1xyXG4gICAgICAgICAgICAvKiBJRTExICovXHJcbiAgICAgICAgICAgIGVsZW0ubXNSZXF1ZXN0RnVsbHNjcmVlbigpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qIENsb3NlIGZ1bGxzY3JlZW4gKi9cclxuICAgIGNsb3NlRnVsbHNjcmVlbigpIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4pIHtcclxuICAgICAgICAgICAgLyogU2FmYXJpICovXHJcbiAgICAgICAgICAgIGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKClcclxuICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4pIHtcclxuICAgICAgICAgICAgLyogSUUxMSAqL1xyXG4gICAgICAgICAgICBkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAnLi9CdXR0b24uanMnXHJcblxyXG4vKipcclxuICogQnV0dG9uIGZvciB0b2dnbGluZyBmdWxsc2NyZWVuIG1vZGVcclxuICpcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFpvb21CdXR0b25zIGV4dGVuZHMgQnV0dG9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcblxyXG4gICAgICAgIHRoaXMub25ab29tID0gb3B0cy5vblpvb20gLy8gY3VzdG9tIHVzZXIgZXZlbnQgaGFuZGxlclxyXG4gICAgICAgIHRoaXMuZGVsdGEgPSBvcHRzLmRlbHRhIHx8IDAuMlxyXG5cclxuICAgICAgICAvLyB6b29tIGluIGJ0blxyXG4gICAgICAgIHRoaXMuem9vbUluQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXHJcbiAgICAgICAgdGhpcy56b29tSW5CdG4uaW5uZXJIVE1MID0gYDxhIGlkPVwiem9vbWluXCIgY2xhc3M9XCJncmlkdml6LXpvb20tYnV0dG9uXCIgdGl0bGU9XCJab29tIGluXCI+KzwvYT5gXHJcbiAgICAgICAgdGhpcy56b29tSW5CdG4udGl0bGUgPSAnWm9vbSBpbidcclxuICAgICAgICB0aGlzLnpvb21JbkJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuem9vbUluKGUpXHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLnpvb21JbkJ0bi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnpvb21JbkJ0bi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnbGlnaHRncmV5J1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy56b29tSW5CdG4uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnpvb21JbkJ0bi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZmZmZidcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyB6b29tIG91dCBidG5cclxuICAgICAgICB0aGlzLnpvb21PdXRCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcclxuICAgICAgICB0aGlzLnpvb21PdXRCdG4uaW5uZXJIVE1MID0gYDxhIGlkPVwiem9vbWluXCIgY2xhc3M9XCJncmlkdml6LXpvb20tYnV0dG9uXCIgdGl0bGU9XCJab29tIG91dFwiPi08L2E+YFxyXG4gICAgICAgIHRoaXMuem9vbU91dEJ0bi50aXRsZSA9ICdab29tIG91dCdcclxuICAgICAgICB0aGlzLnpvb21PdXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnpvb21PdXQoZSlcclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuem9vbU91dEJ0bi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnpvb21PdXRCdG4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2xpZ2h0Z3JleSdcclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuem9vbU91dEJ0bi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuem9vbU91dEJ0bi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZmZmZidcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvL3NldCBzdHlsZXNcclxuICAgICAgICBsZXQgYnRucyA9IFt0aGlzLnpvb21JbkJ0biwgdGhpcy56b29tT3V0QnRuXVxyXG4gICAgICAgIGJ0bnMuZm9yRWFjaCgoYnRuLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGJ0bi5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcidcclxuICAgICAgICAgICAgYnRuLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2NlbnRlcidcclxuICAgICAgICAgICAgYnRuLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcclxuICAgICAgICAgICAgYnRuLnN0eWxlLmJvcmRlciA9ICdub25lJ1xyXG4gICAgICAgICAgICBidG4uc3R5bGUuY29sb3IgPSAnYmxhY2snXHJcbiAgICAgICAgICAgIGJ0bi5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJ1xyXG4gICAgICAgICAgICBidG4uc3R5bGUudGV4dERlY29yYXRpb24gPSAnbm9uZSdcclxuICAgICAgICAgICAgYnRuLnN0eWxlLnBhZGRpbmcgPSAnNHB4J1xyXG4gICAgICAgICAgICBidG4uc3R5bGUuZm9udFNpemUgPSAnMjBweCdcclxuICAgICAgICAgICAgYnRuLnN0eWxlLmZvbnRXZWlnaHQgPSAnYm9sZCdcclxuICAgICAgICAgICAgYnRuLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSdcclxuICAgICAgICAgICAgaWYgKGkgPT0gMCkgYnRuLnN0eWxlLmJvcmRlckJvdHRvbSA9ICcxcHggc29saWQgZ3JleSdcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyB1bnNldCBwYXJlbnQgY2xhc3MgaGVpZ2h0IGFuZCBkaXNwbGF5IGZvciBkdWFsIGJ1dHRvbnNcclxuICAgICAgICB0aGlzLnN0eWxlKCdoZWlnaHQnLCAndW5zZXQnKVxyXG4gICAgICAgIHRoaXMuc3R5bGUoJ2Rpc3BsYXknLCAndW5zZXQnKVxyXG5cclxuICAgICAgICAvL3NldCBwb3NpdGlvblxyXG4gICAgICAgIGlmIChvcHRzLngpIHtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZSgnbGVmdCcsIG9wdHMueCArICdweCcpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZSgncmlnaHQnLCAnMTBweCcpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRzLnkpIHtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZSgndG9wJywgb3B0cy55ICsgJ3B4JylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlKCd0b3AnLCAnMTBweCcpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhcHBlbmQgdG8gYnV0dG9uIGNvbnRhaW5lclxyXG4gICAgICAgIHRoaXMuZGl2Lm5vZGUoKS5hcHBlbmRDaGlsZCh0aGlzLnpvb21JbkJ0bilcclxuICAgICAgICB0aGlzLmRpdi5ub2RlKCkuYXBwZW5kQ2hpbGQodGhpcy56b29tT3V0QnRuKVxyXG4gICAgfVxyXG5cclxuICAgIC8qIFpvb20gaW4gKi9cclxuICAgIHpvb21JbihlKSB7XHJcbiAgICAgICAgdGhpcy5hcHAuc2V0Wm9vbUZhY3Rvcih0aGlzLmFwcC5nZXRab29tRmFjdG9yKCkgKiAoMSAtIHRoaXMuZGVsdGEpKS5yZWRyYXcoKVxyXG4gICAgICAgIGlmICh0aGlzLm9uWm9vbSkgdGhpcy5vblpvb20oZSlcclxuICAgIH1cclxuXHJcbiAgICAvKiBab29tIG91dCAqL1xyXG4gICAgem9vbU91dChlKSB7XHJcbiAgICAgICAgdGhpcy5hcHAuc2V0Wm9vbUZhY3Rvcih0aGlzLmFwcC5nZXRab29tRmFjdG9yKCkgKiAoMSArIHRoaXMuZGVsdGEpKS5yZWRyYXcoKVxyXG4gICAgICAgIGlmICh0aGlzLm9uWm9vbSkgdGhpcy5vblpvb20oZSlcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbi8qKiBAdHlwZWRlZiB7eyBkaW1zOiBvYmplY3QsIGNyczogc3RyaW5nLCB0aWxlU2l6ZUNlbGw6IG51bWJlciwgb3JpZ2luUG9pbnQ6IHt4Om51bWJlcix5Om51bWJlcn0sIHJlc29sdXRpb25HZW86IG51bWJlciwgdGlsaW5nQm91bmRzOmltcG9ydChcIi4uL0RhdGFzZXRcIikuRW52ZWxvcGUgfX0gR3JpZEluZm8gKi9cclxuXHJcbmltcG9ydCB7IGNzdiB9IGZyb20gJ2QzLWZldGNoJ1xyXG5pbXBvcnQgeyBEYXRhc2V0Q29tcG9uZW50IH0gZnJvbSAnLi4vRGF0YXNldENvbXBvbmVudC5qcydcclxuXHJcbi8qKlxyXG4gKiBBIGRhdGFzZXQgY29tcG9zZWQgb2YgYSBzaW5nbGUgQ1NWIGZpbGUgKG5vdCB0aWxlZCkuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDU1ZHcmlkIGV4dGVuZHMgRGF0YXNldENvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgZGF0YXNldC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSBkYXRhc2V0IHJlc29sdXRpb24gaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXHJcbiAgICAgKiBAcGFyYW0ge3twcmVwcm9jZXNzPzooZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsKTpib29sZWFuKX19IG9wdHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodXJsLCByZXNvbHV0aW9uLCBvcHRzID0ge30pIHtcclxuICAgICAgICBzdXBlcih1cmwsIHJlc29sdXRpb24sIG9wdHMpXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSAqL1xyXG4gICAgICAgIHRoaXMuY2VsbHMgPSBbXVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBwcml2YXRlICAqL1xyXG4gICAgICAgIHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPSAnbm90TG9hZGVkJ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdCBkYXRhIHdpdGhpbiBhIGdlb2dyYXBoaWMgZW52ZWxvcGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkVudmVsb3BlfHVuZGVmaW5lZH0gZVxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IHJlZHJhd1xyXG4gICAgICovXHJcbiAgICBnZXREYXRhKGUsIHJlZHJhdykge1xyXG4gICAgICAgIC8vY2hlY2sgaWYgZGF0YSBhbHJlYWR5IGxvYWRlZFxyXG4gICAgICAgIGlmICh0aGlzLmluZm9Mb2FkaW5nU3RhdHVzICE9ICdub3RMb2FkZWQnKSByZXR1cm4gdGhpc1xyXG5cclxuICAgICAgICAvL2xvYWQgZGF0YVxyXG4gICAgICAgIHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPSAnbG9hZGluZydcclxuICAgICAgICA7KGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjc3YodGhpcy51cmwpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IGNvb3JkaW5hdGVzIGluIG51bWJlcnNcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy54ID0gK2MueFxyXG4gICAgICAgICAgICAgICAgICAgIGMueSA9ICtjLnlcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL3ByZXByb2Nlc3MvZmlsdGVyXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmVwcm9jZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxscyA9IFtdXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IHRoaXMucHJlcHJvY2VzcyhjKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYiA9PSBmYWxzZSkgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxscy5wdXNoKGMpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxzID0gZGF0YVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBjaGVjayBpZiByZWRyYXcgaXMgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgICAgICAvL3RoYXQgaXMgaWYgdGhlIGRhdGFzZXQgYmVsb25ncyB0byBhIGxheWVyIHdoaWNoIGlzIHZpc2libGUgYXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxyXG5cclxuICAgICAgICAgICAgICAgIC8vZXhlY3V0ZSB0aGUgY2FsbGJhY2ssIHVzdWFsbHkgYSBkcmF3IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAocmVkcmF3KSByZWRyYXcoKVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPSAnbG9hZGVkJ1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy9tYXJrIGFzIGZhaWxlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9ICdmYWlsZWQnXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzID0gW11cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKClcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGwgdGhlIHZpZXcgY2FjaGUgd2l0aCBhbGwgY2VsbHMgd2hpY2ggYXJlIHdpdGhpbiBhIGdlb2dyYXBoaWNhbCBlbnZlbG9wZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0RhdGFzZXRcIikuRW52ZWxvcGV9IGV4dEdlb1xyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVZpZXdDYWNoZShleHRHZW8pIHtcclxuICAgICAgICAvL2RhdGEgbm90IGxvYWRlZCB5ZXRcclxuICAgICAgICBpZiAoIXRoaXMuY2VsbHMpIHJldHVyblxyXG5cclxuICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlID0gW11cclxuICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGhpcy5jZWxscykge1xyXG4gICAgICAgICAgICBpZiAoK2NlbGwueCArIHRoaXMucmVzb2x1dGlvbiA8IGV4dEdlby54TWluKSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoK2NlbGwueCAtIHRoaXMucmVzb2x1dGlvbiA+IGV4dEdlby54TWF4KSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoK2NlbGwueSArIHRoaXMucmVzb2x1dGlvbiA8IGV4dEdlby55TWluKSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoK2NlbGwueSAtIHRoaXMucmVzb2x1dGlvbiA+IGV4dEdlby55TWF4KSBjb250aW51ZVxyXG4gICAgICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlLnB1c2goY2VsbClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG4vKipcclxuICogQSBncmlkIHRpbGUuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHcmlkVGlsZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzIFRoZSB0aWxlIGNlbGxzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhUIFRoZSBYIHBvc2l0aW9uIG9mIHRoZSB0aWxlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlUIFRoZSBZIHBvc2l0aW9uIG9mIHRoZSB0aWxlLlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NTVkdyaWRcIikuR3JpZEluZm99IGdyaWRJbmZvIFRoZSBncmlkIGluZm8gb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjZWxscywgeFQsIHlULCBncmlkSW5mbykge1xyXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPGltcG9ydChcIi4uL0RhdGFzZXRcIikuQ2VsbD59ICovXHJcbiAgICAgICAgdGhpcy5jZWxscyA9IGNlbGxzXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy54ID0geFRcclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnkgPSB5VFxyXG5cclxuICAgICAgICBjb25zdCByID0gZ3JpZEluZm8ucmVzb2x1dGlvbkdlb1xyXG4gICAgICAgIGNvbnN0IHMgPSBncmlkSW5mby50aWxlU2l6ZUNlbGxcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkVudmVsb3BlfSAqL1xyXG4gICAgICAgIHRoaXMuZXh0R2VvID0ge1xyXG4gICAgICAgICAgICB4TWluOiBncmlkSW5mby5vcmlnaW5Qb2ludC54ICsgciAqIHMgKiB0aGlzLngsXHJcbiAgICAgICAgICAgIHhNYXg6IGdyaWRJbmZvLm9yaWdpblBvaW50LnggKyByICogcyAqICh0aGlzLnggKyAxKSxcclxuICAgICAgICAgICAgeU1pbjogZ3JpZEluZm8ub3JpZ2luUG9pbnQueSArIHIgKiBzICogdGhpcy55LFxyXG4gICAgICAgICAgICB5TWF4OiBncmlkSW5mby5vcmlnaW5Qb2ludC55ICsgciAqIHMgKiAodGhpcy55ICsgMSksXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbnZlcnQgY2VsbCBjb29yZGluYXRlcyBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlc1xyXG4gICAgICAgIGZvciAobGV0IGNlbGwgb2YgdGhpcy5jZWxscykge1xyXG4gICAgICAgICAgICBjZWxsLnggPSB0aGlzLmV4dEdlby54TWluICsgY2VsbC54ICogclxyXG4gICAgICAgICAgICBjZWxsLnkgPSB0aGlzLmV4dEdlby55TWluICsgY2VsbC55ICogclxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbi8qKiBAdHlwZWRlZiB7eyBkaW1zOiBvYmplY3QsIGNyczogc3RyaW5nLCB0aWxlU2l6ZUNlbGw6IG51bWJlciwgb3JpZ2luUG9pbnQ6IHt4Om51bWJlcix5Om51bWJlcn0sIHJlc29sdXRpb25HZW86IG51bWJlciwgdGlsaW5nQm91bmRzOmltcG9ydChcIi4uL0RhdGFzZXQuanNcIikuRW52ZWxvcGUgfX0gR3JpZEluZm8gKi9cclxuXHJcbmltcG9ydCB7IERhdGFzZXRDb21wb25lbnQgfSBmcm9tICcuLi9EYXRhc2V0Q29tcG9uZW50LmpzJ1xyXG5cclxuLyoqXHJcbiAqIEEgZGF0YXNldCBjb21wb3NlZCBvZiBhIHNpbmdsZSBDU1YgZmlsZSAobm90IHRpbGVkKS5cclxuICpcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExHcmlkIGV4dGVuZHMgRGF0YXNldENvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSBkYXRhc2V0IHJlc29sdXRpb24gaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjZWxscyBUaGUgY2VsbHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJlc29sdXRpb24sIGNlbGxzKSB7XHJcbiAgICAgICAgc3VwZXIoXCJcIiwgcmVzb2x1dGlvbilcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPGltcG9ydChcIi4uL0RhdGFzZXQuanNcIikuQ2VsbD59ICovXHJcbiAgICAgICAgdGhpcy5jZWxscyA9IGNlbGxzIHx8IFtdXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0IGRhdGEgd2l0aGluIGEgZ2VvZ3JhcGhpYyBlbnZlbG9wZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0RhdGFzZXQuanNcIikuRW52ZWxvcGV8dW5kZWZpbmVkfSBlXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gcmVkcmF3XHJcbiAgICAgKi9cclxuICAgIGdldERhdGEoZSwgcmVkcmF3KSB7IHJldHVybiB0aGlzIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGwgdGhlIHZpZXcgY2FjaGUgd2l0aCBhbGwgY2VsbHMgd2hpY2ggYXJlIHdpdGhpbiBhIGdlb2dyYXBoaWNhbCBlbnZlbG9wZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0RhdGFzZXQuanNcIikuRW52ZWxvcGV9IGV4dEdlb1xyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVZpZXdDYWNoZShleHRHZW8pIHtcclxuICAgICAgICAvL2RhdGEgbm90IGxvYWRlZCB5ZXRcclxuICAgICAgICBpZiAoIXRoaXMuY2VsbHMpIHJldHVyblxyXG5cclxuICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlID0gW11cclxuICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGhpcy5jZWxscykge1xyXG4gICAgICAgICAgICBpZiAoK2NlbGwueCArIHRoaXMucmVzb2x1dGlvbiA8IGV4dEdlby54TWluKSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoK2NlbGwueCAtIHRoaXMucmVzb2x1dGlvbiA+IGV4dEdlby54TWF4KSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoK2NlbGwueSArIHRoaXMucmVzb2x1dGlvbiA8IGV4dEdlby55TWluKSBjb250aW51ZVxyXG4gICAgICAgICAgICBpZiAoK2NlbGwueSAtIHRoaXMucmVzb2x1dGlvbiA+IGV4dEdlby55TWF4KSBjb250aW51ZVxyXG4gICAgICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlLnB1c2goY2VsbClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG4vKiogQHR5cGVkZWYge3sgZGltczogb2JqZWN0LCBjcnM6IHN0cmluZywgdGlsZVNpemVDZWxsOiBudW1iZXIsIG9yaWdpblBvaW50OiB7eDpudW1iZXIseTpudW1iZXJ9LCByZXNvbHV0aW9uR2VvOiBudW1iZXIsIHRpbGluZ0JvdW5kczppbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkVudmVsb3BlLCBmb3JtYXQ6aW1wb3J0KFwiLi4vRGF0YXNldENvbXBvbmVudFwiKS5Gb3JtYXQgfX0gR3JpZEluZm8gKi9cclxuXHJcbi8vIGludGVybmFsXHJcbmltcG9ydCB7IEdyaWRUaWxlIH0gZnJvbSAnLi9HcmlkVGlsZS5qcydcclxuaW1wb3J0IHsgQXBwIH0gZnJvbSAnLi4vQXBwLmpzJ1xyXG5pbXBvcnQgeyBEYXRhc2V0Q29tcG9uZW50IH0gZnJvbSAnLi4vRGF0YXNldENvbXBvbmVudC5qcydcclxuaW1wb3J0IHsgbW9uaXRvciwgbW9uaXRvckR1cmF0aW9uIH0gZnJvbSAnLi4vdXRpbHMvVXRpbHMuanMnXHJcblxyXG4vLyBleHRlcm5hbFxyXG5pbXBvcnQgeyBqc29uLCBjc3YgfSBmcm9tICdkMy1mZXRjaCdcclxuXHJcbi8qKlxyXG4gKiBBIHRpbGVkIGRhdGFzZXQsIGNvbXBvc2VkIG9mIENTViB0aWxlcy5cclxuICpcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRpbGVkR3JpZCBleHRlbmRzIERhdGFzZXRDb21wb25lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgb2YgdGhlIGRhdGFzZXQuXHJcbiAgICAgKiBAcGFyYW0ge0FwcH0gYXBwIFRoZSBhcHBsaWNhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7e3ByZXByb2Nlc3M/OihmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGwpOmJvb2xlYW4pIH19IG9wdHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodXJsLCBhcHAsIG9wdHMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHVybCwgMCwgb3B0cylcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFwcCBiZWluZyB1c2VkLlxyXG4gICAgICAgICAqIEB0eXBlIHtBcHB9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHBcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGdyaWQgaW5mbyBvYmplY3QsIGZyb20gdGhlIGluZm8uanNvbiBmaWxlLlxyXG4gICAgICAgICAqICBAdHlwZSB7R3JpZEluZm8gfCB1bmRlZmluZWR9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiAgKi9cclxuICAgICAgICB0aGlzLmluZm8gPSB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKiBAcHJpdmF0ZSAgKi9cclxuICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ25vdExvYWRlZCdcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNhY2hlIG9mIHRoZSBsb2FkZWQgdGlsZXMuIEl0IGlzIGRvdWJsZSBpbmRleGVkOiBieSB4VCBhbmQgdGhlbiB5VC5cclxuICAgICAgICAgKiBFeGFtcGxlOiB0aGlzLmNhY2hlW3hUXVt5VF0gcmV0dXJucyB0aGUgdGlsZSBhdCBbeFRdW3lUXSBsb2NhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAgICAgICogKi9cclxuICAgICAgICB0aGlzLmNhY2hlID0ge31cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIHRoZSBpbmZvLmpzb24gZnJvbSB0aGUgdXJsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTp2b2lkfSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybnMgdGhpc1xyXG4gICAgICovXHJcbiAgICBsb2FkSW5mbyhjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghdGhpcy5pbmZvICYmIHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPT09ICdub3RMb2FkZWQnKSB7XHJcbiAgICAgICAgICAgIDsgKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGpzb24odGhpcy51cmwgKyAnaW5mby5qc29uJylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm8gPSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gZGF0YS5yZXNvbHV0aW9uR2VvXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmZvTG9hZGluZ1N0YXR1cyA9ICdsb2FkZWQnXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpXHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbWFyayBhcyBmYWlsZWRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm9Mb2FkaW5nU3RhdHVzID0gJ2ZhaWxlZCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkoKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2sgJiYgKHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPT09ICdsb2FkZWQnIHx8IHRoaXMuaW5mb0xvYWRpbmdTdGF0dXMgPT09ICdmYWlsZWQnKSlcclxuICAgICAgICAgICAgY2FsbGJhY2soKVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIGEgdGlsaW5nIGVudmVsb3BlIGZyb20gYSBnZW9ncmFwaGljYWwgZW52ZWxvcGUuXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0byB1c2UgdG8ga25vdyB3aGljaCB0aWxlcyB0byBkb3dubG9hZCBmb3IgYSBnZW9ncmFwaGljYWwgdmlldy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0RhdGFzZXRcIikuRW52ZWxvcGV9IGVcclxuICAgICAqIEByZXR1cm5zIHtpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkVudmVsb3BlfHVuZGVmaW5lZH1cclxuICAgICAqL1xyXG4gICAgZ2V0VGlsaW5nRW52ZWxvcGUoZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbmZvKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZEluZm8oKCkgPT4geyB9KVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHBvID0gdGhpcy5pbmZvLm9yaWdpblBvaW50LFxyXG4gICAgICAgICAgICByID0gdGhpcy5pbmZvLnJlc29sdXRpb25HZW8sXHJcbiAgICAgICAgICAgIHMgPSB0aGlzLmluZm8udGlsZVNpemVDZWxsXHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHhNaW46IE1hdGguZmxvb3IoKGUueE1pbiAtIHBvLngpIC8gKHIgKiBzKSksXHJcbiAgICAgICAgICAgIHhNYXg6IE1hdGguZmxvb3IoKGUueE1heCAtIHBvLngpIC8gKHIgKiBzKSksXHJcbiAgICAgICAgICAgIHlNaW46IE1hdGguZmxvb3IoKGUueU1pbiAtIHBvLnkpIC8gKHIgKiBzKSksXHJcbiAgICAgICAgICAgIHlNYXg6IE1hdGguZmxvb3IoKGUueU1heCAtIHBvLnkpIC8gKHIgKiBzKSksXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdCBkYXRhIHdpdGhpbiBhIGdlb2dyYXBoaWMgZW52ZWxvcGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkVudmVsb3BlfSBleHRHZW9cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTp2b2lkfSByZWRyYXdGdW5cclxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxyXG4gICAgICovXHJcbiAgICBnZXREYXRhKGV4dEdlbywgcmVkcmF3RnVuKSB7XHJcbiAgICAgICAgLy9UT0RPIGVtcHR5IGNhY2hlIHdoZW4gaXQgZ2V0cyB0b28gYmlnID9cclxuXHJcbiAgICAgICAgLy9jaGVjayBpZiBpbmZvIGhhcyBiZWVuIGxvYWRlZFxyXG4gICAgICAgIGlmICghdGhpcy5pbmZvKSByZXR1cm4gdGhpc1xyXG5cclxuICAgICAgICAvL3RpbGVzIHdpdGhpbiB0aGUgc2NvcGVcclxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL0RhdGFzZXRcIikuRW52ZWxvcGV8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgIGNvbnN0IHRiID0gdGhpcy5nZXRUaWxpbmdFbnZlbG9wZShleHRHZW8pXHJcbiAgICAgICAgaWYgKCF0YikgcmV0dXJuIHRoaXNcclxuXHJcbiAgICAgICAgLy9ncmlkIGJvdW5kc1xyXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5FbnZlbG9wZX0gKi9cclxuICAgICAgICBjb25zdCBnYiA9IHRoaXMuaW5mby50aWxpbmdCb3VuZHNcclxuXHJcbiAgICAgICAgZm9yIChsZXQgeFQgPSBNYXRoLm1heCh0Yi54TWluLCBnYi54TWluKTsgeFQgPD0gTWF0aC5taW4odGIueE1heCwgZ2IueE1heCk7IHhUKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeVQgPSBNYXRoLm1heCh0Yi55TWluLCBnYi55TWluKTsgeVQgPD0gTWF0aC5taW4odGIueU1heCwgZ2IueU1heCk7IHlUKyspIHtcclxuICAgICAgICAgICAgICAgIC8vcHJlcGFyZSBjYWNoZVxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlW3hUXSkgdGhpcy5jYWNoZVt4VF0gPSB7fVxyXG5cclxuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgdGlsZSBleGlzdHMgaW4gdGhlIGNhY2hlXHJcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge0dyaWRUaWxlfSAqL1xyXG4gICAgICAgICAgICAgICAgbGV0IHRpbGUgPSB0aGlzLmNhY2hlW3hUXVt5VF1cclxuICAgICAgICAgICAgICAgIGlmICh0aWxlKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vbWFyayB0aWxlIGFzIGxvYWRpbmdcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVbeFRdW3lUXSA9IFwibG9hZGluZ1wiO1xyXG4gICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JlcXVlc3QgdGlsZVxyXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPGltcG9ydChcIi4uL0RhdGFzZXRcIikuQ2VsbD59ICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjZWxsc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY3N2KHRoaXMudXJsICsgeFQgKyAnLycgKyB5VCArICcuY3N2JylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignKioqIFRpbGVkR3JpZCBwYXJzZSBzdGFydCcpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ByZXByb2Nlc3MvZmlsdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXByb2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzID0gW11cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IHRoaXMucHJlcHJvY2VzcyhjKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiID09IGZhbHNlKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goYylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzID0gZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJ3ByZXByb2Nlc3MgLyBmaWx0ZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFyayBhcyBmYWlsZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZVt4VF1beVRdID0gJ2ZhaWxlZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3N0b3JlIHRpbGUgaW4gY2FjaGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaWxlIGluZm8gaW5rbm93bicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWxlXyA9IG5ldyBHcmlkVGlsZShjZWxscywgeFQsIHlULCB0aGlzLmluZm8pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZVt4VF1beVRdID0gdGlsZV9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCdzdG9yYWdlJylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBubyByZWRyYXcgaXMgc3BlY2lmaWVkLCB0aGVuIGxlYXZlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWRyYXdGdW4pIHJldHVyblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHJlZHJhdyBpcyByZWFsbHkgbmVlZGVkLCB0aGF0IGlzIGlmOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAxLiB0aGUgZGF0YXNldCBiZWxvbmdzIHRvIGEgbGF5ZXIgd2hpY2ggaXMgdmlzaWJsZSBhdCB0aGUgY3VycmVudCB6b29tIGxldmVsXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlZHJhdyA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy9nbyB0aHJvdWdoIHRoZSBsYXllcnNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB6ZiA9IHRoaXMuYXBwLmdldFpvb21GYWN0b3IoKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGF5IG9mIHRoaXMuYXBwLmxheWVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxheS52aXNpYmxlKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF5LmdldERhdGFzZXRDb21wb25lbnQoemYpICE9IHRoaXMpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZm91bmQgb25lIGxheWVyLiBObyBuZWVkIHRvIHNlZWsgbW9yZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVkcmF3ID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJ2NoZWNrIHJlZHJhdyAxJylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWRyYXcpIHJldHVyblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAyLiB0aGUgdGlsZSBpcyB3aXRoaW4gdGhlIHZpZXcsIHRoYXQgaXMgaXRzIGdlbyBlbnZlbG9wZSBpbnRlcnNlY3RzIHRoZSB2aWV3ZXIgZ2VvIGVudmVsb3BlLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudiA9IHRoaXMuYXBwLnVwZGF0ZUV4dGVudEdlbygpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW52VCA9IHRpbGVfLmV4dEdlb1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnYueE1heCA8PSBlbnZULnhNaW4pIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnYueE1pbiA+PSBlbnZULnhNYXgpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnYueU1heCA8PSBlbnZULnlNaW4pIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnYueU1pbiA+PSBlbnZULnlNYXgpIHJldHVyblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJ2NoZWNrIHJlZHJhdyAyJylcclxuICAgICAgICAgICAgICAgICAgICAvL2lmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyoqKiBUaWxlZEdyaWQgcGFyc2UgZW5kJylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZWRyYXdcclxuICAgICAgICAgICAgICAgICAgICByZWRyYXdGdW4oKVxyXG4gICAgICAgICAgICAgICAgfSkoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxsIHRoZSB2aWV3IGNhY2hlIHdpdGggYWxsIGNlbGxzIHdoaWNoIGFyZSB3aXRoaW4gYSBnZW9ncmFwaGljYWwgZW52ZWxvcGUuXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5FbnZlbG9wZX0gZXh0R2VvXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgdXBkYXRlVmlld0NhY2hlKGV4dEdlbykge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgdGhpcy5jZWxsc1ZpZXdDYWNoZSA9IFtdXHJcblxyXG4gICAgICAgIC8vY2hlY2sgaWYgaW5mbyBoYXMgYmVlbiBsb2FkZWRcclxuICAgICAgICBpZiAoIXRoaXMuaW5mbykgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vdGlsZXMgd2l0aGluIHRoZSBzY29wZVxyXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5FbnZlbG9wZXx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgY29uc3QgdGIgPSB0aGlzLmdldFRpbGluZ0VudmVsb3BlKGV4dEdlbylcclxuICAgICAgICBpZiAoIXRiKSByZXR1cm5cclxuXHJcbiAgICAgICAgLy9ncmlkIGJvdW5kc1xyXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5FbnZlbG9wZX0gKi9cclxuICAgICAgICBjb25zdCBnYiA9IHRoaXMuaW5mby50aWxpbmdCb3VuZHNcclxuXHJcbiAgICAgICAgZm9yIChsZXQgeFQgPSBNYXRoLm1heCh0Yi54TWluLCBnYi54TWluKTsgeFQgPD0gTWF0aC5taW4odGIueE1heCwgZ2IueE1heCk7IHhUKyspIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlW3hUXSkgY29udGludWVcclxuICAgICAgICAgICAgZm9yIChsZXQgeVQgPSBNYXRoLm1heCh0Yi55TWluLCBnYi55TWluKTsgeVQgPD0gTWF0aC5taW4odGIueU1heCwgZ2IueU1heCk7IHlUKyspIHtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IHRpbGVcclxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7R3JpZFRpbGV9ICovXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aWxlID0gdGhpcy5jYWNoZVt4VF1beVRdXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRpbGUgfHwgdHlwZW9mIHRpbGUgPT09ICdzdHJpbmcnKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZ2V0IGNlbGxzXHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuY2VsbHNWaWV3Q2FjaGUgPSB0aGlzLmNlbGxzVmlld0NhY2hlLmNvbmNhdCh0aWxlLmNlbGxzKVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiB0aWxlLmNlbGxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCtjZWxsLnggKyB0aGlzLnJlc29sdXRpb24gPCBleHRHZW8ueE1pbikgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoK2NlbGwueCAtIHRoaXMucmVzb2x1dGlvbiA+IGV4dEdlby54TWF4KSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgrY2VsbC55ICsgdGhpcy5yZXNvbHV0aW9uIDwgZXh0R2VvLnlNaW4pIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCtjZWxsLnkgLSB0aGlzLnJlc29sdXRpb24gPiBleHRHZW8ueU1heCkgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxzVmlld0NhY2hlLnB1c2goY2VsbClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IExlZ2VuZCB9IGZyb20gJy4uL0xlZ2VuZC5qcydcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBlbGVtZW50IGZvciBjb2xvciBjYXRlZ3Jvcmllcy5cclxuICpcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbG9yQ2F0ZWdvcnlMZWdlbmQgZXh0ZW5kcyBMZWdlbmQge1xyXG4gICAgLyoqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvL2NvbC9jYXRlZ29yaWVzIGFycmF5LCBpbiBkaXNwbGF5IG9yZGVyXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPEFycmF5LjxzdHJpbmc+Pn0gKi9cclxuICAgICAgICB0aGlzLmNvbENhdCA9IG9wdHMuY29sQ2F0IHx8IFtbJ2dyYXknLCAnLSddXVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9TdHlsZVwiKS5TaGFwZX0gKi9cclxuICAgICAgICB0aGlzLnNoYXBlID0gb3B0cy5zaGFwZSB8fCAnY2lyY2xlJ1xyXG4gICAgICAgIHRoaXMuZGltZW5zaW9uID0gb3B0cy5kaW1lbnNpb24gfHwgeyByOiA4IH1cclxuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gb3B0cy5zdHJva2VDb2xvciB8fCAnZ3JheSdcclxuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aCB8fCAxXHJcblxyXG4gICAgICAgIHRoaXMudGl0bGUgPSBvcHRzLnRpdGxlXHJcbiAgICAgICAgdGhpcy50aXRsZUZvbnRTaXplID0gb3B0cy50aXRsZUZvbnRTaXplIHx8ICcwLjhlbSdcclxuICAgICAgICB0aGlzLnRpdGxlRm9udFdlaWdodCA9IG9wdHMudGl0bGVGb250V2VpZ2h0IHx8ICdib2xkJ1xyXG5cclxuICAgICAgICAvL2xhYmVsXHJcbiAgICAgICAgdGhpcy5sYWJlbEZvbnRTaXplID0gb3B0cy5sYWJlbEZvbnRTaXplIHx8ICcwLjhlbSdcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7eyBzdHlsZTogaW1wb3J0KFwiLi4vU3R5bGVcIikuU3R5bGUsIHI6IG51bWJlciwgemY6IG51bWJlciwgc1NpemU6IGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXQsIHNDb2xvcjogaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdCB9fSBvcHRzXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShvcHRzKSB7XHJcbiAgICAgICAgLy9jbGVhclxyXG4gICAgICAgIHRoaXMuZGl2LnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIC8vYnVpbGRcclxuXHJcbiAgICAgICAgLy90aXRsZVxyXG4gICAgICAgIGlmICh0aGlzLnRpdGxlKVxyXG4gICAgICAgICAgICB0aGlzLmRpdlxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZGl2JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgdGhpcy50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsIHRoaXMudGl0bGVGb250V2VpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4tYm90dG9tJywgJzdweCcpXHJcbiAgICAgICAgICAgICAgICAudGV4dCh0aGlzLnRpdGxlKVxyXG5cclxuICAgICAgICAvL2NhdGVnb3JpZXNcclxuICAgICAgICBjb25zdCBuYiA9IHRoaXMuY29sQ2F0Lmxlbmd0aFxyXG4gICAgICAgIGlmIChuYiA9PSAwKSByZXR1cm5cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHRoaXMuY29sQ2F0W2ldXHJcblxyXG4gICAgICAgICAgICAvL21ha2UgZGl2IGZvciBjYXRlZ29yeVxyXG4gICAgICAgICAgICBjb25zdCBkID0gdGhpcy5kaXYuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAvL3RvIGVuYWJsZSB2ZXJ0aWNhbCBjZW50ZXJpbmdcclxuICAgICAgICAgICAgLy8uc3R5bGUoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpXHJcblxyXG4gICAgICAgICAgICBjb25zdCBzdyA9IHRoaXMuc3Ryb2tlV2lkdGhcclxuXHJcbiAgICAgICAgICAgIC8vZHJhdyBncmFwaGljIGVsZW1lbnQ6IGJveCAvIGNpcmNsZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zaGFwZSA9PT0gJ3NxdWFyZScpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGggPSB0aGlzLmRpbWVuc2lvbi5oIHx8IDE1XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gdGhpcy5kaW1lbnNpb24udyB8fCAyMFxyXG4gICAgICAgICAgICAgICAgZC5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgJ2lubGluZScpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3N2ZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdyArIDIgKiBzdylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaCArIDIgKiBzdylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBzdylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHN3KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgY2F0WzBdKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgdGhpcy5zdHJva2VDb2xvcilcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHRoaXMuc3Ryb2tlV2lkdGgpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaGFwZSA9PT0gJ2NpcmNsZScpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmRpbWVuc2lvbi5yIHx8IDhcclxuICAgICAgICAgICAgICAgIGNvbnN0IGggPSAyICogciArIDIgKiBzd1xyXG4gICAgICAgICAgICAgICAgZC5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgJ2lubGluZScpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3N2ZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgaClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY3gnLCByICsgc3cpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgciArIHN3KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgcilcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBjYXRbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCB0aGlzLnN0cm9rZUNvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5zdHJva2VXaWR0aClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzaGFwZTonICsgdGhpcy5zaGFwZSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy93cml0ZSBsYWJlbCB0ZXh0XHJcbiAgICAgICAgICAgIGQuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAgICAgLy9zaG93IG9uIHJpZ2h0IG9mIGdyYXBoaWNcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsICdpbmxpbmUnKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vY2VudGVyIHZlcnRpY2FsbHlcclxuICAgICAgICAgICAgICAgIC8vLnN0eWxlKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKS5zdHlsZShcInRvcFwiLCBcIjBcIikuc3R5bGUoXCJib3R0b21cIiwgXCIwXCIpXHJcblxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdwYWRkaW5nLWxlZnQnLCAnNXB4JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgdGhpcy5sYWJlbEZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoY2F0WzFdKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IExlZ2VuZCB9IGZyb20gJy4uL0xlZ2VuZC5qcydcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBlbGVtZW50IGZvciBkaXNjcmV0ZSBjb2xvciBzdHlsZS5cclxuICogSW5zcGlyYXRpb246IGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AZDMvY29sb3ItbGVnZW5kXHJcbiAqXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb2xvckRpc2NyZXRlTGVnZW5kIGV4dGVuZHMgTGVnZW5kIHtcclxuICAgIC8qKiBAcGFyYW0ge09iamVjdH0gb3B0cyAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqIEBwcml2YXRlIEB0eXBlIHtBcnJheS48QXJyYXkuPHN0cmluZz4+fSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3JzID0gb3B0cy5jb2xvcnNcclxuICAgICAgICAvKiogQHByaXZhdGUgQHR5cGUge0FycmF5LjxBcnJheS48c3RyaW5nPj59ICovXHJcbiAgICAgICAgdGhpcy5icmVha3NUZXh0ID0gb3B0cy5icmVha3NUZXh0XHJcblxyXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8IDMwMFxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0cy5oZWlnaHQgfHwgMTVcclxuXHJcbiAgICAgICAgdGhpcy50aXRsZSA9IG9wdHMudGl0bGVcclxuICAgICAgICB0aGlzLnRpdGxlRm9udFNpemUgPSBvcHRzLnRpdGxlRm9udFNpemUgfHwgJzAuOGVtJ1xyXG4gICAgICAgIHRoaXMudGl0bGVGb250V2VpZ2h0ID0gb3B0cy50aXRsZUZvbnRXZWlnaHQgfHwgJ2JvbGQnXHJcblxyXG4gICAgICAgIHRoaXMudGlja1NpemUgPSBvcHRzLnRpY2tTaXplIHx8IDNcclxuXHJcbiAgICAgICAgLy9sYWJlbFxyXG4gICAgICAgIHRoaXMubGFiZWxGb250U2l6ZSA9IG9wdHMubGFiZWxGb250U2l6ZSB8fCAnMC44ZW0nXHJcbiAgICAgICAgdGhpcy5pbnZlcnQgPSBvcHRzLmludmVydFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHt7IHN0eWxlOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdHlsZSwgcjogbnVtYmVyLCB6ZjogbnVtYmVyLCBzU2l6ZTogaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdCwgc0NvbG9yOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0IH19IG9wdHNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKG9wdHMpIHtcclxuICAgICAgICAvL2NsZWFyXHJcbiAgICAgICAgdGhpcy5kaXYuc2VsZWN0QWxsKCcqJykucmVtb3ZlKClcclxuXHJcbiAgICAgICAgLy9idWlsZFxyXG5cclxuICAgICAgICAvL3RpdGxlXHJcbiAgICAgICAgaWYgKHRoaXMudGl0bGUpXHJcbiAgICAgICAgICAgIHRoaXMuZGl2XHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLnRpdGxlRm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtd2VpZ2h0JywgdGhpcy50aXRsZUZvbnRXZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ21hcmdpbi1ib3R0b20nLCAnN3B4JylcclxuICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMudGl0bGUpXHJcblxyXG4gICAgICAgIC8vY2xhc3Nlc1xyXG4gICAgICAgIGNvbnN0IG5iID0gdGhpcy5jb2xvcnMubGVuZ3RoXHJcbiAgICAgICAgaWYgKG5iID09IDApIHJldHVyblxyXG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoIC8gbmJcclxuXHJcbiAgICAgICAgLy9tYWtlIHN2ZyBlbGVtZW50XHJcbiAgICAgICAgY29uc3Qgc3ZnID0gdGhpcy5kaXZcclxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy53aWR0aClcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0ICsgdGhpcy50aWNrU2l6ZSArIDIgKyAxMClcclxuXHJcbiAgICAgICAgLy9kcmF3IGdyYXBoaWMgZWxlbWVudHNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspIHtcclxuICAgICAgICAgICAgc3ZnLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGkgKiB3KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmhlaWdodClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIHRoaXMuY29sb3JzW2ldKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy90aWNrIGxpbmVcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5iOyBpKyspIHtcclxuICAgICAgICAgICAgc3ZnLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB3ICogaSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3ICogaSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHRoaXMuaGVpZ2h0ICsgdGhpcy50aWNrU2l6ZSlcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbGFiZWxzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuYjsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vcHJlcGFyZSBsYWJlbFxyXG4gICAgICAgICAgICBzdmcuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICd0aWNrbGFiZWxfJyArIGkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHcgKiBpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB0aGlzLmhlaWdodCArIHRoaXMudGlja1NpemUgKyAyKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLmxhYmVsRm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICAvLy5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxyXG4gICAgICAgICAgICAgICAgLy8uc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIkFyaWFsXCIpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgaSA9PSAwID8gJ3N0YXJ0JyA6IGkgPT0gdGhpcy50aWNrcyAtIDEgPyAnZW5kJyA6ICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAndG9wJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZG9taW5hbnQtYmFzZWxpbmUnLCAnaGFuZ2luZycpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgLnRleHQodGhpcy5icmVha3NUZXh0W2kgLSAxXSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9MZWdlbmQuanMnXHJcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ2QzLWZvcm1hdCdcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBlbGVtZW50IGZvciBjb250aW51b3VzIGNvbG9yIHN0eWxlLlxyXG4gKiBJbnNwaXJhdGlvbjogaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BkMy9jb2xvci1sZWdlbmRcclxuICpcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbG9yTGVnZW5kIGV4dGVuZHMgTGVnZW5kIHtcclxuICAgIC8qKiBAcGFyYW0ge09iamVjdH0gb3B0cyAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgdGhpcy5jb2xvclJhbXAgPSBvcHRzLmNvbG9yUmFtcFxyXG5cclxuICAgICAgICAvL2Z1bmN0aW9uICh0WzAsMV0sIHIsIHMpIC0+IHYgKGZvciBsYWJlbCB0ZXh0KVxyXG4gICAgICAgIHRoaXMuZnVuID0gb3B0cy5mdW5cclxuXHJcbiAgICAgICAgdGhpcy50aXRsZSA9IG9wdHMudGl0bGVcclxuICAgICAgICB0aGlzLnRpY2tTaXplID0gb3B0cy50aWNrU2l6ZSB8fCA2XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdHMud2lkdGggfHwgMzAwXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRzLmhlaWdodCB8fCAxNVxyXG4gICAgICAgIHRoaXMubWFyZ2luID0gb3B0cy5tYXJnaW4gfHwgNVxyXG4gICAgICAgIHRoaXMudGlja3MgPSBvcHRzLnRpY2tzIHx8IE1hdGguZmxvb3IodGhpcy53aWR0aCAvIDUwKVxyXG4gICAgICAgIHRoaXMudGlja0Zvcm1hdCA9IG9wdHMudGlja0Zvcm1hdCB8fCAnLC4wZidcclxuICAgICAgICB0aGlzLnRpY2tVbml0ID0gb3B0cy50aWNrVW5pdFxyXG5cclxuICAgICAgICB0aGlzLmZvbnRTaXplID0gb3B0cy5mb250U2l6ZSB8fCAnMC44ZW0nXHJcbiAgICAgICAgdGhpcy5pbnZlcnQgPSBvcHRzLmludmVydFxyXG5cclxuICAgICAgICAvL3RvIGJlIHVzZWQgYXMgb3B0cyA9PiBvcHRzLnNBbHBoYSB0byBzaG93IGxlZ2VuZCBvbiBhbHBoYSBjaGFubmVsXHJcbiAgICAgICAgdGhpcy5nZXRTdGF0cyA9IG9wdHMuZ2V0U3RhdHMgfHwgKG9wdHMgPT4gb3B0cy5zQ29sb3IpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3sgc3R5bGU6IGltcG9ydChcIi4uL1N0eWxlXCIpLlN0eWxlLCByOiBudW1iZXIsIHpmOiBudW1iZXIsIHNTaXplOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0LCBzQ29sb3I6IGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXQsIHNBbHBoYTogaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdCB9fSBvcHRzXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShvcHRzKSB7XHJcbiAgICAgICAgLy9jb3VsZCBoYXBwZW4gd2hlbiBkYXRhIGlzIHN0aWxsIGxvYWRpbmdcclxuICAgICAgICBpZiAoIW9wdHMuc0NvbG9yKSByZXR1cm5cclxuXHJcbiAgICAgICAgLy9jbGVhclxyXG4gICAgICAgIHRoaXMuZGl2LnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gMTJcclxuXHJcbiAgICAgICAgY29uc3Qgc3ZnVyA9IHRoaXMud2lkdGggKyAyICogdGhpcy5tYXJnaW5cclxuICAgICAgICBjb25zdCBzdmdIID0gdGhpcy5oZWlnaHQgKyAzICogdGhpcy5tYXJnaW4gKyB0aXRsZUhlaWdodCArIHRoaXMudGlja1NpemUgKyAxMFxyXG4gICAgICAgIGNvbnN0IHN2ZyA9IHRoaXMuZGl2LmFwcGVuZCgnc3ZnJykuYXR0cignd2lkdGgnLCBzdmdXKS5hdHRyKCdoZWlnaHQnLCBzdmdIKVxyXG4gICAgICAgIC8vICA8cmVjdCB3aWR0aD1cIjMwMFwiIGhlaWdodD1cIjEwMFwiIHN0eWxlPVwiZmlsbDpyZ2IoMCwwLDI1NSk7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlOnJnYigwLDAsMClcIiAvPlxyXG5cclxuICAgICAgICAvL3RpdGxlXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgdGhpcy5tYXJnaW4pXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgdGhpcy5tYXJnaW4pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzAuOGVtJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsICdib2xkJylcclxuICAgICAgICAgICAgLnN0eWxlKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAndG9wJylcclxuICAgICAgICAgICAgLnN0eWxlKCdkb21pbmFudC1iYXNlbGluZScsICdoYW5naW5nJylcclxuICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdub25lJylcclxuICAgICAgICAgICAgLnRleHQodGhpcy50aXRsZSlcclxuXHJcbiAgICAgICAgY29uc3QgZyA9IHN2Z1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHRoaXMubWFyZ2luICsgJyAnICsgKDIgKiB0aGlzLm1hcmdpbiArIHRpdGxlSGVpZ2h0KSArICcpJylcclxuXHJcbiAgICAgICAgLy9kcmF3IGNvbG9yIGJhclxyXG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoID0gdGhpcy5oZWlnaHRcclxuICAgICAgICBjb25zdCBzdGVwID0gNVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSArPSBzdGVwKSB7XHJcbiAgICAgICAgICAgIGxldCB0ID0gaSAvICh3IC0gMSlcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW52ZXJ0KSB0ID0gMSAtIHRcclxuICAgICAgICAgICAgZy5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgc3RlcClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgdGhpcy5jb2xvclJhbXAodCkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGlja3M7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdCA9IGkgLyAodGhpcy50aWNrcyAtIDEpXHJcblxyXG4gICAgICAgICAgICAvL3RpY2sgbGluZVxyXG4gICAgICAgICAgICBnLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB3ICogdClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3ICogdClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGggKyB0aGlzLnRpY2tTaXplKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnYmxhY2snKVxyXG5cclxuICAgICAgICAgICAgLy9wcmVwYXJlIHRpY2sgbGFiZWxcclxuICAgICAgICAgICAgZy5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3RpY2tsYWJlbF8nICsgaSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgdyAqIHQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGggKyB0aGlzLnRpY2tTaXplICsgMilcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgdGhpcy5mb250U2l6ZSlcclxuICAgICAgICAgICAgICAgIC8vLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgXCJib2xkXCIpXHJcbiAgICAgICAgICAgICAgICAvLy5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiQXJpYWxcIilcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCBpID09IDAgPyAnc3RhcnQnIDogaSA9PSB0aGlzLnRpY2tzIC0gMSA/ICdlbmQnIDogJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2FsaWdubWVudC1iYXNlbGluZScsICd0b3AnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdkb21pbmFudC1iYXNlbGluZScsICdoYW5naW5nJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXHJcbiAgICAgICAgICAgIC8vLnRleHQoXCItXCIpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSB0aWNrIGxhYmVsc1xyXG5cclxuICAgICAgICAvL2xhYmVsIHRleHQgZm9ybWF0XHJcbiAgICAgICAgY29uc3QgZiA9IHRoaXMudGlja0Zvcm1hdCAmJiB0aGlzLnRpY2tGb3JtYXQgIT0gJ3RleHQnID8gZm9ybWF0KHRoaXMudGlja0Zvcm1hdCkgOiAodikgPT4gdlxyXG4gICAgICAgIGNvbnN0IHN0YXQgPSB0aGlzLmdldFN0YXRzKG9wdHMpXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRpY2tzOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHQgPSBpIC8gKHRoaXMudGlja3MgLSAxKVxyXG5cclxuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuZnVuKHQsIG9wdHMuciwgc3RhdClcclxuICAgICAgICAgICAgY29uc3QgdGV4dCA9ICh2ID8gZih2KSA6ICcwJykgKyAodGhpcy50aWNrVW5pdCA/IHRoaXMudGlja1VuaXQgOiAnJylcclxuXHJcbiAgICAgICAgICAgIC8vdGljayBsYWJlbFxyXG4gICAgICAgICAgICB0aGlzLmRpdi5zZWxlY3QoJyMnICsgJ3RpY2tsYWJlbF8nICsgaSkudGV4dCh0ZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IExlZ2VuZCB9IGZyb20gJy4uL0xlZ2VuZC5qcydcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBlbGVtZW50IGZvciBzZWdtZW50IG9yaWVudGF0aW9uLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2VnbWVudE9yaWVudGF0aW9uTGVnZW5kIGV4dGVuZHMgTGVnZW5kIHtcclxuICAgIC8qKiBAcGFyYW0ge09iamVjdH0gb3B0cyAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLy90aXRsZVxyXG4gICAgICAgIHRoaXMudGl0bGUgPSBvcHRzLnRpdGxlXHJcbiAgICAgICAgdGhpcy50aXRsZUZvbnRTaXplID0gb3B0cy50aXRsZUZvbnRTaXplIHx8ICcwLjhlbSdcclxuICAgICAgICB0aGlzLnRpdGxlRm9udFdlaWdodCA9IG9wdHMudGl0bGVGb250V2VpZ2h0IHx8ICdib2xkJ1xyXG5cclxuICAgICAgICAvL2V4YWdlcmF0aW9uXHJcbiAgICAgICAgdGhpcy5leGFnZ2VyYXRpb25GYWN0b3IgPSBvcHRzLmV4YWdnZXJhdGlvbkZhY3RvciB8fCAwLjVcclxuXHJcbiAgICAgICAgLy9jb2xvclxyXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICdncmF5J1xyXG4gICAgICAgIC8vb3JpZW50YXRpb25cclxuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gb3B0cy5vcmllbnRhdGlvbiB8fCAwXHJcbiAgICAgICAgLy93aWR0aFxyXG4gICAgICAgIHRoaXMud2lkdGhQaXggPSBvcHRzLndpZHRoUGl4IHx8IDNcclxuXHJcbiAgICAgICAgLy9sYWJlbFxyXG4gICAgICAgIHRoaXMubGFiZWxGb250U2l6ZSA9IG9wdHMubGFiZWxGb250U2l6ZSB8fCAnMC44ZW0nXHJcbiAgICAgICAgdGhpcy5sYWJlbFVuaXRUZXh0ID0gb3B0cy5sYWJlbFVuaXRUZXh0IHx8ICcnXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3sgc3R5bGU6IGltcG9ydChcIi4uL3N0eWxlL1NlZ21lbnRTdHlsZVwiKS5TZWdtZW50U3R5bGUsIHI6IG51bWJlciwgemY6IG51bWJlciwgc0NvbG9yOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0LCBzTGVuZ3RoOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0LCBzV2lkdGg6IGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXQgfX0gb3B0c1xyXG4gICAgICovXHJcbiAgICB1cGRhdGUob3B0cykge1xyXG4gICAgICAgIC8vY291bGQgaGFwcGVuIHdoZW4gZGF0YSBpcyBzdGlsbCBsb2FkaW5nXHJcbiAgICAgICAgaWYgKCFvcHRzLnNXaWR0aCkgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vY2xlYXJcclxuICAgICAgICB0aGlzLmRpdi5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICBjb25zdCBkID0gdGhpcy5kaXYuYXBwZW5kKCdkaXYnKVxyXG5cclxuICAgICAgICAvL3RpdGxlXHJcbiAgICAgICAgaWYgKHRoaXMudGl0bGUpIHtcclxuICAgICAgICAgICAgZC5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAndGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLnRpdGxlRm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtd2VpZ2h0JywgdGhpcy50aXRsZUZvbnRXZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAudGV4dCh0aGlzLnRpdGxlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb21wdXRlIHNlZ21lbnQgd2lkdGggYW5kIGxlbmd0aCwgaW4gcGl4XHJcbiAgICAgICAgY29uc3Qgc1dpZHRoID0gdGhpcy53aWR0aFBpeFxyXG4gICAgICAgIGNvbnN0IHNMZW5ndGggPSAoMSAqIG9wdHMucikgLyBvcHRzLnpmXHJcblxyXG4gICAgICAgIC8vZHJhdyBTVkcgc2VnbWVudFxyXG4gICAgICAgIGNvbnN0IHN2Z1MgPSBNYXRoLm1heChzTGVuZ3RoLCBzV2lkdGgpXHJcbiAgICAgICAgY29uc3Qgc3ZnID0gZC5hcHBlbmQoJ3N2ZycpLmF0dHIoJ3dpZHRoJywgc3ZnUykuYXR0cignaGVpZ2h0Jywgc3ZnUykuc3R5bGUoJycsICdpbmxpbmUtYmxvY2snKVxyXG5cclxuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcygoLXRoaXMub3JpZW50YXRpb24gKiBNYXRoLlBJKSAvIDE4MClcclxuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbigoLXRoaXMub3JpZW50YXRpb24gKiBNYXRoLlBJKSAvIDE4MClcclxuICAgICAgICBjb25zdCBkYyA9IHN2Z1MgKiAwLjUsXHJcbiAgICAgICAgICAgIGwyID0gc0xlbmd0aCAqIDAuNVxyXG4gICAgICAgIHN2Zy5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAuYXR0cigneDEnLCBkYyAtIGNvcyAqIGwyKVxyXG4gICAgICAgICAgICAuYXR0cigneTEnLCBkYyAtIHNpbiAqIGwyKVxyXG4gICAgICAgICAgICAuYXR0cigneDInLCBkYyArIGNvcyAqIGwyKVxyXG4gICAgICAgICAgICAuYXR0cigneTInLCBkYyArIHNpbiAqIGwyKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRoaXMuY29sb3IpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgc1dpZHRoKVxyXG5cclxuICAgICAgICAvL3RleHQgbGFiZWxcclxuICAgICAgICBkLmFwcGVuZCgnZGl2JylcclxuICAgICAgICAgICAgLy9zaG93IG9uIHJpZ2h0IG9mIHN2Z1xyXG4gICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnaW5saW5lJylcclxuICAgICAgICAgICAgLnN0eWxlKCdwYWRkaW5nLWxlZnQnLCAnNXB4JylcclxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLmxhYmVsRm9udFNpemUpXHJcbiAgICAgICAgICAgIC8vLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgXCJib2xkXCIpXHJcbiAgICAgICAgICAgIC50ZXh0KHRoaXMubGFiZWxVbml0VGV4dClcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IExlZ2VuZCB9IGZyb20gJy4uL0xlZ2VuZC5qcydcclxuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5cclxuLyoqXHJcbiAqIEEgbGVnZW5kIGVsZW1lbnQgZm9yIHNlZ21lbnQgd2lkdGguXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9zZXBoIERhdmllcywgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTZWdtZW50V2lkdGhMZWdlbmQgZXh0ZW5kcyBMZWdlbmQge1xyXG4gICAgLyoqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvL3RpdGxlXHJcbiAgICAgICAgdGhpcy50aXRsZSA9IG9wdHMudGl0bGVcclxuICAgICAgICB0aGlzLnRpdGxlRm9udFNpemUgPSBvcHRzLnRpdGxlRm9udFNpemUgfHwgJzAuOGVtJ1xyXG4gICAgICAgIHRoaXMudGl0bGVGb250V2VpZ2h0ID0gb3B0cy50aXRsZUZvbnRXZWlnaHQgfHwgJ2JvbGQnXHJcblxyXG4gICAgICAgIC8vZXhhZ2VyYXRpb25cclxuICAgICAgICAvL2lmIHNldCB0byAxLCB0aGUgc2VnbWVudCB3aWR0aCBpbiB0aGUgbGVnZW5kIHdpbGwgYmUgdGhlIG9uZSBvZiB0aGUgbWF4aW11bSB3aWR0aCBvbiB0aGUgbWFwXHJcbiAgICAgICAgdGhpcy5leGFnZ2VyYXRpb25GYWN0b3IgPSBvcHRzLmV4YWdnZXJhdGlvbkZhY3RvciB8fCAwLjVcclxuXHJcbiAgICAgICAgLy9jb2xvciBvZiB0aGUgc2VnbWVudCBpbiB0aGUgbGVnZW5kXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgJ2dyYXknXHJcbiAgICAgICAgLy9vcmllbnRhdGlvbiBvZiB0aGUgc2VnbWVudCBpbiB0aGUgbGVnZW5kXHJcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IG9wdHMub3JpZW50YXRpb24gfHwgMFxyXG5cclxuICAgICAgICAvL2xhYmVsXHJcbiAgICAgICAgdGhpcy5sYWJlbEZvbnRTaXplID0gb3B0cy5sYWJlbEZvbnRTaXplIHx8ICcwLjhlbSdcclxuICAgICAgICB0aGlzLmxhYmVsVW5pdFRleHQgPSBvcHRzLmxhYmVsVW5pdFRleHQgfHwgJydcclxuXHJcbiAgICAgICAgLy9zZWdtZW50IGxlbmd0aCBpbiBnZW8gdW5pdCAtIGEgZnVuY3Rpb24gb2YgdGhlIHJlc29sdXRpb24gciBhbmQgem9vbSBsZXZlbCB6ZlxyXG4gICAgICAgIHRoaXMubGVuZ3RoRnVuID0gb3B0cy5sZW5ndGhFeGFnZ2VyYXRpb25GYWN0b3IgfHwgKChyLCB6ZikgPT4gcilcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7eyBzdHlsZTogaW1wb3J0KFwiLi4vc3R5bGUvU2VnbWVudFN0eWxlXCIpLlNlZ21lbnRTdHlsZSwgcjogbnVtYmVyLCB6ZjogbnVtYmVyLCBzQ29sb3I6IGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXQsIHNMZW5ndGg6IGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXQsIHNXaWR0aDogaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdCB9fSBvcHRzXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShvcHRzKSB7XHJcbiAgICAgICAgLy9jb3VsZCBoYXBwZW4gd2hlbiBkYXRhIGlzIHN0aWxsIGxvYWRpbmdcclxuICAgICAgICBpZiAoIW9wdHMuc1dpZHRoKSByZXR1cm5cclxuXHJcbiAgICAgICAgLy9jbGVhclxyXG4gICAgICAgIHRoaXMuZGl2LnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmRpdi5hcHBlbmQoJ2RpdicpXHJcblxyXG4gICAgICAgIC8vdGl0bGVcclxuICAgICAgICBpZiAodGhpcy50aXRsZSkge1xyXG4gICAgICAgICAgICBkLmFwcGVuZCgnZGl2JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd0aXRsZScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIHRoaXMudGl0bGVGb250U2l6ZSlcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC13ZWlnaHQnLCB0aGlzLnRpdGxlRm9udFdlaWdodClcclxuICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMudGl0bGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2dldCBzZWdtZW50IG1heCB2YWx1ZVxyXG4gICAgICAgIGNvbnN0IHZhbHVlXyA9IG9wdHMuc1dpZHRoLm1heCAqIHRoaXMuZXhhZ2dlcmF0aW9uRmFjdG9yXHJcbiAgICAgICAgLy9tYWtlICduaWNlJyB2YWx1ZSAocG93ZXIgb2YgdGVuLCBvciBtdWx0aXBsZSlcclxuICAgICAgICBsZXQgcG93MTAgPSBNYXRoLmxvZzEwKHZhbHVlXylcclxuICAgICAgICBwb3cxMCA9IE1hdGguZmxvb3IocG93MTApXHJcbiAgICAgICAgbGV0IHZhbHVlID0gTWF0aC5wb3coMTAsIHBvdzEwKVxyXG4gICAgICAgIGlmICh2YWx1ZSAqIDggPD0gdmFsdWVfKSB2YWx1ZSAqPSA4XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgKiA2IDw9IHZhbHVlXykgdmFsdWUgKj0gNlxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICogNSA8PSB2YWx1ZV8pIHZhbHVlICo9IDVcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAqIDQgPD0gdmFsdWVfKSB2YWx1ZSAqPSA0XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgKiAyLjUgPD0gdmFsdWVfKSB2YWx1ZSAqPSAyLjVcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAqIDIgPD0gdmFsdWVfKSB2YWx1ZSAqPSAyXHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgKiAxLjUgPD0gdmFsdWVfKSB2YWx1ZSAqPSAxLjVcclxuXHJcbiAgICAgICAgLy9jb21wdXRlIHNlZ21lbnQgd2lkdGggYW5kIGxlbmd0aCwgaW4gcGl4XHJcbiAgICAgICAgY29uc3Qgc1dpZHRoID0gb3B0cy53aWR0aEZ1bih2YWx1ZSwgb3B0cy5yLCBvcHRzLnNXaWR0aCwgb3B0cy56ZikgLyBvcHRzLnpmXHJcbiAgICAgICAgY29uc3Qgc0xlbmd0aCA9IHRoaXMubGVuZ3RoRnVuKG9wdHMuciwgb3B0cy56ZikgLyBvcHRzLnpmXHJcblxyXG4gICAgICAgIC8vVE9ETyB1c2Ugb3JpZW50YXRpb25cclxuXHJcbiAgICAgICAgY29uc3Qgc3ZnID0gZC5hcHBlbmQoJ3N2ZycpLmF0dHIoJ3dpZHRoJywgc0xlbmd0aCkuYXR0cignaGVpZ2h0Jywgc1dpZHRoKS5zdHlsZSgnJywgJ2lubGluZS1ibG9jaycpXHJcblxyXG4gICAgICAgIC8vPGxpbmUgeDE9XCIwXCIgeTE9XCIwXCIgeDI9XCIyMDBcIiB5Mj1cIjIwMFwiIHN0eWxlPVwic3Ryb2tlOnJnYigyNTUsMCwwKTtzdHJva2Utd2lkdGg6MlwiIC8+XHJcbiAgICAgICAgc3ZnLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIHNXaWR0aCAvIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIHNMZW5ndGgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIHNXaWR0aCAvIDIpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgdGhpcy5jb2xvcilcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBzV2lkdGgpXHJcblxyXG4gICAgICAgIGNvbnN0IHZhbHVlVCA9IGZvcm1hdCgnLC4ycicpKHZhbHVlKVxyXG4gICAgICAgIGQuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAvL3Nob3cgb24gcmlnaHQgb2YgZ3JhcGhpY1xyXG4gICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnaW5saW5lJylcclxuICAgICAgICAgICAgLnN0eWxlKCdwYWRkaW5nLWxlZnQnLCAnNXB4JylcclxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLmxhYmVsRm9udFNpemUpXHJcbiAgICAgICAgICAgIC8vLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgXCJib2xkXCIpXHJcbiAgICAgICAgICAgIC50ZXh0KHZhbHVlVCArICh0aGlzLmxhYmVsVW5pdFRleHQgPyAnICcgOiAnJykgKyB0aGlzLmxhYmVsVW5pdFRleHQpXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9MZWdlbmQuanMnXHJcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ2QzLWZvcm1hdCdcclxuXHJcbi8qKlxyXG4gKiBBIGxlZ2VuZCBlbGVtZW50IGZvciBwcm9wb3J0aW9uYWwgc3ltYm9scy5cclxuICpcclxuICogQGF1dGhvciBKb3NlcGggRGF2aWVzLCBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNpemVMZWdlbmQgZXh0ZW5kcyBMZWdlbmQge1xyXG4gICAgLyoqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvL2V4YWdlcmF0aW9uXHJcbiAgICAgICAgdGhpcy5leGFnZ2VyYXRpb25GYWN0b3IgPSBvcHRzLmV4YWdnZXJhdGlvbkZhY3RvciB8fCAwLjhcclxuXHJcbiAgICAgICAgLy9pZiB2YWx1ZSBpcyB0byBiZSBmb3JjZWRcclxuICAgICAgICB0aGlzLnZhbHVlID0gb3B0cy52YWx1ZSB8fCB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgLy90aXRsZVxyXG4gICAgICAgIHRoaXMudGl0bGUgPSBvcHRzLnRpdGxlXHJcbiAgICAgICAgdGhpcy50aXRsZUZvbnRTaXplID0gb3B0cy50aXRsZUZvbnRTaXplIHx8ICcwLjhlbSdcclxuICAgICAgICB0aGlzLnRpdGxlRm9udFdlaWdodCA9IG9wdHMudGl0bGVGb250V2VpZ2h0IHx8ICdib2xkJ1xyXG5cclxuICAgICAgICAvL3N5bWJvbFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge2ltcG9ydChcIi4uL1N0eWxlXCIpLlNoYXBlfSAqL1xyXG4gICAgICAgIHRoaXMuc2hhcGUgPSBvcHRzLnNoYXBlIHx8ICdjaXJjbGUnXHJcbiAgICAgICAgdGhpcy5maWxsQ29sb3IgPSBvcHRzLmZpbGxDb2xvciB8fCAnbm9uZSdcclxuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gb3B0cy5zdHJva2VDb2xvciB8fCAnZ3JheSdcclxuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aCB8fCAxXHJcblxyXG4gICAgICAgIC8vbGFiZWxcclxuICAgICAgICB0aGlzLmxhYmVsRm9udFNpemUgPSBvcHRzLmxhYmVsRm9udFNpemUgfHwgJzAuOGVtJ1xyXG4gICAgICAgIHRoaXMubGFiZWxVbml0VGV4dCA9IG9wdHMubGFiZWxVbml0VGV4dCB8fCAnJ1xyXG4gICAgICAgIHRoaXMubGFiZWxGb3JtYXQgPSBvcHRzLmxhYmVsRm9ybWF0IHx8ICcsLjJyJ1xyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vdGhpcy5kaXYuc3R5bGUoXCJ0ZXh0LWFsaWduXCIsIFwiY2VudGVyXCIpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3sgc3R5bGU6IGltcG9ydChcIi4uL3N0eWxlL1NoYXBlQ29sb3JTaXplU3R5bGVcIikuU2hhcGVDb2xvclNpemVTdHlsZSwgcjogbnVtYmVyLCB6ZjogbnVtYmVyLCBzU2l6ZTogaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdCwgc0NvbG9yOiBpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0IH19IG9wdHNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKG9wdHMpIHtcclxuICAgICAgICAvL2NvdWxkIGhhcHBlbiB3aGVuIGRhdGEgaXMgc3RpbGwgbG9hZGluZ1xyXG4gICAgICAgIGlmICghb3B0cy5zU2l6ZSkgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vY2xlYXJcclxuICAgICAgICB0aGlzLmRpdi5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKVxyXG5cclxuICAgICAgICAvL2dldCB2YWx1ZVxyXG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWVcclxuICAgICAgICBpZiAodmFsdWUgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSAnbmljZSB2YWx1ZVxyXG5cclxuICAgICAgICAgICAgLy9nZXQgbWF4IHZhbHVlXHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlXyA9IG9wdHMuc1NpemUubWF4ICogdGhpcy5leGFnZ2VyYXRpb25GYWN0b3JcclxuXHJcbiAgICAgICAgICAgIC8vdGFrZSAnbmljZScgdmFsdWUgKHBvd2VyIG9mIHRlbiwgb3IgbXVsdGlwbGUpXHJcbiAgICAgICAgICAgIGxldCBwb3cxMCA9IE1hdGgubG9nMTAodmFsdWVfKVxyXG4gICAgICAgICAgICBwb3cxMCA9IE1hdGguZmxvb3IocG93MTApXHJcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5wb3coMTAsIHBvdzEwKVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgKiA4IDw9IHZhbHVlXykgdmFsdWUgKj0gOFxyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAqIDYgPD0gdmFsdWVfKSB2YWx1ZSAqPSA2XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICogNSA8PSB2YWx1ZV8pIHZhbHVlICo9IDVcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgKiA0IDw9IHZhbHVlXykgdmFsdWUgKj0gNFxyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAqIDIuNSA8PSB2YWx1ZV8pIHZhbHVlICo9IDIuNVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAqIDIgPD0gdmFsdWVfKSB2YWx1ZSAqPSAyXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm5cclxuXHJcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZGl2LmFwcGVuZCgnZGl2JylcclxuICAgICAgICAvL3RvIGVuYWJsZSB2ZXJ0aWNhbCBjZW50ZXJpbmdcclxuICAgICAgICAvLy5zdHlsZShcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIilcclxuXHJcbiAgICAgICAgLy90aXRsZVxyXG4gICAgICAgIGlmICh0aGlzLnRpdGxlKSB7XHJcbiAgICAgICAgICAgIGQuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3RpdGxlJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgdGhpcy50aXRsZUZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsIHRoaXMudGl0bGVGb250V2VpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLnRleHQodGhpcy50aXRsZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY29tcHV0ZSBzaXplIG9mIHN5bWJvbCwgaW4gcGl4XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IG9wdHMuc3R5bGUuc2l6ZSh2YWx1ZSwgb3B0cy5yLCBvcHRzLnNTaXplLCBvcHRzLnpmKSAvIG9wdHMuemZcclxuXHJcbiAgICAgICAgY29uc3Qgc3ZnID0gZFxyXG4gICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBzaXplICsgdGhpcy5zdHJva2VXaWR0aCArIDIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBzaXplICsgdGhpcy5zdHJva2VXaWR0aCArIDIpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnJywgJ2lubGluZS1ibG9jaycpXHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNoYXBlID09PSAnc3F1YXJlJykge1xyXG4gICAgICAgICAgICBzdmcuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHNpemUpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgc2l6ZSlcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIHRoaXMuZmlsbENvbG9yKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCB0aGlzLnN0cm9rZUNvbG9yKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB0aGlzLnN0cm9rZVdpZHRoKVxyXG4gICAgICAgICAgICAvL1RPRE8gdGVzdFxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaGFwZSA9PT0gJ2NpcmNsZScpIHtcclxuICAgICAgICAgICAgLy8gPGNpcmNsZSBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCI0MFwiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlLXdpZHRoPVwiM1wiIGZpbGw9XCJyZWRcIiAvPlxyXG4gICAgICAgICAgICBjb25zdCByID0gKHNpemUgKyB0aGlzLnN0cm9rZVdpZHRoKSAqIDAuNVxyXG4gICAgICAgICAgICBzdmcuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgciArIDEpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCByICsgMSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgcilcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIHRoaXMuZmlsbENvbG9yKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCB0aGlzLnN0cm9rZUNvbG9yKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB0aGlzLnN0cm9rZVdpZHRoKVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaGFwZSA9PT0gJ2RvbnV0Jykge1xyXG4gICAgICAgICAgICAvL1RPRE9cclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2hhcGUgPT09ICdkaWFtb25kJykge1xyXG4gICAgICAgICAgICAvL1RPRE9cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2hhcGU6JyArIHRoaXMuc2hhcGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB2YWx1ZVQgPSBmb3JtYXQodGhpcy5sYWJlbEZvcm1hdCkodmFsdWUpXHJcbiAgICAgICAgZC5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAgIC8vc2hvdyBvbiByaWdodCBvZiBncmFwaGljXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsICdpbmxpbmUnKVxyXG5cclxuICAgICAgICAgICAgLy9jZW50ZXIgdmVydGljYWxseVxyXG4gICAgICAgICAgICAvLy5zdHlsZShcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIikuc3R5bGUoXCJ0b3BcIiwgXCIwXCIpLnN0eWxlKFwiYm90dG9tXCIsIFwiMFwiKVxyXG5cclxuICAgICAgICAgICAgLnN0eWxlKCdwYWRkaW5nLWxlZnQnLCAnNXB4JylcclxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLmxhYmVsRm9udFNpemUpXHJcbiAgICAgICAgICAgIC50ZXh0KHZhbHVlVCArICh0aGlzLmxhYmVsVW5pdFRleHQgPyAnICcgOiAnJykgKyB0aGlzLmxhYmVsVW5pdFRleHQpXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL1N0eWxlLmpzJ1xyXG5cclxuLyoqIEB0eXBlZGVmIHtcImZsYWdcInxcInBpZWNoYXJ0XCJ8XCJyaW5nXCJ8XCJzZWdtZW50XCJ8XCJyYWRhclwifFwiYWdlcHlyYW1pZFwifFwiaGFsZnRvbmVcIn0gQ29tcG9zaXRpb25UeXBlICovXHJcblxyXG4vKipcclxuICogQSBzdHlsZSBzaG93aW5nIHRoZSBjb21wb3NpdGlvbiBvZiBhIHRvdGFsIGluIGRpZmZlcmVudCBjYXRlZ29yaWVzLCB3aXRoIGRpZmZlcmVudCBjb2xvciBodWVzLlxyXG4gKiBJdCBjb25zaXN0cyBvZiBhIHN5bWJvbCB3aXRoIGRpZmZlcmVudCBwYXJ0cywgd2hvc2Ugc2l6ZSByZWZsZWN0IHRoZSBwcm9wb3J0aW9uIG9mIHRoZSBjb3JyZXNwb25kaW5nIGNhdGVnb3J5LlxyXG4gKiBGb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCBzeW1ib2xzLCBAc2VlIENvbXBvc2l0aW9uVHlwZVxyXG4gKiBUaGUgc3ltYm9sIGNhbiBiZSBzY2FsZWQgZGVwZW5kaW5nIG9uIHRoZSBjZWxsIGltcG9ydGFuY2UuXHJcbiAqXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb21wb3NpdGlvblN0eWxlIGV4dGVuZHMgU3R5bGUge1xyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGljdGlvbmFyeSAoc3RyaW5nIC0+IGNvbG9yKSB3aGljaCBnaXZlIHRoZSBjb2xvciBvZiBlYWNoIGNhdGVnb3J5LlxyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9ICovXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3JcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHR5cGUgb2YgZGVjb21wb3NpdGlvbiBzeW1ib2wgb2YgYSBjZWxsLCBAc2VlIENvbXBvc2l0aW9uVHlwZVxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGwpOkNvbXBvc2l0aW9uVHlwZX0gKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBvcHRzLnR5cGVcclxuXHJcbiAgICAgICAgLyoqIFRoZSBjb2x1bW4gd2hlcmUgdG8gZ2V0IHRoZSBzaXplIHZhbHVlcy5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuc2l6ZUNvbCA9IG9wdHMuc2l6ZUNvbFxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpemUgb2YgYSBjZWxsLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZSB8fCAoKHYsIHIsIHMsIHpmKSA9PiByKVxyXG5cclxuICAgICAgICAvKiogRm9yIHN0eWxlIHR5cGVzIHdpdGggc3RyaXBlcyAoZmxhZywgc2VnbWVudCksIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgc3RyaXBlcyAoMCBmb3IgaG9yaXpvbnRhbCwgb3RoZXIgZm9yIHZlcnRpY2FsKS5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsLG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnN0cmlwZXNPcmllbnRhdGlvbiA9IG9wdHMuc3RyaXBlc09yaWVudGF0aW9uIHx8ICgoKSA9PiAwKSAvLyhjLHIsemYpID0+IC4uLlxyXG5cclxuICAgICAgICAvKiogVGhlIGZ1bmN0aW9uIHNwZWNpZnlpbmcgYW4gb2Zmc2V0IGFuZ2xlIGZvciBhIHJhZGFyLCBoYWxmdG9uZSBvciBwaWUgY2hhcnQgc3R5bGUuXHJcbiAgICAgICAgICogVGhlIGFuZ2xlIGlzIHNwZWNpZmllZCBpbiBkZWdyZWUuIFRoZSByb3RhdGlvbiBpcyBhbnRpLWNsb2Nrd2lzZS5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsLG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLm9mZnNldEFuZ2xlID0gb3B0cy5vZmZzZXRBbmdsZSB8fCAoKCkgPT4gMCkgLy8oY2VsbCxyLHpmKSA9PiAuLi5cclxuXHJcbiAgICAgICAgLyoqIFRoZSBmdW5jdGlvbiBzcGVjaWZ5aW5nIHRoZSBoZWlnaHQgb2YgdGhlIGFnZSBweXJhbWlkLCBpbiBnZW8gdW5pdC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsLG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLmFnZVB5cmFtaWRIZWlnaHQgPSBvcHRzLmFnZVB5cmFtaWRIZWlnaHQgfHwgKChjLCByLCB6ZikgPT4gcikgLy8oY2VsbCxyLHpmKSA9PiAuLi5cclxuXHJcbiAgICAgICAgLyoqIEZvciBwaWUgY2hhcnQsIHRoaXMgaXMgcGFyYW1ldGVyIGZvciBpbnRlcm5hbCByYWRpdXMsIHNvIHRoYXQgdGhlIHBpZSBjaGFydCBsb29rcyBsaWtlIGEgZG9udXQuXHJcbiAgICAgICAgICogMCBmb3Igbm9ybWFsIHBpZSBjaGFydHMsIDAuNSB0byBlbXB0eSBoYWxmIG9mIHRoZSByYWRpdXMuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnBpZUNoYXJ0SW50ZXJuYWxSYWRpdXNGYWN0b3IgPSBvcHRzLnBpZUNoYXJ0SW50ZXJuYWxSYWRpdXNGYWN0b3IgfHwgMFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBjZWxscyBhcyBzcXVhcmVzIGRlcGVuZGluZyBvbiB0aGVpciB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcclxuICAgICAqL1xyXG4gICAgZHJhdyhjZWxscywgciwgY2cpIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vem9vbSBmYWN0b3JcclxuICAgICAgICBjb25zdCB6ZiA9IGNnLmdldFpmKClcclxuXHJcbiAgICAgICAgbGV0IHN0YXRcclxuICAgICAgICBpZiAodGhpcy5zaXplQ29sKSB7XHJcbiAgICAgICAgICAgIC8vaWYgc2l6ZSBpcyB1c2VkLCBzb3J0IGNlbGxzIGJ5IHNpemUgc28gdGhhdCB0aGUgYmlnZ2VzdCBhcmUgZHJhd24gZmlyc3RcclxuICAgICAgICAgICAgY2VsbHMuc29ydCgoYzEsIGMyKSA9PiBjMlt0aGlzLnNpemVDb2xdIC0gYzFbdGhpcy5zaXplQ29sXSlcclxuICAgICAgICAgICAgLy9hbmQgY29tcHV0ZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgIHN0YXQgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLnNpemVDb2xdLCB0cnVlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9uYiBjYXRlZ29yaWVzIC0gdXNlZCBmb3IgcmFkYXIgYW5kIGFnZXB5cmFtaWRcclxuICAgICAgICBjb25zdCBuYkNhdCA9IE9iamVjdC5lbnRyaWVzKHRoaXMuY29sb3IpLmxlbmd0aFxyXG5cclxuICAgICAgICAvL2RyYXcgaW4gZ2VvIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgY2cuc2V0Q2FudmFzVHJhbnNmb3JtKClcclxuXHJcbiAgICAgICAgLy9kcmF3IGNhbGxzXHJcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICAvL3NpemVcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgICAgICBsZXQgc18gPSB0aGlzLnNpemUgfHwgKCgpID0+IHIpXHJcbiAgICAgICAgICAgIC8vc2l6ZSAtIGluIGdlb1xyXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICAgICAgY29uc3Qgc0cgPSBzXyhjZWxsW3RoaXMuc2l6ZUNvbF0sIHIsIHN0YXQsIHpmKVxyXG5cclxuICAgICAgICAgICAgLy9nZXQgb2Zmc2V0XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGNlbGwsIHIsIHpmKVxyXG5cclxuICAgICAgICAgICAgLy9nZXQgc3ltYm9sIHR5cGVcclxuICAgICAgICAgICAgY29uc3QgdHlwZV8gPSB0aGlzLnR5cGUgPyB0aGlzLnR5cGUoY2VsbCkgOiAnZmxhZydcclxuXHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSBjZW50ZXIgcG9zaXRpb25cclxuICAgICAgICAgICAgY29uc3QgeGMgPSBjZWxsLnggKyBvZmZzZXQuZHggKyAodHlwZV8gPT09ICdhZ2VweXJhbWlkJyA/IDAgOiByICogMC41KVxyXG4gICAgICAgICAgICBjb25zdCB5YyA9IGNlbGwueSArIG9mZnNldC5keSArICh0eXBlXyA9PT0gJ2FnZXB5cmFtaWQnID8gMCA6IHIgKiAwLjUpXHJcblxyXG4gICAgICAgICAgICAvL2NvbXB1dGUgb2Zmc2V0IGFuZ2xlLCB3aGVuIHJlbGV2YW50XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZkFuZyA9IHRoaXMub2Zmc2V0QW5nbGUgPyAodGhpcy5vZmZzZXRBbmdsZShjZWxsLCByLCB6ZikgKiBNYXRoLlBJKSAvIDE4MCA6IDBcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlXyA9PT0gJ2FnZXB5cmFtaWQnIHx8IHR5cGVfID09PSAncmFkYXInIHx8IHR5cGVfID09PSAnaGFsZnRvbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAvL2dldCBjZWxsIGNhdGVnb3J5IG1heCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgbGV0IG1heFZhbCA9IC1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuY29sb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9ICtjZWxsW2tleV1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodiA+IG1heFZhbCkgbWF4VmFsID0gdlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vY3VtdWxcclxuICAgICAgICAgICAgICAgIGxldCBjdW11bCA9IDBcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlXyA9PT0gJ2FnZXB5cmFtaWQnICYmIHRoaXMuYWdlUHlyYW1pZEhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICBjdW11bCA9IChyIC0gdGhpcy5hZ2VQeXJhbWlkSGVpZ2h0KGNlbGwsIHIsIHpmKSkgLyAyXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZV8gPT09ICdyYWRhcicgfHwgdHlwZV8gPT09ICdoYWxmdG9uZScpIGN1bXVsID0gTWF0aC5QSSAvIDIgKyBvZmZBbmdcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbXB1dGUgdGhlIGluY3JlbWVudCwgd2hpY2ggaXMgdGhlIHZhbHVlIHRvIGluY3JlbWVudCB0aGUgY3VtdWwgZm9yIGVhY2ggY2F0ZWdvcnlcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluY3IgPVxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVfID09PSAnYWdlcHlyYW1pZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAodGhpcy5hZ2VQeXJhbWlkSGVpZ2h0ID8gdGhpcy5hZ2VQeXJhbWlkSGVpZ2h0KGNlbGwsIHIsIHpmKSA6IHIpIC8gbmJDYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlXyA9PT0gJ3JhZGFyJyB8fCB0eXBlXyA9PT0gJ2hhbGZ0b25lJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICgyICogTWF0aC5QSSkgLyBuYkNhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgaWYgKGluY3IgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHN5bWJvbCB0eXBlOicgKyB0eXBlXylcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBbY29sdW1uLCBjb2xvcl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5jb2xvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZV8gPT09ICdhZ2VweXJhbWlkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NldCBjYXRlZ29yeSBjb2xvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sb3JcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IGNhdGVnb3J5IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNlbGxbY29sdW1uXVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21wdXRlIGNhdGVnb3J5IGxlbmd0aCAtIGluIGdlb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd0cgPSAoc0cgKiB2YWwpIC8gbWF4VmFsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RyYXcgYmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsUmVjdCh4YyArIChyIC0gd0cpIC8gMiwgeWMgKyBjdW11bCwgd0csIGluY3IpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25leHQgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1bXVsICs9IGluY3JcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVfID09PSAncmFkYXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IGNhdGVnb3J5IGNvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsU3R5bGUgPSBjb2xvclxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgY2F0ZWdyb3kgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gY2VsbFtjb2x1bW5dXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgY2F0ZWdvcnkgcmFkaXVzIC0gaW4gZ2VvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IHJHID0gdGhpcy5yYWRpdXModmFsLCByLCBzdGF0LCBjZWxsU3RhdCwgemYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJHID0gKHNHIC8gMikgKiBNYXRoLnNxcnQodmFsIC8gbWF4VmFsKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kcmF3IGFuZ3VsYXIgc2VjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKHhjLCB5YylcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmFyYyh4YywgeWMsIHJHLCBjdW11bCAtIGluY3IsIGN1bXVsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKHhjLCB5YylcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmZpbGwoKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9uZXh0IGFuZ3VsYXIgc2VjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1bXVsICs9IGluY3JcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVfID09PSAnaGFsZnRvbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IGNhdGVnb3J5IGNvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsU3R5bGUgPSBjb2xvclxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgY2F0ZWdyb3kgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gY2VsbFtjb2x1bW5dXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXB1dGUgY2F0ZWdvcnkgcmFkaXVzIC0gaW4gZ2VvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByRyA9IHNHICogMC4zMzMgKiBNYXRoLnNxcnQodmFsIC8gbWF4VmFsKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kcmF3IGNpcmNsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmFyYyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhjICsgciAqIDAuMjUgKiBNYXRoLmNvcyhjdW11bCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5YyArIHIgKiAwLjI1ICogTWF0aC5zaW4oY3VtdWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgckcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAqIE1hdGguUElcclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbCgpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25leHQgYW5ndWxhciBzZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VtdWwgKz0gaW5jclxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzeW1ib2wgdHlwZTonICsgdHlwZV8pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9jb21wdXRlIHRvdGFsXHJcbiAgICAgICAgICAgICAgICBsZXQgdG90YWwgPSAwXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gb2YgT2JqZWN0LmtleXModGhpcy5jb2xvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gK2NlbGxbY29sdW1uXVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdikgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSB2XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRvdGFsIHx8IGlzTmFOKHRvdGFsKSkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgZGVjb21wb3NpdGlvbiBzeW1ib2xcclxuICAgICAgICAgICAgICAgIGxldCBjdW11bCA9IDBcclxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSByICogKDEgLSBzRyAvIHIpICogMC41XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmkgPSB0aGlzLnN0cmlwZXNPcmllbnRhdGlvbihjZWxsLCByLCB6ZilcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBbY29sdW1uLCBjb2xvcl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5jb2xvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2dldCBzaGFyZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJlID0gY2VsbFtjb2x1bW5dIC8gdG90YWxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNoYXJlIHx8IGlzTmFOKHNoYXJlKSkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZXQgY29sb3JcclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sb3JcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kcmF3IHN5bWJvbCBwYXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVfID09PSAnZmxhZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kcmF3IGZsYWcgc3RyaXBlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC54ICsgZCArIG9mZnNldC5keCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnkgKyBkICsgY3VtdWwgKiBzRyArIG9mZnNldC5keSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzRyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZSAqIHNHXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC54ICsgZCArIGN1bXVsICogc0cgKyBvZmZzZXQuZHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC55ICsgZCArIG9mZnNldC5keSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZSAqIHNHLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNHXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVfID09PSAncGllY2hhcnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhdyBwaWUgY2hhcnQgYW5ndWxhciBzZWN0b3JcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBhbmdsZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYTEgPSBjdW11bCAqIDIgKiBNYXRoLlBJXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGEyID0gKGN1bXVsICsgc2hhcmUpICogMiAqIE1hdGguUElcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyh4YywgeWMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5hcmMoeGMsIHljLCBzRyAqIDAuNSwgYTEgKyBvZmZBbmcsIGEyICsgb2ZmQW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5waWVDaGFydEludGVybmFsUmFkaXVzRmFjdG9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmFyYyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4YyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5YyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzRyAqIDAuNSAqIHRoaXMucGllQ2hhcnRJbnRlcm5hbFJhZGl1c0ZhY3RvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMSArIG9mZkFuZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMiArIG9mZkFuZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5jbG9zZVBhdGgoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbCgpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlXyA9PT0gJ3JpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZHJhdyByaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguYXJjKHhjLCB5YywgTWF0aC5zcXJ0KDEgLSBjdW11bCkgKiBzRyAqIDAuNSwgMCwgMiAqIE1hdGguUEkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVfID09PSAnc2VnbWVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kcmF3IHNlZ21lbnQgc2VjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd0cgPSAoc0cgKiBzRykgLyByXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC54ICsgb2Zmc2V0LmR4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwueSArIChyIC0gd0cpIC8gMiArIGN1bXVsICogd0cgKyBvZmZzZXQuZHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZSAqIHdHXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC54ICsgY3VtdWwgKiByICsgb2Zmc2V0LmR4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwueSArIChyIC0gd0cpIC8gMiArIG9mZnNldC5keSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZSAqIHIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd0dcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBzeW1ib2wgdHlwZTonICsgdHlwZV8pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjdW11bCArPSBzaGFyZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXHJcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHI6IHIsIHpmOiB6Ziwgc1NpemU6IHN0YXQgfSlcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IFNpZGVTdHlsZSB9IGZyb20gJy4vU2lkZVN0eWxlLmpzJ1xyXG5cclxuLyoqIEB0eXBlZGVmIHt7eDpudW1iZXIseTpudW1iZXIsb3I6XCJ2XCJ8XCJoXCIsdmFsdWU6bnVtYmVyfX0gU2lkZSAqL1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb250b3VyU3R5bGUgZXh0ZW5kcyBTaWRlU3R5bGUge1xyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICAvL29wdHMuaW50ZXJ2YWwgPSBvcHRzLmludGVydmFsIHx8IDEwMFxyXG5cclxuICAgICAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xyXG4gICAgICAgIG9wdHMuYnJlYWtzID0gb3B0cy5icmVha3MgfHwgWzEwMCwgMTAwMCwgMTAwMDAsIDEwMDAwMCwgMTAwMDAwMF1cclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihTaWRlLG51bWJlcixudW1iZXIpOnN0cmluZ30gKi9cclxuICAgICAgICBvcHRzLndpZHRoID0gb3B0cy53aWR0aCB8fCAoKCkgPT4gMSkgLy8ocywgciwgemYpID0+IC4uLlxyXG5cclxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKFNpZGUsbnVtYmVyLG51bWJlcik6c3RyaW5nfSAqL1xyXG4gICAgICAgIG9wdHMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgoKSA9PiAnI0U3QTkzNScpIC8vKHMsIHIsIHpmKSA9PiAuLi5cclxuXHJcbiAgICAgICAgLy9vdmVycmlkZSBtZXRob2QgZm9yIGNvbnRvdXIgZHJhd2luZ1xyXG5cclxuICAgICAgICBjb25zdCBnZXRDbGFzcyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICh2ID09IHVuZGVmaW5lZCkgcmV0dXJuIDBcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRzLmJyZWFrcy5sZW5ndGg7IGkrKykgaWYgKHYgPCBvcHRzLmJyZWFrc1tpXSkgcmV0dXJuIGlcclxuICAgICAgICAgICAgcmV0dXJuIG9wdHMuYnJlYWtzLmxlbmd0aFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy52YWx1ZSA9ICh2MSwgdjIsIHIsIHMsIHpmKSA9PiB7XHJcbiAgICAgICAgICAgIC8vaWYgKCF2MSB8fCAhdjIpIHJldHVybiAwXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhnZXRDbGFzcyh2MikgLSBnZXRDbGFzcyh2MSkpXHJcblxyXG4gICAgICAgICAgICAvL2NoZWNrIGlmIHYxIC0gdjIgY3Jvc3MgYSBjb250b3VyIGxpbmVcclxuICAgICAgICAgICAgLy9jb25zdCByMSA9IE1hdGguZmxvb3IodjEgLyBvcHRzLmludGVydmFsKTtcclxuICAgICAgICAgICAgLy9jb25zdCByMiA9IE1hdGguZmxvb3IodjIgLyBvcHRzLmludGVydmFsKTtcclxuICAgICAgICAgICAgLy9yZXR1cm4gTWF0aC5hYnMocjIgLSByMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NhbWUgY29sb3IgZm9yIGFsbFxyXG4gICAgICAgIHRoaXMuY29sb3IgPSAoc2lkZSwgciwgcywgemYpID0+IChzaWRlLnZhbHVlID8gb3B0cy5jb2xvcihzaWRlLCByLCB6ZikgOiB1bmRlZmluZWQpXHJcblxyXG4gICAgICAgIC8vd2lkdGg6IG11bHRpcGxlIG9mXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IChzaWRlLCByLCBzLCB6ZikgPT4gc2lkZS52YWx1ZSAqIHpmICogb3B0cy53aWR0aChzaWRlLCByLCB6ZilcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vU3R5bGUuanMnXHJcbmltcG9ydCB7IHJhbmRvbU5vcm1hbCB9IGZyb20gJ2QzLXJhbmRvbSdcclxuaW1wb3J0IHsgY2hlY2tXZWJHTFN1cHBvcnQsIG1ha2VXZWJHTENhbnZhcyB9IGZyb20gJy4uL3V0aWxzL3dlYkdMVXRpbHMuanMnXHJcbmltcG9ydCB7IFdlYkdMU3F1YXJlQ29sb3JpbmcgfSBmcm9tICcuLi91dGlscy9XZWJHTFNxdWFyZUNvbG9yaW5nLmpzJ1xyXG5pbXBvcnQgeyBjb2xvciB9IGZyb20gJ2QzLWNvbG9yJ1xyXG5pbXBvcnQgeyBtb25pdG9yLCBtb25pdG9yRHVyYXRpb24gfSBmcm9tICcuLi91dGlscy9VdGlscy5qcydcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRG90RGVuc2l0eVN0eWxlIGV4dGVuZHMgU3R5bGUge1xyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGNvbHVtbi9hdHRyaWJ1dGUgb2YgdGhlIHRhYnVsYXIgZGF0YSB3aGVyZSB0byByZXRyaWV2ZSB0aGUgdmFyaWFibGUgZm9yIGRvdCBudW1iZXIuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLm5iQ29sID0gb3B0cy5uYkNvbFxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBkb3RzIGZvciBhIGNlbGwgdmFsdWUuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdCxudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLm5iID0gb3B0cy5uYiB8fCAoKHYsIHIsIHMsIHpmKSA9PiAoKCgwLjMgKiByICogcikgLyAoemYgKiB6ZikpICogdikgLyBzLm1heClcclxuXHJcbiAgICAgICAgLyoqIFRoZSBjb2xvciBvZiB0aGUgZG90cy4gU2FtZSBjb2xvciBmb3IgYWxsIGRvdHMgd2l0aGluIGEgY2VsbC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsKTpzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKCgpID0+ICcjRkY1NzMzJylcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaXplIG9mIHRoZSBkb3RzLCBpbiBnZW8gdW5pdC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuZG90U2l6ZSA9IG9wdHMuZG90U2l6ZSAvL3x8ICgociwgemYpID0+IC4uLlxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpZ21hIG9mIHRoZSBkaXN0cmlidXRpb24gZnJvbSB0aGUgcmVzb2x1dGlvbiwgaW4gZ2VvIHVuaXQuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnNpZ21hID0gb3B0cy5zaWdtYSAvL3x8ICgocix6ZikgPT4gLi4uXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGNlbGxzIGFzIHRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGNnXHJcbiAgICAgKi9cclxuICAgIGRyYXcoY2VsbHMsIHIsIGNnKSB7XHJcbiAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignKioqIERvdERlbnNpdHlTdHlsZSBkcmF3JylcclxuXHJcbiAgICAgICAgLy9maWx0ZXJcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxyXG5cclxuICAgICAgICAvL3pvb20gZmFjdG9yXHJcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXHJcblxyXG4gICAgICAgIGxldCBzdGF0XHJcbiAgICAgICAgaWYgKHRoaXMubmJDb2wpIHN0YXQgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLm5iQ29sXSwgdHJ1ZSlcclxuICAgICAgICBpZiAoIXN0YXQpIHJldHVyblxyXG5cclxuICAgICAgICAvL3NpemUgb2YgdGhlIGRvdHNcclxuICAgICAgICBjb25zdCBzR2VvID0gdGhpcy5kb3RTaXplID8gdGhpcy5kb3RTaXplKHIsIHpmKSA6IDIgKiB6ZlxyXG5cclxuICAgICAgICAvL21ha2UgcmFuZG9tIGZ1bmN0aW9uXHJcbiAgICAgICAgY29uc3Qgc2lnID0gdGhpcy5zaWdtYSA/IHRoaXMuc2lnbWEociwgemYpIDogciAqIDAuNFxyXG4gICAgICAgIGNvbnN0IHJhbmQgPSByYW5kb21Ob3JtYWwoMCwgc2lnKVxyXG5cclxuICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcgcHJlcGFyYXRpb24nKVxyXG5cclxuICAgICAgICBpZiAoY2hlY2tXZWJHTFN1cHBvcnQoKSkge1xyXG4gICAgICAgICAgICAvL2NyZWF0ZSBjYW52YXMgYW5kIHdlYmdsIHJlbmRlcmVyXHJcbiAgICAgICAgICAgIGNvbnN0IGN2V0dMID0gbWFrZVdlYkdMQ2FudmFzKGNnLncgKyAnJywgY2cuaCArICcnKVxyXG4gICAgICAgICAgICBpZiAoIWN2V0dMKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyB3ZWJHTCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9jcmVhdGUgd2ViR0wgcHJvZ3JhbVxyXG4gICAgICAgICAgICBjb25zdCBwcm9nID0gbmV3IFdlYkdMU3F1YXJlQ29sb3JpbmcoY3ZXR0wuZ2wsIHNHZW8gLyB6ZilcclxuXHJcbiAgICAgICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyB3ZWJnbCBjcmVhdGlvbicpXHJcblxyXG4gICAgICAgICAgICBjb25zdCByMiA9IHIgLyAyXHJcblxyXG4gICAgICAgICAgICBsZXQgY29sLCBvZmZzZXQsIG5iLCBjeCwgY3ksIGNjXHJcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IGNvbG9yXHJcbiAgICAgICAgICAgICAgICBjb2wgPSB0aGlzLmNvbG9yKGMpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbCB8fCBjb2wgPT09ICdub25lJykgY29udGludWVcclxuXHJcbiAgICAgICAgICAgICAgICAvL2dldCBvZmZzZXRcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0KGMsIHIsIHpmKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vbnVtYmVyIG9mIGRvdHNcclxuICAgICAgICAgICAgICAgIG5iID0gdGhpcy5uYihjW3RoaXMubmJDb2xdLCByLCBzdGF0LCB6ZilcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NlbGwgY2VudGVyXHJcbiAgICAgICAgICAgICAgICBjeCA9IGMueCArIG9mZnNldC5keCArIHIyXHJcbiAgICAgICAgICAgICAgICBjeSA9IGMueSArIG9mZnNldC5keSArIHIyXHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IGNvbG9yXHJcbiAgICAgICAgICAgICAgICBjYyA9IGNvbG9yKGNvbClcclxuICAgICAgICAgICAgICAgIGlmICghY2MpIHJldHVyblxyXG5cclxuICAgICAgICAgICAgICAgIC8vcmFuZG9tIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbmI7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBwcm9nLmFkZFBvaW50RGF0YTIoY3ggKyByYW5kKCksIGN5ICsgcmFuZCgpLCBjYy5yLCBjYy5nLCBjYy5iLCBjYy5vcGFjaXR5KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcgZGF0YSBwcmVwYXJhdGlvbicpXHJcblxyXG4gICAgICAgICAgICAvL2RyYXdcclxuICAgICAgICAgICAgcHJvZy5kcmF3KGNnLmdldFdlYkdMVHJhbnNmb3JtKCkpXHJcblxyXG4gICAgICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcgd2ViZ2wgZHJhd2luZycpXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgaW4gY2FudmFzIGdlb1xyXG4gICAgICAgICAgICBjZy5pbml0Q2FudmFzVHJhbnNmb3JtKClcclxuICAgICAgICAgICAgY2cuY3R4LmRyYXdJbWFnZShjdldHTC5jYW52YXMsIDAsIDApXHJcblxyXG4gICAgICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcgY2FudmFzIGRyYXdpbmcnKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vZHJhdyB3aXRoIEhUTUwgY2FudmFzXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgaW4gZ2VvIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGNnLnNldENhbnZhc1RyYW5zZm9ybSgpXHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNlbGxzKSB7XHJcbiAgICAgICAgICAgICAgICAvL2dldCBjb2xvclxyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2xvcihjKVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb2wgfHwgY29sID09PSAnbm9uZScpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAvL3NldCBjb2xvclxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxTdHlsZSA9IGNvbFxyXG5cclxuICAgICAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoYywgciwgemYpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9udW1iZXIgb2YgZG90c1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmIgPSB0aGlzLm5iKGNbdGhpcy5uYkNvbF0sIHIsIHN0YXQsIHpmKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZHJhdyByYW5kb20gZG90c1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3ggPSBjLnggKyBvZmZzZXQuZHggKyByIC8gMixcclxuICAgICAgICAgICAgICAgICAgICBjeSA9IGMueSArIG9mZnNldC5keSArIHIgLyAyXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuYjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxSZWN0KGN4ICsgcmFuZCgpLCBjeSArIHJhbmQoKSwgc0dlbywgc0dlbylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByOiByLCB6ZjogemYgfSlcclxuXHJcbiAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignKioqIERvdERlbnNpdHlTdHlsZSBlbmQgZHJhdycpXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL1N0eWxlLmpzJ1xyXG5cclxuLyoqIEB0eXBlZGVmIHt7eDpudW1iZXIseTpudW1iZXIsb3I6XCJ2XCJ8XCJoXCIsYzE6aW1wb3J0KCcuLi9EYXRhc2V0LmpzJykuQ2VsbHx1bmRlZmluZWQsYzI6aW1wb3J0KCcuLi9EYXRhc2V0LmpzJykuQ2VsbHx1bmRlZmluZWR9fSBTaWRlICovXHJcblxyXG4vKipcclxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIElzb0ZlbmNlU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcblxyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGljdGlvbmFyeSAoc3RyaW5nIC0+IGNvbG9yKSB3aGljaCBnaXZlIHRoZSBjb2xvciBvZiBlYWNoIGNhdGVnb3J5LlxyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9ICovXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3JcclxuXHJcbiAgICAgICAgLyoqIFRoZSBjb2x1bW4gd2hlcmUgdG8gZ2V0IHRoZSBoZWlnaHQgdmFsdWVzLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5oZWlnaHRDb2wgPSBvcHRzLmhlaWdodENvbFxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGhlaWdodCBvZiBhIGNlbGwuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRzLmhlaWdodCB8fCAoKHYsIHIsIHMsIHpmKSA9PiByICogMC40KVxyXG5cclxuICAgICAgICAvKiogVGhlIHBlcnNwZWN0aXZlIGFuZ2xlLCBpbiBkZWdyZWUsIHdpdGhpbiBbLTE4MCwxODBdLCBmcm9tIFtPLHhdIGF4aXMuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLmFuZ2xlID0gb3B0cy5hbmdsZSAhPSB1bmRlZmluZWQgPyBvcHRzLmFuZ2xlIDogNTBcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb3JuZXIgbGluZSBzdHJva2Ugc3R5bGUuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydCgnLi4vRGF0YXNldC5qcycpLkNlbGwsbnVtYmVyLG51bWJlcixudW1iZXIpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvcm5lckxpbmVTdHJva2VDb2xvciA9IG9wdHMuY29ybmVyTGluZVN0cm9rZUNvbG9yIHx8ICgoYywgciwgemYsIGFuZ2xlKSA9PiBcIiM5OTlcIilcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjb3JuZXIgbGluZSB3aWR0aC5cclxuICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoJy4uL0RhdGFzZXQuanMnKS5DZWxsLG51bWJlcixudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5jb3JuZXJMaW5lV2lkdGggPSBvcHRzLmNvcm5lckxpbmVXaWR0aCB8fCAoKGMsIHIsIHpmLCBhbmdsZSkgPT4gKGFuZ2xlICUgOTAgPT0gMCA/IDAgOiAwLjggKiB6ZikpXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogU2hvdyB2ZXJ0aWNhbCBjcm9zcy1zZWN0aW9ucy5cclxuICAgICAgICAqIEB0eXBlIHtib29sZWFufSAqL1xyXG4gICAgICAgIHRoaXMuc1ZlcnQgPSBvcHRzLnNWZXJ0ICE9IHVuZGVmaW5lZCA/IG9wdHMuc1ZlcnQgOiB0cnVlXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogU2hvdyBob3Jpem9udGFsIGNyb3NzLXNlY3Rpb25zLlxyXG4gICAgICAgICogQHR5cGUge2Jvb2xlYW59ICovXHJcbiAgICAgICAgdGhpcy5zSG9yID0gb3B0cy5zSG9yICE9IHVuZGVmaW5lZCA/IG9wdHMuc0hvciA6IHRydWVcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgY2VsbHMgYXMgc2VnbWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldC5qc1wiKS5DZWxsPn0gY2VsbHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0dlb0NhbnZhcy5qc1wiKS5HZW9DYW52YXN9IGNnXHJcbiAgICAgKi9cclxuICAgIGRyYXcoY2VsbHMsIHIsIGNnKSB7XHJcbiAgICAgICAgLy9maWx0ZXJcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxyXG5cclxuICAgICAgICAvL3pvb20gZmFjdG9yXHJcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXHJcblxyXG4gICAgICAgIGxldCBzdGF0XHJcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0Q29sKSB7XHJcbiAgICAgICAgICAgIC8vaWYgc2l6ZSBpcyB1c2VkLCBzb3J0IGNlbGxzIGJ5IHNpemUgc28gdGhhdCB0aGUgYmlnZ2VzdCBhcmUgZHJhd24gZmlyc3RcclxuICAgICAgICAgICAgY2VsbHMuc29ydCgoYzEsIGMyKSA9PiBjMlt0aGlzLmhlaWdodENvbF0gLSBjMVt0aGlzLmhlaWdodENvbF0pXHJcbiAgICAgICAgICAgIC8vYW5kIGNvbXB1dGUgc3RhdGlzdGljc1xyXG4gICAgICAgICAgICBzdGF0ID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5oZWlnaHRDb2xdLCB0cnVlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9uYiBjYXRlZ29yaWVzIC0gdXNlZCBmb3IgcmFkYXIgYW5kIGFnZXB5cmFtaWRcclxuICAgICAgICBjb25zdCBjYXRzID0gT2JqZWN0LmtleXModGhpcy5jb2xvcilcclxuXHJcbiAgICAgICAgLy9oYWxmIHJlc29sdXRpb25cclxuICAgICAgICBjb25zdCByMiA9IHIgLyAyXHJcblxyXG4gICAgICAgIC8vZ2V0IG9mZnNldFxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldCh1bmRlZmluZWQsIHIsIHpmKSwgZHggPSBvZmZzZXQuZHgsIGR5ID0gb2Zmc2V0LmR5XHJcblxyXG4gICAgICAgIC8vaGVpZ2h0XHJcbiAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIGxldCBoXyA9IHRoaXMuaGVpZ2h0XHJcblxyXG4gICAgICAgIC8vbWFrZSBzaWRlc1xyXG4gICAgICAgIC8qKiAgQHR5cGUge0FycmF5LjxTaWRlPn0gKi9cclxuICAgICAgICBjb25zdCBzaWRlcyA9IFtdXHJcblxyXG4gICAgICAgIC8vbWFrZSBob3Jpem9udGFsIHNpZGVzIC0gZXhjZXB0IHdoZW4gYW5nbGUlMTgwPTBcclxuICAgICAgICAvL3NvcnQgY2VsbHMgYnkgeCBhbmQgeVxyXG4gICAgICAgIGlmICh0aGlzLmFuZ2xlICUgMTgwICE9IDkwICYmIHRoaXMuc1ZlcnQpIHtcclxuICAgICAgICAgICAgY2VsbHMuc29ydCgoYzEsIGMyKSA9PiAoYzIueCA9PSBjMS54ID8gYzEueSAtIGMyLnkgOiBjMS54IC0gYzIueCkpXHJcbiAgICAgICAgICAgIGxldCBjMSA9IGNlbGxzWzBdXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBjMiA9IGNlbGxzW2ldXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChjMS55ICsgciA9PSBjMi55KSAmJiAoYzEueCA9PSBjMi54KSlcclxuICAgICAgICAgICAgICAgICAgICAvL2NlbGxzIGluIHNhbWUgY29sdW1uIGFuZCB0b3VjaCBhbG9uZyBob3Jpem9udGFsIHNpZGVcclxuICAgICAgICAgICAgICAgICAgICAvL21ha2Ugc2hhcmVkIHNpZGVcclxuICAgICAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHsgeDogYzEueCArIHIyLCB5OiBjMi55LCBvcjogJ2gnLCBjMTogYzEsIGMyOiBjMiB9KVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jZWxscyBkbyBub3QgdG91Y2ggYWxvbmcgaG9yaXpvbnRhbCBzaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgLy9tYWtlIHR3byBzaWRlczogdG9wIG9uZSBmb3IgYzEsIGJvdHRvbSBmb3IgYzJcclxuICAgICAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHsgeDogYzEueCArIHIyLCB5OiBjMS55ICsgciwgb3I6ICdoJywgYzE6IGMxLCBjMjogdW5kZWZpbmVkIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7IHg6IGMyLnggKyByMiwgeTogYzIueSwgb3I6ICdoJywgYzE6IHVuZGVmaW5lZCwgYzI6IGMyIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYzEgPSBjMlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL21ha2UgdmVydGljYWwgc2lkZXMgLSBleGNlcHQgd2hlbiBhbmdsZSUxODA9OTBcclxuICAgICAgICAvL3NvcnQgY2VsbHMgYnkgeSBhbmQgeFxyXG4gICAgICAgIGlmICh0aGlzLmFuZ2xlICUgMTgwICE9IDAgJiYgdGhpcy5zSG9yKSB7XHJcbiAgICAgICAgICAgIGNlbGxzLnNvcnQoKGMxLCBjMikgPT4gKGMyLnkgPT0gYzEueSA/IGMxLnggLSBjMi54IDogYzEueSAtIGMyLnkpKVxyXG4gICAgICAgICAgICBsZXQgYzEgPSBjZWxsc1swXVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYzIgPSBjZWxsc1tpXVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICgoYzEueCArIHIgPT0gYzIueCkgJiYgKGMxLnkgPT0gYzIueSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jZWxscyBpbiBzYW1lIHJvdyBhbmQgdG91Y2ggYWxvbmcgdmVydGljYWwgc2lkZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzaGFyZWQgc2lkZVxyXG4gICAgICAgICAgICAgICAgICAgIHNpZGVzLnB1c2goeyB4OiBjMi54LCB5OiBjMS55ICsgcjIsIG9yOiAndicsIGMxOiBjMSwgYzI6IGMyIH0pXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NlbGxzIGRvIG5vdCB0b3VjaCBhbG9uZyB2ZXJ0aWNhbCBzaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgLy9tYWtlIHR3byBzaWRlczogcmlnaHQgb25lIGZvciBjMSwgbGVmdCBmb3IgYzJcclxuICAgICAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHsgeDogYzEueCArIHIsIHk6IGMxLnkgKyByMiwgb3I6ICd2JywgYzE6IGMxLCBjMjogdW5kZWZpbmVkIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7IHg6IGMyLngsIHk6IGMyLnkgKyByMiwgb3I6ICd2JywgYzE6IHVuZGVmaW5lZCwgYzI6IGMyIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYzEgPSBjMlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGlmIChzaWRlcy5sZW5ndGggPT0gMCkgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vYW5nbGUgaW4gcmFkaWFuc1xyXG4gICAgICAgIGNvbnN0IGFSYWQgPSB0aGlzLmFuZ2xlICogTWF0aC5QSSAvIDE4MCwgY29zID0gTWF0aC5jb3MoYVJhZCksIHNpbiA9IE1hdGguc2luKGFSYWQpXHJcblxyXG4gICAgICAgIC8vc29ydCBzaWRlcyBzbyB0aGF0IHRoZSBiYWNrIG9uZXMgYXJlIGRyYXduIGZpcnN0LiBUaGlzIGRlcGVuZHMgb24gdGhlIGFuZ2xlLlxyXG4gICAgICAgIC8vZGVwZW5kaW5nIG9uIGRpc3RhbmNlIHRvIHRoZSByZWZlcmVuY2UgY29ybmVyIHBvaW50XHJcbiAgICAgICAgY29uc3QgeENvcm5lciA9IE1hdGguYWJzKHRoaXMuYW5nbGUpIDwgOTAgPyBjZy5leHRHZW8ueE1pbiA6IGNnLmV4dEdlby54TWF4XHJcbiAgICAgICAgY29uc3QgeUNvcm5lciA9IHRoaXMuYW5nbGUgPCAwID8gY2cuZXh0R2VvLnlNYXggOiBjZy5leHRHZW8ueU1pblxyXG4gICAgICAgIHNpZGVzLnNvcnQoKHMxLCBzMikgPT4gKE1hdGguaHlwb3QoczIueCAtIHhDb3JuZXIsIHMyLnkgLSB5Q29ybmVyKSAtIE1hdGguaHlwb3QoczEueCAtIHhDb3JuZXIsIHMxLnkgLSB5Q29ybmVyKSkpXHJcblxyXG4gICAgICAgIC8vcHJlcGFyZSBmdW5jdGlvbiB0byBkcmF3IGNvcm5lciBsaW5lIGZvciBhIGNlbGwgKmMqXHJcbiAgICAgICAgY29uc3QgZHJhd0Nvcm5lckxpbmUgPSAoYykgPT4ge1xyXG5cclxuICAgICAgICAgICAgaWYgKCFjKSByZXR1cm5cclxuICAgICAgICAgICAgLy9saW5lIHN0eWxlXHJcbiAgICAgICAgICAgIGNvbnN0IGx3ID0gdGhpcy5jb3JuZXJMaW5lV2lkdGggPyB0aGlzLmNvcm5lckxpbmVXaWR0aChjLCByLCB6ZiwgdGhpcy5hbmdsZSkgOiAwLjggKiB6ZlxyXG4gICAgICAgICAgICBpZiAobHcgPT0gMCkgcmV0dXJuXHJcbiAgICAgICAgICAgIGNnLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29ybmVyTGluZVN0cm9rZUNvbG9yID8gdGhpcy5jb3JuZXJMaW5lU3Ryb2tlQ29sb3IoYywgciwgemYsIHRoaXMuYW5nbGUpIDogXCIjMzMzXCJcclxuICAgICAgICAgICAgY2cuY3R4LmxpbmVXaWR0aCA9IGx3XHJcblxyXG4gICAgICAgICAgICAvL2hlaWdodCAtIGluIGdlb1xyXG4gICAgICAgICAgICBjb25zdCBoRyA9IGhfKGNbdGhpcy5oZWlnaHRDb2xdLCByLCBzdGF0LCB6ZilcclxuXHJcbiAgICAgICAgICAgIC8vZHJhdyBsaW5lXHJcbiAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICBjZy5jdHgubW92ZVRvKGMueCArIHIyICsgZHgsIGMueSArIHIyICsgZHkpXHJcbiAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oYy54ICsgcjIgKyBoRyAqIGNvcyArIGR4LCBjLnkgKyByMiArIGhHICogc2luICsgZHkpXHJcbiAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IGluIGdlbyBjb29yZGluYXRlc1xyXG4gICAgICAgIGNnLnNldENhbnZhc1RyYW5zZm9ybSgpXHJcblxyXG4gICAgICAgIC8vZHJhdyBzaWRlc1xyXG4gICAgICAgIGNnLmN0eC5saW5lQ2FwID0gXCJyb3VuZFwiO1xyXG4gICAgICAgIGZvciAobGV0IHMgb2Ygc2lkZXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vaGVpZ2h0cyAtIGluIGdlb1xyXG4gICAgICAgICAgICBjb25zdCBoRzEgPSBzLmMxID8gaF8ocy5jMVt0aGlzLmhlaWdodENvbF0sIHIsIHN0YXQsIHpmKSA6IDAsXHJcbiAgICAgICAgICAgICAgICBoRzIgPSBzLmMyID8gaF8ocy5jMlt0aGlzLmhlaWdodENvbF0sIHIsIHN0YXQsIHpmKSA6IDBcclxuXHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSB0b3RhbHMgZm9yIGJvdGggY2VsbHNcclxuICAgICAgICAgICAgY29uc3QgdG90YWwxID0gY29tcHV0ZVRvdGFsKHMuYzEsIGNhdHMpLFxyXG4gICAgICAgICAgICAgICAgdG90YWwyID0gY29tcHV0ZVRvdGFsKHMuYzIsIGNhdHMpXHJcbiAgICAgICAgICAgIGlmICh0b3RhbDEgPT0gMCAmJiB0b3RhbDIgPT0gMCkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIGxldCBjdW11bDEgPSAwLCBjdW11bDIgPSAwXHJcbiAgICAgICAgICAgIGZvciAobGV0IFtjb2x1bW4sIGNvbG9yXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmNvbG9yKSkge1xyXG4gICAgICAgICAgICAgICAgLy9kcmF3IHN0cmlwZSBvZiBzaWRlIHMgYW5kIGNhdGVnb3J5IGNvbHVtblxyXG5cclxuICAgICAgICAgICAgICAgIC8vZ2V0IHZhbHVlcyBmb3IgYm90aCBjZWxsc1xyXG4gICAgICAgICAgICAgICAgbGV0IHYxID0gcy5jMSA/ICtzLmMxW2NvbHVtbl0gOiAwXHJcbiAgICAgICAgICAgICAgICBsZXQgdjIgPSBzLmMyID8gK3MuYzJbY29sdW1uXSA6IDBcclxuICAgICAgICAgICAgICAgIGlmICh2MSA9PSAwICYmIHYyID09IDApIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb21wdXRlIGhlaWdodHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGgxID0gaEcxICogY3VtdWwxIC8gdG90YWwxIHx8IDBcclxuICAgICAgICAgICAgICAgIGNvbnN0IGgxbiA9IGhHMSAqIChjdW11bDEgKyB2MSkgLyB0b3RhbDEgfHwgMFxyXG4gICAgICAgICAgICAgICAgY29uc3QgaDIgPSBoRzIgKiBjdW11bDIgLyB0b3RhbDIgfHwgMFxyXG4gICAgICAgICAgICAgICAgY29uc3QgaDJuID0gaEcyICogKGN1bXVsMiArIHYyKSAvIHRvdGFsMiB8fCAwXHJcblxyXG4gICAgICAgICAgICAgICAgLy9tYWtlIHBhdGhcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgaWYgKHMub3IgPT0gXCJoXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2hvcml6b250YWwgc2lkZSAtIHZlcnRpY2FsIHNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbSBsZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhzLnggKyBoMSAqIGNvcyArIGR4LCBzLnkgLSByMiArIGgxICogc2luICsgZHkpXHJcbiAgICAgICAgICAgICAgICAgICAgLy90b3AgbGVmdFxyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8ocy54ICsgaDIgKiBjb3MgKyBkeCwgcy55ICsgcjIgKyBoMiAqIHNpbiArIGR5KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vdG9wIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhzLnggKyBoMm4gKiBjb3MgKyBkeCwgcy55ICsgcjIgKyBoMm4gKiBzaW4gKyBkeSlcclxuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbSByaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8ocy54ICsgaDFuICogY29zICsgZHgsIHMueSAtIHIyICsgaDFuICogc2luICsgZHkpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdmVydGljYWwgc2lkZSAtIGhvcml6b250YWwgc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYm90dG9tIGxlZnRcclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKHMueCAtIHIyICsgaDEgKiBjb3MgKyBkeCwgcy55ICsgaDEgKiBzaW4gKyBkeSlcclxuICAgICAgICAgICAgICAgICAgICAvL2JvdHRvbSByaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8ocy54ICsgcjIgKyBoMiAqIGNvcyArIGR4LCBzLnkgKyBoMiAqIHNpbiArIGR5KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vdG9wIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhzLnggKyByMiArIGgybiAqIGNvcyArIGR4LCBzLnkgKyBoMm4gKiBzaW4gKyBkeSlcclxuICAgICAgICAgICAgICAgICAgICAvL3RvcCBsZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhzLnggLSByMiArIGgxbiAqIGNvcyArIGR4LCBzLnkgKyBoMW4gKiBzaW4gKyBkeSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vY2cuY3R4LmNsb3NlUGF0aCgpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9maWxsXHJcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sb3JcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcclxuXHJcbiAgICAgICAgICAgICAgICBjdW11bDEgKz0gdjFcclxuICAgICAgICAgICAgICAgIGN1bXVsMiArPSB2MlxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBkcmF3IG9ubHkgb25lIGxpbmVcclxuICAgICAgICAgICAgICAgIC8vZHJhdyBjb3JuZXIgbGluZVxyXG4gICAgICAgICAgICAgICAgLy9pZiAocy5vciA9PSBcImhcIikge1xyXG4gICAgICAgICAgICAgICAgZHJhd0Nvcm5lckxpbmUocy5jMSlcclxuICAgICAgICAgICAgICAgIGRyYXdDb3JuZXJMaW5lKHMuYzIpXHJcbiAgICAgICAgICAgICAgICAvL2lmICh0aGlzLmFuZ2xlID4gMCAmJiBzLm9yID09IFwiaFwiKSBkcmF3Q29ybmVyTGluZShzLmMyKVxyXG4gICAgICAgICAgICAgICAgLy9lbHNlIGRyYXdDb3JuZXJMaW5lKHMuYzIpXHJcbiAgICAgICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByOiByLCB6ZjogemYsIHNTaXplOiBzdGF0IH0pXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuY29uc3QgY29tcHV0ZVRvdGFsID0gKGNlbGwsIGNhdGVnb3JpZXMpID0+IHtcclxuICAgIGlmICghY2VsbCkgcmV0dXJuIDBcclxuICAgIGxldCB0b3RhbCA9IDBcclxuICAgIGZvciAobGV0IGNvbHVtbiBvZiBjYXRlZ29yaWVzKSB7XHJcbiAgICAgICAgY29uc3QgdiA9IGNlbGxbY29sdW1uXVxyXG4gICAgICAgIGlmICghdikgY29udGludWVcclxuICAgICAgICB0b3RhbCArPSArdlxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvdGFsIHx8IDBcclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vU3R5bGUuanMnXHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEpveVBsb3RTdHlsZSBleHRlbmRzIFN0eWxlIHtcclxuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqIFRoZSBjZWxsIGNvbHVtbiB3aGVyZSB0byBnZXQgdGhlIHZhbHVlIHRvIHJlcHJlc2VudC5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0Q29sID0gb3B0cy5oZWlnaHRDb2xcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBoZWlnaHQgb2YgYSBjZWxsLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0cy5oZWlnaHQgfHwgKCh2KSA9PiBNYXRoLnNxcnQodikpXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIse21pbjpudW1iZXIsIG1heDpudW1iZXJ9LG51bWJlcixudW1iZXIpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmxpbmVDb2xvciA9IG9wdHMubGluZUNvbG9yIHx8ICgoeSwgeXMsIHIsIHpmKSA9PiAnI0JCQicpXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcix7bWluOm51bWJlciwgbWF4Om51bWJlcn0sbnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gb3B0cy5saW5lV2lkdGggfHwgKCh5LCB5cywgciwgemYpID0+IHpmKVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIse21pbjpudW1iZXIsIG1heDpudW1iZXJ9LG51bWJlcixudW1iZXIpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmZpbGxDb2xvciA9IG9wdHMuZmlsbENvbG9yIHx8ICgoeSwgeXMsIHIsIHpmKSA9PiAnI2MwOGM1OTY4JylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgY2VsbHMgYXMgc3F1YXJlcyBkZXBlbmRpbmcgb24gdGhlaXIgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGNnXHJcbiAgICAgKiAqL1xyXG4gICAgZHJhdyhjZWxscywgciwgY2cpIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIGNnLmN0eC5saW5lSm9pbiA9ICdyb3VuZCdcclxuXHJcbiAgICAgICAgLy96b29tIGZhY3RvclxyXG4gICAgICAgIGNvbnN0IHpmID0gY2cuZ2V0WmYoKVxyXG5cclxuICAgICAgICAvL2NvbXB1dGUgc3RhdGlzdGljc1xyXG4gICAgICAgIGNvbnN0IHN0YXQgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLmhlaWdodENvbF0sIHRydWUpXHJcblxyXG4gICAgICAgIC8vaW5kZXggY2VsbHMgYnkgeSBhbmQgeFxyXG4gICAgICAgIC8qKiAgQHR5cGUge29iamVjdH0gKi9cclxuICAgICAgICBjb25zdCBpbmQgPSB7fVxyXG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICBsZXQgcm93ID0gaW5kW2NlbGwueV1cclxuICAgICAgICAgICAgaWYgKCFyb3cpIHtcclxuICAgICAgICAgICAgICAgIHJvdyA9IHt9XHJcbiAgICAgICAgICAgICAgICBpbmRbY2VsbC55XSA9IHJvd1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvd1tjZWxsLnhdID0gdGhpcy5oZWlnaHQoY2VsbFt0aGlzLmhlaWdodENvbF0sIHIsIHN0YXQsIHpmKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb21wdXRlIGV4dGVudFxyXG4gICAgICAgIGNvbnN0IGUgPSBjZy5leHRHZW9cclxuICAgICAgICBpZiAoIWUpIHJldHVyblxyXG4gICAgICAgIGNvbnN0IHhNaW4gPSBNYXRoLmZsb29yKGUueE1pbiAvIHIpICogclxyXG4gICAgICAgIGNvbnN0IHhNYXggPSBNYXRoLmZsb29yKGUueE1heCAvIHIpICogclxyXG4gICAgICAgIGNvbnN0IHlNaW4gPSBNYXRoLmZsb29yKGUueU1pbiAvIHIpICogclxyXG4gICAgICAgIGNvbnN0IHlNYXggPSBNYXRoLmZsb29yKGUueU1heCAvIHIpICogclxyXG5cclxuICAgICAgICAvKiogIEB0eXBlIHt7bWluOm51bWJlciwgbWF4Om51bWJlcn19ICovXHJcbiAgICAgICAgY29uc3QgeXMgPSB7IG1pbjogeU1pbiwgbWF4OiB5TWF4IH1cclxuXHJcbiAgICAgICAgLy9kcmF3IGluIGdlbyBjb29yZGluYXRlc1xyXG4gICAgICAgIGNnLnNldENhbnZhc1RyYW5zZm9ybSgpXHJcblxyXG4gICAgICAgIC8vZHJhdyBsaW5lcywgcm93IGJ5IHJvdywgc3RhdGluZyBmcm9tIHRoZSB0b3BcclxuICAgICAgICBmb3IgKGxldCB5ID0geU1heDsgeSA+PSB5TWluOyB5IC09IHIpIHtcclxuICAgICAgICAgICAgLy9nZXQgcm93XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGluZFt5XVxyXG5cclxuICAgICAgICAgICAgLy9ubyByb3dcclxuICAgICAgICAgICAgaWYgKCFyb3cpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL3BsYWNlIGZpcnN0IHBvaW50XHJcbiAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICBjZy5jdHgubW92ZVRvKHhNaW4gLSByIC8gMiwgeSlcclxuXHJcbiAgICAgICAgICAgIC8vc3RvcmUgdGhlIHByZXZpb3VzIGhlaWdodFxyXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgICAgIGxldCBoR19cclxuXHJcbiAgICAgICAgICAgIC8vZ28gdGhyb3VnaCB0aGUgbGluZSBjZWxsc1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0geE1pbjsgeCA8PSB4TWF4OyB4ICs9IHIpIHtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IGNvbHVtbiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgICAgICAgICBsZXQgaEcgPSByb3dbeF1cclxuICAgICAgICAgICAgICAgIGlmICghaEcpIGhHID0gMFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChoRyB8fCBoR18pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2RyYXcgbGluZSBvbmx5IHdoZW4gYXQgbGVhc3Qgb25lIG9mIGJvdGggdmFsdWVzIGlzIG5vbi1udWxsXHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIHRlc3QgYmV6aWVyQ3VydmVUb1xyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oeCArIHIgLyAyLCB5ICsgaEcpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZWxzZSBtb3ZlIHRoZSBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oeCArIHIgLyAyLCB5KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9zdG9yZSB0aGUgcHJldmlvdXMgdmFsdWVcclxuICAgICAgICAgICAgICAgIGhHXyA9IGhHXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vbGFzdCBwb2ludFxyXG4gICAgICAgICAgICBpZiAoaEdfKSBjZy5jdHgubGluZVRvKHhNYXggKyByIC8gMiwgeSlcclxuXHJcbiAgICAgICAgICAgIC8vZHJhdyBmaWxsXHJcbiAgICAgICAgICAgIGNvbnN0IGZjID0gdGhpcy5maWxsQ29sb3IoeSwgeXMsIHIsIHpmKVxyXG4gICAgICAgICAgICBpZiAoZmMgJiYgZmMgIT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gZmNcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IGxpbmVcclxuICAgICAgICAgICAgY29uc3QgbGMgPSB0aGlzLmxpbmVDb2xvcih5LCB5cywgciwgemYpXHJcbiAgICAgICAgICAgIGNvbnN0IGx3ID0gdGhpcy5saW5lV2lkdGgoeSwgeXMsIHIsIHpmKVxyXG4gICAgICAgICAgICBpZiAobGMgJiYgbGMgIT0gJ25vbmUnICYmIGx3ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gbGNcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSBsd1xyXG4gICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBUYW5ha2FTdHlsZSB9IGZyb20gJy4vVGFuYWthU3R5bGUuanMnXHJcbmltcG9ydCB7IFN0cm9rZVN0eWxlIH0gZnJvbSAnLi9TdHJva2VTdHlsZS5qcydcclxuaW1wb3J0IHsgU3F1YXJlQ29sb3JDYXRXR0xTdHlsZSB9IGZyb20gJy4vU3F1YXJlQ29sb3JDYXRXR0xTdHlsZS5qcydcclxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGVnb1N0eWxlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcclxuICAgICAqIEByZXR1cm5zIHtBcnJheS48U3R5bGU+fVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0KGNvbCwgb3B0cykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8vdGhlIGNvbG9yc1xyXG4gICAgICAgIC8vaHR0cDovL3d3dy5qZW5ueXNjcmF5b25jb2xsZWN0aW9uLmNvbS8yMDIxLzA2L2FsbC1jdXJyZW50LWxlZ28tY29sb3JzLmh0bWxcclxuICAgICAgICAvL2h0dHBzOi8vbGVvbmF3aWN6LmdpdGh1Yi5pby9sZWdvY29sb3JzL3JlZmVyZW5jZS9maWd1cmVzL1JFQURNRS1wbG90LTEucG5nXHJcbiAgICAgICAgb3B0cy5jb2xvcnMgPSBvcHRzLmNvbG9ycyB8fCBbXHJcbiAgICAgICAgICAgICcjMDA4NTJiJywgLy9kYXJrZXIgZ3JlZW5cclxuICAgICAgICAgICAgJyNhZmQyNDYnLCAvL2xpZ2h0IGdyZWVuXHJcbiAgICAgICAgICAgICcjZmFjODBhJywgLy9kYXJrIHllbGxvd1xyXG4gICAgICAgICAgICAnI2JiODA1YScsIC8vYnJvd25cclxuICAgICAgICAgICAgJyNkNjc5MjMnLCAvL21vc3RhcmRcclxuICAgICAgICAgICAgJyNjYjRlMjknLCAvL3JlZGlzaFxyXG4gICAgICAgICAgICAnI2I0MDAwMCcsIC8vcmVkXHJcbiAgICAgICAgICAgICcjNzIwMDEyJywgLy9kYXJrIHJlZFxyXG4gICAgICAgICAgICAvL1wicHVycGxlXCIsXHJcbiAgICAgICAgICAgIC8vXCIjZWVlXCIgLy93aGl0aGVcclxuICAgICAgICBdXHJcblxyXG4gICAgICAgIG9wdHMuY29sRGFyayA9IG9wdHMuY29sRGFyayB8fCAnIzMzMydcclxuICAgICAgICBvcHRzLmNvbEJyaWdodCA9IG9wdHMuY29sQnJpZ2h0IHx8ICcjYWFhJ1xyXG4gICAgICAgIG9wdHMud2lkdGhGYWN0b3IgPSBvcHRzLndpZHRoRmFjdG9yIHx8IDAuMTJcclxuXHJcbiAgICAgICAgLy9yZXVzZSB0YW5ha2EgYXMgYmFzaXNcclxuICAgICAgICBjb25zdCB0cyA9IFRhbmFrYVN0eWxlLmdldChjb2wsIG9wdHMpXHJcbiAgICAgICAgLy9zdHlsZSB0byBzaG93IGxpbWl0cyBiZXR3ZWVuIHBpZWNlc1xyXG4gICAgICAgIGNvbnN0IHNzdCA9IG5ldyBTdHJva2VTdHlsZSh7XHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiAoKSA9PiAnIzY2NicsXHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAodiwgciwgcywgeikgPT4gMC4yICogeixcclxuICAgICAgICAgICAgZmlsdGVyOiBvcHRzLmZpbHRlcixcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB0c1swXSxcclxuICAgICAgICAgICAgc3N0LFxyXG4gICAgICAgICAgICB0c1sxXSxcclxuICAgICAgICAgICAgbmV3IExlZ29Ub3BTdHlsZSh7IGNvbERhcms6IG9wdHMuY29sRGFyaywgY29sQnJpZ2h0OiBvcHRzLmNvbEJyaWdodCwgZmlsdGVyOiBvcHRzLmZpbHRlciB9KSxcclxuICAgICAgICBdXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk6c3RyaW5nfSBjb2xcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFN0eWxlPn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldENhdChjb2wsIG9wdHMpIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICBvcHRzLmNvbERhcmsgPSBvcHRzLmNvbERhcmsgfHwgJyMzMzMnXHJcbiAgICAgICAgb3B0cy5jb2xCcmlnaHQgPSBvcHRzLmNvbEJyaWdodCB8fCAnI2FhYSdcclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBjb25zdCBzID0gbmV3IFNxdWFyZUNvbG9yQ2F0V0dMU3R5bGUoeyBjb2xvckNvbDogY29sLCBjb2xvcjogb3B0cy5jb2xvciB9KVxyXG4gICAgICAgIC8vc3R5bGUgdG8gc2hvdyBsaW1pdHMgYmV0d2VlbiBwaWVjZXNcclxuICAgICAgICBjb25zdCBzc3QgPSBuZXcgU3Ryb2tlU3R5bGUoeyBzdHJva2VDb2xvcjogKCkgPT4gJyM2NjYnLCBzdHJva2VXaWR0aDogKHYsIHIsIHMsIHopID0+IDAuMiAqIHogfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIFtzLCBzc3QsIG5ldyBMZWdvVG9wU3R5bGUoeyBjb2xEYXJrOiBvcHRzLmNvbERhcmssIGNvbEJyaWdodDogb3B0cy5jb2xCcmlnaHQgfSldXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHN0eWxlIHRvIGRyYXcgdG9wIGNpcmNsZSBvZiBsZWdvIGJyaWNrcy5cclxuICovXHJcbmNsYXNzIExlZ29Ub3BTdHlsZSBleHRlbmRzIFN0eWxlIHtcclxuICAgIC8qKiBAcGFyYW0ge29iamVjdHx1bmRlZmluZWR9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcbiAgICAgICAgdGhpcy5jb2xEYXJrID0gb3B0cy5jb2xEYXJrIHx8ICcjMzMzJ1xyXG4gICAgICAgIHRoaXMuY29sQnJpZ2h0ID0gb3B0cy5jb2xCcmlnaHQgfHwgJyNhYWEnXHJcbiAgICB9XHJcblxyXG4gICAgZHJhdyhjZWxscywgciwgY2cpIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSAwLjYgKiBjZy5nZXRaZigpXHJcblxyXG4gICAgICAgIC8vZGFyayBwYXJ0XHJcbiAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xEYXJrXHJcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjZWxscykge1xyXG4gICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgY2cuY3R4LmFyYyhjLnggKyByICogMC41LCBjLnkgKyByICogMC41LCByICogMC41NSAqIDAuNSwgTWF0aC5QSSAvIDQsIC1NYXRoLlBJICogKDMgLyA0KSwgdHJ1ZSlcclxuICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2JyaWdodCBwYXJ0XHJcbiAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xCcmlnaHRcclxuICAgICAgICBmb3IgKGxldCBjIG9mIGNlbGxzKSB7XHJcbiAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICBjZy5jdHguYXJjKGMueCArIHIgKiAwLjUsIGMueSArIHIgKiAwLjUsIHIgKiAwLjU1ICogMC41LCBNYXRoLlBJIC8gNCwgLU1hdGguUEkgKiAoMyAvIDQpLCBmYWxzZSlcclxuICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTW9zYWljU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3IgY29sb3IuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yQ29sID0gb3B0cy5jb2xvckNvbFxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIHRoZSBjZWxsLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkKTpzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKCgpID0+ICcjRUE2QkFDJylcclxuXHJcbiAgICAgICAgLyoqIFRoZSBtb3NhaWMgZmFjdG9yLCB3aXRoaW4gWzAsMC41XS4gU2V0IHRvIDAgZm9yIG5vIG1vc2FpYyBlZmZlY3QuIFNldCB0byAwLjUgZm9yIHN0cm9uZyBtb3NhaWMgZWZmZWN0LlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5tb3NhaWNGYWN0b3IgPSBvcHRzLm1vc2FpY0ZhY3RvciB8fCAwLjE1XHJcblxyXG4gICAgICAgIC8qKiBUaGUgbW9zYWljIHNoYWRvdyBmYWN0b3IsIHdpdGhpbiBbMCwwLjVdLiBTZXQgdG8gMCBmb3Igbm8gbW9zYWljIHNoYWRvdy4gU2V0IHRvIDAuNSBmb3Igc3Ryb25nIG1vc2FpYyBzaGFkb3cuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnNoYWRvd0ZhY3RvciA9IG9wdHMuc2hhZG93RmFjdG9yIHx8IDAuMlxyXG5cclxuICAgICAgICAvKiogVGhlIG1vc2FpYyBzaGFkb3cgY29sb3IuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnNoYWRvd0NvbG9yID0gb3B0cy5zaGFkb3dDb2xvciB8fCAnIzU1NSdcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb25cclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcclxuICAgICAqL1xyXG4gICAgZHJhdyhjZWxscywgcmVzb2x1dGlvbiwgY2cpIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vem9vbSBmYWN0b3JcclxuICAgICAgICBjb25zdCB6ZiA9IGNnLmdldFpmKClcclxuXHJcbiAgICAgICAgbGV0IHN0YXRDb2xvclxyXG4gICAgICAgIGlmICh0aGlzLmNvbG9yQ29sKSB7XHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSBjb2xvciB2YXJpYWJsZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgIHN0YXRDb2xvciA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMuY29sb3JDb2xdLCB0cnVlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zZXQgc3Ryb2tlIHN0eWxlLCBmb3Igc2hhZG93XHJcbiAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zaGFkb3dDb2xvclxyXG4gICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSB0aGlzLnNoYWRvd0ZhY3RvciAqIHJlc29sdXRpb25cclxuICAgICAgICBjZy5jdHgubGluZUpvaW4gPSAncm91bmQnXHJcbiAgICAgICAgY2cuY3R4LmxpbmVDYXAgPSAnYnV0dCdcclxuXHJcbiAgICAgICAgLy9mdW5jdGlvbiB0byBjb21wdXRlIHBvc2l0aW9uIG1vc2FpYyBlZmZlY3RcclxuICAgICAgICBjb25zdCBkID0gcmVzb2x1dGlvbiAqIHRoaXMubW9zYWljRmFjdG9yXHJcbiAgICAgICAgY29uc3QgbW9zYWljID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4geyB4OiBNYXRoLnJhbmRvbSgpICogZCwgeTogTWF0aC5yYW5kb20oKSAqIGQgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IHdpdGggSFRNTCBjYW52YXMgaW4gZ2VvIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgY2cuc2V0Q2FudmFzVHJhbnNmb3JtKClcclxuXHJcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICAvL3NldCBmaWxsIGNvbG9yXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sb3IgPyB0aGlzLmNvbG9yKGNlbGxbdGhpcy5jb2xvckNvbF0sIHJlc29sdXRpb24sIHN0YXRDb2xvcikgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKCFjb2wgfHwgY29sID09PSAnbm9uZScpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGNnLmN0eC5maWxsU3R5bGUgPSBjb2xcclxuXHJcbiAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjZWxsLCByZXNvbHV0aW9uLCB6ZilcclxuXHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSBwb3NpdGlvbiBtb3NhaWMgZWZmZWN0XHJcbiAgICAgICAgICAgIGNvbnN0IGxsID0gbW9zYWljKCksXHJcbiAgICAgICAgICAgICAgICB1bCA9IG1vc2FpYygpLFxyXG4gICAgICAgICAgICAgICAgbHIgPSBtb3NhaWMoKSxcclxuICAgICAgICAgICAgICAgIHVyID0gbW9zYWljKClcclxuXHJcbiAgICAgICAgICAgIC8vc3Ryb2tlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvd0ZhY3RvciA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhjZWxsLnggKyBvZmZzZXQuZHggKyBsbC54LCBjZWxsLnkgKyBvZmZzZXQuZHkgKyBsbC55KVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjZWxsLnggKyBvZmZzZXQuZHggKyByZXNvbHV0aW9uIC0gbHIueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgbHIueSlcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY2VsbC54ICsgb2Zmc2V0LmR4ICsgcmVzb2x1dGlvbiAtIHVyLngsIGNlbGwueSArIG9mZnNldC5keSArIHJlc29sdXRpb24gLSB1ci55KVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZmlsbFxyXG5cclxuICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oY2VsbC54ICsgb2Zmc2V0LmR4ICsgbGwueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgbGwueSlcclxuICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjZWxsLnggKyBvZmZzZXQuZHggKyByZXNvbHV0aW9uIC0gbHIueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgbHIueSlcclxuICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjZWxsLnggKyBvZmZzZXQuZHggKyByZXNvbHV0aW9uIC0gdXIueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgcmVzb2x1dGlvbiAtIHVyLnkpXHJcbiAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY2VsbC54ICsgb2Zmc2V0LmR4ICsgdWwueCwgY2VsbC55ICsgb2Zmc2V0LmR5ICsgcmVzb2x1dGlvbiAtIHVsLnkpXHJcbiAgICAgICAgICAgIGNnLmN0eC5maWxsKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcjogcmVzb2x1dGlvbiwgemY6IHpmLCBzQ29sb3I6IHN0YXRDb2xvciB9KVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTmluamFTdGFyU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3IgY29sb3IuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yQ29sID0gb3B0cy5jb2xvckNvbFxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIHRoZSBjZWxsLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgoKSA9PiAnI0VBNkJBQycpIC8vKHYscixzLHpmKSA9PiB7fVxyXG5cclxuICAgICAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGNvbHVtbi9hdHRyaWJ1dGUgb2YgdGhlIHRhYnVsYXIgZGF0YSB3aGVyZSB0byByZXRyaWV2ZSB0aGUgdmFyaWFibGUgZm9yIHNpemUuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnNpemVDb2wgPSBvcHRzLnNpemVDb2xcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaXplIG9mIGEgY2VsbCwgd2l0aGluIFswLDFdOlxyXG4gICAgICAgICAqICAtIDAsIG5vdGhpbmcgc2hvd25cclxuICAgICAgICAgKiAgLSAxLCBlbnRpcmUgc3F1YXJlXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5zaXplID0gb3B0cy5zaXplXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgc2hhcGUuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL0RhdGFzZXRcIikuQ2VsbCk6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuc2hhcGUgPSBvcHRzLnNoYXBlIHx8ICgoKSA9PiAnbycpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGNnXHJcbiAgICAgKi9cclxuICAgIGRyYXcoY2VsbHMsIHIsIGNnKSB7XHJcbiAgICAgICAgLy9maWx0ZXJcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxyXG5cclxuICAgICAgICAvL3pvb20gZmFjdG9yXHJcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXHJcblxyXG4gICAgICAgIGxldCBzdGF0U2l6ZVxyXG4gICAgICAgIGlmICh0aGlzLnNpemVDb2wpIHtcclxuICAgICAgICAgICAgLy9pZiBzaXplIGlzIHVzZWQsIHNvcnQgY2VsbHMgYnkgc2l6ZSBzbyB0aGF0IHRoZSBiaWdnZXN0IGFyZSBkcmF3biBmaXJzdFxyXG4gICAgICAgICAgICBjZWxscy5zb3J0KChjMSwgYzIpID0+IGMyW3RoaXMuc2l6ZUNvbF0gLSBjMVt0aGlzLnNpemVDb2xdKVxyXG4gICAgICAgICAgICAvL2FuZCBjb21wdXRlIHNpemUgdmFyaWFibGUgc3RhdGlzdGljc1xyXG4gICAgICAgICAgICBzdGF0U2l6ZSA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMuc2l6ZUNvbF0sIHRydWUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgc3RhdENvbG9yXHJcbiAgICAgICAgaWYgKHRoaXMuY29sb3JDb2wpIHtcclxuICAgICAgICAgICAgLy9jb21wdXRlIGNvbG9yIHZhcmlhYmxlIHN0YXRpc3RpY3NcclxuICAgICAgICAgICAgc3RhdENvbG9yID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5jb2xvckNvbF0sIHRydWUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgd2l0aCBIVE1MIGNhbnZhc1xyXG4gICAgICAgIC8vaW4gZ2VvIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgY2cuc2V0Q2FudmFzVHJhbnNmb3JtKClcclxuXHJcbiAgICAgICAgY29uc3QgcjIgPSByICogMC41XHJcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICAvL2NvbG9yXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sb3IgPyB0aGlzLmNvbG9yKGNlbGxbdGhpcy5jb2xvckNvbF0sIHIsIHN0YXRDb2xvciwgemYpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PT0gJ25vbmUnKSBjb250aW51ZVxyXG4gICAgICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gY29sXHJcblxyXG4gICAgICAgICAgICAvL3NoYXBlXHJcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5zaGFwZSA/IHRoaXMuc2hhcGUoY2VsbCkgOiAnbydcclxuICAgICAgICAgICAgaWYgKHNoYXBlID09PSAnbm9uZScpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL3NpemVcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgICAgICBsZXQgc18gPSB0aGlzLnNpemUgfHwgKCgpID0+IDAuNSlcclxuICAgICAgICAgICAgLy9zaXplIC0gaW4gZ2VvIHVuaXRcclxuICAgICAgICAgICAgY29uc3Qgc0cyID0gc18oY2VsbFt0aGlzLnNpemVDb2xdLCByLCBzdGF0U2l6ZSwgemYpICogcjJcclxuXHJcbiAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxyXG4gICAgICAgICAgICAvL1RPRE8gdXNlXHJcbiAgICAgICAgICAgIC8vY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoY2VsbCwgciwgemYpXHJcblxyXG4gICAgICAgICAgICAvL2NlbnRlciBwb3NpdGlvblxyXG4gICAgICAgICAgICBjb25zdCBjeCA9IGNlbGwueCArIHIyXHJcbiAgICAgICAgICAgIGNvbnN0IGN5ID0gY2VsbC55ICsgcjJcclxuXHJcbiAgICAgICAgICAgIGlmIChzaGFwZSA9PT0gJ3AnKSB7XHJcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oY3gsIGN5ICsgcjIpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4ICsgc0cyLCBjeSArIHNHMilcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY3ggKyByMiwgY3kpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4ICsgc0cyLCBjeSAtIHNHMilcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY3gsIGN5IC0gcjIpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4IC0gc0cyLCBjeSAtIHNHMilcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY3ggLSByMiwgY3kpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4IC0gc0cyLCBjeSArIHNHMilcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ28nKSB7XHJcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oY3gsIGN5ICsgc0cyKVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjeCArIHIyLCBjeSArIHIyKVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjeCArIHNHMiwgY3kpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4ICsgcjIsIGN5IC0gcjIpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4LCBjeSAtIHNHMilcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY3ggLSByMiwgY3kgLSByMilcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY3ggLSBzRzIsIGN5KVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjeCAtIHIyLCBjeSArIHIyKVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGwoKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNoYXBlOicgKyBzaGFwZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByOiByLCB6ZjogemYsIHNTaXplOiBzdGF0U2l6ZSwgc0NvbG9yOiBzdGF0Q29sb3IgfSlcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vU3R5bGUuanMnXHJcblxyXG4vKipcclxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBpbGxhclN0eWxlIGV4dGVuZHMgU3R5bGUge1xyXG4gICAgLy9UT0RPIG1ha2UgYSB3ZWJHTCB2ZXJzaW9uID9cclxuXHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0Q29sID0gb3B0cy5oZWlnaHRDb2xcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBoZWlnaHQgb2YgdGhlIGxpbmUgcmVwcmVzZW50aW5nIGEgY2VsbCwgaW4gZ2VvIHVuaXRcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCxudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0XHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3JDb2wgPSBvcHRzLmNvbG9yQ29sXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3Igb2YgdGhlIGxpbmUgcmVwcmVzZW50aW5nIGEgY2VsbC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCk6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgoKSA9PiAnI2MwOGM1OScpIC8vYmJcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy53aWR0aENvbCA9IG9wdHMud2lkdGhDb2xcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB3aWR0aCBvZiB0aGUgbGluZSByZXByZXNlbnRpbmcgYSBjZWxsLCBpbiBnZW8gdW5pdFxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8ICgodiwgcikgPT4gMC41ICogcilcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xyXG4gICAgICAgIHRoaXMuc2ltcGxlID0gb3B0cy5zaW1wbGUgPT0gdHJ1ZVxyXG5cclxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnZpZXdIZWlnaHRGYWN0b3IgPSBvcHRzLnZpZXdIZWlnaHRGYWN0b3IgfHwgMS41XHJcbiAgICAgICAgLy8wLDAgaXMgdGhlIGNlbnRlclxyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMudmlld1NYID0gb3B0cy52aWV3U1ggPT0gdW5kZWZpbmVkID8gMCA6IG9wdHMudmlld1NYXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy52aWV3U1kgPSBvcHRzLnZpZXdTWSA9PSB1bmRlZmluZWQgPyAtMC41IDogb3B0cy52aWV3U1lcclxuXHJcbiAgICAgICAgLy9UT0RPIHJlcGxhY2Ugd2l0aCBzdW4gbG9jYXRpb24gP1xyXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuc2hhZG93RGlyZWN0aW9uID1cclxuICAgICAgICAgICAgb3B0cy5zaGFkb3dEaXJlY3Rpb24gPT0gdW5kZWZpbmVkID8gKC00MC4zICogTWF0aC5QSSkgLyAxODAuMCA6IG9wdHMuc2hhZG93RGlyZWN0aW9uXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5zaGFkb3dGYWN0b3IgPSBvcHRzLnNoYWRvd0ZhY3RvciB8fCAwLjNcclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnNoYWRvd0NvbG9yID0gb3B0cy5zaGFkb3dDb2xvciB8fCAnIzAwMDAwMDMzJ1xyXG5cclxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLm91dGxpbmVDb2wgPSBvcHRzLm91dGxpbmVDb2wgfHwgJyNGRkZGRkYnXHJcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5vdXRsaW5lV2lkdGhQaXggPSBvcHRzLm91dGxpbmVXaWR0aFBpeCA9PSB1bmRlZmluZWQgPyAwLjUgOiBvcHRzLm91dGxpbmVXaWR0aFBpeFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBjZWxscyBhcyBzZWdtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcclxuICAgICAqL1xyXG4gICAgZHJhdyhjZWxscywgciwgY2cpIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vem9vbSBmYWN0b3JcclxuICAgICAgICBjb25zdCB6ZiA9IGNnLmdldFpmKClcclxuXHJcbiAgICAgICAgbGV0IHN0YXRIZWlnaHRcclxuICAgICAgICBpZiAodGhpcy5oZWlnaHRDb2wpIHtcclxuICAgICAgICAgICAgLy9jb21wdXRlIHNpemUgdmFyaWFibGUgc3RhdGlzdGljc1xyXG4gICAgICAgICAgICBzdGF0SGVpZ2h0ID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5oZWlnaHRDb2xdLCB0cnVlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHN0YXRDb2xvclxyXG4gICAgICAgIGlmICh0aGlzLmNvbG9yQ29sKSB7XHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSBjb2xvciB2YXJpYWJsZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgIHN0YXRDb2xvciA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMuY29sb3JDb2xdLCB0cnVlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHN0YXRXaWR0aFxyXG4gICAgICAgIGlmICh0aGlzLndpZHRoQ29sKSB7XHJcbiAgICAgICAgICAgIC8vYW5kIGNvbXB1dGUgc2l6ZSB2YXJpYWJsZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgIHN0YXRXaWR0aCA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMud2lkdGhDb2xdLCB0cnVlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9nZXQgdmlldyBjZW50ZXIgZ2VvIHBvc2l0aW9uXHJcbiAgICAgICAgY29uc3QgY3Z4ID0gY2cuZ2V0Q2VudGVyKCkueCArIHRoaXMudmlld1NYICogY2cudyAqIHpmXHJcbiAgICAgICAgY29uc3QgY3Z5ID0gY2cuZ2V0Q2VudGVyKCkueSArIHRoaXMudmlld1NZICogY2cuaCAqIHpmXHJcbiAgICAgICAgLy9nZXQgdmlldyBoZWlnaHRcclxuICAgICAgICBjb25zdCBIID0gdGhpcy52aWV3SGVpZ2h0RmFjdG9yICogKGNnLncgKyBjZy5oKSAqIDAuNSAqIHpmXHJcblxyXG4gICAgICAgIC8vc29ydCBjZWxscyBieSB5IGFuZCB4XHJcbiAgICAgICAgLy9jb25zdCBkaXN0VG9WaWV3Q2VudGVyID0gKGMpID0+IHsgY29uc3QgZHggPSBjdnggLSBjLngsIGR5ID0gY3Z5IC0gYy55OyByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSB9XHJcbiAgICAgICAgY2VsbHMuc29ydCgoYzEsIGMyKSA9PiAxMDAwMDAwMDAgKiAoYzIueSAtIGMxLnkpICsgYzEueCAtIGMyLngpXHJcblxyXG4gICAgICAgIGNnLmN0eC5saW5lQ2FwID0gdGhpcy5zaW1wbGUgPyAnYnV0dCcgOiAncm91bmQnXHJcblxyXG4gICAgICAgIC8vZHJhdyBpbiBnZW8gY29vcmRpbmF0ZXNcclxuICAgICAgICBjZy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxyXG5cclxuICAgICAgICAvL2RyYXcgc2hhZG93c1xyXG4gICAgICAgIGNnLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc2hhZG93Q29sb3JcclxuICAgICAgICBjZy5jdHguZmlsbFN0eWxlID0gdGhpcy5zaGFkb3dDb2xvclxyXG4gICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgLy93aWR0aFxyXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IHdHID0gdGhpcy53aWR0aCA/IHRoaXMud2lkdGgoY1t0aGlzLndpZHRoQ29sXSwgciwgc3RhdFdpZHRoLCB6ZikgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKCF3RyB8fCB3RyA8IDApIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL2hlaWdodFxyXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IGhHID0gdGhpcy5oZWlnaHQgPyB0aGlzLmhlaWdodChjW3RoaXMuaGVpZ2h0Q29sXSwgciwgc3RhdEhlaWdodCwgemYpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmICghaEcgfHwgaEcgPCAwKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9nZXQgb2Zmc2V0XHJcbiAgICAgICAgICAgIC8vVE9ETyB1c2UgdGhhdFxyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjLCByLCB6ZilcclxuXHJcbiAgICAgICAgICAgIC8vc2V0IHdpZHRoXHJcbiAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSB3R1xyXG5cclxuICAgICAgICAgICAgLy9jb21wdXRlIGNlbGwgY2VudHJlIHBvc3RpdGlvblxyXG4gICAgICAgICAgICBjb25zdCBjeCA9IGMueCArIHIgLyAyXHJcbiAgICAgICAgICAgIGNvbnN0IGN5ID0gYy55ICsgciAvIDJcclxuICAgICAgICAgICAgY29uc3QgbHMgPSBoRyAqIHRoaXMuc2hhZG93RmFjdG9yXHJcblxyXG4gICAgICAgICAgICAvL2RyYXcgc2VnbWVudFxyXG4gICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhjeCwgY3kpXHJcbiAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY3ggKyBscyAqIE1hdGguY29zKHRoaXMuc2hhZG93RGlyZWN0aW9uKSwgY3kgKyBscyAqIE1hdGguc2luKHRoaXMuc2hhZG93RGlyZWN0aW9uKSlcclxuICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICBpZiAodGhpcy5zaW1wbGUpIHtcclxuICAgICAgICAgICAgICAgIC8vZHJhdyBiYXNlIGNpcmNsZVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmFyYyhcclxuICAgICAgICAgICAgICAgICAgICBjeCwgY3ksXHJcbiAgICAgICAgICAgICAgICAgICAgd0cgKiAwLjUsXHJcbiAgICAgICAgICAgICAgICAgICAgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIC8vY2cuY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgfSovXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2RyYXcgcGlsbGFyc1xyXG4gICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgLy9jb2xvclxyXG4gICAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sb3IgPyB0aGlzLmNvbG9yKGNbdGhpcy5jb2xvckNvbF0sIHIsIHN0YXRDb2xvcikgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKCFjb2wpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL3dpZHRoXHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICAgICAgY29uc3Qgd0cgPSB0aGlzLndpZHRoID8gdGhpcy53aWR0aChjW3RoaXMud2lkdGhDb2xdLCByLCBzdGF0V2lkdGgsIHpmKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIXdHIHx8IHdHIDwgMCkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8vaGVpZ2h0XHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICAgICAgY29uc3QgaEcgPSB0aGlzLmhlaWdodCA/IHRoaXMuaGVpZ2h0KGNbdGhpcy5oZWlnaHRDb2xdLCByLCBzdGF0SGVpZ2h0LCB6ZikgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKCFoRyB8fCBoRyA8IDApIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcclxuICAgICAgICAgICAgLy9UT0RPIHVzZSB0aGF0XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGMsIHIsIHpmKVxyXG5cclxuICAgICAgICAgICAgLy9jb21wdXRlIGNlbGwgY2VudHJlIHBvc3RpdGlvblxyXG4gICAgICAgICAgICBjb25zdCBjeCA9IGMueCArIHIgLyAyXHJcbiAgICAgICAgICAgIGNvbnN0IGN5ID0gYy55ICsgciAvIDJcclxuXHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSBhbmdsZVxyXG4gICAgICAgICAgICBjb25zdCBkeCA9IGN4IC0gY3Z4LFxyXG4gICAgICAgICAgICAgICAgZHkgPSBjeSAtIGN2eVxyXG4gICAgICAgICAgICBjb25zdCBhID0gTWF0aC5hdGFuMihkeSwgZHgpXHJcbiAgICAgICAgICAgIGNvbnN0IEQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpXHJcbiAgICAgICAgICAgIGNvbnN0IGQgPSAoRCAqIGhHKSAvIChIIC0gaEcpXHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5zaW1wbGUpIHtcclxuICAgICAgICAgICAgICAgIC8vZHJhdyBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSB3R1xyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKGN4LCBjeSlcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY3ggKyBkICogTWF0aC5jb3MoYSksIGN5ICsgZCAqIE1hdGguc2luKGEpKVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgYmFja2dyb3VuZCBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLm91dGxpbmVDb2xcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSB3RyArIDIgKiB0aGlzLm91dGxpbmVXaWR0aFBpeCAqIHpmXHJcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oY3gsIGN5KVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjeCArIGQgKiBNYXRoLmNvcyhhKSwgY3kgKyBkICogTWF0aC5zaW4oYSkpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcclxuXHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gY29sXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVdpZHRoID0gd0dcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhjeCwgY3kpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGN4ICsgZCAqIE1hdGguY29zKGEpLCBjeSArIGQgKiBNYXRoLnNpbihhKSlcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZHJhdyB0b3AgY2lyY2xlXHJcbiAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLm91dGxpbmVDb2xcclxuICAgICAgICAgICAgICAgIC8vY2cuY3R4LmZpbGxTdHlsZSA9IFwiI2MwOGM1OVwiXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVdpZHRoID0gdGhpcy5vdXRsaW5lV2lkdGhQaXggKiB6ZlxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHguYXJjKGN4ICsgZCAqIE1hdGguY29zKGEpLCBjeSArIGQgKiBNYXRoLnNpbihhKSwgd0cgKiAwLjUsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSlcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKVxyXG4gICAgICAgICAgICAgICAgLy9jZy5jdHguZmlsbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2luIGNhc2UuLi5cclxuICAgICAgICBjZy5jdHgubGluZUNhcCA9ICdidXR0J1xyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXHJcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHI6IHIsIHpmOiB6Ziwgc0NvbG9yOiBzdGF0Q29sb3IgfSlcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vU3R5bGUuanMnXHJcblxyXG4vKipcclxuICogQSBzdHlsZSB3aGVyZSBlYWNoIGNlbGwgaXMgcmVwcmVzZW50ZWQgYnkgYSBzZWdtZW50IHdob3NlIGxlbmd0aCwgd2lkdGgsIGNvbG9yIGFuZCBvcmllbnRhdGlvbiBjYW4gdmFyeSBhY2NvcmRpbmcgdG8gc3RhdGlzdGljYWwgdmFsdWVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2VnbWVudFN0eWxlIGV4dGVuZHMgU3R5bGUge1xyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG9yaWVudGF0aW9uIChpbiBkZWdyZWVzKSBvZiB0aGUgc2VnbWVudCByZXByZXNlbnRpbmcgYSBjZWxsLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGwpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gb3B0cy5vcmllbnRhdGlvbiB8fCAoKCkgPT4gMClcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yQ29sID0gb3B0cy5jb2xvckNvbFxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIHRoZSBjZWxsIHNlZ21lbnQuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKCkgPT4gJyNFQTZCQUMnKVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMubGVuZ3RoQ29sID0gb3B0cy5sZW5ndGhDb2xcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBsZW5ndGggb2YgdGhlIHNlZ21lbnQgcmVwcmVzZW50aW5nIGEgY2VsbCwgaW4gZ2VvIHVuaXRcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCxudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLmxlbmd0aCA9IG9wdHMubGVuZ3RoXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy53aWR0aENvbCA9IG9wdHMud2lkdGhDb2xcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB3aWR0aCBvZiB0aGUgc2VnbWVudCByZXByZXNlbnRpbmcgYSBjZWxsLCBpbiBnZW8gdW5pdFxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGNlbGxzIGFzIHNlZ21lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gclxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9HZW9DYW52YXNcIikuR2VvQ2FudmFzfSBjZ1xyXG4gICAgICovXHJcbiAgICBkcmF3KGNlbGxzLCByLCBjZykge1xyXG4gICAgICAgIC8vZmlsdGVyXHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcclxuXHJcbiAgICAgICAgLy96b29tIGZhY3RvclxyXG4gICAgICAgIGNvbnN0IHpmID0gY2cuZ2V0WmYoKVxyXG5cclxuICAgICAgICBsZXQgc3RhdENvbG9yXHJcbiAgICAgICAgaWYgKHRoaXMuY29sb3JDb2wpIHtcclxuICAgICAgICAgICAgLy9jb21wdXRlIGNvbG9yIHZhcmlhYmxlIHN0YXRpc3RpY3NcclxuICAgICAgICAgICAgc3RhdENvbG9yID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5jb2xvckNvbF0sIHRydWUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgc3RhdExlbmd0aFxyXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aENvbCkge1xyXG4gICAgICAgICAgICAvL2lmIGxlbmd0aCBpcyB1c2VkLCBzb3J0IGNlbGxzIGJ5IGxlbmd0aCBzbyB0aGF0IHRoZSBsb25nZXN0cyBhcmUgZHJhd24gZmlyc3RcclxuICAgICAgICAgICAgY2VsbHMuc29ydCgoYzEsIGMyKSA9PiBjMlt0aGlzLmxlbmd0aENvbF0gLSBjMVt0aGlzLmxlbmd0aENvbF0pXHJcbiAgICAgICAgICAgIC8vYW5kIGNvbXB1dGUgc2l6ZSB2YXJpYWJsZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgIHN0YXRMZW5ndGggPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLmxlbmd0aENvbF0sIHRydWUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgc3RhdFdpZHRoXHJcbiAgICAgICAgaWYgKHRoaXMud2lkdGhDb2wpIHtcclxuICAgICAgICAgICAgLy9hbmQgY29tcHV0ZSBzaXplIHZhcmlhYmxlIHN0YXRpc3RpY3NcclxuICAgICAgICAgICAgc3RhdFdpZHRoID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy53aWR0aENvbF0sIHRydWUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGNnLmN0eC5saW5lQ2FwID0gJ2J1dHQnXHJcblxyXG4gICAgICAgIC8vY29udmVyc2lvbiBmYWN0b3IgZGVncmVlIC0+IHJhZGlhblxyXG4gICAgICAgIGNvbnN0IGYgPSBNYXRoLlBJIC8gMTgwXHJcblxyXG4gICAgICAgIC8vZHJhdyBpbiBnZW8gY29vcmRpbmF0ZXNcclxuICAgICAgICBjZy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxyXG5cclxuICAgICAgICBmb3IgKGxldCBjIG9mIGNlbGxzKSB7XHJcbiAgICAgICAgICAgIC8vY29sb3JcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yID8gdGhpcy5jb2xvcihjW3RoaXMuY29sb3JDb2xdLCByLCBzdGF0Q29sb3IpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmICghY29sKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy93aWR0aFxyXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IHdHID0gdGhpcy53aWR0aCA/IHRoaXMud2lkdGgoY1t0aGlzLndpZHRoQ29sXSwgciwgc3RhdFdpZHRoLCB6ZikgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKCF3RyB8fCB3RyA8IDApIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL2xlbmd0aFxyXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IGxHID0gdGhpcy5sZW5ndGggPyB0aGlzLmxlbmd0aChjW3RoaXMubGVuZ3RoQ29sXSwgciwgc3RhdExlbmd0aCwgemYpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmICghbEcgfHwgbEcgPCAwKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9vcmllbnRhdGlvbiAoaW4gcmFkaWFuKVxyXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICAgICAgY29uc3Qgb3IgPSB0aGlzLm9yaWVudGF0aW9uKGMpICogZlxyXG4gICAgICAgICAgICBpZiAob3IgPT09IHVuZGVmaW5lZCB8fCBpc05hTihvcikpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoYywgciwgemYpXHJcblxyXG4gICAgICAgICAgICAvL3NldCBjb2xvciBhbmQgd2lkdGhcclxuICAgICAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gY29sXHJcbiAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSB3R1xyXG5cclxuICAgICAgICAgICAgLy9jb21wdXRlIHNlZ21lbnQgY2VudHJlIHBvc3RpdGlvblxyXG4gICAgICAgICAgICBjb25zdCBjeCA9IGMueCArIHIgLyAyICsgb2Zmc2V0LmR4XHJcbiAgICAgICAgICAgIGNvbnN0IGN5ID0gYy55ICsgciAvIDIgKyBvZmZzZXQuZHlcclxuXHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSBzZWdtZW50IGRpcmVjdGlvblxyXG4gICAgICAgICAgICBjb25zdCBkeCA9IDAuNSAqIE1hdGguY29zKG9yKSAqIGxHXHJcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gMC41ICogTWF0aC5zaW4ob3IpICogbEdcclxuXHJcbiAgICAgICAgICAgIC8vZHJhdyBzZWdtZW50XHJcbiAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICBjZy5jdHgubW92ZVRvKGN4IC0gZHgsIGN5IC0gZHkpXHJcbiAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY3ggKyBkeCwgY3kgKyBkeSlcclxuICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmQsIGlmIGFueVxyXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7XHJcbiAgICAgICAgICAgIHdpZHRoRnVuOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICByOiByLFxyXG4gICAgICAgICAgICB6ZjogemYsXHJcbiAgICAgICAgICAgIHNDb2xvcjogc3RhdENvbG9yLFxyXG4gICAgICAgICAgICAvL3NMZW5ndGg6IHN0YXRMZW5ndGgsXHJcbiAgICAgICAgICAgIHNXaWR0aDogc3RhdFdpZHRoLFxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL1N0eWxlLmpzJ1xyXG5pbXBvcnQgeyBjb2xvciB9IGZyb20gJ2QzLWNvbG9yJ1xyXG5cclxuLyoqXHJcbiAqIEEgdmVyeSBnZW5lcmljIHN0eWxlIHRoYXQgc2hvd3MgZ3JpZCBjZWxscyB3aXRoIHNwZWNpZmljIGNvbG9yLCBzaXplIGFuZCBzaGFwZS5cclxuICogSXQgY2FuIGJlIHVzZWQgdG8gc2hvdyB2YXJpYWJsZXMgYXMgY2VsbCBjb2xvcnMsIGNlbGwgc2l6ZSwgY2VsbCBzaGFwZSwgb3IgYW55IGNvbWJpbmF0aW9uIG9mIHRoZSB0aHJlZSB2aXN1YWwgdmFyaWFibGVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEpvc2VwaCBEYXZpZXMsIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2hhcGVDb2xvclNpemVTdHlsZSBleHRlbmRzIFN0eWxlIHtcclxuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBjb2x1bW4vYXR0cmlidXRlIG9mIHRoZSB0YWJ1bGFyIGRhdGEgd2hlcmUgdG8gcmV0cmlldmUgdGhlIHZhcmlhYmxlIGZvciBjb2xvci5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3JDb2wgPSBvcHRzLmNvbG9yQ29sXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3Igb2YgdGhlIGNlbGwuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdHMuY29sb3IgfHwgKCgpID0+ICcjRUE2QkFDJykgLy8odixyLHMsemYpID0+IHt9XHJcblxyXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3Igc2l6ZS5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuc2l6ZUNvbCA9IG9wdHMuc2l6ZUNvbFxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpemUgb2YgYSBjZWxsIGluIGdlb2dyYXBoaWNhbCB1bml0LlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZVxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNoYXBlIG9mIGEgY2VsbC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsKTppbXBvcnQoXCIuLi9TdHlsZVwiKS5TaGFwZX0gKi9cclxuICAgICAgICB0aGlzLnNoYXBlID0gb3B0cy5zaGFwZSB8fCAoKCkgPT4gJ3NxdWFyZScpXHJcblxyXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3IgY29sb3IgYWxwaGEuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmFscGhhQ29sID0gb3B0cy5hbHBoYUNvbFxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIGFscGhhIG9mIHRoZSBjZWxsLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuYWxwaGFGID0gb3B0cy5hbHBoYUZcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgY2VsbHMgYXMgc3F1YXJlcywgd2l0aCB2YXJpb3VzIGNvbG9ycyBhbmQgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcclxuICAgICAqL1xyXG4gICAgZHJhdyhjZWxscywgciwgY2cpIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vem9vbSBmYWN0b3JcclxuICAgICAgICBjb25zdCB6ZiA9IGNnLmdldFpmKClcclxuXHJcbiAgICAgICAgbGV0IHN0YXRTaXplXHJcbiAgICAgICAgaWYgKHRoaXMuc2l6ZUNvbCkge1xyXG4gICAgICAgICAgICAvL2lmIHNpemUgaXMgdXNlZCwgc29ydCBjZWxscyBieSBzaXplIHNvIHRoYXQgdGhlIGJpZ2dlc3QgYXJlIGRyYXduIGZpcnN0XHJcbiAgICAgICAgICAgIGNlbGxzLnNvcnQoKGMxLCBjMikgPT4gYzJbdGhpcy5zaXplQ29sXSAtIGMxW3RoaXMuc2l6ZUNvbF0pXHJcbiAgICAgICAgICAgIC8vYW5kIGNvbXB1dGUgc2l6ZSB2YXJpYWJsZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgIHN0YXRTaXplID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5zaXplQ29sXSwgdHJ1ZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzdGF0Q29sb3JcclxuICAgICAgICBpZiAodGhpcy5jb2xvckNvbCkge1xyXG4gICAgICAgICAgICAvL2NvbXB1dGUgY29sb3IgdmFyaWFibGUgc3RhdGlzdGljc1xyXG4gICAgICAgICAgICBzdGF0Q29sb3IgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLmNvbG9yQ29sXSwgdHJ1ZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzdGF0QWxwaGFcclxuICAgICAgICBpZiAodGhpcy5hbHBoYUNvbCkge1xyXG4gICAgICAgICAgICAvL2NvbXB1dGUgY29sb3IgYWxwaGEgdmFyaWFibGUgc3RhdGlzdGljc1xyXG4gICAgICAgICAgICBzdGF0QWxwaGEgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLmFscGhhQ29sXSwgdHJ1ZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyB3aXRoIEhUTUwgY2FudmFzXHJcbiAgICAgICAgLy9pbiBnZW8gY29vcmRpbmF0ZXNcclxuICAgICAgICBjZy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxyXG5cclxuICAgICAgICBjb25zdCByMiA9IHIgKiAwLjVcclxuICAgICAgICBmb3IgKGxldCBjZWxsIG9mIGNlbGxzKSB7XHJcbiAgICAgICAgICAgIC8vY29sb3JcclxuICAgICAgICAgICAgbGV0IGNvbCA9IHRoaXMuY29sb3IgPyB0aGlzLmNvbG9yKGNlbGxbdGhpcy5jb2xvckNvbF0sIHIsIHN0YXRDb2xvciwgemYpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PT0gJ25vbmUnKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9hbHBoYVxyXG4gICAgICAgICAgICBpZiAodGhpcy5hbHBoYUNvbCAmJiB0aGlzLmFscGhhRikge1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgYWxwaGFcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFscGhhID0gdGhpcy5hbHBoYUYoY2VsbFt0aGlzLmFscGhhQ29sXSwgciwgc3RhdEFscGhhLCB6ZilcclxuICAgICAgICAgICAgICAgIGlmIChhbHBoYSA9PSAwKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgLy9hcHBseSBhbHBoYSB0byBjb2xvciBjb2xcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbF8gPSBjb2xvcihjb2wpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbF8pIGNvbCA9IGByZ2JhKCR7Y29sXy5yfSwgJHtjb2xfLmd9LCAke2NvbF8uYn0sICR7YWxwaGF9KWA7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBkZWNvZGUgY29sb3IgXCIgKyBjb2wgKyBcIiBpbiBTaGFwZUNvbG9yU2l6ZVN0eWxlXCIpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vc2hhcGVcclxuICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLnNoYXBlID8gdGhpcy5zaGFwZShjZWxsKSA6ICdzcXVhcmUnXHJcbiAgICAgICAgICAgIGlmIChzaGFwZSA9PT0gJ25vbmUnKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9zaXplXHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCxudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICAgICAgbGV0IHNfID0gdGhpcy5zaXplIHx8ICgoKSA9PiByKVxyXG4gICAgICAgICAgICAvL3NpemUgLSBpbiBnZW8gdW5pdFxyXG4gICAgICAgICAgICBjb25zdCBzRyA9IHNfKGNlbGxbdGhpcy5zaXplQ29sXSwgciwgc3RhdFNpemUsIHpmKVxyXG5cclxuICAgICAgICAgICAgLy9nZXQgb2Zmc2V0XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0KGNlbGwsIHIsIHpmKVxyXG5cclxuICAgICAgICAgICAgY2cuY3R4LmZpbGxTdHlsZSA9IGNvbFxyXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdzcXVhcmUnKSB7XHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgc3F1YXJlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gciAqICgxIC0gc0cgLyByKSAqIDAuNVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxSZWN0KGNlbGwueCArIGQgKyBvZmZzZXQuZHgsIGNlbGwueSArIGQgKyBvZmZzZXQuZHksIHNHLCBzRylcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2NpcmNsZScpIHtcclxuICAgICAgICAgICAgICAgIC8vZHJhdyBjaXJjbGVcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmFyYyhjZWxsLnggKyByMiArIG9mZnNldC5keCwgY2VsbC55ICsgcjIgKyBvZmZzZXQuZHksIHNHICogMC41LCAwLCAyICogTWF0aC5QSSwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbCgpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdkb251dCcpIHtcclxuICAgICAgICAgICAgICAgIC8vZHJhdyBkb251dFxyXG4gICAgICAgICAgICAgICAgY29uc3QgeGMgPSBjZWxsLnggKyByMiArIG9mZnNldC5keCxcclxuICAgICAgICAgICAgICAgICAgICB5YyA9IGNlbGwueSArIHIyICsgb2Zmc2V0LmR5XHJcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oeGMsIHljKVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmFyYyh4YywgeWMsIHIyLCAwLCAyICogTWF0aC5QSSlcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5hcmMoeGMsIHljLCAoMSAtIHNHIC8gcikgKiByMiwgMCwgMiAqIE1hdGguUEksIHRydWUpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHguY2xvc2VQYXRoKClcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsKClcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2RpYW1vbmQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzMiA9IHNHICogMC41XHJcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oY2VsbC54ICsgcjIgLSBzMiwgY2VsbC55ICsgcjIpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGNlbGwueCArIHIyLCBjZWxsLnkgKyByMiArIHMyKVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjZWxsLnggKyByMiArIHMyLCBjZWxsLnkgKyByMilcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY2VsbC54ICsgcjIsIGNlbGwueSArIHIyIC0gczIpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbCgpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2hhcGU6JyArIHNoYXBlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXHJcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHI6IHIsIHpmOiB6Ziwgc1NpemU6IHN0YXRTaXplLCBzQ29sb3I6IHN0YXRDb2xvciwgc0FscGhhOiBzdGF0QWxwaGEgfSlcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vU3R5bGUuanMnXHJcblxyXG4vKiogQHR5cGVkZWYge3t4Om51bWJlcix5Om51bWJlcixvcjpcInZcInxcImhcIix2MTpzdHJpbmd8dW5kZWZpbmVkLHYyOnN0cmluZ3x1bmRlZmluZWR9fSBTaWRlICovXHJcblxyXG4vKipcclxuICogQSBzdHlsZSB0byBzaG93IHRoZSBzaWRlcyBvZiBncmlkIGNlbGxzIGJhc2VkIG9uIHRoZWlyIGRpZmZlcmVudCBjYXRlZ29yaWVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2lkZUNhdFN0eWxlIGV4dGVuZHMgU3R5bGUge1xyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGNvbHVtbi9hdHRyaWJ1dGUgb2YgdGhlIHRhYnVsYXIgZGF0YSB3aGVyZSB0byByZXRyaWV2ZSB0aGUgY2F0ZWdvcmljYWwgdmFsdWUuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbCA9IG9wdHMuY29sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkaWN0aW9uYXJ5IChzdHJpbmcgLT4gY29sb3IpIHdoaWNoIGdpdmUgdGhlIGNvbG9yIG9mIGVhY2ggY2F0ZWdvcnkuXHJcbiAgICAgICAgICogQHR5cGUge29iamVjdH0gKi9cclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvclxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHdpZHRoIG9mIGEgY2VsbCBzaWRlIGxpbmUsIGluIGdlbyB1bml0XHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKFNpZGUsbnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoIHx8ICgoc2lkZSwgciwgeikgPT4gciAqIDAuMilcclxuXHJcbiAgICAgICAgLyoqIEEgZmlsbCBjb2xvciBmb3IgdGhlIGNlbGxzLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGwpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmZpbGxDb2xvciA9IG9wdHMuZmlsbENvbG9yXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcclxuICAgICAqL1xyXG4gICAgZHJhdyhjZWxscywgciwgY2cpIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIGlmICghY2VsbHMgfHwgY2VsbHMubGVuZ3RoID09IDApIHJldHVyblxyXG5cclxuICAgICAgICAvL3pvb20gZmFjdG9yXHJcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXHJcblxyXG4gICAgICAgIC8qKiAgQHR5cGUge0FycmF5LjxTaWRlPn0gKi9cclxuICAgICAgICBjb25zdCBzaWRlcyA9IFtdXHJcblxyXG4gICAgICAgIC8vbWFrZSBob3Jpem9udGFsIHNpZGVzXHJcbiAgICAgICAgLy9zb3J0IGNlbGxzIGJ5IHggYW5kIHlcclxuICAgICAgICBjZWxscy5zb3J0KChjMSwgYzIpID0+IChjMi54ID09IGMxLnggPyBjMS55IC0gYzIueSA6IGMxLnggLSBjMi54KSlcclxuICAgICAgICBsZXQgYzEgPSBjZWxsc1swXVxyXG4gICAgICAgIGxldCB2MSA9IGMxW3RoaXMuY29sXVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGMyID0gY2VsbHNbaV1cclxuICAgICAgICAgICAgbGV0IHYyID0gYzJbdGhpcy5jb2xdXHJcblxyXG4gICAgICAgICAgICBpZiAoYzEueSArIHIgPT0gYzIueSAmJiBjMS54ID09IGMyLngpIHtcclxuICAgICAgICAgICAgICAgIC8vY2VsbHMgaW4gc2FtZSBjb2x1bW4gYW5kIHRvdWNoIGFsb25nIGhvcml6b250YWwgc2lkZVxyXG4gICAgICAgICAgICAgICAgLy9tYWtlIHNoYXJlZCBzaWRlXHJcbiAgICAgICAgICAgICAgICBpZiAodjEgIT0gdjIpIHNpZGVzLnB1c2goeyB4OiBjMS54LCB5OiBjMi55LCBvcjogJ2gnLCB2MTogdjEsIHYyOiB2MiB9KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9jZWxscyBkbyBub3QgdG91Y2ggYWxvbmcgaG9yaXpvbnRhbCBzaWRlXHJcbiAgICAgICAgICAgICAgICAvL21ha2UgdHdvIHNpZGVzOiB0b3Agb25lIGZvciBjMSwgYm90dG9tIGZvciBjMlxyXG4gICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7IHg6IGMxLngsIHk6IGMxLnkgKyByLCBvcjogJ2gnLCB2MTogdjEsIHYyOiB1bmRlZmluZWQgfSlcclxuICAgICAgICAgICAgICAgIHNpZGVzLnB1c2goeyB4OiBjMi54LCB5OiBjMi55LCBvcjogJ2gnLCB2MTogdW5kZWZpbmVkLCB2MjogdjIgfSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYzEgPSBjMlxyXG4gICAgICAgICAgICB2MSA9IHYyXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL21ha2UgdmVydGljYWwgc2lkZXNcclxuICAgICAgICAvL3NvcnQgY2VsbHMgYnkgeSBhbmQgeFxyXG4gICAgICAgIGNlbGxzLnNvcnQoKGMxLCBjMikgPT4gKGMyLnkgPT0gYzEueSA/IGMxLnggLSBjMi54IDogYzEueSAtIGMyLnkpKVxyXG4gICAgICAgIGMxID0gY2VsbHNbMF1cclxuICAgICAgICB2MSA9IGMxW3RoaXMuY29sXVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGMyID0gY2VsbHNbaV1cclxuICAgICAgICAgICAgbGV0IHYyID0gYzJbdGhpcy5jb2xdXHJcblxyXG4gICAgICAgICAgICBpZiAoYzEueCArIHIgPT0gYzIueCAmJiBjMS55ID09IGMyLnkpIHtcclxuICAgICAgICAgICAgICAgIC8vY2VsbHMgaW4gc2FtZSByb3cgYW5kIHRvdWNoIGFsb25nIHZlcnRpY2FsIHNpZGVcclxuICAgICAgICAgICAgICAgIC8vbWFrZSBzaGFyZWQgc2lkZVxyXG4gICAgICAgICAgICAgICAgaWYgKHYxICE9IHYyKSBzaWRlcy5wdXNoKHsgeDogYzEueCArIHIsIHk6IGMxLnksIG9yOiAndicsIHYxOiB2MSwgdjI6IHYyIH0pXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2NlbGxzIGRvIG5vdCB0b3VjaCBhbG9uZyB2ZXJ0aWNhbCBzaWRlXHJcbiAgICAgICAgICAgICAgICAvL21ha2UgdHdvIHNpZGVzOiByaWdodCBvbmUgZm9yIGMxLCBsZWZ0IGZvciBjMlxyXG4gICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7IHg6IGMxLnggKyByLCB5OiBjMS55LCBvcjogJ3YnLCB2MTogdjEsIHYyOiB1bmRlZmluZWQgfSlcclxuICAgICAgICAgICAgICAgIHNpZGVzLnB1c2goeyB4OiBjMi54LCB5OiBjMi55LCBvcjogJ3YnLCB2MTogdW5kZWZpbmVkLCB2MjogdjIgfSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYzEgPSBjMlxyXG4gICAgICAgICAgICB2MSA9IHYyXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGlmIChzaWRlcy5sZW5ndGggPT0gMCkgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vZHJhdyBpbiBnZW8gY29vcmRpbmF0ZXNcclxuICAgICAgICBjZy5zZXRDYW52YXNUcmFuc2Zvcm0oKVxyXG5cclxuICAgICAgICAvL2RyYXcgY2VsbHMsIGlmIGZpbGxDb2xvciBzcGVjaWZpZWRcclxuICAgICAgICBpZiAodGhpcy5maWxsQ29sb3IpXHJcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZjID0gdGhpcy5maWxsQ29sb3IoYylcclxuICAgICAgICAgICAgICAgIGlmICghZmMgfHwgZmMgPT0gJ25vbmUnKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxTdHlsZSA9IGZjXHJcbiAgICAgICAgICAgICAgICBjZy5jdHguZmlsbFJlY3QoYy54LCBjLnksIHIsIHIpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kcmF3IHNpZGVzXHJcbiAgICAgICAgY2cuY3R4LmxpbmVDYXAgPSAnYnV0dCdcclxuICAgICAgICBmb3IgKGxldCBzIG9mIHNpZGVzKSB7XHJcbiAgICAgICAgICAgIC8vd2lkdGhcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgICAgICBjb25zdCB3RyA9IHRoaXMud2lkdGggPyB0aGlzLndpZHRoKHMsIHIsIHpmKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIXdHIHx8IHdHIDw9IDApIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGNvbnN0IHcyID0gd0cgKiAwLjVcclxuXHJcbiAgICAgICAgICAgIC8vc2V0IGNvbG9yIGFuZCB3aWR0aFxyXG4gICAgICAgICAgICBjZy5jdHgubGluZVdpZHRoID0gd0dcclxuXHJcbiAgICAgICAgICAgIC8vZHJhdyBzZWdtZW50IHdpdGggY29ycmVjdCBvcmllbnRhdGlvblxyXG4gICAgICAgICAgICBpZiAocy5vciA9PT0gJ2gnKSB7XHJcbiAgICAgICAgICAgICAgICAvL3RvcCBsaW5lXHJcbiAgICAgICAgICAgICAgICBpZiAocy52Mikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3Jbcy52Ml1cclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKHMueCwgcy55ICsgdzIpXHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhzLnggKyByLCBzLnkgKyB3MilcclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2JvdHRvbSBsaW5lXHJcbiAgICAgICAgICAgICAgICBpZiAocy52MSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3Jbcy52MV1cclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKHMueCwgcy55IC0gdzIpXHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhzLnggKyByLCBzLnkgLSB3MilcclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vcmlnaHQgbGluZVxyXG4gICAgICAgICAgICAgICAgaWYgKHMudjIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yW3MudjJdXHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhzLnggKyB3Miwgcy55KVxyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8ocy54ICsgdzIsIHMueSArIHIpXHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9sZWZ0IGxpbmVcclxuICAgICAgICAgICAgICAgIGlmIChzLnYxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcltzLnYxXVxyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8ocy54IC0gdzIsIHMueSlcclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKHMueCAtIHcyLCBzLnkgKyByKVxyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXHJcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHI6IHIsIHpmOiB6ZiB9KVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcclxuXHJcbi8qKiBAdHlwZWRlZiB7e3g6bnVtYmVyLHk6bnVtYmVyLG9yOlwidlwifFwiaFwiLHZhbHVlOm51bWJlcn19IFNpZGUgKi9cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2lkZVN0eWxlIGV4dGVuZHMgU3R5bGUge1xyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGNvbHVtbi9hdHRyaWJ1dGUgb2YgdGhlIHRhYnVsYXIgZGF0YSB3aGVyZSB0byByZXRyaWV2ZSB0aGUgdmFyaWFibGUgZm9yIHRoZSBjZWxsIHZhbHVlcy5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMudmFsdWVDb2wgPSBvcHRzLnZhbHVlQ29sXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgdmFsdWUgb2YgYSBjZWxsIHNpZGUuIFRoaXMgdmFsdWUgaXMgY29tcHV0ZWQgZnJvbSB0aGUgdHdvIGFkamFjZW50IGNlbGwgdmFsdWVzLlxyXG4gICAgICAgICAqIEZvciBob3Jpem9udGFsIHNpZGVzLCB2MSBpcyB0aGUgdmFsdWUgb2YgdGhlIGNlbGwgYmVsb3cgYW5kIHYyIHRoZSB2YWx1ZSBvZiB0aGUgY2VsbCBhYm92ZS5cclxuICAgICAgICAgKiBGb3IgdmVydGljYWwgc2lkZXMsIHYxIGlzIHRoZSB2YWx1ZSBvZiB0aGUgY2VsbCBsZWZ0IGFuZCB2MiB0aGUgdmFsdWUgb2YgdGhlIGNlbGwgcmlnaHQuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcnx1bmRlZmluZWQsbnVtYmVyfHVuZGVmaW5lZCxudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IG9wdHMudmFsdWUgfHwgKCh2MSwgdjIsIHIsIHMsIHpmKSA9PiAxKVxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIGEgY2VsbCBzaWRlLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihTaWRlLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCxudW1iZXIpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yID0gb3B0cy5jb2xvciB8fCAoKCkgPT4gJyNFQTZCQUMnKVxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHdpZHRoIG9mIGEgY2VsbCBzaWRlLCBpbiBnZW8gdW5pdFxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihTaWRlLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCxudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAoKHNpZGUsIHIsIHMsIHpmKSA9PiAociAqIHNpZGUudmFsdWUpIC8gNSlcclxuXHJcbiAgICAgICAgLyoqIG9yaWVudGF0aW9uLiBTZXQgdG8gOTAgdG8gc2hvdyBzaWRlcyBhcyBzbG9wZSBsaW5lcyBmb3IgZXhhbXBsZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSBvcHRzLm9yaWVudGF0aW9uIHx8IDBcclxuXHJcbiAgICAgICAgLyoqIEEgZmlsbCBjb2xvciBmb3IgdGhlIGNlbGxzLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGwpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmZpbGxDb2xvciA9IG9wdHMuZmlsbENvbG9yXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcclxuICAgICAqL1xyXG4gICAgZHJhdyhjZWxscywgciwgY2cpIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vem9vbSBmYWN0b3JcclxuICAgICAgICBjb25zdCB6ZiA9IGNnLmdldFpmKClcclxuXHJcbiAgICAgICAgLy9jb21wdXRlIHN0YXRzIG9uIGNlbGwgdmFsdWVzXHJcbiAgICAgICAgbGV0IHN0YXRWYWx1ZVxyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlQ29sKSB7XHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSBjb2xvciB2YXJpYWJsZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgIHN0YXRWYWx1ZSA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMudmFsdWVDb2xdLCB0cnVlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqICBAdHlwZSB7QXJyYXkuPFNpZGU+fSAqL1xyXG4gICAgICAgIGNvbnN0IHNpZGVzID0gW11cclxuXHJcbiAgICAgICAgLy9tYWtlIGhvcml6b250YWwgc2lkZXNcclxuICAgICAgICAvL3NvcnQgY2VsbHMgYnkgeCBhbmQgeVxyXG4gICAgICAgIGNlbGxzLnNvcnQoKGMxLCBjMikgPT4gKGMyLnggPT0gYzEueCA/IGMxLnkgLSBjMi55IDogYzEueCAtIGMyLngpKVxyXG4gICAgICAgIGxldCBjMSA9IGNlbGxzWzBdXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgYzIgPSBjZWxsc1tpXVxyXG5cclxuICAgICAgICAgICAgaWYgKChjMS55ICsgciA9PSBjMi55KSAmJiAoYzEueCA9PSBjMi54KSlcclxuICAgICAgICAgICAgICAgIC8vY2VsbHMgaW4gc2FtZSBjb2x1bW4gYW5kIHRvdWNoIGFsb25nIGhvcml6b250YWwgc2lkZVxyXG4gICAgICAgICAgICAgICAgLy9tYWtlIHNoYXJlZCBzaWRlXHJcbiAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBjMS54LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGMyLnksXHJcbiAgICAgICAgICAgICAgICAgICAgb3I6ICdoJyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZShjMVt0aGlzLnZhbHVlQ29sXSwgYzJbdGhpcy52YWx1ZUNvbF0sIHIsIHN0YXRWYWx1ZSwgemYpLFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2NlbGxzIGRvIG5vdCB0b3VjaCBhbG9uZyBob3Jpem9udGFsIHNpZGVcclxuICAgICAgICAgICAgICAgIC8vbWFrZSB0d28gc2lkZXM6IHRvcCBvbmUgZm9yIGMxLCBib3R0b20gZm9yIGMyXHJcbiAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBjMS54LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGMxLnkgKyByLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yOiAnaCcsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUoYzFbdGhpcy52YWx1ZUNvbF0sIHVuZGVmaW5lZCwgciwgc3RhdFZhbHVlLCB6ZiksXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgc2lkZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogYzIueCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBjMi55LFxyXG4gICAgICAgICAgICAgICAgICAgIG9yOiAnaCcsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUodW5kZWZpbmVkLCBjMlt0aGlzLnZhbHVlQ29sXSwgciwgc3RhdFZhbHVlLCB6ZiksXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjMSA9IGMyXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL21ha2UgdmVydGljYWwgc2lkZXNcclxuICAgICAgICAvL3NvcnQgY2VsbHMgYnkgeSBhbmQgeFxyXG4gICAgICAgIGNlbGxzLnNvcnQoKGMxLCBjMikgPT4gKGMyLnkgPT0gYzEueSA/IGMxLnggLSBjMi54IDogYzEueSAtIGMyLnkpKVxyXG4gICAgICAgIGMxID0gY2VsbHNbMF1cclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjMiA9IGNlbGxzW2ldXHJcblxyXG4gICAgICAgICAgICBpZiAoKGMxLnggKyByID09IGMyLngpICYmIChjMS55ID09IGMyLnkpKVxyXG4gICAgICAgICAgICAgICAgLy9jZWxscyBpbiBzYW1lIHJvdyBhbmQgdG91Y2ggYWxvbmcgdmVydGljYWwgc2lkZVxyXG4gICAgICAgICAgICAgICAgLy9tYWtlIHNoYXJlZCBzaWRlXHJcbiAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBjMS54ICsgcixcclxuICAgICAgICAgICAgICAgICAgICB5OiBjMS55LFxyXG4gICAgICAgICAgICAgICAgICAgIG9yOiAndicsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUoYzFbdGhpcy52YWx1ZUNvbF0sIGMyW3RoaXMudmFsdWVDb2xdLCByLCBzdGF0VmFsdWUsIHpmKSxcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9jZWxscyBkbyBub3QgdG91Y2ggYWxvbmcgdmVydGljYWwgc2lkZVxyXG4gICAgICAgICAgICAgICAgLy9tYWtlIHR3byBzaWRlczogcmlnaHQgb25lIGZvciBjMSwgbGVmdCBmb3IgYzJcclxuICAgICAgICAgICAgICAgIHNpZGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IGMxLnggKyByLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGMxLnksXHJcbiAgICAgICAgICAgICAgICAgICAgb3I6ICd2JyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZShjMVt0aGlzLnZhbHVlQ29sXSwgdW5kZWZpbmVkLCByLCBzdGF0VmFsdWUsIHpmKSxcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICBzaWRlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBjMi54LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGMyLnksXHJcbiAgICAgICAgICAgICAgICAgICAgb3I6ICd2JyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSh1bmRlZmluZWQsIGMyW3RoaXMudmFsdWVDb2xdLCByLCBzdGF0VmFsdWUsIHpmKSxcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGMxID0gYzJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgaWYgKHNpZGVzLmxlbmd0aCA9PSAwKSByZXR1cm5cclxuXHJcbiAgICAgICAgLy9jb21wdXRlIHN0YXRzIG9uIHNpZGVzXHJcbiAgICAgICAgY29uc3Qgc3RhdFNpZGVzID0gU2lkZVN0eWxlLmdldFNpZGVTdGF0aXN0aWNzKHNpZGVzLCB0cnVlKVxyXG5cclxuICAgICAgICAvL2RyYXcgaW4gZ2VvIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgY2cuc2V0Q2FudmFzVHJhbnNmb3JtKClcclxuXHJcbiAgICAgICAgLy9kcmF3IGNlbGxzLCBpZiBmaWxsQ29sb3Igc3BlY2lmaWVkXHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbENvbG9yKVxyXG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNlbGxzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmYyA9IHRoaXMuZmlsbENvbG9yKGMpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWZjIHx8IGZjID09ICdub25lJykgY29udGludWVcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5maWxsU3R5bGUgPSBmY1xyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmZpbGxSZWN0KGMueCwgYy55LCByLCByKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyBzaWRlc1xyXG4gICAgICAgIGNnLmN0eC5saW5lQ2FwID0gJ2J1dHQnXHJcbiAgICAgICAgY29uc3QgcjIgPSByIC8gMlxyXG4gICAgICAgIGZvciAobGV0IHMgb2Ygc2lkZXMpIHtcclxuICAgICAgICAgICAgLy9jb2xvclxyXG4gICAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sb3IgPyB0aGlzLmNvbG9yKHMsIHIsIHN0YXRTaWRlcywgemYpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmICghY29sIHx8IGNvbCA9PSAnbm9uZScpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL3dpZHRoXHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cclxuICAgICAgICAgICAgY29uc3Qgd0cgPSB0aGlzLndpZHRoID8gdGhpcy53aWR0aChzLCByLCBzdGF0U2lkZXMsIHpmKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIXdHIHx8IHdHIDw9IDApIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL3NldCBjb2xvciBhbmQgd2lkdGhcclxuICAgICAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gY29sXHJcbiAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSB3R1xyXG5cclxuICAgICAgICAgICAgLy9kcmF3IHNlZ21lbnQgd2l0aCBjb3JyZWN0IG9yaWVudGF0aW9uXHJcbiAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PSA5MCkge1xyXG4gICAgICAgICAgICAgICAgY2cuY3R4Lm1vdmVUbyhzLnggKyByMiwgcy55ICsgcjIpXHJcbiAgICAgICAgICAgICAgICBpZiAocy5vciA9PT0gJ2gnKSBjZy5jdHgubGluZVRvKHMueCArIHIyLCBzLnkgLSByMilcclxuICAgICAgICAgICAgICAgIGVsc2UgY2cuY3R4LmxpbmVUbyhzLnggLSByMiwgcy55ICsgcjIpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKHMueCwgcy55KVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhzLnggKyAocy5vciA9PT0gJ2gnID8gciA6IDApLCBzLnkgKyAocy5vciA9PT0gJ3YnID8gciA6IDApKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByOiByLCB6ZjogemYgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgc29tZSBzdGF0aXN0aWNzIG9uIGEgdmFsdWUgb2Ygc29tZSBzaWRlcy5cclxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBkZWZpbmUgaG93IHRvIGRyYXcgc3BlY2lmaWNhbGx5IHRoZSBzaWRlcyB3aXRoaW4gdGhlIHZpZXcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48U2lkZT59IHNpZGVzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZVplcm9zXHJcbiAgICAgKiBAcmV0dXJucyB7aW1wb3J0KFwiLi4vU3R5bGVcIikuU3RhdCB8IHVuZGVmaW5lZH1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFNpZGVTdGF0aXN0aWNzKHNpZGVzLCBpZ25vcmVaZXJvcykge1xyXG4gICAgICAgIGlmICghc2lkZXMgfHwgc2lkZXMubGVuZ3RoID09IDApIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICBsZXQgbWluID0gSW5maW5pdHlcclxuICAgICAgICBsZXQgbWF4ID0gLUluZmluaXR5XHJcbiAgICAgICAgLy9sZXQgc3VtID0gMFxyXG4gICAgICAgIC8vbGV0IG5iID0gMFxyXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBzaWRlcykge1xyXG4gICAgICAgICAgICBjb25zdCB2ID0gcy52YWx1ZVxyXG4gICAgICAgICAgICBpZiAoaWdub3JlWmVyb3MgJiYgIXYpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGlmICh2IDwgbWluKSBtaW4gPSB2XHJcbiAgICAgICAgICAgIGlmICh2ID4gbWF4KSBtYXggPSB2XHJcbiAgICAgICAgICAgIC8vc3VtICs9IHZcclxuICAgICAgICAgICAgLy9uYisrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IG1pbjogbWluLCBtYXg6IG1heCB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL1N0eWxlLmpzJ1xyXG5pbXBvcnQgeyBtYWtlV2ViR0xDYW52YXMgfSBmcm9tICcuLi91dGlscy93ZWJHTFV0aWxzLmpzJ1xyXG5pbXBvcnQgeyBXZWJHTFNxdWFyZUNvbG9yaW5nQ2F0QWR2YW5jZWQgfSBmcm9tICcuLi91dGlscy9XZWJHTFNxdWFyZUNvbG9yaW5nQ2F0QWR2YW5jZWQuanMnXHJcbmltcG9ydCB7IG1vbml0b3IsIG1vbml0b3JEdXJhdGlvbiB9IGZyb20gJy4uL3V0aWxzL1V0aWxzLmpzJ1xyXG5cclxuLyoqXHJcbiAqIFN0eWxlIGJhc2VkIG9uIHdlYkdMXHJcbiAqIFRvIHNob3cgY2VsbHMgYXMgY29sb3JlZCBzcXVhcmVzLCBmcm9tIGNhdGVnb3JpZXMuXHJcbiAqIEFsbHMgc3F1YXJlcyB3aXRoIHRoZSBzYW1lIHNpemVcclxuICpcclxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNxdWFyZUNvbG9yQ2F0V0dMU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICAvKiogQHBhcmFtIHtvYmplY3R9IG9wdHMgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKVxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBjb2x1bW4vYXR0cmlidXRlIG9mIHRoZSB0YWJ1bGFyIGRhdGEgd2hlcmUgdG8gcmV0cmlldmUgdGhlIGNhdGVnb3J5IG9mIHRoZSBjZWxsLCBmb3IgY29sb3JpbmcuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yQ29sID0gb3B0cy5jb2xvckNvbFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGljdGlvbmFyeSAoc3RyaW5nIC0+IGNvbG9yKSB3aGljaCBnaXZlIHRoZSBjb2xvciBvZiBlYWNoIGNhdGVnb3J5LlxyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9ICovXHJcbiAgICAgICAgb3B0cy5jb2xvciA9IG9wdHMuY29sb3IgfHwgdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7IEFycmF5LjxzdHJpbmc+IH0gQHByaXZhdGUgKi9cclxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0cy5jb2xvcilcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHsgb2JqZWN0IH0gQHByaXZhdGUgKi9cclxuICAgICAgICB0aGlzLmNhdFRvSSA9IHt9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB0aGlzLmNhdFRvSVtrZXlzW2ldXSA9IGkgKyAnJ1xyXG5cclxuICAgICAgICAvKiogQHR5cGUgeyBBcnJheS48c3RyaW5nPiB9IEBwcml2YXRlICovXHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBbXVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9ycy5wdXNoKG9wdHMuY29sb3JbJycgKyBrZXlzW2ldXSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaXplIG9mIHRoZSBjZWxscywgaW4gZ2VvZ3JhcGhpY2FsIHVuaXQuIEFsbCBjZWxscyBoYXZlIHRoZSBzYW1lIHNpemUuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLnNpemUgPSBvcHRzLnNpemUgLy8gKHJlc29sdXRpb24sIHpmKSA9PiAuLi5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7IFdlYkdMU3F1YXJlQ29sb3JpbmdDYXRBZHZhbmNlZCB9ICovXHJcbiAgICAgICAgdGhpcy53Z3AgPSBuZXcgV2ViR0xTcXVhcmVDb2xvcmluZ0NhdEFkdmFuY2VkKHRoaXMuY29sb3JzKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48aW1wb3J0KFwiLi4vRGF0YXNldFwiKS5DZWxsPn0gY2VsbHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByXHJcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0dlb0NhbnZhc1wiKS5HZW9DYW52YXN9IGNnXHJcbiAgICAgKi9cclxuICAgIGRyYXcoY2VsbHMsIHIsIGNnKSB7XHJcbiAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignKioqIFNxdWFyZUNvbG9yQ2F0V0dMU3R5bGUgZHJhdycpXHJcblxyXG4gICAgICAgIC8vZmlsdGVyXHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcclxuXHJcbiAgICAgICAgLy96b29tIGZhY3RvclxyXG4gICAgICAgIGNvbnN0IHpmID0gY2cuZ2V0WmYoKVxyXG5cclxuICAgICAgICAvL2FkZCB2ZXJ0aWNlIGFuZCBmcmFnbWVudCBkYXRhXHJcbiAgICAgICAgY29uc3QgcjIgPSByIC8gMlxyXG4gICAgICAgIGxldCBjLFxyXG4gICAgICAgICAgICBuYiA9IGNlbGxzLmxlbmd0aFxyXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzQnVmZmVyID0gW11cclxuICAgICAgICBjb25zdCBpQnVmZmVyID0gW11cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iOyBpKyspIHtcclxuICAgICAgICAgICAgYyA9IGNlbGxzW2ldXHJcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IGNbdGhpcy5jb2xvckNvbF1cclxuICAgICAgICAgICAgaWYgKGNhdCA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbmV4cGVjdGVkIGNhdGVnb3J5OiAnICsgY2F0KVxyXG4gICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgICAgICAgICAgY29uc3QgaV8gPSB0aGlzLmNhdFRvSVtjYXRdXHJcbiAgICAgICAgICAgIGlmIChpc05hTigraV8pKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5leHBlY3RlZCBjYXRlZ29yeSBpbmRleDogJyArIGNhdCArICcgJyArIGlfKVxyXG4gICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2ZXJ0aWNlc0J1ZmZlci5wdXNoKGMueCArIHIyLCBjLnkgKyByMilcclxuICAgICAgICAgICAgaUJ1ZmZlci5wdXNoKCtpXylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyAgIHdlYmdsIHByb2dyYW0gaW5wdXRzIHByZXBhcmF0aW9uJylcclxuXHJcbiAgICAgICAgLy9jcmVhdGUgY2FudmFzIGFuZCB3ZWJnbCByZW5kZXJlclxyXG4gICAgICAgIGNvbnN0IGN2V0dMID0gbWFrZVdlYkdMQ2FudmFzKGNnLncgKyAnJywgY2cuaCArICcnKVxyXG4gICAgICAgIGlmICghY3ZXR0wpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gd2ViR0wnKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignICAgd2ViIEdMIGNhbnZhcyBjcmVhdGlvbicpXHJcblxyXG4gICAgICAgIC8vZHJhd1xyXG4gICAgICAgIGNvbnN0IHNpemVHZW8gPSB0aGlzLnNpemUgPyB0aGlzLnNpemUociwgemYpIDogciArIDAuMiAqIHpmXHJcbiAgICAgICAgdGhpcy53Z3AuZHJhdyhjdldHTC5nbCwgdmVydGljZXNCdWZmZXIsIGlCdWZmZXIsIGNnLmdldFdlYkdMVHJhbnNmb3JtKCksIHNpemVHZW8gLyB6ZilcclxuXHJcbiAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignICAgd2ViZ2wgZHJhd2luZycpXHJcblxyXG4gICAgICAgIC8vZHJhdyBpbiBjYW52YXMgZ2VvXHJcbiAgICAgICAgY2cuaW5pdENhbnZhc1RyYW5zZm9ybSgpXHJcbiAgICAgICAgY2cuY3R4LmRyYXdJbWFnZShjdldHTC5jYW52YXMsIDAsIDApXHJcblxyXG4gICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyAgIGNhbnZhcyBkcmF3aW5nJylcclxuXHJcbiAgICAgICAgLy91cGRhdGUgbGVnZW5kc1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kcyh7IHN0eWxlOiB0aGlzLCByOiByLCB6ZjogemYgfSlcclxuXHJcbiAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignKioqIFNxdWFyZUNvbG9yQ2F0V0dMU3R5bGUgZW5kIGRyYXcnKVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcclxuaW1wb3J0IHsgbWFrZVdlYkdMQ2FudmFzIH0gZnJvbSAnLi4vdXRpbHMvd2ViR0xVdGlscy5qcydcclxuaW1wb3J0IHsgV2ViR0xTcXVhcmVDb2xvcmluZ0FkdmFuY2VkIH0gZnJvbSAnLi4vdXRpbHMvV2ViR0xTcXVhcmVDb2xvcmluZ0FkdmFuY2VkLmpzJ1xyXG5pbXBvcnQgeyBtb25pdG9yLCBtb25pdG9yRHVyYXRpb24gfSBmcm9tICcuLi91dGlscy9VdGlscy5qcydcclxuXHJcbi8qKlxyXG4gKiBTdHlsZSBiYXNlZCBvbiB3ZWJHTFxyXG4gKiBUbyBzaG93IGNlbGxzIGFzIGNvbG9yZWQgc3F1YXJlcywgd2l0aCBjb21wdXRhdGlvbiBvZiB0aGUgY29sb3JzIG9uIEdQVSBzaWRlIChmYXN0ZXIgdGhhbiBKYXZhU2NyaXB0IHNpZGUpLlxyXG4gKiBBbGxzIHNxdWFyZXMgd2l0aCB0aGUgc2FtZSBzaXplXHJcbiAqXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTcXVhcmVDb2xvcldHTFN0eWxlIGV4dGVuZHMgU3R5bGUge1xyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3IgY29sb3IuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yQ29sID0gb3B0cy5jb2xvckNvbFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgdCB2YWx1ZSAod2l0aGluIFswLDFdKSBvZiB0aGUgY2VsbC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0KTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy50RnVuID0gb3B0cy50RnVuIHx8ICgodiwgciwgcykgPT4gdiAvIHMubWF4KVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXN0cmlidXRpb24gc3RyZXRjaGluZyBtZXRob2QuXHJcbiAgICAgICAgICogVGhlIHN0cmV0Y2hpbmcgaXMgcGVyZm9ybWVkIG9uIEdQVSBzaWRlIChmcmFnbWVudCBzaGFkZXIpLlxyXG4gICAgICAgICAqIEB0eXBlIHt7IGZ1bjpzdHJpbmcsIGFscGhhOm51bWJlciB9fSAqL1xyXG4gICAgICAgIHRoaXMuc3RyZXRjaGluZyA9IG9wdHMuc3RyZXRjaGluZ1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2FtcGxlIG9mIHRoZSBjb2xvciByYW1wLlxyXG4gICAgICAgICAqIFRoZSBjb2xvciBpcyBjb21wdXRlZCBvbiBHUFUgc2lkZSAoZnJhZ21lbnQgc2hhZGVyKSBiYXNlZCBvbiB0aG9zZSB2YWx1ZXMgKGxpbmVhciBpbnRlcnBvbGF0aW9uKS5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59ICovXHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPVxyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyB8fFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAncmdiKDE1OCwgMSwgNjYpJyxcclxuICAgICAgICAgICAgICAgICdyZ2IoMjQ4LCAxNDIsIDgzKScsXHJcbiAgICAgICAgICAgICAgICAncmdiKDI1MSwgMjQ4LCAxNzYpJyxcclxuICAgICAgICAgICAgICAgICdyZ2IoMTM3LCAyMDcsIDE2NSknLFxyXG4gICAgICAgICAgICAgICAgJ3JnYig5NCwgNzksIDE2MiknLFxyXG4gICAgICAgICAgICBdLnJldmVyc2UoKVxyXG4gICAgICAgIGlmIChvcHRzLmNvbG9yKVxyXG4gICAgICAgICAgICB0aGlzLmNvbG9ycyA9IFtcclxuICAgICAgICAgICAgICAgIG9wdHMuY29sb3IoMCksXHJcbiAgICAgICAgICAgICAgICBvcHRzLmNvbG9yKDAuMiksXHJcbiAgICAgICAgICAgICAgICBvcHRzLmNvbG9yKDAuNCksXHJcbiAgICAgICAgICAgICAgICBvcHRzLmNvbG9yKDAuNiksXHJcbiAgICAgICAgICAgICAgICBvcHRzLmNvbG9yKDAuOCksXHJcbiAgICAgICAgICAgICAgICBvcHRzLmNvbG9yKDEpLFxyXG4gICAgICAgICAgICBdXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZSB0aGUgb3BhY2l0eSBvZiB0aGUgc3R5bGUsIHdpdGhpbiBbMCwxXS5cclxuICAgICAgICAgKiBJZiB0aGlzIG9wYWNpdHkgaXMgZGVmaW5lZCwgdGhlIGluZGl2aWR1YWwgY29sb3Igb3BhY2l0eSB3aWxsIGJlIGlnbm9yZWQuXHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcHRzLm9wYWNpdHkgLy8gKHIsemYpID0+IC4uLlxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgc2l6ZSBvZiB0aGUgY2VsbHMsIGluIGdlb2dyYXBoaWNhbCB1bml0LiBBbGwgY2VsbHMgaGF2ZSB0aGUgc2FtZSBzaXplLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5zaXplID0gb3B0cy5zaXplIC8vIChyZXNvbHV0aW9uLCB6ZikgPT4gLi4uXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcclxuICAgICAqL1xyXG4gICAgZHJhdyhjZWxscywgciwgY2cpIHtcclxuICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcqKiogU3F1YXJlQ29sb3JXR0xTdHlsZSBkcmF3JylcclxuXHJcbiAgICAgICAgLy9maWx0ZXJcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIGNlbGxzID0gY2VsbHMuZmlsdGVyKHRoaXMuZmlsdGVyKVxyXG5cclxuICAgICAgICAvL3pvb20gZmFjdG9yXHJcbiAgICAgICAgY29uc3QgemYgPSBjZy5nZXRaZigpXHJcblxyXG4gICAgICAgIC8vY29tcHV0ZSBjb2xvciB2YXJpYWJsZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgY29uc3Qgc3RhdENvbG9yID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5jb2xvckNvbF0sIHRydWUpXHJcbiAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignICAgY29sb3Igc3RhdHMgY29tcHV0YXRpb24nKVxyXG5cclxuICAgICAgICBpZiAoIXN0YXRDb2xvcikgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vY3JlYXRlIGNhbnZhcyBhbmQgd2ViZ2wgcmVuZGVyZXJcclxuICAgICAgICAvL2ZvciBvcGFjaXR5IGNvbnRyb2wsIHNlZTogaHR0cHM6Ly93ZWJnbGZ1bmRhbWVudGFscy5vcmcvd2ViZ2wvbGVzc29ucy93ZWJnbC1hbmQtYWxwaGEuaHRtbFxyXG4gICAgICAgIGNvbnN0IGN2V0dMID0gbWFrZVdlYkdMQ2FudmFzKFxyXG4gICAgICAgICAgICBjZy53ICsgJycsXHJcbiAgICAgICAgICAgIGNnLmggKyAnJyxcclxuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ICE9IHVuZGVmaW5lZCA/IHsgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSB9IDogdW5kZWZpbmVkXHJcbiAgICAgICAgKVxyXG4gICAgICAgIGlmICghY3ZXR0wpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gd2ViR0wnKVxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vbml0b3IpIG1vbml0b3JEdXJhdGlvbignICAgd2ViIEdMIGNhbnZhcyBjcmVhdGlvbicpXHJcblxyXG4gICAgICAgIC8vYWRkIHZlcnRpY2UgYW5kIGZyYWdtZW50IGRhdGFcclxuICAgICAgICBjb25zdCByMiA9IHIgLyAyXHJcbiAgICAgICAgY29uc3QgdmVydGljZXNCdWZmZXIgPSBbXVxyXG4gICAgICAgIGNvbnN0IHRCdWZmZXIgPSBbXVxyXG4gICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMudEZ1bihjW3RoaXMuY29sb3JDb2xdLCByLCBzdGF0Q29sb3IpXHJcbiAgICAgICAgICAgIGlmICh0ID09IG51bGwgfHwgdCA9PSB1bmRlZmluZWQpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIHZlcnRpY2VzQnVmZmVyLnB1c2goYy54ICsgcjIsIGMueSArIHIyKVxyXG4gICAgICAgICAgICB0QnVmZmVyLnB1c2godCA+IDEgPyAxIDogdCA8IDAgPyAwIDogdClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyAgIHdlYmdsIGRyYXdpbmcgZGF0YSBwcmVwYXJhdGlvbicpXHJcblxyXG4gICAgICAgIC8vY29tcHV0ZSBwaXhlbCBzaXplXHJcbiAgICAgICAgY29uc3Qgc2l6ZUdlbyA9IHRoaXMuc2l6ZSA/IHRoaXMuc2l6ZShyLCB6ZikgOiByICsgMC4yICogemZcclxuXHJcbiAgICAgICAgLy9jb21wdXRlIG9wYWNpdHlcclxuICAgICAgICBjb25zdCBvcCA9IHRoaXMub3BhY2l0eSA/IHRoaXMub3BhY2l0eShyLCB6ZikgOiB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBjb25zdCB3Z3AgPSBuZXcgV2ViR0xTcXVhcmVDb2xvcmluZ0FkdmFuY2VkKGN2V0dMLmdsLCB0aGlzLmNvbG9ycywgdGhpcy5zdHJldGNoaW5nLCBzaXplR2VvIC8gemYsIG9wKVxyXG5cclxuICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcgICB3ZWJnbCBwcm9ncmFtIHByZXBhcmF0aW9uJylcclxuXHJcbiAgICAgICAgLy9kcmF3XHJcbiAgICAgICAgd2dwLmRyYXcodmVydGljZXNCdWZmZXIsIHRCdWZmZXIsIGNnLmdldFdlYkdMVHJhbnNmb3JtKCkpXHJcblxyXG4gICAgICAgIGlmIChtb25pdG9yKSBtb25pdG9yRHVyYXRpb24oJyAgIHdlYmdsIGRyYXdpbmcnKVxyXG5cclxuICAgICAgICAvL2RyYXcgaW4gY2FudmFzIGdlb1xyXG4gICAgICAgIGNnLmluaXRDYW52YXNUcmFuc2Zvcm0oKVxyXG4gICAgICAgIGNnLmN0eC5kcmF3SW1hZ2UoY3ZXR0wuY2FudmFzLCAwLCAwKVxyXG5cclxuICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcgICBjYW52YXMgZHJhd2luZycpXHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGxlZ2VuZHNcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcjogciwgemY6IHpmLCBzQ29sb3I6IHN0YXRDb2xvciB9KVxyXG5cclxuICAgICAgICBpZiAobW9uaXRvcikgbW9uaXRvckR1cmF0aW9uKCcqKiogU3F1YXJlQ29sb3JXR0xTdHlsZSBlbmQgZHJhdycpXHJcbiAgICB9XHJcbn1cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gJy4uL1N0eWxlLmpzJ1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTdHJva2VTdHlsZSBleHRlbmRzIFN0eWxlIHtcclxuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBjb2x1bW4vYXR0cmlidXRlIG9mIHRoZSB0YWJ1bGFyIGRhdGEgd2hlcmUgdG8gcmV0cmlldmUgdGhlIHZhcmlhYmxlIGZvciBjb2xvci5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3JDb2wgPSBvcHRzLnN0cm9rZUNvbG9yQ29sXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgY29sb3Igb2YgdGhlIHN0cm9rZS5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCk6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBvcHRzLnN0cm9rZUNvbG9yIHx8ICgoKSA9PiAnIzY2NicpXHJcblxyXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3Igc2l6ZS5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuc2l6ZUNvbCA9IG9wdHMuc2l6ZUNvbFxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHNpemUgb2YgYSBjZWxsIGluIGdlb2dyYXBoaWNhbCB1bml0LlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZVxyXG5cclxuICAgICAgICAvKiogVGhlIHN0cm9rZSBsaW5lIHdpZHRoLCBpbiBwaXhlbHMuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoQ29sID0gb3B0cy5zdHJva2VXaWR0aENvbFxyXG5cclxuICAgICAgICAvKiogVGhlIHN0cm9rZSBsaW5lIHdpZHRoIGluIGdlb2dyYXBoaWNhbCB1bml0LlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoIC8vICh2LHIscyx6KT0+Li4uXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgc2hhcGUgb2YgYSBjZWxsLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGwpOmltcG9ydChcIi4uL1N0eWxlXCIpLlNoYXBlfSAqL1xyXG4gICAgICAgIHRoaXMuc2hhcGUgPSBvcHRzLnNoYXBlIHx8ICgoKSA9PiAnc3F1YXJlJylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgY2VsbHMgYXMgc3F1YXJlcywgd2l0aCB2YXJpb3VzIGNvbG9ycyBhbmQgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxpbXBvcnQoXCIuLi9EYXRhc2V0XCIpLkNlbGw+fSBjZWxsc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJcclxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vR2VvQ2FudmFzXCIpLkdlb0NhbnZhc30gY2dcclxuICAgICAqL1xyXG4gICAgZHJhdyhjZWxscywgciwgY2cpIHtcclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vem9vbSBmYWN0b3JcclxuICAgICAgICBjb25zdCB6ZiA9IGNnLmdldFpmKClcclxuXHJcbiAgICAgICAgbGV0IHN0YXRDb2xvclxyXG4gICAgICAgIGlmICh0aGlzLnN0cm9rZUNvbG9yQ29sKSBzdGF0Q29sb3IgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLnN0cm9rZUNvbG9yQ29sXSwgdHJ1ZSlcclxuXHJcbiAgICAgICAgbGV0IHN0YXRTaXplXHJcbiAgICAgICAgaWYgKHRoaXMuc2l6ZUNvbCkgc3RhdFNpemUgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLnNpemVDb2xdLCB0cnVlKVxyXG5cclxuICAgICAgICBsZXQgc3RhdFdpZHRoXHJcbiAgICAgICAgaWYgKHRoaXMuc3Ryb2tlV2lkdGhDb2wpIHN0YXRXaWR0aCA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMuc3Ryb2tlV2lkdGhDb2xdLCB0cnVlKVxyXG5cclxuICAgICAgICAvL2RyYXcgd2l0aCBIVE1MIGNhbnZhc1xyXG4gICAgICAgIC8vaW4gZ2VvIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgY2cuc2V0Q2FudmFzVHJhbnNmb3JtKClcclxuXHJcbiAgICAgICAgY29uc3QgcjIgPSByICogMC41XHJcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICAvL2NvbG9yXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuc3Ryb2tlQ29sb3JcclxuICAgICAgICAgICAgICAgID8gdGhpcy5zdHJva2VDb2xvcihjZWxsW3RoaXMuc3Ryb2tlQ29sb3JDb2xdLCByLCBzdGF0Q29sb3IpXHJcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIWNvbCB8fCBjb2wgPT09ICdub25lJykgY29udGludWVcclxuICAgICAgICAgICAgY2cuY3R4LnN0cm9rZVN0eWxlID0gY29sXHJcblxyXG4gICAgICAgICAgICAvL3NpemVcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgICAgICBsZXQgc18gPSB0aGlzLnNpemUgfHwgKCgpID0+IHIpXHJcbiAgICAgICAgICAgIC8vc2l6ZSAtIGluIGdlbyB1bml0XHJcbiAgICAgICAgICAgIGNvbnN0IHNHID0gc18oY2VsbFt0aGlzLnNpemVDb2xdLCByLCBzdGF0U2l6ZSwgemYpXHJcblxyXG4gICAgICAgICAgICAvL3dpZHRoXHJcbiAgICAgICAgICAgIGNvbnN0IHdpID0gdGhpcy5zdHJva2VXaWR0aFxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLnN0cm9rZVdpZHRoKGNlbGxbdGhpcy5zdHJva2VXaWR0aENvbF0sIHIsIHN0YXRXaWR0aCwgemYpXHJcbiAgICAgICAgICAgICAgICA6IDEgKiB6ZlxyXG4gICAgICAgICAgICBpZiAoIXdpIHx8IHdpIDw9IDApIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSB3aVxyXG5cclxuICAgICAgICAgICAgLy9zaGFwZVxyXG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuc2hhcGUgPyB0aGlzLnNoYXBlKGNlbGwpIDogJ3NxdWFyZSdcclxuICAgICAgICAgICAgaWYgKHNoYXBlID09PSAnbm9uZScpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL2dldCBvZmZzZXRcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoY2VsbCwgciwgemYpXHJcblxyXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT09ICdzcXVhcmUnKSB7XHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgc3F1YXJlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gciAqICgxIC0gc0cgLyByKSAqIDAuNVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgucmVjdChjZWxsLnggKyBkICsgb2Zmc2V0LmR4LCBjZWxsLnkgKyBkICsgb2Zmc2V0LmR5LCBzRywgc0cpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2NpcmNsZScpIHtcclxuICAgICAgICAgICAgICAgIC8vZHJhdyBjaXJjbGVcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmFyYyhjZWxsLnggKyByMiArIG9mZnNldC5keCwgY2VsbC55ICsgcjIgKyBvZmZzZXQuZHksIHNHICogMC41LCAwLCAyICogTWF0aC5QSSwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHguc3Ryb2tlKClcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ2RpYW1vbmQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzMiA9IHNHICogMC41XHJcbiAgICAgICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oY2VsbC54ICsgcjIgLSBzMiwgY2VsbC55ICsgcjIpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGNlbGwueCArIHIyLCBjZWxsLnkgKyByMiArIHMyKVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjZWxsLnggKyByMiArIHMyLCBjZWxsLnkgKyByMilcclxuICAgICAgICAgICAgICAgIGNnLmN0eC5saW5lVG8oY2VsbC54ICsgcjIsIGNlbGwueSArIHIyIC0gczIpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGNlbGwueCArIHIyIC0gczIsIGNlbGwueSArIHIyKVxyXG4gICAgICAgICAgICAgICAgY2cuY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdkb251dCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2hhcGU6JyArIHNoYXBlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXHJcbiAgICAgICAgLy90aGlzLnVwZGF0ZUxlZ2VuZHMoeyBzdHlsZTogdGhpcywgcjogcmVzb2x1dGlvbiwgemY6IHpmLCBzU2l6ZTogc3RhdFNpemUsIHNDb2xvcjogc3RhdENvbG9yIH0pO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgU3F1YXJlQ29sb3JXR0xTdHlsZSB9IGZyb20gJy4vU3F1YXJlQ29sb3JXR0xTdHlsZS5qcydcclxuaW1wb3J0IHsgU2lkZVN0eWxlIH0gZnJvbSAnLi9TaWRlU3R5bGUuanMnXHJcblxyXG4vKipcclxuICpcclxuICogQHNlZSBodHRwczovL21hbmlmb2xkLm5ldC9kb2MvbWZkOS9leGFtcGxlX190YW5ha2FfY29udG91cnMuaHRtXHJcbiAqXHJcbiAqIEBhdXRob3IgSnVsaWVuIEdhZmZ1cmlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBUYW5ha2FTdHlsZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPGltcG9ydChcIi4uL1N0eWxlXCIpLlN0eWxlPn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldChjb2wsIG9wdHMpIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvL2dldCBjb2xvcnMgZnJvbSBkMyByYW1wcywgaWYgJ25iJyBpcyBzcGVjaWZpZWRcclxuICAgICAgICBpZiAob3B0cy5uYiAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKG9wdHMubmIgPCAyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd1bmV4cGVjdGVkIG51bWJlciBvZiBjb2xvcnMgaW4gdGFuYWthICg8Mik6ICcgKyBvcHRzLm5iKVxyXG4gICAgICAgICAgICAgICAgb3B0cy5uYiA9IDJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW9wdHMuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2NvbG9yIGZ1bmN0aW9uIG5vdCBkZWZpbmVkIGluIHRhbmFrYScpXHJcbiAgICAgICAgICAgICAgICBvcHRzLmNvbG9yID0gKCkgPT4gJ2dyYXknXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSBbXVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdHMubmI7IGkrKykgb3B0cy5jb2xvcnMucHVzaChvcHRzLmNvbG9yKGkgLyAob3B0cy5uYiAtIDEpKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb2xvcnMuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fSAqL1xyXG4gICAgICAgIG9wdHMuY29sb3JzID0gb3B0cy5jb2xvcnMgfHwgWycjYTliYjllJywgJyNjOWRjYWEnLCAnI2ZkZTg5ZicsICcjZjlhNTc5JywgJyNlYjQ0NGInXVxyXG4gICAgICAgIGNvbnN0IG5iID0gb3B0cy5jb2xvcnMubGVuZ3RoXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHRvIGNvbXB1dGUgJ3QnIGZyb20gdGhlIHZhbHVlIHZcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0KTpudW1iZXJ9ICovXHJcbiAgICAgICAgb3B0cy50RnVuID0gb3B0cy50RnVuIHx8ICgodiwgciwgcykgPT4gKHYgLSBzLm1pbikgLyAocy5tYXggLSBzLm1pbikpXHJcblxyXG4gICAgICAgIC8vc2hhZG93IGNvbG9yc1xyXG4gICAgICAgIG9wdHMuY29sRGFyayA9IG9wdHMuY29sRGFyayB8fCAnIzExMSdcclxuICAgICAgICBvcHRzLmNvbEJyaWdodCA9IG9wdHMuY29sQnJpZ2h0IHx8ICcjZGRkJ1xyXG5cclxuICAgICAgICAvL3dpZHRoIG9mIHRoZSBzZWdtZW50IChzaGFyZSBvZiB0aGUgcmVzb2x1dGlvbilcclxuICAgICAgICBvcHRzLndpZHRoRmFjdG9yID0gb3B0cy53aWR0aEZhY3RvciB8fCAwLjA4XHJcblxyXG4gICAgICAgIC8vc2hhZGluZ1xyXG4gICAgICAgIG9wdHMubmV3U2hhZGluZyA9IG9wdHMubmV3U2hhZGluZ1xyXG4gICAgICAgIG9wdHMubmV3U2hhZGluZ1dpZHRoUGl4ID0gb3B0cy5uZXdTaGFkaW5nV2lkdGhQaXggfHwgMlxyXG4gICAgICAgIC8vdHJhbnNwYXJlbmN5IHZhbHVlLCB3aXRoaW4gWzAsMV1cclxuICAgICAgICBvcHRzLm5ld1NoYWRpbmdUciA9XHJcbiAgICAgICAgICAgIG9wdHMubmV3U2hhZGluZ1RyIHx8XHJcbiAgICAgICAgICAgICgoc2lkZVZhbHVlLCBzaWRlU3RhdCkgPT5cclxuICAgICAgICAgICAgICAgIE1hdGguYWJzKHNpZGVWYWx1ZSkgLyBNYXRoLm1heChNYXRoLmFicyhzaWRlU3RhdC5taW4pLCBNYXRoLmFicyhzaWRlU3RhdC5tYXgpKSlcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHQgQSBjZWxsIHQgdmFsdWUsIHdpdGhpbiBbMCwxXS5cclxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgY2xhc3MgbnVtYmVyIGZvciB0aGUgdmFsdWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBnZXRDbGFzcyA9ICh0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc05hTih0KSB8fCB0ID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCB0IHZhbHVlIDE6ICcgKyB0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC05XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYjsgaSsrKSBpZiAodCA8PSAoaSArIDEpIC8gbmIpIHJldHVybiBpXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgdCB2YWx1ZSAyOiAnICsgdClcclxuICAgICAgICAgICAgcmV0dXJuIC05XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjb2xTdHlsZSA9IG5ldyBTcXVhcmVDb2xvcldHTFN0eWxlKHtcclxuICAgICAgICAgICAgY29sb3JDb2w6IGNvbCxcclxuICAgICAgICAgICAgY29sb3JzOiBvcHRzLmNvbG9ycyxcclxuICAgICAgICAgICAgdEZ1bjogKHYsIHIsIHMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBvcHRzLnRGdW4odiwgciwgcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBnZXRDbGFzcyh0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgLyAobmIgLSAxKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvL3N0cmV0Y2hpbmc6IHsgZnVuOiBcImV4cFJldlwiLCBhbHBoYTogLTcgfSxcclxuICAgICAgICAgICAgc2l6ZTogKHIsIHpmKSA9PiByICsgMC41ICogemYsIC8vdGhhdCBpcyB0byBlbnN1cmUgbm8gZ2FwIGJldHdlZW4gc2FtZSBjbGFzcyBjZWxscyBpcyB2aXNpYmxlXHJcbiAgICAgICAgICAgIGZpbHRlcjogb3B0cy5maWx0ZXIsXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICBpZiBubyB3ZWIgZ2w6ICAgIFxyXG4gICAgICAgICAgICBjb25zdCBjb2xTdHlsZSA9IG5ldyBTaGFwZUNvbG9yU2l6ZVN0eWxlKHtcclxuICAgICAgICAgICAgICAgIGNvbG9yQ29sOiBjb2wsXHJcbiAgICAgICAgICAgICAgICAvL3RoZSBjb2xvciBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzc1xyXG4gICAgICAgICAgICAgICAgY29sb3I6ICh2LCByLCBzLCB6ZikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ID09IDAgJiYgb3B0cy50RnVuICYmIGlzTmFOKG9wdHMudEZ1bih2LCByLCBzKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0cy5jb2xvcnNbZ2V0Q2xhc3Mob3B0cy50RnVuID8gb3B0cy50RnVuKHYsIHIsIHMpIDogdildXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2hhcGU6ICgpID0+IFwic3F1YXJlXCIsXHJcbiAgICAgICAgICAgICAgICBzaXplOiAodiwgciwgcywgemYpID0+IHIgKyAwLjUgKiB6ZiwgLy90aGF0IGlzIHRvIGVuc3VyZSBubyBnYXAgYmV0d2VlbiBzYW1lIGNsYXNzIGNlbGxzIGlzIHZpc2libGVcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKiogVGhlIHNpZGUgc3R5bGUsIGZvciB0aGUgc2hhZG93IGVmZmVjdCAqL1xyXG4gICAgICAgIGNvbnN0IHNpZGVTdHlsZSA9IG5ldyBTaWRlU3R5bGUoe1xyXG4gICAgICAgICAgICB2YWx1ZUNvbDogY29sLFxyXG4gICAgICAgICAgICB2YWx1ZTogKHYxLCB2MiwgciwgcywgemYpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSB0aGUgbnVtYmVyIG9mIGNsYXNzZXMgb2YgZGlmZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQgJiYgdjIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDBcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gb3B0cy50RnVuKHYxLCByLCBzKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09IHVuZGVmaW5lZCB8fCBpc05hTih0KSkgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlOiAnICsgdjEgKyAnIC0gJyArIHQpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGdldENsYXNzKHQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKyAxXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYxID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gb3B0cy50RnVuKHYyLCByLCBzKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09IHVuZGVmaW5lZCB8fCBpc05hTih0KSkgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlOiAnICsgdjIgKyAnIC0gJyArIHQpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGdldENsYXNzKHQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1jIC0gMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdDEgPSBvcHRzLnRGdW4odjEsIHIsIHMpXHJcbiAgICAgICAgICAgICAgICBpZiAodDEgPT0gdW5kZWZpbmVkIHx8IGlzTmFOKHQxKSkgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlOiAnICsgdjEgKyAnIC0gJyArIHQxKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdDIgPSBvcHRzLnRGdW4odjIsIHIsIHMpXHJcbiAgICAgICAgICAgICAgICBpZiAodDIgPT0gdW5kZWZpbmVkIHx8IGlzTmFOKHQyKSkgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlOiAnICsgdjIgKyAnIC0gJyArIHQyKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYzEgPSBnZXRDbGFzcyh0MSlcclxuICAgICAgICAgICAgICAgIGNvbnN0IGMyID0gZ2V0Q2xhc3ModDIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLWMyICsgYzFcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGNvbG9yOiBvcHRzLm5ld1NoYWRpbmdcclxuICAgICAgICAgICAgICAgID8gLy9ibGFjayB3aXRoIHRyYW5zcGFyZW5jeSBkZXBlbmRpbmcgb24gZGlmZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgICAoc2lkZSwgciwgcywgeikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHIgPSBvcHRzLm5ld1NoYWRpbmdUcihzaWRlLnZhbHVlLCBzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzaWRlLnZhbHVlID4gMCAmJiBzaWRlLm9yID09PSAnaCcpIHx8IChzaWRlLnZhbHVlIDwgMCAmJiBzaWRlLm9yID09PSAndicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAncmdiYSgyNTUsMjU1LDEwMCwnICsgdHIgKyAnKSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdyZ2JhKDAsMCwwLCcgKyB0ciArICcpJ1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA6IC8vd2hpdGUgb3IgYmxhY2ssIGRlcGVuZGluZyBvbiBvcmllbnRhdGlvbiBhbmQgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgKHNpZGUsIHIsIHMsIHopID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWRlLnZhbHVlID09PSAwKSByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIFwiZ3JheVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZS5vciA9PT0gJ3YnKSByZXR1cm4gc2lkZS52YWx1ZSA8IDAgPyBvcHRzLmNvbEJyaWdodCA6IG9wdHMuY29sRGFya1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUudmFsdWUgPCAwID8gb3B0cy5jb2xEYXJrIDogb3B0cy5jb2xCcmlnaHRcclxuICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHdpZHRoOiBvcHRzLm5ld1NoYWRpbmdcclxuICAgICAgICAgICAgICAgID8gLy9maWxsIHNpemVcclxuICAgICAgICAgICAgICAgICAgKHNpZGUsIHIsIHMsIHopID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRzLm5ld1NoYWRpbmdXaWR0aFBpeCAqIHpcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgOiAvL3dpZHRoIGRlcGVuZHMgb24gdGhlIHZhbHVlLCB0aGF0IGlzIHRoZSBudW1iZXIgb2YgY2xhc3NlcyBvZiBkaWZmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICAgIChzaWRlLCByLCBzLCB6KSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgb3B0cy53aWR0aEZhY3RvciAqIHIgKiBNYXRoLmFicyhzaWRlLnZhbHVlKSAqIChzaWRlLm9yID09PSAndicgPyAwLjUgOiAxKSxcclxuXHJcbiAgICAgICAgICAgIGZpbHRlcjogb3B0cy5maWx0ZXIsXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIFtjb2xTdHlsZSwgc2lkZVN0eWxlXVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgU3R5bGUgfSBmcm9tICcuLi9TdHlsZS5qcydcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAYXV0aG9yIEp1bGllbiBHYWZmdXJpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGV4dFN0eWxlIGV4dGVuZHMgU3R5bGUge1xyXG4gICAgLyoqIEBwYXJhbSB7b2JqZWN0fSBvcHRzICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cylcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fVxyXG5cclxuICAgICAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGNvbHVtbi9hdHRyaWJ1dGUgb2YgdGhlIHRhYnVsYXIgZGF0YSB3aGVyZSB0byByZXRyaWV2ZSB0aGUgdmFyaWFibGUgZm9yIHRleHQuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnRleHRDb2wgPSBvcHRzLnRleHRDb2xcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSB0ZXh0IG9mIGEgY2VsbC5cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcixpbXBvcnQoXCIuLi9TdHlsZVwiKS5TdGF0fHVuZGVmaW5lZCxudW1iZXIpOnN0cmluZ30gKi9cclxuICAgICAgICB0aGlzLnRleHQgPSBvcHRzLnRleHQgfHwgKCh2LCByLCBzLCB6KSA9PiAnWCcpXHJcblxyXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3IgY29sb3IuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yQ29sID0gb3B0cy5jb2xvckNvbFxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIHRoZSBjZWxsLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgoKSA9PiAnI0VBNkJBQycpXHJcblxyXG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY29sdW1uL2F0dHJpYnV0ZSBvZiB0aGUgdGFidWxhciBkYXRhIHdoZXJlIHRvIHJldHJpZXZlIHRoZSB2YXJpYWJsZSBmb3IgZm9udCBzaXplLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5mb250U2l6ZUNvbCA9IG9wdHMuZm9udFNpemVDb2xcclxuXHJcbiAgICAgICAgLyoqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBmb250IHNpemUgb2YgYSBjZWxsIGluIGdlbyB1bml0LlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMuZm9udFNpemUgPSBvcHRzLmZvbnRTaXplIHx8ICgodiwgciwgcywgeikgPT4gciAqIDAuOClcclxuXHJcbiAgICAgICAgLyoqIFRoZSB0ZXh0IGZvbnQgZmFtaWx5LlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5mb250RmFtaWx5ID0gb3B0cy5mb250RmFtaWx5IHx8ICdBcmlhbCdcclxuXHJcbiAgICAgICAgLyoqIFRoZSB0ZXh0IGZvbnQgd2VpZ2h0LlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy5mb250V2VpZ2h0ID0gb3B0cy5mb250V2VpZ2h0IHx8ICdib2xkJ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBjZWxscyBhcyB0ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL0RhdGFzZXRcIikuQ2VsbD59IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gclxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9HZW9DYW52YXNcIikuR2VvQ2FudmFzfSBjZ1xyXG4gICAgICovXHJcbiAgICBkcmF3KGNlbGxzLCByLCBjZykge1xyXG4gICAgICAgIC8vZmlsdGVyXHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSBjZWxscyA9IGNlbGxzLmZpbHRlcih0aGlzLmZpbHRlcilcclxuXHJcbiAgICAgICAgLy96b29tIGZhY3RvclxyXG4gICAgICAgIGNvbnN0IHpmID0gY2cuZ2V0WmYoKVxyXG5cclxuICAgICAgICBsZXQgc3RhdFRleHRcclxuICAgICAgICBpZiAodGhpcy50ZXh0Q29sKSB7XHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSB0ZXh0IHZhcmlhYmxlIHN0YXRpc3RpY3NcclxuICAgICAgICAgICAgc3RhdFRleHQgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLnRleHRDb2xdLCB0cnVlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHN0YXRDb2xvclxyXG4gICAgICAgIGlmICh0aGlzLmNvbG9yQ29sKSB7XHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSBjb2xvciB2YXJpYWJsZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgICAgIHN0YXRDb2xvciA9IFN0eWxlLmdldFN0YXRpc3RpY3MoY2VsbHMsIChjKSA9PiBjW3RoaXMuY29sb3JDb2xdLCB0cnVlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHN0YXRGb250U2l6ZVxyXG4gICAgICAgIGlmICh0aGlzLmZvbnRTaXplQ29sKSB7XHJcbiAgICAgICAgICAgIC8vaWYgc2l6ZSBpcyB1c2VkLCBzb3J0IGNlbGxzIGJ5IHNpemUgc28gdGhhdCB0aGUgYmlnZ2VzdCBhcmUgZHJhd24gZmlyc3RcclxuICAgICAgICAgICAgY2VsbHMuc29ydCgoYzEsIGMyKSA9PiBjMlt0aGlzLmZvbnRTaXplQ29sXSAtIGMxW3RoaXMuZm9udFNpemVDb2xdKVxyXG4gICAgICAgICAgICAvL2FuZCBjb21wdXRlIHNpemUgdmFyaWFibGUgc3RhdGlzdGljc1xyXG4gICAgICAgICAgICBzdGF0Rm9udFNpemUgPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLmZvbnRTaXplQ29sXSwgdHJ1ZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZHJhdyB3aXRoIEhUTUwgY2FudmFzXHJcbiAgICAgICAgLy9pbiBzY3JlZW4gY29vcmRpbmF0ZXNcclxuICAgICAgICBjZy5pbml0Q2FudmFzVHJhbnNmb3JtKClcclxuXHJcbiAgICAgICAgZm9yIChsZXQgY2VsbCBvZiBjZWxscykge1xyXG4gICAgICAgICAgICAvL2dldCBjZWxsIHRleHRcclxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMudGV4dCA/IHRoaXMudGV4dChjZWxsW3RoaXMudGV4dENvbF0sIHIsIHN0YXRUZXh0LCB6ZikgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKHRleHQgPT0gdW5kZWZpbmVkIHx8IHRleHQgPT0gbnVsbCB8fCB0ZXh0ICsgJycgPT09ICcnKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy9jb2xvclxyXG4gICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yID8gdGhpcy5jb2xvcihjZWxsW3RoaXMuY29sb3JDb2xdLCByLCBzdGF0Q29sb3IsIHpmKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIWNvbCkgY29udGludWVcclxuICAgICAgICAgICAgY2cuY3R4LmZpbGxTdHlsZSA9IGNvbFxyXG5cclxuICAgICAgICAgICAgLy9mb250IHNpemVcclxuICAgICAgICAgICAgLy9zaXplIC0gaW4gcGl4ZWwgdW5pdFxyXG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZVBpeCA9IHRoaXMuZm9udFNpemUoY2VsbFt0aGlzLmZvbnRTaXplQ29sXSwgciwgc3RhdEZvbnRTaXplLCB6ZikgLyB6ZlxyXG5cclxuICAgICAgICAgICAgLy9zZXQgZm9udFxyXG4gICAgICAgICAgICBjb25zdCBmb250RmFtaWx5ID0gdGhpcy5mb250RmFtaWx5IHx8ICdBcmlhbCdcclxuICAgICAgICAgICAgY29uc3QgZm9udFdlaWdodCA9IHRoaXMuZm9udFdlaWdodCB8fCAnYm9sZCdcclxuICAgICAgICAgICAgY2cuY3R4LmZvbnQgPSBmb250V2VpZ2h0ICsgJyAnICsgZm9udFNpemVQaXggKyAncHggJyArIGZvbnRGYW1pbHlcclxuXHJcbiAgICAgICAgICAgIC8vZ2V0IG9mZnNldFxyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldChjZWxsLCByLCB6ZilcclxuXHJcbiAgICAgICAgICAgIC8vdGV4dCBwb3NpdGlvblxyXG4gICAgICAgICAgICBjZy5jdHgudGV4dEFsaWduID0gJ2NlbnRlcidcclxuICAgICAgICAgICAgY29uc3QgdHggPSBjZy5nZW9Ub1BpeFgoY2VsbC54ICsgciAqIDAuNSArIG9mZnNldC5keClcclxuICAgICAgICAgICAgY29uc3QgdHkgPSBjZy5nZW9Ub1BpeFkoY2VsbC55ICsgciAqIDAuNSArIG9mZnNldC5keSkgKyBmb250U2l6ZVBpeCAqIDAuMyAvL2l0IHNob3VsZCBiZSAwLjUgYnV0IDAuMyBzZWVtcyB0byB3b3JrIGJldHRlclxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IHRoZSB0ZXh0XHJcbiAgICAgICAgICAgIGNnLmN0eC5maWxsVGV4dCh0ZXh0LCB0eCwgdHkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3VwZGF0ZSBsZWdlbmRzXHJcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKHsgc3R5bGU6IHRoaXMsIHI6IHIsIHpmOiB6Ziwgc0NvbG9yOiBzdGF0Q29sb3IgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkIGEgZnVuY3Rpb24gWzAsMV0tPnN0cmluZyBmb3IgY2hhcmFjdGVycyBsZWdlbmRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjaGFyc1xyXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKG51bWJlcik6c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0Q2hhckxlZ2VuZEZ1bihjaGFycykge1xyXG4gICAgICAgIGNvbnN0IG5iID0gY2hhcnMubGVuZ3RoXHJcbiAgICAgICAgcmV0dXJuICh0KSA9PiAodCA9PSAwID8gJycgOiB0ID09IDEgPyBjaGFyc1tuYiAtIDFdIDogY2hhcnNbTWF0aC5mbG9vcih0ICogbmIpXSlcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IFN0eWxlIH0gZnJvbSAnLi4vU3R5bGUuanMnXHJcblxyXG4vKiogQHR5cGVkZWYge1wiZmlyc3RcInxcImJvdHRvbVwifFwiY2VudGVyXCJ8XCJ0b3BcInxcImxhc3RcIn0gQW5jaG9yTW9kZVlFbnVtICovXHJcblxyXG4vKipcclxuICogU2hvdyBjZWxsIGFzIHRpbWVzZXJpZXMgY2hhcnRcclxuICogQ2FuIGJlIHVzZWQgZm9yIHNwYXJrbGluZSBtYXAgb2YgaHR0cHM6Ly9kYXRhZ2lzdGlwcy5oeXBvdGhlc2VzLm9yZy80ODhcclxuICpcclxuICogQGF1dGhvciBKdWxpZW4gR2FmZnVyaVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRpbWVTZXJpZXNTdHlsZSBleHRlbmRzIFN0eWxlIHtcclxuICAgIC8qKiBAcGFyYW0ge29iamVjdH0gb3B0cyAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge31cclxuXHJcbiAgICAgICAgLyoqIFRoZSBjb2x1bW5zIG9mIHRoZSB0aW1lIHNlcmllcywgb3JkZXJlZCBpbiBjaHJvbm9sb2dpY2FsIG9yZGVyLlxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn0gKi9cclxuICAgICAgICB0aGlzLnRzID0gb3B0cy50c1xyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiBzcGVjaWZ5aW5nIHdoZW4gYSB2YWx1ZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBcIm5vIGRhdGFcIiBhbmQgdGh1cyBub3QgaWdub3JlZC4gVGhlIGxpbmUgd2lsbCBoYXZlIGEgYnJlYWsgYXQgdGhlc2UgdmFsdWVzLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihzdHJpbmcpOmJvb2xlYW59ICovXHJcbiAgICAgICAgdGhpcy5ub0RhdGEgPSBvcHRzLm5vRGF0YSB8fCAoKHYpID0+IHYgPT09IHVuZGVmaW5lZCB8fCB2ID09IFwiXCIgfHwgdiA9PT0gbnVsbCB8fCBpc05hTigrdikpXHJcblxyXG4gICAgICAgIC8veFxyXG4gICAgICAgIC8qKiBpbiBnZW8gdW5pdFxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9EYXRhc2V0LmpzXCIpLkNlbGwsbnVtYmVyLG51bWJlcik6bnVtYmVyfSAqL1xyXG4gICAgICAgIHRoaXMub2Zmc2V0WCA9IG9wdHMub2Zmc2V0WCB8fCAoKGMsIHIsIHpmKSA9PiAwKVxyXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCAoKGMsIHIsIHpmKSA9PiByKVxyXG5cclxuICAgICAgICAvL3lcclxuICAgICAgICAvKiogaW4gZ2VvIHVuaXRcclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cclxuICAgICAgICB0aGlzLm9mZnNldFkgPSBvcHRzLm9mZnNldFkgfHwgKChjLCByLCB6ZikgPT4gMClcclxuICAgICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL0RhdGFzZXQuanNcIikuQ2VsbCxudW1iZXIsbnVtYmVyKTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRzLmhlaWdodCB8fCAoKGMsIHIsIHpmKSA9PiByKVxyXG4gICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRGF0YXNldC5qc1wiKS5DZWxsLG51bWJlcixudW1iZXIpOkFuY2hvck1vZGVZRW51bX0gKi9cclxuICAgICAgICB0aGlzLmFuY2hvck1vZGVZID0gb3B0cy5hbmNob3JNb2RlWSB8fCAoKGMsIHIsIHpmKSA9PiBcImNlbnRlclwiKVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmxpbmVXaWR0aENvbCA9IG9wdHMubGluZVdpZHRoQ29sXHJcblxyXG4gICAgICAgIC8qKiBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgd2lkdGggb2YgdGhlIGxpbmUsIGluIGdlbyB1bml0XHJcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIsaW1wb3J0KFwiLi4vU3R5bGUuanNcIikuU3RhdHx1bmRlZmluZWQsbnVtYmVyKTpudW1iZXJ9ICovXHJcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSBvcHRzLmxpbmVXaWR0aCB8fCAoKHYsIHIsIHMsIHpmKSA9PiAxLjUgKiB6ZilcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgICAgICB0aGlzLmNvbG9yQ29sID0gb3B0cy5jb2xvckNvbFxyXG5cclxuICAgICAgICAvKiogQSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGNvbG9yIG9mIHRoZSBjZWxsLlxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyLGltcG9ydChcIi4uL1N0eWxlLmpzXCIpLlN0YXR8dW5kZWZpbmVkLG51bWJlcik6c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRzLmNvbG9yIHx8ICgodiwgciwgcywgemYpID0+ICdibGFjaycpXHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBjZWxscyBhcyB0ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGltcG9ydChcIi4uL0RhdGFzZXQuanNcIikuQ2VsbD59IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gclxyXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9HZW9DYW52YXMuanNcIikuR2VvQ2FudmFzfSBjZ1xyXG4gICAgICovXHJcbiAgICBkcmF3KGNlbGxzLCByLCBjZykge1xyXG5cclxuICAgICAgICAvL2ZpbHRlclxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikgY2VsbHMgPSBjZWxscy5maWx0ZXIodGhpcy5maWx0ZXIpXHJcblxyXG4gICAgICAgIC8vem9vbSBmYWN0b3JcclxuICAgICAgICBjb25zdCB6ZiA9IGNnLmdldFpmKClcclxuXHJcbiAgICAgICAgbGV0IHN0YXRXaWR0aFxyXG4gICAgICAgIGlmICh0aGlzLmxpbmVXaWR0aENvbCkge1xyXG4gICAgICAgICAgICAvL2FuZCBjb21wdXRlIHNpemUgdmFyaWFibGUgc3RhdGlzdGljc1xyXG4gICAgICAgICAgICBzdGF0V2lkdGggPSBTdHlsZS5nZXRTdGF0aXN0aWNzKGNlbGxzLCAoYykgPT4gY1t0aGlzLmxpbmVXaWR0aENvbF0sIHRydWUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgc3RhdENvbG9yXHJcbiAgICAgICAgaWYgKHRoaXMuY29sb3JDb2wpIHtcclxuICAgICAgICAgICAgLy9jb21wdXRlIGNvbG9yIHZhcmlhYmxlIHN0YXRpc3RpY3NcclxuICAgICAgICAgICAgc3RhdENvbG9yID0gU3R5bGUuZ2V0U3RhdGlzdGljcyhjZWxscywgKGMpID0+IGNbdGhpcy5jb2xvckNvbF0sIHRydWUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbXB1dGUgY2VsbCBhbXBsaXR1ZGVcclxuICAgICAgICBjb25zdCBnZXRBbXBsaXR1ZGUgPSBjID0+IHtcclxuICAgICAgICAgICAgbGV0IG1pbiwgbWF4XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50cykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gY1t0XTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gdW5kZWZpbmVkKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PSB1bmRlZmluZWQgfHwgdmFsIDwgbWluKSBtaW4gPSB2YWxcclxuICAgICAgICAgICAgICAgIGlmIChtYXggPT0gdW5kZWZpbmVkIHx8IHZhbCA+IG1heCkgbWF4ID0gdmFsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1pbiA9PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICAgICAgcmV0dXJuIG1heCAtIG1pblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb21wdXRlIG1heCBhbXBsaXR1ZGVcclxuICAgICAgICBsZXQgYW1wTWF4XHJcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjZWxscykge1xyXG4gICAgICAgICAgICBjb25zdCBhbXAgPSBnZXRBbXBsaXR1ZGUoYylcclxuICAgICAgICAgICAgaWYgKGFtcCA9PSB1bmRlZmluZWQpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGlmIChhbXBNYXggPT0gdW5kZWZpbmVkIHx8IGFtcCA+IGFtcE1heCkgYW1wTWF4ID0gYW1wXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYW1wTWF4KSByZXR1cm5cclxuXHJcbiAgICAgICAgY29uc3QgbmIgPSB0aGlzLnRzLmxlbmd0aFxyXG5cclxuICAgICAgICAvL2RyYXcgd2l0aCBIVE1MIGNhbnZhc1xyXG4gICAgICAgIC8vaW4gZ2VvIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgY2cuc2V0Q2FudmFzVHJhbnNmb3JtKClcclxuXHJcbiAgICAgICAgY2cuY3R4LmxpbmVDYXAgPSBcImJ1dHRcIlxyXG4gICAgICAgIGZvciAobGV0IGMgb2YgY2VsbHMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vbGluZSB3aWR0aFxyXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IHdHID0gdGhpcy5saW5lV2lkdGggPyB0aGlzLmxpbmVXaWR0aChjW3RoaXMubGluZVdpZHRoQ29sXSwgciwgc3RhdFdpZHRoLCB6ZikgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKCF3RyB8fCB3RyA8IDApIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvL2xpbmUgY29sb3JcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xyXG4gICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmNvbG9yID8gdGhpcy5jb2xvcihjW3RoaXMuY29sb3JDb2xdLCByLCBzdGF0Q29sb3IsIHpmKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIWNvbCkgY29udGludWVcclxuXHJcblxyXG4gICAgICAgICAgICAvL3hcclxuICAgICAgICAgICAgY29uc3Qgb2ZmWCA9IHRoaXMub2Zmc2V0WCA/IHRoaXMub2Zmc2V0WChjLCByLCB6ZikgOiAwXHJcbiAgICAgICAgICAgIGlmIChvZmZYID09IHVuZGVmaW5lZCB8fCBpc05hTihvZmZYKSkgY29udGludWVcclxuICAgICAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggPyB0aGlzLndpZHRoKGMsIHIsIHpmKSA6IHJcclxuICAgICAgICAgICAgaWYgKHcgPT0gdW5kZWZpbmVkIHx8IGlzTmFOKHcpKSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgLy95XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZlkgPSB0aGlzLm9mZnNldFkgPyB0aGlzLm9mZnNldFkoYywgciwgemYpIDogMFxyXG4gICAgICAgICAgICBpZiAob2ZmWSA9PSB1bmRlZmluZWQgfHwgaXNOYU4ob2ZmWSkpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodCA/IHRoaXMuaGVpZ2h0KGMsIHIsIHpmKSA6IHJcclxuICAgICAgICAgICAgaWYgKGggPT0gdW5kZWZpbmVkIHx8IGlzTmFOKGgpKSBjb250aW51ZVxyXG4gICAgICAgICAgICBjb25zdCBhbmNoWSA9IHRoaXMuYW5jaG9yTW9kZVkgPyB0aGlzLmFuY2hvck1vZGVZKGMsIHIsIHpmKSA6IFwiY2VudGVyXCJcclxuICAgICAgICAgICAgaWYgKCFhbmNoWSkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIGNnLmN0eC5saW5lV2lkdGggPSB3R1xyXG4gICAgICAgICAgICBjZy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xcclxuXHJcbiAgICAgICAgICAgIC8vY29tcHV0ZSBhbmNob3IgWSBmaWd1cmVzXHJcbiAgICAgICAgICAgIGxldCB2YWwwLCB5MFxyXG4gICAgICAgICAgICBpZiAoYW5jaFkgPT09IFwiZmlyc3RcIikge1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgZmlyc3QgdmFsdWVcclxuICAgICAgICAgICAgICAgIHZhbDAgPSBjW3RoaXMudHNbMF1dXHJcbiAgICAgICAgICAgICAgICB5MCA9IDBcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbmNoWSA9PT0gXCJsYXN0XCIpIHtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IGxhc3QgdmFsdWVcclxuICAgICAgICAgICAgICAgIHZhbDAgPSBjW3RoaXMudHNbdGhpcy50cy5sZW5ndGggLSAxXV1cclxuICAgICAgICAgICAgICAgIHkwID0gMFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFuY2hZID09PSBcImJvdHRvbVwiKSB7XHJcbiAgICAgICAgICAgICAgICAvL2dldCBtaW5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9ICtjW3RdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gdW5kZWZpbmVkKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwwID09IHVuZGVmaW5lZCB8fCB2YWwgPCB2YWwwKSB2YWwwID0gdmFsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB5MCA9IDBcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbmNoWSA9PT0gXCJ0b3BcIikge1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgbWF4XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSArY1t0XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09IHVuZGVmaW5lZCkgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsMCA9PSB1bmRlZmluZWQgfHwgdmFsID4gdmFsMCkgdmFsMCA9IHZhbFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeTAgPSByXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5jaFkgPT09IFwiY2VudGVyXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IG1pbiBhbmQgbWF4XHJcbiAgICAgICAgICAgICAgICBsZXQgbWluLCBtYXhcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGNbdF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PSB1bmRlZmluZWQpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA9PSB1bmRlZmluZWQgfHwgdmFsIDwgbWluKSBtaW4gPSB2YWxcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4ID09IHVuZGVmaW5lZCB8fCB2YWwgPiBtYXgpIG1heCA9IHZhbFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFsMCA9ICgrbWF4ICsgK21pbikgKiAwLjVcclxuICAgICAgICAgICAgICAgIHkwID0gciAvIDJcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5leHBlY3RlZCBhbmNob3JNb2RlWTogXCIgKyBhbmNoWSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKi9kcmF3IGxpbmVcclxuICAgICAgICAgICAgaWYgKHZhbDAgPT0gdW5kZWZpbmVkIHx8IGlzTmFOKHZhbDApKSBjb250aW51ZVxyXG4gICAgICAgICAgICBjZy5jdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgICAgY29uc3Qgc1ggPSB3IC8gKG5iIC0gMSlcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBjW3RoaXMudHNbaV1dXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsID09IHVuZGVmaW5lZCB8fCBpc05hTih2YWwpKSBicmVha1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKGMueCArIGkgKiBzWCArIG9mZlgsIGMueSArIHkwICsgKHZhbCAtIHZhbDApICogaCAvIGFtcE1heCArIG9mZlkpXHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY2cuY3R4LmxpbmVUbyhjLnggKyBpICogc1ggKyBvZmZYLCBjLnkgKyB5MCArICh2YWwgLSB2YWwwKSAqIGggLyBhbXBNYXggKyBvZmZZKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKSovXHJcblxyXG5cclxuICAgICAgICAgICAgLy9kcmF3IGxpbmUsIHNlZ21lbnQgYnkgc2VnbWVudFxyXG4gICAgICAgICAgICBjb25zdCBzWCA9IHcgLyAobmIgLSAxKVxyXG5cclxuICAgICAgICAgICAgLy9oYW5kbGUgZmlyc3QgcG9pbnRcclxuICAgICAgICAgICAgbGV0IHYwID0gY1t0aGlzLnRzWzBdXVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9EYXRhKHYwKSkge1xyXG4gICAgICAgICAgICAgICAgY2cuY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICAgICAgICBjZy5jdHgubW92ZVRvKGMueCArIG9mZlgsIGMueSArIHkwICsgKHYwIC0gdmFsMCkgKiBoIC8gYW1wTWF4ICsgb2ZmWSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHYwLCBpc05hTih2MCkpXHJcblxyXG4gICAgICAgICAgICBsZXQgdjFcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuYjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2MSA9IGNbdGhpcy50c1tpXV1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2RyYXcgc2VnbWVudCBmcm9tIHYwIHRvIHYxXHJcblxyXG4gICAgICAgICAgICAgICAgLy9ib3RoIHBvaW50cyAnbm8gZGF0YSdcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vRGF0YSh2MCkgJiYgdGhpcy5ub0RhdGEodjEpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2Vjb25kIHBvaW50ICdubyBkYXRhJ1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5ub0RhdGEodjApICYmIHRoaXMubm9EYXRhKHYxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5zdHJva2UoKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IHBvaW50ICdubyBkYXRhJ1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5vRGF0YSh2MCkgJiYgIXRoaXMubm9EYXRhKHYxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgICAgICAgICAgIGNnLmN0eC5tb3ZlVG8oYy54ICsgaSAqIHNYICsgb2ZmWCwgYy55ICsgeTAgKyAodjEgLSB2YWwwKSAqIGggLyBhbXBNYXggKyBvZmZZKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2JvdGggcG9pbnRzIGhhdmUgZGF0YTogdHJhY2UgbGluZVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjZy5jdHgubGluZVRvKGMueCArIGkgKiBzWCArIG9mZlgsIGMueSArIHkwICsgKHYxIC0gdmFsMCkgKiBoIC8gYW1wTWF4ICsgb2ZmWSlcclxuICAgICAgICAgICAgICAgICAgICAvL2lmIGl0IGlzIHRoZSBsYXN0IHBvaW50LCBzdHJva2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBuYiAtIDEpIGNnLmN0eC5zdHJva2UoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdjAgPSB2MVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy91cGRhdGUgbGVnZW5kLCBpZiBhbnlcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoe1xyXG4gICAgICAgICAgICB3aWR0aEZ1bjogdGhpcy5saW5lV2lkdGgsXHJcbiAgICAgICAgICAgIHI6IHIsXHJcbiAgICAgICAgICAgIHpmOiB6ZixcclxuICAgICAgICAgICAgc0NvbG9yOiBzdGF0Q29sb3IsXHJcbiAgICAgICAgICAgIC8vc0xlbmd0aDogc3RhdExlbmd0aCxcclxuICAgICAgICAgICAgc1dpZHRoOiBzdGF0V2lkdGgsXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGNsYXNzIGlkIGZyb20gYSB2YWx1ZSBhbmQgY2xhc3MgYnJlYWsgdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2IHRoZSB2YWx1ZVxyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBicmVha3MgdGhlIGJyZWFrc1xyXG4gKiBAcmV0dXJucyBUaGUgY2xhc3MgaWQsIGZyb20gMCB0byBicmVha3MubGVuZ3RoXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3ModiwgYnJlYWtzKSB7XHJcbiAgICBpZiAoIWJyZWFrcykgcmV0dXJuXHJcbiAgICBpZiAoYnJlYWtzLmxlbmd0aCA9PSAwKSByZXR1cm4gMFxyXG4gICAgaWYgKHYgPD0gYnJlYWtzWzBdKSByZXR1cm4gMFxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBicmVha3MubGVuZ3RoOyBpKyspIGlmIChicmVha3NbaSAtIDFdIDwgdiAmJiB2IDw9IGJyZWFrc1tpXSkgcmV0dXJuIGlcclxuICAgIHJldHVybiBicmVha3MubGVuZ3RoXHJcbn1cclxuXHJcbmV4cG9ydCBsZXQgbW9uaXRvciA9IGZhbHNlXHJcblxyXG5sZXQgcHJldmlvdXNEYXRlXHJcbmV4cG9ydCBmdW5jdGlvbiBtb25pdG9yRHVyYXRpb24obWVzc2FnZSkge1xyXG4gICAgY29uc3Qgbm93RGF0ZSA9IERhdGUubm93KClcclxuXHJcbiAgICAvL2ZpcnN0IGNhbGxcclxuICAgIGlmICghcHJldmlvdXNEYXRlKSB7XHJcbiAgICAgICAgcHJldmlvdXNEYXRlID0gbm93RGF0ZVxyXG4gICAgICAgIGNvbnNvbGUubG9nKHByZXZpb3VzRGF0ZSwgbWVzc2FnZSlcclxuICAgICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkID0gbm93RGF0ZSAtIHByZXZpb3VzRGF0ZVxyXG4gICAgcHJldmlvdXNEYXRlID0gbm93RGF0ZVxyXG4gICAgY29uc29sZS5sb2coZCwgbWVzc2FnZSlcclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IGluaXRTaGFkZXJQcm9ncmFtLCBjcmVhdGVTaGFkZXIgfSBmcm9tICcuL3dlYkdMVXRpbHMuanMnXHJcbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnZDMtY29sb3InXHJcblxyXG4vKipcclxuICogRXZlcnl0aGluZyB0byBlYXNpbHkgZHJhdyBjb2xvcmVkIHNxdWFyZXMgd2l0aCB3ZWJHTC5cclxuICogQWxsIHRoZSBzYW1lIHNpemUsIGJ1dCBkaWZmZXJlbnQgZmlsbCBjb2xvci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXZWJHTFNxdWFyZUNvbG9yaW5nIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgc2l6ZVBpeCkge1xyXG4gICAgICAgIHRoaXMuZ2wgPSBnbFxyXG4gICAgICAgIHRoaXMuc2l6ZVBpeCA9IHNpemVQaXggfHwgMTAuMFxyXG5cclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBpbml0U2hhZGVyUHJvZ3JhbShcclxuICAgICAgICAgICAgZ2wsXHJcbiAgICAgICAgICAgIGNyZWF0ZVNoYWRlcihcclxuICAgICAgICAgICAgICAgIGdsLFxyXG4gICAgICAgICAgICAgICAgZ2wuVkVSVEVYX1NIQURFUixcclxuICAgICAgICAgICAgICAgIGBcclxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgcG9zO1xyXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHNpemVQaXg7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyBtYXQ7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGNvbG9yO1xyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KG1hdCAqIHZlYzMocG9zLCAxLjApLCAxLjApO1xyXG4gICAgICAgICAgICAgIGdsX1BvaW50U2l6ZSA9IHNpemVQaXg7XHJcbiAgICAgICAgICAgICAgdkNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIGBcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgY3JlYXRlU2hhZGVyKFxyXG4gICAgICAgICAgICAgICAgZ2wsXHJcbiAgICAgICAgICAgICAgICBnbC5GUkFHTUVOVF9TSEFERVIsXHJcbiAgICAgICAgICAgICAgICBgXHJcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xyXG4gICAgICAgICAgICB2b2lkIG1haW4odm9pZCkge1xyXG4gICAgICAgICAgICAgICAgdmVjNCB2Q29sb3JfID0gdkNvbG9yIC8gMjU1LjA7XHJcbiAgICAgICAgICAgICAgICB2Q29sb3JfWzNdID0gMjU1LjAgKiB2Q29sb3JfWzNdO1xyXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yXztcclxuICAgICAgICAgICAgfWBcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIClcclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSlcclxuXHJcbiAgICAgICAgLy9idWZmZXIgZGF0YVxyXG4gICAgICAgIHRoaXMudmVydGljZXNCdWZmZXIgPSBbXVxyXG4gICAgICAgIHRoaXMuY29sb3JzQnVmZmVyID0gW11cclxuICAgIH1cclxuXHJcbiAgICAvKiogQWRkIGRhdGEgdG8gdmVydGljZXMvc2l6ZS9jb2xvciBidWZmZXJzIGZvciBjb2xvciBzcXVhcmVzIGRyYXdpbmcgKi9cclxuICAgIGFkZFBvaW50RGF0YSh4QywgeUMsIGNvbCkge1xyXG4gICAgICAgIC8vY29udmVydCBjb2xvclxyXG4gICAgICAgIGNvbnN0IGNjID0gY29sb3IoY29sKVxyXG4gICAgICAgIC8vY29uc3QgY2MgPSB7cjo0NSxnOjg3LGI6OTgsb3BhY2l0eTowLjl9XHJcbiAgICAgICAgaWYgKCFjYykgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vdmVydGljZXNcclxuICAgICAgICB0aGlzLnZlcnRpY2VzQnVmZmVyLnB1c2goeEMsIHlDKVxyXG4gICAgICAgIC8vY29sb3JcclxuICAgICAgICB0aGlzLmNvbG9yc0J1ZmZlci5wdXNoKGNjLnIsIGNjLmcsIGNjLmIsIGNjLm9wYWNpdHkpXHJcbiAgICB9XHJcblxyXG4gICAgYWRkUG9pbnREYXRhMih4QywgeUMsIHIsIGcsIGIsIG9wYWNpdHkpIHtcclxuICAgICAgICAvL3ZlcnRpY2VzXHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlc0J1ZmZlci5wdXNoKHhDLCB5QylcclxuICAgICAgICAvL2NvbG9yXHJcbiAgICAgICAgdGhpcy5jb2xvcnNCdWZmZXIucHVzaChyLCBnLCBiLCBvcGFjaXR5KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiAgKi9cclxuICAgIGRyYXcodHJhbnNmb01hdCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbFxyXG5cclxuICAgICAgICAvL3ZlcnRpY2UgZGF0YVxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBnbC5jcmVhdGVCdWZmZXIoKSlcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSh0aGlzLnZlcnRpY2VzQnVmZmVyKSwgZ2wuU1RBVElDX0RSQVcpXHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sICdwb3MnKVxyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgICAgICAgIHBvc2l0aW9uLFxyXG4gICAgICAgICAgICAyLCAvL251bUNvbXBvbmVudHNcclxuICAgICAgICAgICAgZ2wuRkxPQVQsIC8vdHlwZVxyXG4gICAgICAgICAgICBmYWxzZSwgLy9ub3JtYWxpc2VcclxuICAgICAgICAgICAgMCwgLy9zdHJpZGVcclxuICAgICAgICAgICAgMCAvL29mZnNldFxyXG4gICAgICAgIClcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbilcclxuXHJcbiAgICAgICAgLy9jb2xvciBkYXRhXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGdsLmNyZWF0ZUJ1ZmZlcigpKVxyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHRoaXMuY29sb3JzQnVmZmVyKSwgZ2wuU1RBVElDX0RSQVcpXHJcbiAgICAgICAgdmFyIGNvbG9yID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnY29sb3InKVxyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY29sb3IsIDQsIGdsLkZMT0FULCBmYWxzZSwgMCwgMClcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvcilcclxuXHJcbiAgICAgICAgLy9zaXplUGl4XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sICdzaXplUGl4JyksIDEuMCAqIHRoaXMuc2l6ZVBpeClcclxuXHJcbiAgICAgICAgLy90cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ21hdCcpLCBmYWxzZSwgbmV3IEZsb2F0MzJBcnJheSh0cmFuc2ZvTWF0KSlcclxuXHJcbiAgICAgICAgLy8gRW5hYmxlIHRoZSBkZXB0aCB0ZXN0XHJcbiAgICAgICAgLy9nbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XHJcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGNvbG9yIGJ1ZmZlciBiaXRcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKVxyXG4gICAgICAgIC8vIFNldCB0aGUgdmlldyBwb3J0XHJcbiAgICAgICAgLy9nbC52aWV3cG9ydCgwLCAwLCBjZy53LCBjZy5oKTtcclxuXHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIHRoaXMudmVydGljZXNCdWZmZXIubGVuZ3RoIC8gMilcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbmltcG9ydCB7IGluaXRTaGFkZXJQcm9ncmFtLCBjcmVhdGVTaGFkZXIgfSBmcm9tICcuL3dlYkdMVXRpbHMuanMnXHJcbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnZDMtY29sb3InXHJcblxyXG4vKipcclxuICogRXZlcnl0aGluZyB0byBlYXNpbHkgZHJhdyBjb2xvcmVkIHNxdWFyZXMgd2l0aCB3ZWJHTC5cclxuICogQWxsIHRoZSBzYW1lIHNpemUsIGJ1dCBkaWZmZXJlbnQgZmlsbCBjb2xvci5cclxuICogVGhlIGNvbG9yIGludGVycG9sYXRpb24gaXMgY29tcHV0ZWQgaW4gdGhlIGZyYWdtZW50IHNoYWRlciBwcm9ncmFtLCBieSB0aGUgR1BVLCB0aHVzIGl0IGlzIGxlc3MgZmxleGlibGUgYnV0IGZhc3Rlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXZWJHTFNxdWFyZUNvbG9yaW5nQWR2YW5jZWQge1xyXG4gICAgLy9zZWU6XHJcbiAgICAvL2h0dHBzOi8vd2ViZ2xmdW5kYW1lbnRhbHMub3JnL3dlYmdsL2xlc3NvbnMvZnIvd2ViZ2wtc2hhZGVycy1hbmQtZ2xzbC5odG1sI2xlcy11bmlmb3Jtcy1kYW5zLWxlcy1zaGFkZXJzLWRlLXZlcnRleFxyXG4gICAgLy9odHRwczovL3RoZWJvb2tvZnNoYWRlcnMuY29tL2dsb3NzYXJ5Lz9zZWFyY2g9bWl4XHJcbiAgICAvL2h0dHBzOi8vdGhlYm9va29mc2hhZGVycy5jb20vMDYvXHJcbiAgICAvL2h0dHBzOi8vdGhlYm9va29mc2hhZGVycy5jb20vZ2xvc3NhcnkvXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBnbFxyXG4gICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gY29sb3JzXHJcbiAgICAgKiBAcGFyYW0ge3tmdW46c3RyaW5nLGFscGhhOm51bWJlcn19IHN0cmV0Y2hpbmdcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplUGl4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGdsb2JhbE9wYWNpdHlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ2wsIGNvbG9ycywgc3RyZXRjaGluZywgc2l6ZVBpeCA9IDEwLCBnbG9iYWxPcGFjaXR5ID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9ICovXHJcbiAgICAgICAgdGhpcy5nbCA9IGdsXHJcbiAgICAgICAgLy9nbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRydWUpO1xyXG4gICAgICAgIC8vZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcbiAgICAgICAgLy9nbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFNoYWRlcn0gKi9cclxuICAgICAgICBjb25zdCB2U2hhZGVyID0gY3JlYXRlU2hhZGVyKFxyXG4gICAgICAgICAgICBnbCxcclxuICAgICAgICAgICAgZ2wuVkVSVEVYX1NIQURFUixcclxuICAgICAgICAgICAgYFxyXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMyIHBvcztcclxuICAgICAgICB1bmlmb3JtIGZsb2F0IHNpemVQaXg7XHJcbiAgICAgICAgdW5pZm9ybSBtYXQzIG1hdDtcclxuXHJcbiAgICAgICAgYXR0cmlidXRlIGZsb2F0IHQ7XHJcbiAgICAgICAgdmFyeWluZyBmbG9hdCB2dDtcclxuXHJcbiAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KG1hdCAqIHZlYzMocG9zLCAxLjApLCAxLjApO1xyXG4gICAgICAgICAgZ2xfUG9pbnRTaXplID0gc2l6ZVBpeDtcclxuICAgICAgICAgIHZ0ID0gdDtcclxuICAgICAgICB9XHJcbiAgICAgIGBcclxuICAgICAgICApXHJcblxyXG4gICAgICAgIC8vcHJlcGFyZSBmcmFnbWVudCBzaGFkZXIgY29kZVxyXG4gICAgICAgIC8vZGVjbGFyZSB0aGUgdW5pZm9ybSBhbmQgb3RoZXIgdmFyaWFibGVzXHJcbiAgICAgICAgbGV0IGZzaFN0cmluZyA9XHJcbiAgICAgICAgICAgICcnICtcclxuICAgICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbicgK1xyXG4gICAgICAgICAgICAndmFyeWluZyBmbG9hdCB2dDtcXG4nICtcclxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGE7XFxuJyArXHJcbiAgICAgICAgICAgICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSBbXVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIG91dC5wdXNoKCd1bmlmb3JtIHZlYzQgYycgKyBpICsgJztcXG4nKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5qb2luKCcnKVxyXG4gICAgICAgICAgICB9KSgpICtcclxuICAgICAgICAgICAgLy9zdGFydCB0aGUgbWFpbiBmdW5jdGlvbiwgYXBwbHkgdGhlIHN0cmV0Y2hpbmcgb2YgdFxyXG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHtcXG4nXHJcblxyXG4gICAgICAgIGlmIChzdHJldGNoaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChzdHJldGNoaW5nLmZ1biA9PSAncG93JylcclxuICAgICAgICAgICAgICAgIC8vc1BvdyA9ICh0LCBhbHBoYSA9IDMpID0+IE1hdGgucG93KHQsIGFscGhhKTtcclxuICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgZmxvYXQgdCA9IHBvdyh2dCwgYWxwaGEpO1xcbidcclxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyZXRjaGluZy5mdW4gPT0gJ3Bvd1JldicpXHJcbiAgICAgICAgICAgICAgICAvL3NQb3dSZXYgPSAodCwgYWxwaGEgPSAzKSA9PiAxIC0gTWF0aC5wb3coMSAtIHQsIDEgLyBhbHBoYSk7XHJcbiAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIGZsb2F0IHQgPSAxLjAtcG93KDEuMC12dCwgMS4wL2FscGhhKTtcXG4nXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmV0Y2hpbmcuZnVuID09ICdleHAnKVxyXG4gICAgICAgICAgICAgICAgLy9zRXhwID0gKHQsIGFscGhhID0gMykgPT4gYWxwaGEgPT0gMCA/IHQgOiAoTWF0aC5leHAodCAqIGFscGhhKSAtIDEpIC8gKE1hdGguZXhwKGFscGhhKSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZXRjaGluZy5hbHBoYSA9PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGZsb2F0IHQgPSB2dDtgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJyAgIGZsb2F0IHQgPSAoZXhwKHZ0ICogYWxwaGEpIC0gMS4wKSAvIChleHAoYWxwaGEpIC0gMS4wKTtcXG4nXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmV0Y2hpbmcuZnVuID09ICdleHBSZXYnKVxyXG4gICAgICAgICAgICAgICAgLy9zRXhwUmV2ID0gKHQsIGFscGhhID0gMykgPT4gYWxwaGEgPT0gMCA/IHQgOiAxIC0gKDEgLyBhbHBoYSkgKiBNYXRoLmxvZyhNYXRoLmV4cChhbHBoYSkgKiAoMSAtIHQpICsgdCk7XHJcbiAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz1cclxuICAgICAgICAgICAgICAgICAgICBzdHJldGNoaW5nLmFscGhhID09IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgZmxvYXQgdCA9IHZ0O2BcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnICAgZmxvYXQgdCA9IDEuMCAtICgxLjAgLyBhbHBoYSkgKiBsb2coZXhwKGFscGhhKSAqICgxLjAgLSB2dCkgKyB2dCk7XFxuJ1xyXG4gICAgICAgICAgICBlbHNlIGlmIChzdHJldGNoaW5nLmZ1biA9PSAnY2lyY2xlTG93Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0cmV0Y2hpbmcuYWxwaGEgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAvL2lmIChhbHBoYSA9PSAwKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIGZsb2F0IHQgPSB2dDtcXG4nXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJldGNoaW5nLmFscGhhID09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGFscGhhID09IDEpIHJldHVybiBNYXRoLnNxcnQoMiAqIHQgLSB0ICogdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICBmbG9hdCB0ID0gc3FydCh2dCAqICgyLjAgLSB2dCkpO1xcbidcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc3QgYSA9IGFscGhhIC8gKDEgLSBhbHBoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gTWF0aC5zcXJ0KDEgLyAoYSAqIGEpICsgdCAqICgyIC8gYSArIDIgLSB0KSkgLSAxIC8gYTtcclxuICAgICAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz1cclxuICAgICAgICAgICAgICAgICAgICAgICAgJyAgIGZsb2F0IGEgPSBhbHBoYSAvICgxLjAgLSBhbHBoYSk7XFxuJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcgICBmbG9hdCB0ID0gc3FydCgxLjAgLyAoYSAqIGEpICsgdnQgKiAoIDIuMC9hICsgMi4wIC0gdnQgKSkgLSAxLjAgLyBhO1xcbidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJldGNoaW5nLmZ1biA9PSAnY2lyY2xlSGlnaCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIDEgLSBzQ2lyY2xlTG93KDEgLSB0LCBhbHBoYSlcclxuICAgICAgICAgICAgICAgIGlmIChzdHJldGNoaW5nLmFscGhhID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAoYWxwaGEgPT0gMCkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZnNoU3RyaW5nICs9ICcgICBmbG9hdCB0ID0gdnQ7XFxuJ1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyZXRjaGluZy5hbHBoYSA9PSAxKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChhbHBoYSA9PSAxKSByZXR1cm4gTWF0aC5zcXJ0KDIgKiB0IC0gdCAqIHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgZmxvYXQgdCA9IDEuMCAtIHNxcnQoKDEuMCAtIHZ0KSAqICgxLjAgKyB2dCkpO1xcbidcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc3QgYSA9IGFscGhhIC8gKDEgLSBhbHBoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gTWF0aC5zcXJ0KDEgLyAoYSAqIGEpICsgKDIgKiB0KSAvIGEgKyAyICogdCAtIHQgKiB0KSAtIDEgLyBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnICAgZmxvYXQgYSA9IGFscGhhIC8gKDEuMCAtIGFscGhhKTtcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyAgIGZsb2F0IHQgPSAxLjAgLSBzcXJ0KDEuMCAvIChhICogYSkgKyAoMS4wLXZ0KSAqICggMi4wL2EgKyAxLjAgKyB2dCApKSArIDEuMCAvIGE7XFxuJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBzdHJldGNoaW5nIGZ1bmN0aW9uIGNvZGU6ICcgKyBzdHJldGNoaW5nLmZ1bilcclxuICAgICAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgZmxvYXQgdCA9IHZ0O1xcbidcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZzaFN0cmluZyArPSAnICAgZmxvYXQgdCA9IHZ0O1xcbidcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY2hvb3NlIGluaXRpYWwgYW5kIGZpbmFsIGNvbG9ycywgYW5kIGFkanVzdCB0IHZhbHVlXHJcbiAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPT0gMSkgZnNoU3RyaW5nICs9ICcgICB2ZWM0IGNJPWMwO1xcbiAgIHZlYzQgY0Y9YzA7XFxuJ1xyXG4gICAgICAgIGVsc2UgaWYgKGNvbG9ycy5sZW5ndGggPT0gMikgZnNoU3RyaW5nICs9ICcgICB2ZWM0IGNJPWMwO1xcbiAgIHZlYzQgY0Y9YzE7XFxuJ1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBuYiA9IGNvbG9ycy5sZW5ndGggLSAxXHJcbiAgICAgICAgICAgIGNvbnN0IG5icyA9IG5iICsgJy4wJ1xyXG4gICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIHZlYzQgY0k7XFxuJ1xyXG4gICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIHZlYzQgY0Y7XFxuJ1xyXG4gICAgICAgICAgICBmc2hTdHJpbmcgKz0gJyAgIGlmKHQ8MS4wLycgKyBuYnMgKyAnKSB7IGNJPWMwOyBjRj1jMTsgdD10KicgKyBuYnMgKyAnOyB9XFxuJ1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IG5iOyBpKyspXHJcbiAgICAgICAgICAgICAgICBmc2hTdHJpbmcgKz1cclxuICAgICAgICAgICAgICAgICAgICAnICAgZWxzZSBpZih0PCcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGkgK1xyXG4gICAgICAgICAgICAgICAgICAgICcuMC8nICtcclxuICAgICAgICAgICAgICAgICAgICBuYnMgK1xyXG4gICAgICAgICAgICAgICAgICAgICcpIHsgY0k9YycgK1xyXG4gICAgICAgICAgICAgICAgICAgIChpIC0gMSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICc7IGNGPWMnICtcclxuICAgICAgICAgICAgICAgICAgICBpICtcclxuICAgICAgICAgICAgICAgICAgICAnOyB0PScgK1xyXG4gICAgICAgICAgICAgICAgICAgIG5icyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyp0LScgK1xyXG4gICAgICAgICAgICAgICAgICAgIChpIC0gMSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICcuMDsgfVxcbidcclxuICAgICAgICAgICAgZnNoU3RyaW5nICs9XHJcbiAgICAgICAgICAgICAgICAnICAgZWxzZSB7IGNJPWMnICsgKG5iIC0gMSkgKyAnOyBjRj1jJyArIG5iICsgJzsgdD0nICsgbmJzICsgJyp0LScgKyAobmIgLSAxKSArICcuMDsgfVxcbidcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vb25lIHNpbmdsZSBjb2xvclxyXG4gICAgICAgIGlmIChjb2xvcnMubGVuZ3RoID09IDEpIGZzaFN0cmluZyArPSAnICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjMFswXSwgYzBbMV0sIGMwWzJdLCBjMFszXSk7fVxcbidcclxuICAgICAgICAvL3NldCBpbnRlcnBvbGF0ZWQgY29sb3IsIGJldHdlZW4gaW5pdGlhbCBhbmQgZmluYWwgb25lXHJcbiAgICAgICAgZWxzZSBmc2hTdHJpbmcgKz0gJyAgIGdsX0ZyYWdDb2xvciA9IG1peChjSSwgY0YsIHQpO31cXG4nXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coZnNoU3RyaW5nKVxyXG5cclxuICAgICAgICAvKiogQHR5cGUge1dlYkdMU2hhZGVyfSAqL1xyXG4gICAgICAgIGNvbnN0IGZTaGFkZXIgPSBjcmVhdGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnNoU3RyaW5nKVxyXG5cclxuICAgICAgICAvKiogQHR5cGUge1dlYkdMUHJvZ3JhbX0gKi9cclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBpbml0U2hhZGVyUHJvZ3JhbShnbCwgdlNoYWRlciwgZlNoYWRlcilcclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSlcclxuXHJcbiAgICAgICAgLy9zZXQgdW5pZm9ybXNcclxuXHJcbiAgICAgICAgLy9zaXplUGl4XHJcbiAgICAgICAgLy9UT0RPOiBidWcgaGVyZS4gU2VlbXMgdG8gYmUgbGltaXRlZCB0byBzb21lIHRocmVzaG9sZCB2YWx1ZSAoYXJvdW5kIDI1MCkuXHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sICdzaXplUGl4JyksIDEuMCAqIHNpemVQaXgpXHJcblxyXG4gICAgICAgIC8vc3RyZXRjaGluZyBhbHBoYSBmYWN0b3JcclxuICAgICAgICBnbC51bmlmb3JtMWYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2FscGhhJyksIHN0cmV0Y2hpbmcgPyAxLjAgKiBzdHJldGNoaW5nLmFscGhhIDogMC4wKVxyXG5cclxuICAgICAgICAvL2NvbG9yc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjb2xvcihjb2xvcnNbaV0pXHJcblxyXG4gICAgICAgICAgICBsZXQgb3BhY2l0eSA9IGMub3BhY2l0eVxyXG4gICAgICAgICAgICBpZiAoYy5vcGFjaXR5ID09IDEgJiYgZ2xvYmFsT3BhY2l0eSAhPSB1bmRlZmluZWQpIG9wYWNpdHkgPSBnbG9iYWxPcGFjaXR5XHJcblxyXG4gICAgICAgICAgICBnbC51bmlmb3JtNGZ2KGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sICdjJyArIGkpLCBbXHJcbiAgICAgICAgICAgICAgICArYy5yIC8gMjU1LjAsXHJcbiAgICAgICAgICAgICAgICArYy5nIC8gMjU1LjAsXHJcbiAgICAgICAgICAgICAgICArYy5iIC8gMjU1LjAsXHJcbiAgICAgICAgICAgICAgICArb3BhY2l0eSxcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqICAqL1xyXG4gICAgZHJhdyh2ZXJ0aWNlc0J1ZmZlciwgdEJ1ZmZlciwgdHJhbnNmb01hdCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbFxyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLnByb2dyYW1cclxuXHJcbiAgICAgICAgLy92ZXJ0aWNlIGRhdGFcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpXHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXNCdWZmZXIpLCBnbC5TVEFUSUNfRFJBVylcclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdwb3MnKVxyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgICAgICAgIHBvc2l0aW9uLFxyXG4gICAgICAgICAgICAyLCAvL251bUNvbXBvbmVudHNcclxuICAgICAgICAgICAgZ2wuRkxPQVQsIC8vdHlwZVxyXG4gICAgICAgICAgICBmYWxzZSwgLy9ub3JtYWxpc2VcclxuICAgICAgICAgICAgMCwgLy9zdHJpZGVcclxuICAgICAgICAgICAgMCAvL29mZnNldFxyXG4gICAgICAgIClcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbilcclxuXHJcbiAgICAgICAgLy90IGRhdGFcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2wuY3JlYXRlQnVmZmVyKCkpXHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkodEJ1ZmZlciksIGdsLlNUQVRJQ19EUkFXKVxyXG4gICAgICAgIGNvbnN0IHQgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAndCcpXHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0LCAxLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApXHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodClcclxuXHJcbiAgICAgICAgLy90cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdtYXQnKSwgZmFsc2UsIG5ldyBGbG9hdDMyQXJyYXkodHJhbnNmb01hdCkpXHJcblxyXG4gICAgICAgIC8vIEVuYWJsZSB0aGUgZGVwdGggdGVzdFxyXG4gICAgICAgIC8vZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgIC8vIENsZWFyIHRoZSBjb2xvciBidWZmZXIgYml0XHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVClcclxuICAgICAgICAvLyBTZXQgdGhlIHZpZXcgcG9ydFxyXG4gICAgICAgIC8vZ2wudmlld3BvcnQoMCwgMCwgY2cudywgY2cuaCk7XHJcblxyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCB2ZXJ0aWNlc0J1ZmZlci5sZW5ndGggLyAyKVxyXG4gICAgfVxyXG59XHJcbiIsIi8vQHRzLWNoZWNrXHJcbid1c2Ugc3RyaWN0J1xyXG5cclxuaW1wb3J0IHsgaW5pdFNoYWRlclByb2dyYW0sIGNyZWF0ZVNoYWRlciB9IGZyb20gJy4vd2ViR0xVdGlscy5qcydcclxuaW1wb3J0IHsgY29sb3IgfSBmcm9tICdkMy1jb2xvcidcclxuXHJcbi8qKlxyXG4gKiBFdmVyeXRoaW5nIHRvIGVhc2lseSBkcmF3IGNvbG9yZWQgc3F1YXJlcyB3aXRoIHdlYkdMLlxyXG4gKiBBbGwgdGhlIHNhbWUgc2l6ZSwgYnV0IGRpZmZlcmVudCBmaWxsIGNvbG9yLlxyXG4gKiBDb2xvciBiYXNlZCBvbiBjYXRlZ29yaWVzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdlYkdMU3F1YXJlQ29sb3JpbmdDYXRBZHZhbmNlZCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9yc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xvcnMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59ICovXHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBjb2xvcnNcclxuXHJcbiAgICAgICAgLyoqIFZlY3RvciBzaGFkZXIgcHJvZ3JhbVxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICAgICAgdGhpcy52c2hTdHJpbmcgPSBgXHJcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgcG9zO1xyXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgc2l6ZVBpeDtcclxuICAgICAgICB1bmlmb3JtIG1hdDMgbWF0O1xyXG5cclxuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgaTtcclxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZpO1xyXG5cclxuICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQobWF0ICogdmVjMyhwb3MsIDEuMCksIDEuMCk7XHJcbiAgICAgICAgICBnbF9Qb2ludFNpemUgPSBzaXplUGl4O1xyXG4gICAgICAgICAgdmkgPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBgXHJcblxyXG4gICAgICAgIC8vcHJlcGFyZSBmcmFnbWVudCBzaGFkZXIgY29kZVxyXG4gICAgICAgIC8vZGVjbGFyZSB0aGUgdW5pZm9ybSBhbmQgb3RoZXIgdmFyaWFibGVzXHJcbiAgICAgICAgY29uc3Qgb3V0ID0gW11cclxuICAgICAgICBvdXQucHVzaCgncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudmFyeWluZyBmbG9hdCB2aTtcXG4nKVxyXG4gICAgICAgIC8vYWRkIGNvbG9yIHVuaWZvcm1zXHJcbiAgICAgICAgb3V0LnB1c2goJ3VuaWZvcm0gdmVjNCcpXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSBvdXQucHVzaCgnLCcpXHJcbiAgICAgICAgICAgIG91dC5wdXNoKCcgYycgKyBpKVxyXG4gICAgICAgIH1cclxuICAgICAgICBvdXQucHVzaCgnO1xcbicpXHJcbiAgICAgICAgLy9zdGFydCB0aGUgbWFpbiBmdW5jdGlvblxyXG4gICAgICAgIG91dC5wdXNoKCd2b2lkIG1haW4odm9pZCkge1xcbicpXHJcbiAgICAgICAgLy9jaG9vc2UgY29sb3IgaVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkgb3V0LnB1c2goJ2Vsc2UgJylcclxuICAgICAgICAgICAgb3V0LnB1c2goJ2lmKHZpPT0nKVxyXG4gICAgICAgICAgICBvdXQucHVzaChpKVxyXG4gICAgICAgICAgICBvdXQucHVzaCgnLjApIGdsX0ZyYWdDb2xvciA9IHZlYzQoYycpXHJcbiAgICAgICAgICAgIG91dC5wdXNoKGkpXHJcbiAgICAgICAgICAgIG91dC5wdXNoKCdbMF0sIGMnKVxyXG4gICAgICAgICAgICBvdXQucHVzaChpKVxyXG4gICAgICAgICAgICBvdXQucHVzaCgnWzFdLCBjJylcclxuICAgICAgICAgICAgb3V0LnB1c2goaSlcclxuICAgICAgICAgICAgb3V0LnB1c2goJ1syXSwgYycpXHJcbiAgICAgICAgICAgIG91dC5wdXNoKGkpXHJcbiAgICAgICAgICAgIG91dC5wdXNoKCdbM10pO1xcbicpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dC5wdXNoKCdlbHNlIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTtcXG59JylcclxuICAgICAgICAvKiogRnJhZ21lbnQgc2hhZGVyIHByb2dyYW1cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgICAgIHRoaXMuZnNoU3RyaW5nID0gb3V0LmpvaW4oJycpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqICAqL1xyXG4gICAgZHJhdyhnbCwgdmVydGljZXNCdWZmZXIsIGlCdWZmZXIsIHRyYW5zZm9NYXQsIHNpemVQaXggPSAxMCkge1xyXG4gICAgICAgIC8qKiBAdHlwZSB7V2ViR0xTaGFkZXJ9ICovXHJcbiAgICAgICAgY29uc3QgdlNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdGhpcy52c2hTdHJpbmcpXHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7V2ViR0xTaGFkZXJ9ICovXHJcbiAgICAgICAgY29uc3QgZlNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCB0aGlzLmZzaFN0cmluZylcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHtXZWJHTFByb2dyYW19ICovXHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGluaXRTaGFkZXJQcm9ncmFtKGdsLCB2U2hhZGVyLCBmU2hhZGVyKVxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSlcclxuXHJcbiAgICAgICAgLy9zZXQgdW5pZm9ybXNcclxuXHJcbiAgICAgICAgLy9zaXplUGl4XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnc2l6ZVBpeCcpLCAxLjAgKiBzaXplUGl4KVxyXG5cclxuICAgICAgICAvL2NvbG9yc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2xvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYyA9IGNvbG9yKHRoaXMuY29sb3JzW2ldKVxyXG4gICAgICAgICAgICBnbC51bmlmb3JtNGZ2KGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnYycgKyBpKSwgW1xyXG4gICAgICAgICAgICAgICAgK2MuciAvIDI1NS4wLFxyXG4gICAgICAgICAgICAgICAgK2MuZyAvIDI1NS4wLFxyXG4gICAgICAgICAgICAgICAgK2MuYiAvIDI1NS4wLFxyXG4gICAgICAgICAgICAgICAgK2Mub3BhY2l0eSxcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdmVydGljZSBkYXRhXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGdsLmNyZWF0ZUJ1ZmZlcigpKVxyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzQnVmZmVyKSwgZ2wuU1RBVElDX0RSQVcpXHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAncG9zJylcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxyXG4gICAgICAgICAgICBwb3NpdGlvbixcclxuICAgICAgICAgICAgMiwgLy9udW1Db21wb25lbnRzXHJcbiAgICAgICAgICAgIGdsLkZMT0FULCAvL3R5cGVcclxuICAgICAgICAgICAgZmFsc2UsIC8vbm9ybWFsaXNlXHJcbiAgICAgICAgICAgIDAsIC8vc3RyaWRlXHJcbiAgICAgICAgICAgIDAgLy9vZmZzZXRcclxuICAgICAgICApXHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb24pXHJcblxyXG4gICAgICAgIC8vaSBkYXRhXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGdsLmNyZWF0ZUJ1ZmZlcigpKVxyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KGlCdWZmZXIpLCBnbC5TVEFUSUNfRFJBVylcclxuICAgICAgICBjb25zdCBpID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2knKVxyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaSwgMSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKVxyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXHJcblxyXG4gICAgICAgIC8vdHJhbnNmb3JtYXRpb25cclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnbWF0JyksIGZhbHNlLCBuZXcgRmxvYXQzMkFycmF5KHRyYW5zZm9NYXQpKVxyXG5cclxuICAgICAgICAvLyBFbmFibGUgdGhlIGRlcHRoIHRlc3RcclxuICAgICAgICAvL2dsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgICAgICAvLyBDbGVhciB0aGUgY29sb3IgYnVmZmVyIGJpdFxyXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpXHJcbiAgICAgICAgLy8gU2V0IHRoZSB2aWV3IHBvcnRcclxuICAgICAgICAvL2dsLnZpZXdwb3J0KDAsIDAsIGNnLncsIGNnLmgpO1xyXG5cclxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgdmVydGljZXNCdWZmZXIubGVuZ3RoIC8gMilcclxuICAgIH1cclxufVxyXG4iLCIvL0B0cy1jaGVja1xyXG4ndXNlIHN0cmljdCdcclxuXHJcbi8qKlxyXG4gKiBTb21lIGZ1bmN0aW9uIFswLDFdLT5bMCwxXSB0byBzdHJldGNoIHJhbmdlIG9mIHZhbHVlcy5cclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXVyb3N0YXQvZ3JpZHZpei9ibG9iL21hc3Rlci9kb2NzL3JlZmVyZW5jZS5tZCNzdHJldGNoaW5nXHJcbiAqIEBzZWUgaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BqZ2FmZnVyaS9zdHJldGNoaW5nXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIFswLDFdLT5bMCwxXSB0byBzdHJldGNoIHJhbmdlIG9mIHZhbHVlcy5cclxuICogUG9seW5vbWlhbFxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdCBUaGUgdmFsdWUgdG8gc3RyZXRjaCwgd2l0aGluIFswLDFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYSAxOiBubyBzdHJldGNoaW5nLiA8MTogc2hvdyBsb3cgdmFsdWVzLiA+MTogc2hvdyBoaWdoIHZhbHVlcy5cclxuICogQHJldHVybnMge251bWJlcn0gVGhlIHN0cmV0Y2hlZCB2YWx1ZSwgd2l0aGluIFswLDFdXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc1BvdyA9ICh0LCBhbHBoYSA9IDMpID0+IE1hdGgucG93KHQsIGFscGhhKVxyXG5cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIFswLDFdLT5bMCwxXSB0byBzdHJldGNoIHJhbmdlIG9mIHZhbHVlcy5cclxuICogUG9seW5vbWlhbCAocmV2ZXJzZSlcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHQgVGhlIHZhbHVlIHRvIHN0cmV0Y2gsIHdpdGhpbiBbMCwxXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYWxwaGEgMTogbm8gc3RyZXRjaGluZy4gPDE6IHNob3cgbG93IHZhbHVlcy4gPjE6IHNob3cgaGlnaCB2YWx1ZXMuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzdHJldGNoZWQgdmFsdWUsIHdpdGhpbiBbMCwxXVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNQb3dSZXYgPSAodCwgYWxwaGEgPSAzKSA9PiAxIC0gTWF0aC5wb3coMSAtIHQsIDEgLyBhbHBoYSlcclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiBbMCwxXS0+WzAsMV0gdG8gc3RyZXRjaCByYW5nZSBvZiB2YWx1ZXMuXHJcbiAqIEV4cG9uZW50aWFsXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0IFRoZSB2YWx1ZSB0byBzdHJldGNoLCB3aXRoaW4gWzAsMV1cclxuICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIDA6IG5vIHN0cmV0Y2hpbmcuIC1JbmY6IHNob3cgbG93IHZhbHVlcy4gSW5mOiBzaG93IGhpZ2ggdmFsdWVzLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3RyZXRjaGVkIHZhbHVlLCB3aXRoaW4gWzAsMV1cclxuICovXHJcbmV4cG9ydCBjb25zdCBzRXhwID0gKHQsIGFscGhhID0gMykgPT4gKGFscGhhID09IDAgPyB0IDogKE1hdGguZXhwKHQgKiBhbHBoYSkgLSAxKSAvIChNYXRoLmV4cChhbHBoYSkgLSAxKSlcclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiBbMCwxXS0+WzAsMV0gdG8gc3RyZXRjaCByYW5nZSBvZiB2YWx1ZXMuXHJcbiAqIEV4cG9uZW50aWFsIChyZXZlcnNlKVxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdCBUaGUgdmFsdWUgdG8gc3RyZXRjaCwgd2l0aGluIFswLDFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYSAwOiBubyBzdHJldGNoaW5nLiAtSW5mOiBzaG93IGxvdyB2YWx1ZXMuIEluZjogc2hvdyBoaWdoIHZhbHVlcy5cclxuICogQHJldHVybnMge251bWJlcn0gVGhlIHN0cmV0Y2hlZCB2YWx1ZSwgd2l0aGluIFswLDFdXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc0V4cFJldiA9ICh0LCBhbHBoYSA9IDMpID0+XHJcbiAgICBhbHBoYSA9PSAwID8gdCA6IDEgLSAoMSAvIGFscGhhKSAqIE1hdGgubG9nKE1hdGguZXhwKGFscGhhKSAqICgxIC0gdCkgKyB0KVxyXG5cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIFswLDFdLT5bMCwxXSB0byBzdHJldGNoIHJhbmdlIG9mIHZhbHVlcy5cclxuICogQ2lyY2xlLCBzaG93IGxvdyB2YWx1ZXNcclxuICogTkI6IHNDaXJjbGVIaWdoIGFuZCBzQ2lyY2xlTG93IGFyZSBpbnZlcnNlIGZ1bmN0aW9ucyBvZiBlYWNoIG90aGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdCBUaGUgdmFsdWUgdG8gc3RyZXRjaCwgd2l0aGluIFswLDFdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYSAwOiBubyBzdHJldGNoaW5nLiAxOiBwZXJmZWN0IGNpcmNsZSBzZWN0aW9uXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzdHJldGNoZWQgdmFsdWUsIHdpdGhpbiBbMCwxXVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNDaXJjbGVMb3cgPSAodCwgYWxwaGEgPSAwLjgpID0+IHtcclxuICAgIGlmIChhbHBoYSA9PSAwKSByZXR1cm4gdFxyXG4gICAgaWYgKGFscGhhID09IDEpIHJldHVybiBNYXRoLnNxcnQodCAqICgyIC0gdCkpXHJcbiAgICBjb25zdCBhID0gYWxwaGEgLyAoMSAtIGFscGhhKVxyXG4gICAgcmV0dXJuIE1hdGguc3FydCgxIC8gKGEgKiBhKSArIHQgKiAoMiAvIGEgKyAyIC0gdCkpIC0gMSAvIGFcclxufVxyXG5cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIFswLDFdLT5bMCwxXSB0byBzdHJldGNoIHJhbmdlIG9mIHZhbHVlcy5cclxuICogQ2lyY2xlLCBzaG93IGhpZ2ggdmFsdWVzXHJcbiAqIE5COiBzQ2lyY2xlSGlnaCBhbmQgc0NpcmNsZUxvdyBhcmUgaW52ZXJzZSBmdW5jdGlvbnMgb2YgZWFjaCBvdGhlci5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHQgVGhlIHZhbHVlIHRvIHN0cmV0Y2gsIHdpdGhpbiBbMCwxXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYWxwaGEgMDogbm8gc3RyZXRjaGluZy4gMTogcGVyZmVjdCBjaXJjbGUgc2VjdGlvblxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3RyZXRjaGVkIHZhbHVlLCB3aXRoaW4gWzAsMV1cclxuICovXHJcbmV4cG9ydCBjb25zdCBzQ2lyY2xlSGlnaCA9ICh0LCBhbHBoYSA9IDAuOCkgPT4gMSAtIHNDaXJjbGVMb3coMSAtIHQsIGFscGhhKVxyXG5cclxuLyoqXHJcbiAqIEludmVyc2UgZnVuY3Rpb25zXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEludmVyc2UgZnVuY3Rpb24gb2Ygc0V4cFxyXG4gKiBAcGFyYW0ge251bWJlcn0geVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYWxwaGFcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBzRXhwSW52ZXJzZSA9ICh5LCBhbHBoYSA9IDMpID0+XHJcbiAgICBhbHBoYSA9PSAwID8geSA6ICgxIC8gYWxwaGEpICogTWF0aC5sb2coMSAtIHkgKyB5ICogTWF0aC5leHAoYWxwaGEpKVxyXG5cclxuLyoqXHJcbiAqIEludmVyc2UgZnVuY3Rpb24gb2Ygc0V4cFJldlxyXG4gKiBAcGFyYW0ge251bWJlcn0geVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYWxwaGFcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBzRXhwUmV2SW52ZXJzZSA9ICh5LCBhbHBoYSA9IDMpID0+IChNYXRoLmV4cCgtYWxwaGEgKiB5KSAtIDEpIC8gKE1hdGguZXhwKC1hbHBoYSkgLSAxKVxyXG5cclxuLyoqXHJcbiAqIEludmVyc2UgZnVuY3Rpb24gb2Ygc1Bvd1xyXG4gKiBAcGFyYW0ge251bWJlcn0geVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYWxwaGFcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcblxyXG5leHBvcnQgY29uc3Qgc1Bvd0ludmVyc2UgPSAoeSwgYWxwaGEgPSAzKSA9PiBNYXRoLnBvdyh5LCAxIC8gYWxwaGEpXHJcblxyXG4vKipcclxuICogSW52ZXJzZSBmdW5jdGlvbiBvZiBzUG93UmV2XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNQb3dSZXZJbnZlcnNlID0gKHksIGFscGhhID0gMykgPT4gMSAtIE1hdGgucG93KDEgLSB5LCBhbHBoYSlcclxuXHJcbi8vdGVzdCBjb2RlXHJcbi8qXHJcbmZvciAobGV0IGkgPSAwOyBpIDw9IDE7IGkgKz0gMC4wMDEpIHtcclxuICAvL2NvbnN0IHYgPSBndml6LnNFeHAoZ3Zpei5zRXhwSW52ZXJzZShpKSk7XHJcbiAgLy9jb25zdCB2ID0gZ3Zpei5zRXhwSW52ZXJzZShndml6LnNFeHAoaSkpO1xyXG4gIC8vY29uc3QgdiA9IGd2aXouc0V4cFJldihndml6LnNFeHBSZXZJbnZlcnNlKGkpKTtcclxuICAvL2NvbnN0IHYgPSBndml6LnNFeHBSZXZJbnZlcnNlKGd2aXouc0V4cFJldihpKSk7XHJcbiAgLy9jb25zdCB2ID0gZ3Zpei5zUG93KGd2aXouc1Bvd0ludmVyc2UoaSkpO1xyXG4gIC8vY29uc3QgdiA9IGd2aXouc1Bvd0ludmVyc2UoZ3Zpei5zUG93KGkpKTtcclxuICAvL2NvbnN0IHYgPSBndml6LnNQb3dSZXYoZ3Zpei5zUG93UmV2SW52ZXJzZShpKSk7XHJcbiAgLy9jb25zdCB2ID0gZ3Zpei5zUG93UmV2SW52ZXJzZShndml6LnNQb3dSZXYoaSkpO1xyXG4gIC8vY29uc3QgdiA9IGd2aXouc0NpcmNsZUxvdyhndml6LnNDaXJjbGVIaWdoKGkpKTtcclxuICAvL2NvbnN0IHYgPSBndml6LnNDaXJjbGVIaWdoKGd2aXouc0NpcmNsZUxvdyhpKSk7XHJcbiAgY29uc29sZS5sb2coaSAtIHYpXHJcbn1cclxuKi9cclxuIiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHdpZHRoXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZWlnaHRcclxuICogQHBhcmFtIHtvYmplY3R9IG9wdHNcclxuICogQHJldHVybnMge3tjYW52YXM6SFRNTENhbnZhc0VsZW1lbnQsIGdsOldlYkdMUmVuZGVyaW5nQ29udGV4dH19XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWFrZVdlYkdMQ2FudmFzKHdpZHRoLCBoZWlnaHQsIG9wdHMpIHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXHJcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoKVxyXG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KVxyXG4gICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRzKVxyXG4gICAgaWYgKCFnbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGluaXRpYWxpemUgV2ViR0wuIFlvdXIgYnJvd3NlciBvciBtYWNoaW5lIG1heSBub3Qgc3VwcG9ydCBpdC4nKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgY2FudmFzOiBjYW52YXMsIGdsOiBnbCB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgc2hhZGVyIHByb2dyYW0sIHNvIFdlYkdMIGtub3dzIGhvdyB0byBkcmF3IG91ciBkYXRhXHJcbiAqXHJcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxyXG4gKiBAcGFyYW0gIHsuLi5XZWJHTFNoYWRlcn0gc2hhZGVyc1xyXG4gKiBAcmV0dXJucyB7V2ViR0xQcm9ncmFtfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGluaXRTaGFkZXJQcm9ncmFtKGdsLCAuLi5zaGFkZXJzKSB7XHJcbiAgICAvKiogQHR5cGUge1dlYkdMUHJvZ3JhbXxudWxsfSAqL1xyXG4gICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKVxyXG4gICAgaWYgKHByb2dyYW0gPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIHdlYkdMIHByb2dyYW0nKVxyXG4gICAgZm9yIChjb25zdCBzaGFkZXIgb2Ygc2hhZGVycykgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcilcclxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pXHJcbiAgICBpZiAoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHJldHVybiBwcm9ncmFtXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkgfHwgJ0Nhbm5vdCBjcmVhdGUgd2ViR0wgcHJvZ3JhbSAoMiknKVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNoYWRlciBvZiB0aGUgZ2l2ZW4gdHlwZSwgdXBsb2FkcyB0aGUgc291cmNlIGFuZCBjb21waWxlcyBpdC5cclxuICpcclxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXHJcbiAqIEBwYXJhbSAgey4uLnN0cmluZ30gc291cmNlc1xyXG4gKiBAcmV0dXJucyB7V2ViR0xTaGFkZXJ9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2hhZGVyKGdsLCB0eXBlLCAuLi5zb3VyY2VzKSB7XHJcbiAgICAvKiogQHR5cGUge1dlYkdMU2hhZGVyfG51bGx9ICovXHJcbiAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSlcclxuICAgIGlmIChzaGFkZXIgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIHdlYkdMIHNoYWRlcicpXHJcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2VzLmpvaW4oJ1xcbicpKVxyXG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpXHJcbiAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSByZXR1cm4gc2hhZGVyXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpIHx8ICdDYW5ub3QgY3JlYXRlIHdlYkdMIHNoYWRlciAoMiknKVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgd2ViR0wgaXMgc3VwcG9ydGVkXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrV2ViR0xTdXBwb3J0KCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxyXG4gICAgICAgIHJldHVybiAhIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQgJiZcclxuICAgICAgICAgICAgKGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKSlcclxuICAgICAgICAgICAgPyB0cnVlXHJcbiAgICAgICAgICAgIDogZmFsc2VcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG59XHJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLy9AdHMtY2hlY2tcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG4vLyB0aGUgYXBwbGljYXRpb25cclxuZXhwb3J0IHsgQXBwIH0gZnJvbSAnLi9BcHAuanMnXHJcbmV4cG9ydCB7IEdlb0NhbnZhcyB9IGZyb20gJy4vR2VvQ2FudmFzLmpzJ1xyXG5leHBvcnQgeyBTdHlsZSB9IGZyb20gJy4vU3R5bGUuanMnXHJcbmV4cG9ydCB7IExheWVyIH0gZnJvbSAnLi9MYXllci5qcydcclxuZXhwb3J0IHsgRGF0YXNldCB9IGZyb20gJy4vRGF0YXNldC5qcydcclxuZXhwb3J0IHsgRGF0YXNldENvbXBvbmVudCB9IGZyb20gJy4vRGF0YXNldENvbXBvbmVudC5qcydcclxuXHJcbi8vIGV4cG9ydCBkYXRhc2V0IHR5cGVzXHJcbmV4cG9ydCB7IFRpbGVkR3JpZCB9IGZyb20gJy4vZGF0YXNldC9UaWxlZEdyaWQuanMnXHJcbmV4cG9ydCB7IEdyaWRUaWxlIH0gZnJvbSAnLi9kYXRhc2V0L0dyaWRUaWxlLmpzJ1xyXG5leHBvcnQgeyBDU1ZHcmlkIH0gZnJvbSAnLi9kYXRhc2V0L0NTVkdyaWQuanMnXHJcbmV4cG9ydCB7IExHcmlkIH0gZnJvbSAnLi9kYXRhc2V0L0xHcmlkLmpzJ1xyXG4vL2V4cG9ydCB7IEdlb1RJRkYgfSBmcm9tIFwiLi9kYXRhc2V0L0dlb1RJRkZcIlxyXG5cclxuLy8gZXhwb3J0IHN0eWxlc1xyXG5leHBvcnQgeyBTaGFwZUNvbG9yU2l6ZVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9TaGFwZUNvbG9yU2l6ZVN0eWxlLmpzJ1xyXG5leHBvcnQgeyBTdHJva2VTdHlsZSB9IGZyb20gJy4vc3R5bGUvU3Ryb2tlU3R5bGUuanMnXHJcbmV4cG9ydCB7IEpveVBsb3RTdHlsZSB9IGZyb20gJy4vc3R5bGUvSm95UGxvdFN0eWxlLmpzJ1xyXG5leHBvcnQgeyBDb21wb3NpdGlvblN0eWxlIH0gZnJvbSAnLi9zdHlsZS9Db21wb3NpdGlvblN0eWxlLmpzJ1xyXG5leHBvcnQgeyBTZWdtZW50U3R5bGUgfSBmcm9tICcuL3N0eWxlL1NlZ21lbnRTdHlsZS5qcydcclxuZXhwb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSAnLi9zdHlsZS9UZXh0U3R5bGUuanMnXHJcbmV4cG9ydCB7IFBpbGxhclN0eWxlIH0gZnJvbSAnLi9zdHlsZS9QaWxsYXJTdHlsZS5qcydcclxuZXhwb3J0IHsgU2lkZVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9TaWRlU3R5bGUuanMnXHJcbmV4cG9ydCB7IENvbnRvdXJTdHlsZSB9IGZyb20gJy4vc3R5bGUvQ29udG91clN0eWxlLmpzJ1xyXG5leHBvcnQgeyBTaWRlQ2F0U3R5bGUgfSBmcm9tICcuL3N0eWxlL1NpZGVDYXRTdHlsZS5qcydcclxuZXhwb3J0IHsgRG90RGVuc2l0eVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9Eb3REZW5zaXR5U3R5bGUuanMnXHJcbmV4cG9ydCB7IFRhbmFrYVN0eWxlIH0gZnJvbSAnLi9zdHlsZS9UYW5ha2FTdHlsZS5qcydcclxuZXhwb3J0IHsgTGVnb1N0eWxlIH0gZnJvbSAnLi9zdHlsZS9MZWdvU3R5bGUuanMnXHJcbmV4cG9ydCB7IFNxdWFyZUNvbG9yV0dMU3R5bGUgfSBmcm9tICcuL3N0eWxlL1NxdWFyZUNvbG9yV0dMU3R5bGUuanMnXHJcbmV4cG9ydCB7IFNxdWFyZUNvbG9yQ2F0V0dMU3R5bGUgfSBmcm9tICcuL3N0eWxlL1NxdWFyZUNvbG9yQ2F0V0dMU3R5bGUuanMnXHJcbmV4cG9ydCB7IE1vc2FpY1N0eWxlIH0gZnJvbSAnLi9zdHlsZS9Nb3NhaWNTdHlsZS5qcydcclxuZXhwb3J0IHsgTmluamFTdGFyU3R5bGUgfSBmcm9tICcuL3N0eWxlL05pbmphU3RhclN0eWxlLmpzJ1xyXG5leHBvcnQgeyBUaW1lU2VyaWVzU3R5bGUgfSBmcm9tICcuL3N0eWxlL1RpbWVTZXJpZXNTdHlsZS5qcydcclxuZXhwb3J0IHsgSXNvRmVuY2VTdHlsZSB9IGZyb20gJy4vc3R5bGUvSXNvRmVuY2VTdHlsZS5qcydcclxuXHJcbi8vIGV4cG9ydCBhZGRpdGlvbmFsIGxheWVyc1xyXG5leHBvcnQgeyBCYWNrZ3JvdW5kTGF5ZXIgfSBmcm9tICcuL0JhY2tncm91bmRMYXllci5qcydcclxuZXhwb3J0IHsgQmFja2dyb3VuZExheWVyV01TIH0gZnJvbSAnLi9CYWNrZ3JvdW5kTGF5ZXJXTVMuanMnXHJcbmV4cG9ydCB7IExhYmVsTGF5ZXIgfSBmcm9tICcuL0xhYmVsTGF5ZXIuanMnXHJcbmV4cG9ydCB7IExpbmVMYXllciBhcyBCb3VuZGFyeUxheWVyIH0gZnJvbSAnLi9MaW5lTGF5ZXIuanMnXHJcblxyXG4vLyBleHBvcnQgbGVnZW5kc1xyXG5leHBvcnQgeyBDb2xvckxlZ2VuZCB9IGZyb20gJy4vbGVnZW5kL0NvbG9yTGVnZW5kLmpzJ1xyXG5leHBvcnQgeyBDb2xvckRpc2NyZXRlTGVnZW5kIH0gZnJvbSAnLi9sZWdlbmQvQ29sb3JEaXNjcmV0ZUxlZ2VuZC5qcydcclxuZXhwb3J0IHsgQ29sb3JDYXRlZ29yeUxlZ2VuZCB9IGZyb20gJy4vbGVnZW5kL0NvbG9yQ2F0ZWdvcnlMZWdlbmQuanMnXHJcbmV4cG9ydCB7IFNpemVMZWdlbmQgfSBmcm9tICcuL2xlZ2VuZC9TaXplTGVnZW5kLmpzJ1xyXG5leHBvcnQgeyBTZWdtZW50V2lkdGhMZWdlbmQgfSBmcm9tICcuL2xlZ2VuZC9TZWdtZW50V2lkdGhMZWdlbmQuanMnXHJcbmV4cG9ydCB7IFNlZ21lbnRPcmllbnRhdGlvbkxlZ2VuZCB9IGZyb20gJy4vbGVnZW5kL1NlZ21lbnRPcmllbnRhdGlvbkxlZ2VuZC5qcydcclxuXHJcbi8vIGV4cG9ydCB7IGdvVG9TdHJhaWdodCwgem9vbVRvIH0gZnJvbSBcIi4vdXRpbHMvem9vbVV0aWxzXCJcclxuZXhwb3J0ICogZnJvbSAnLi91dGlscy9zdHJldGNoaW5nLmpzJ1xyXG5cclxuZXhwb3J0IHsgZ2V0Q2xhc3MgfSBmcm9tICcuL3V0aWxzL1V0aWxzLmpzJ1xyXG5cclxuXHJcblxyXG5pbXBvcnQgeyBHZW9DYW52YXMgfSBmcm9tICcuL0dlb0NhbnZhcy5qcydcclxuZXhwb3J0IGNvbnN0IGdldFBhcmFtZXRlckJ5TmFtZSA9IEdlb0NhbnZhcy5nZXRQYXJhbWV0ZXJCeU5hbWVcclxuXHJcbi8vIHNldCBkZWZhdWx0IGQzIGxvY2FsZVxyXG5pbXBvcnQgeyBmb3JtYXREZWZhdWx0TG9jYWxlIH0gZnJvbSAnZDMtZm9ybWF0J1xyXG5mb3JtYXREZWZhdWx0TG9jYWxlKHtcclxuICAgIGRlY2ltYWw6ICcuJyxcclxuICAgIHRob3VzYW5kczogJyAnLFxyXG4gICAgZ3JvdXBpbmc6IFszXSxcclxuICAgIGN1cnJlbmN5OiBbJycsICfigqwnXSxcclxufSlcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9