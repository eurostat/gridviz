<body style="margin: 0; height: 100%; font-family: Arial, Helvetica, sans-serif; overflow: hidden">
    <div id="map" style="height: 100%; width: 100%"></div>

    <div style="
        position: absolute;
        left: 20px;
        top: 20px;
        width: auto;
        height: auto;
        padding: 10px;
        border: 0px;
        border-radius: 5px;
        background: #ffffffcc;
        line-height: 1.6;
        box-shadow: 5px 5px 5px grey;
    ">
        <div id="layer">
            <span style="font-size: 1em">
                <input type="radio" name="layer" id="pop" value="pop" checked />
                <label for="pop">Total population</label>
                <br />
                <input type="radio" name="layer" id="sex" value="sex" />
                <label for="sex">Sex</label>
                <br />
                <input type="radio" name="layer" id="emp" value="emp" />
                <label for="emp">Employment</label>
                <br />
                <input type="radio" name="layer" id="age" value="age" />
                <label for="age">Age</label>
                <br />
                <input type="radio" name="layer" id="mobility" value="mobility" />
                <label for="mobility">Mobility</label>
                <br />
                <input type="radio" name="layer" id="pob" value="pob" />
                <label for="pob">Birth place</label>
                <br />
                <input type="radio" name="layer" id="multi1" value="multi1" />
                <label for="multi1">Age sex employment</label>
                <br />
                <hr />
                <input type="radio" name="layer" id="share" value="share" />
                <label for="share">Share of</label>
                <select id="share_">
                    <option value="F">Women</option>
                    <option value="M">Men</option>
                    <option value="Y_LT15">Age under 15 years</option>
                    <option value="Y15-64">Age 15 to 64 years</option>
                    <option value="Y_GE65">Age 65 years and older</option>
                    <option value="EMP" selected>Employed</option>
                    <option value="SAME">Residence unchanged (2020/2021)</option>
                    <option value="CHG_IN">Moved within the country (2020/2021)</option>
                    <option value="CHG_OUT">Moved from outside the country (2020/2021)</option>
                    <option value="NAT">Born in the country</option>
                    <option value="EU_OTH">Born in another EU member state</option>
                    <option value="OTH">Born outside the EU</option>
                </select>
                <br />
                <input type="checkbox" id="sbtp" checked />
                <label for="sbtp">Size by total population</label>
                <br />
                <hr />
                <input type="radio" name="layer" id="trivariate" value="trivariate" />
                <label for="trivariate">Trivariate color of</label>
                <select id="trivariate_theme">
                    <option value="age" selected>Age</option>
                    <option value="mobility">Mobility</option>
                    <option value="pob">Birth place</option>
                </select>
                <br />
                <input type="checkbox" id="sbtp_tri" checked />
                <label for="sbtp_tri">Size by total population</label>
        </div>
        <hr />
        <input type="checkbox" id="label" checked />
        <label for="label">City names</label><br />
        <input type="checkbox" id="boundary" checked />
        <label for="boundary">Boundaries</label><br />
        <input type="checkbox" id="background" checked />
        <label for="background">Background</label>
        </span>
    </div>

    <script src="../../dist/gridviz.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gridviz-eurostat@2.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-array@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-format@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale@4"></script>
    <script>

        /*
        "T" >= Total population

        "F" >= Women
        "M" >= Men

        "EMP" >= Employed (working population)

        "Y_LT15" >= Age under 15 years
        "Y15-64" >= Age 15 to 64 years
        "Y_GE65" >= Age 65 years and older

        "SAME" >= Residence unchanged (as of January 1, 2021, compared to January 1, 2020)
        "CHG_IN" >= Moved within the country (as of January 1, 2021, compared to January 1, 2020)
        "CHG_OUT" >= Moved from outside the country (as of January 1, 2021, compared to January 1, 2020)

        "NAT" >= Born in the country
        "EU_OTH" >= Born in another EU member state
        "OTH" >= Born outside the EU
        */

        //define map with initial view
        const map = new gridviz.Map(document.getElementById('map'), { x: 4598000, y: 2715000, z: 700, zoomExtent: [10, 10000] })
            .addZoomButtons()
            .setViewFromURL()

        const backgroundLayer1 = new gridviz.BackgroundLayer({
            url: 'https://raw.githubusercontent.com/jgaffuri/mbxyz/main/pub/elevation_shading/',
            resolutions: Array.from({ length: 9 }, (_, i) => 28.00132289714475 * Math.pow(2, 10 - i)),
            origin: [0, 6000000],
            filterColor: () => '#ffffffc0',
            visible: (z) => z > 50,
        })

        const backgroundLayer2 = new gridviz.BackgroundLayer(
            gridviz_eurostat.giscoBackgroundLayer("OSMPositronBackground", 18, "EPSG3035", {
                visible: (z) => z <= 50,
            })
        )

        //define boundaries layer
        const boundariesLayer = new gridviz.GeoJSONLayer(gridviz_eurostat.getEurostatBoundariesLayer())

        //make label layer
        const labelLayer = new gridviz.LabelLayer(gridviz_eurostat.getEuronymeLabelLayer())

        //function to compute the percentage of a cell value
        const computePercentage = (c, col, totalFunction) => {
            const total = totalFunction(c)
            if (total == 0) { c["s" + col] = undefined; return }
            c["s" + col] = +c[col] / total * 100
            if (c["s" + col] < 0 || c["s" + col] > 100 || isNaN(total)) console.log("Unexpected rate for " + col + ": " + c["s" + col], c[col], total)
            c["s" + col] = c["s" + col] > 100 ? 100 : c["s" + col] < 0 ? 0 : c["s" + col]
        }

        //define multi resolution dataset
        const dataset = new gridviz.MultiResolutionDataset(
            [1000, 2000, 5000, 10000, 20000, 50000, 100000],
            resolution => new gridviz.TiledGrid(map, 'http://localhost:1234/' + resolution + 'm/'),
            {
                preprocess: (c) => {
                    if (!c.T || +c.T == 0) return false

                    //male/female index
                    //if (+c.F + +c.M != c.T) console.error("Error found in sex total")
                    c.indMF = +c.M - (+c.F)
                    c.indMF = (100 * c.indMF) / (+c.M + +c.F)
                    if (isNaN(c.indMF)) c.indMF = 0

                    //compute percentages
                    computePercentage(c, "F", c => +c.F + +c.M)
                    computePercentage(c, "M", c => +c.F + +c.M)
                    computePercentage(c, "Y_LT15", c => +c.Y_LT15 + +c["Y15-64"] + +c.Y_GE65)
                    computePercentage(c, "Y15-64", c => +c.Y_LT15 + +c["Y15-64"] + +c.Y_GE65)
                    computePercentage(c, "Y_GE65", c => +c.Y_LT15 + +c["Y15-64"] + +c.Y_GE65)
                    computePercentage(c, "EMP", c => c.T)
                    computePercentage(c, "NAT", c => +c.NAT + +c.EU_OTH + +c.OTH)
                    computePercentage(c, "EU_OTH", c => +c.NAT + +c.EU_OTH + +c.OTH)
                    computePercentage(c, "OTH", c => +c.NAT + +c.EU_OTH + +c.OTH)
                    computePercentage(c, "SAME", c => +c.SAME + +c.CHG_IN + +c.CHG_OUT)
                    computePercentage(c, "CHG_IN", c => +c.SAME + +c.CHG_IN + +c.CHG_OUT)
                    computePercentage(c, "CHG_OUT", c => +c.SAME + +c.CHG_IN + +c.CHG_OUT)
                }
            }
        )

        //make grid layer
        const gridLayer = new gridviz.GridLayer(dataset, [])

        //add layers to map
        map.layers = [backgroundLayer1, backgroundLayer2, gridLayer, boundariesLayer, labelLayer]

        //format function for percentages
        const formatPercentage = d3.format('.1f')

        //
        const update = () => {
            //read GUI selection
            const layCode = document.querySelector('input[name="layer"]:checked').value

            if (layCode != 'share') {
                document.getElementById('share_').disabled = true
                document.getElementById('sbtp').disabled = true
            }
            if (layCode != 'trivariate') {
                document.getElementById('trivariate_theme').disabled = true
                document.getElementById('sbtp_tri').disabled = true
            }

            //set style
            if (layCode === 'pop') {

                const nbClasses = 6
                const colors = d3.schemeYlOrRd[nbClasses]
                gridLayer.styles = [
                    new gridviz.ShapeColorSizeStyle({
                        color: (c, r, z, viewScale) => viewScale(c.T),
                        viewScale: gridviz.viewScaleColor({
                            valueFunction: (c) => +c.T,
                            //colorScale: d3.interpolateYlOrRd,
                            colors: colors,
                            stretching: gridviz.logarithmicScale(-7)
                        }),
                        blendOperation: (z) => z < 100 ? "multiply" : "source-over",
                    }),
                    new gridviz.StrokeStyle({ visible: (z) => z < 50 }),
                ]

                //legend
                gridLayer.styles[0].legends = [
                    new gridviz.ColorDiscreteLegend({
                        title: "Population",
                        width: 300,
                        colors: () => colors,
                        breaks: (viewScale) => viewScale?.breaks.map(b => Math.round(b)),
                    })
                ]

                gridLayer.minPixelsPerCell = 1.5

                gridLayer.cellInfoHTML = (c) => '<b>' + c.T + '</b> person' + (+c.T == 1 ? '' : 's')

            } else if (layCode === 'sex') {

                //sex - color classifier
                const breaks = [-20, -7, -2, -0.5, 0.5, 2, 7, 20]
                const sexColorClassifier = gridviz.colorClassifier(breaks, d3.schemeSpectral[breaks.length + 1])

                const classNumberSize = 4
                const style = new gridviz.ShapeColorSizeStyle({
                    color: (c, r, z, viewScale) => sexColorClassifier(c.indMF),
                    size: (c, r, z, viewScale) => viewScale(c.T),
                    viewScale: gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 4, maxSizeFactor: 1.1 }),
                    shape: () => 'circle',
                    blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                })
                gridLayer.styles = [style]

                gridLayer.minPixelsPerCell = 5

                style.legends = []

                //sex color legend
                style.legends.push(new gridviz.ColorDiscreteLegend({
                    title: "Sex balance, in %",
                    width: 300,
                    colors: () => sexColorClassifier.colors,
                    breaks: () => sexColorClassifier.breaks,
                }))

                //population size legend
                style.addLegends(
                    gridviz.sizeDiscreteViewScaleLegend(
                        classNumberSize, {
                        title: "Population",
                        fillColor: "lightgray",
                        labelFormat: Math.round,
                    })
                )

                gridLayer.cellInfoHTML = (c) =>
                    '<b>' + (+c.F + +c.M) + '</b> person' + (+c.F + +c.M == 1 ? '' : 's') + '<br>' +
                    c.M + ' m' + (c.M == 1 ? "a" : "e") + 'n<br>' +
                    c.F + ' wom' + (c.F == 1 ? 'a' : 'e') + 'n<br>' +
                    'Difference: <b>' + (c.indMF > 0 ? '+' : '') + formatPercentage(c.indMF) + ' % men</b>'




            } else if (layCode === 'emp') {

                const breaks = [30, 40, 45, 50, 55, 60, 70]
                const empColorClassifier = gridviz.colorClassifier(breaks, d3.schemeYlOrRd[breaks.length + 1])
                //d3.interpolateYlOrRd(Math.floor(20*c.sEMP / 100)/20)

                const classNumberSize = 4
                const style = new gridviz.ShapeColorSizeStyle({
                    color: (c, r, z, viewScale) => empColorClassifier(c.sEMP),
                    size: (c, r, z, viewScale) => viewScale(c.T),
                    viewScale: gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 3, maxSizeFactor: 1.1 }),
                    shape: () => 'circle',
                    blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                })
                gridLayer.styles = [style]

                gridLayer.minPixelsPerCell = 6



                //employment color legend
                style.legends.push(new gridviz.ColorDiscreteLegend({
                    title: "Employment, in %",
                    width: 250,
                    colors: () => empColorClassifier.colors,
                    breaks: () => empColorClassifier.breaks,
                }))

                //population size legend
                style.addLegends(
                    gridviz.sizeDiscreteViewScaleLegend(
                        classNumberSize, {
                        title: "Population",
                        fillColor: "lightgray",
                        labelFormat: Math.round,
                    })
                )

                gridLayer.cellInfoHTML = (c) =>
                    '<b>' + formatPercentage(c.sEMP) + ' %</b> employment<br>' +
                    //c.EMP + '<br>' +
                    (+c.F + +c.M) + ' person' + (+c.F + +c.M == 1 ? '' : 's')




            } else if (layCode === 'age') {

                const colAge = d3.interpolateSpectral
                const classNumberSize = 4
                gridLayer.styles = [
                    new gridviz.CompositionStyle({
                        color: {
                            Y_LT15: colAge(0.2),
                            "Y15-64": colAge(0.4),
                            Y_GE65: colAge(0.9),
                        },
                        type: () => 'flag',
                        size: (c, r, z, scale) => scale(+c.T),
                        viewScale: gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 8, maxSizeFactor: 0.9 }),
                        //viewScale: gridviz.sizeScale({ valueFunction: (c) => +c.T, exponent: 0.1 }),
                        stripesOrientation: () => 90,
                        blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                    })
                    ,
                ]

                gridLayer.minPixelsPerCell = 12

                //age
                gridLayer.styles[0].legends = [new gridviz.ColorCategoryLegend({
                    title: "Age",
                    colorLabel: [
                        [colAge(0.2), "Under 15 years"],
                        [colAge(0.4), "15 to 64 years"],
                        [colAge(0.9), "65 years and older"],
                    ]
                })]

                //population
                gridLayer.styles[0].addLegends(
                    gridviz.sizeDiscreteViewScaleLegend(
                        classNumberSize, {
                        title: "Population",
                        shape: "square",
                        fillColor: "lightgray",
                        labelFormat: Math.round,
                    })
                )

                gridLayer.cellInfoHTML = (c) => '<b>' + (+c.Y_LT15 + +c["Y15-64"] + +c.Y_GE65) + '</b> person' + ((+c.Y_LT15 + +c["Y15-64"] + +c.Y_GE65) == 1 ? '' : 's') + "<br>" +
                    c.Y_LT15 + " under 15 years<br>" +
                    c["Y15-64"] + " 15 to 64 years<br>" +
                    c.Y_GE65 + " 65 years and older"

            } else if (layCode === 'mobility') {

                const classNumberSize = 5
                gridLayer.styles = [
                    new gridviz.CompositionStyle({
                        color: {
                            SAME: "#fed9a6", //light mostard
                            CHG_IN: "#7570b3", //blueish
                            CHG_OUT: "#d95f02", //orange
                        },
                        type: () => 'piechart', //flag, piechart, ring, segment, radar, agepyramid, halftone
                        size: (c, r, z, scale) => scale(+c.T),
                        viewScale: gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 6, maxSizeFactor: 1.1 }),
                        blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                    })
                ]

                gridLayer.minPixelsPerCell = 12

                //mobility
                gridLayer.styles[0].legends = [new gridviz.ColorCategoryLegend({
                    title: "Mobility, compared to January 1, 2020",
                    colorLabel: [
                        ["#fed9a6", "Residence unchanged"],
                        ["#7570b3", "Moved within the country"],
                        ["#d95f02", "Moved from outside the country"],
                    ]
                })]

                //population
                gridLayer.styles[0].addLegends(
                    gridviz.sizeDiscreteViewScaleLegend(
                        classNumberSize, {
                        title: "Population",
                        fillColor: "lightgray",
                        labelFormat: Math.round,
                    })
                )

                gridLayer.cellInfoHTML = (c) => '<b>' + (+c.SAME + +c.CHG_IN + +c.CHG_OUT) + '</b> person' + ((+c.SAME + +c.CHG_IN + +c.CHG_OUT) == 1 ? '' : 's') + "<br>" +
                    c.SAME + " residence unchanged<br>" +
                    c.CHG_IN + " moved within the country<br>" +
                    c.CHG_OUT + " moved from outside the country"

            } else if (layCode === 'pob') {

                const classNumberSize = 5
                gridLayer.styles = [
                    new gridviz.CompositionStyle({
                        color: {
                            NAT: "#fed9a6", //light mostard
                            EU_OTH: "#7570b3", //blueish
                            OTH: "#d95f02", //orange
                        },
                        type: () => 'halftone', //flag, piechart, ring, segment, radar, agepyramid, halftone
                        size: (c, r, z, scale) => scale(+c.T),
                        viewScale: gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 8 }),
                        blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                    })
                ]

                gridLayer.minPixelsPerCell = 12

                //place of birth
                gridLayer.styles[0].legends = [new gridviz.ColorCategoryLegend({
                    title: "Place of birth",
                    colorLabel: [
                        ["#fed9a6", "Born in the country"],
                        ["#7570b3", "Born in another EU member state"],
                        ["#d95f02", "Born outside the EU"],
                    ]
                })]

                //population
                gridLayer.styles[0].addLegends(
                    gridviz.sizeDiscreteViewScaleLegend(
                        classNumberSize, {
                        title: "Population",
                        fillColor: "lightgray",
                        labelFormat: Math.round,
                    })
                )

                gridLayer.cellInfoHTML = (c) => '<b>' + (+c.NAT + +c.EU_OTH + +c.OTH) + '</b> person' + ((+c.NAT + +c.EU_OTH + +c.OTH) == 1 ? '' : 's') + "<br>" +
                    c.NAT + " born in the country<br>" +
                    c.EU_OTH + " born in another EU member state<br>" +
                    c.OTH + " born outside the EU"


            } else if (layCode === 'multi1') {
                //sex hue
                //emp value
                //age shape

                //sex classifier
                const sexBreaks = [-2, 2,]
                const sexClassifier = gridviz.classifier(sexBreaks)

                //emp color classifiers
                const empBreaks = [30, 45, 55, 70]
                const empFemaleColorClassifier = gridviz.colorClassifier(empBreaks, d3.schemeReds[empBreaks.length + 1])
                const empMaleColorClassifier = gridviz.colorClassifier(empBreaks, d3.schemeGreys[empBreaks.length + 1])
                const empNeutralColorClassifier = gridviz.colorClassifier(empBreaks, d3.schemeBlues[empBreaks.length + 1])

                //age classifier
                const ageTrivariateClassifier = gridviz.trivariateColorClassifier(
                    ["sY_LT15", "sY15-64", "sY_GE65"],
                    c => 100, {
                    center: [0.15, 0.6, 0.25],
                    withMiddleClasses: false,
                    centralColor: "central",
                    centerCoefficient: 0.25,
                    colors: ["0", "1", "2"],
                })

                const classNumberSize = 4
                const style = new gridviz.ShapeColorSizeStyle({
                    color: (c, r, z, viewScale) => {
                        const sexI = sexClassifier(c.indMF)
                        if (sexI == 0) return empFemaleColorClassifier(c.sEMP)
                        if (sexI == 1) return empNeutralColorClassifier(c.sEMP)
                        if (sexI == 2) return empMaleColorClassifier(c.sEMP)
                    },
                    size: (c, r, z, viewScale) => viewScale(c.T),
                    viewScale: gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 3, maxSizeFactor: 1.1 }),
                    shape: (c) => {
                        const i = ageTrivariateClassifier(c)
                        console.log(i)
                        //TODO
                    },
                    blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                })
                gridLayer.styles = [style]

                gridLayer.minPixelsPerCell = 6



            } else if (layCode === 'share') {

                //unfreeze GUI
                document.getElementById('share_').disabled = false
                document.getElementById('sbtp').disabled = false

                //get gui info
                const shareA = document.querySelector('#share_').value
                const shareB = "s" + shareA
                const sbtp = document.getElementById('sbtp').checked

                //define style

                //breaks
                let breaks = undefined
                switch (shareA) {
                    case 'F': breaks = [40, 45, 49, 50, 51, 55, 60]; break;
                    case 'M': breaks = [40, 45, 49, 50, 51, 55, 60]; break;
                    case 'Y_LT15': breaks = [5, 10, 15, 20, 30]; break;
                    case 'Y15-64': breaks = [50, 60, 65, 70, 80]; break;
                    case 'Y_GE65': breaks = [10, 20, 30, 40, 50]; break;
                    case 'EMP': breaks = [30, 40, 45, 50, 55, 60, 70]; break;
                    case 'SAME': breaks = [70, 80, 90, 95, 99]; break;
                    case 'CHG_IN': breaks = [0.5, 1, 5, 10, 20]; break;
                    case 'CHG_OUT': breaks = [0.5, 1, 2, 5, 10]; break;
                    case 'NAT': breaks = [60, 70, 80, 85, 90, 95, 99]; break;
                    case 'EU_OTH': breaks = [1, 5, 10, 15, 20, 30]; break;
                    case 'OTH': breaks = [1, 5, 10, 20, 30, 50]; break;
                    default:
                        breaks = [30, 40, 45, 50, 55, 60, 70]
                }

                const classNumberColor = breaks.length + 1 //6
                const palette = shareA == 'M' || shareA == 'F' ? d3.schemeSpectral : d3.schemeYlOrRd
                const colors = palette[classNumberColor]
                const colorClassifier = gridviz.colorClassifier(breaks, colors)
                const classNumberSize = 4
                const style = new gridviz.ShapeColorSizeStyle({
                    //filter: c => c[shareB] != undefined,
                    color: (c, r, z, viewScale) => (!c[shareB] || isNaN(c[shareB])) ? "#bbb" : colorClassifier(c[shareB]),
                    viewScale: sbtp ? gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 3, maxSizeFactor: 1.1 }) : undefined,
                    size: sbtp ? (c, r, z, viewScale) => viewScale(c.T) : (c, r) => r,
                    shape: sbtp ? () => 'circle' : () => 'square',
                    blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                })

                //set styles
                gridLayer.styles = [style]
                if (!sbtp) gridLayer.styles.push(new gridviz.StrokeStyle({ visible: (z) => z < 50 }))

                //
                gridLayer.minPixelsPerCell = sbtp ? 6 : 1.5

                //share color legend
                style.addLegends([
                    new gridviz.ColorDiscreteLegend({
                        title: "Share, in percentage",
                        width: 250,
                        colors: () => colors,
                        breaks: () => breaks,
                    })
                ])

                //population size legend
                if (sbtp)
                    style.addLegends(
                        gridviz.sizeDiscreteViewScaleLegend(
                            classNumberSize, {
                            title: "Population",
                            fillColor: "lightgray",
                            labelFormat: Math.round,
                        })
                    )

                gridLayer.cellInfoHTML = (c) =>
                    '<b>' + formatPercentage(c[shareB]) + ' %</b><br>' +
                    c[shareA] + '<br>' //+
                    + c.T + " person(s)"
                //(+c.F + +c.M) + ' person' + (+c.F + +c.M == 1 ? '' : 's')




            } else if (layCode === 'trivariate') {

                //unfreeze GUI
                document.getElementById('trivariate_theme').disabled = false
                document.getElementById('sbtp_tri').disabled = false

                //get gui info
                const theme = document.querySelector('#trivariate_theme').value
                //age, mobility, pob
                const sbtp = document.getElementById('sbtp_tri').checked

                let colorTrivariateFun
                if (theme == "age")
                    colorTrivariateFun = gridviz.trivariateColorClassifier(
                        ["sY_LT15", "sY15-64", "sY_GE65"],
                        c => 100, {
                        center: [0.15, 0.6, 0.25],
                        centralColor: "#999",
                        centerCoefficient: 0.25,
                        colors: ["#4daf4a", "#377eb8", "#e41a1c"],
                    })
                else if (theme == "mobility")
                    colorTrivariateFun = gridviz.trivariateColorClassifier(
                        ["sCHG_OUT", "sSAME", "sCHG_IN"],
                        c => 100, {
                        center: [0.05, 0.85, 0.1],
                        //centralColor: "#999",
                        //centerCoefficient: 0.7,
                        colors: ["#4daf4a", "#377eb8", "#e41a1c"],
                    })
                else if (theme == "pob")
                    colorTrivariateFun = gridviz.trivariateColorClassifier(
                        ["sOTH", "sNAT", "sEU_OTH"],
                        c => 100, {
                        center: [0.25, 0.6, 0.15],
                        //centralColor: "#999",
                        //centerCoefficient: 0.5,
                        colors: ["#4daf4a", "#377eb8", "#e41a1c"],
                    })

                const classNumberSize = 4
                const style = new gridviz.ShapeColorSizeStyle({
                    color: (c) => colorTrivariateFun(c) || "black",
                    viewScale: gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 3, maxSizeFactor: 1.1 }),
                    size: sbtp ? (c, r, z, viewScale) => viewScale(c.T) : (c, r) => r,
                    shape: sbtp ? () => 'circle' : () => "square",
                    blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                })

                //set styles
                gridLayer.styles = [style]
                if (!sbtp) gridLayer.styles.push(new gridviz.StrokeStyle({ visible: (z) => z < 50 }))

                //
                gridLayer.minPixelsPerCell = sbtp ? 6 : 1.5

                //legends

                const legendWidth = 150
                if (theme == "age")
                    gridLayer.styles[0].legends = [new gridviz.TrivariateLegend({
                        title: "Age",
                        classifier: colorTrivariateFun,
                        width: legendWidth,
                        tooltip: map.tooltip,
                        texts: {
                            "0": "Over representation of persons aged <15",
                            "1": "Over representation of persons aged 15 to 64",
                            "2": "Over representation of persons aged >=65",
                            "12": "Under representation of persons aged <15",
                            "02": "Under representation of<br>persons aged 15 to 64",
                            "01": "Under representation of persons aged >=65",
                            "center": "Balanced representation of age groups",
                        },
                        leftText: "Under 15",
                        topText: "Age 15 to 64",
                        rightText: "65 and older",
                        centerCoefficient: 0.5,
                    })]
                else if (theme == "mobility")
                    gridLayer.styles[0].legends = [new gridviz.TrivariateLegend({
                        title: "Mobility (2020-2021)",
                        classifier: colorTrivariateFun,
                        width: legendWidth,
                        tooltip: map.tooltip,
                        texts: {
                            "0": "Over representation of persons<br>that moved from outside the country",
                            "1": "Over representation of persons<br>with residence unchanged",
                            "2": "Over representation of persons<br>that moved within the country",
                            "12": "Under representation of persons<br>that moved from outside the country",
                            "02": "Under representation of persons<br>with residence unchanged",
                            "01": "Under representation of persons<br>that moved within the country",
                            "center": "Balanced representation of mobility groups",
                        },
                        leftText: "Outside",
                        topText: "No change",
                        rightText: "Inside country",
                        //centerCoefficient: 0.5,
                    })]
                else if (theme == "pob")
                    gridLayer.styles[0].legends = [new gridviz.TrivariateLegend({
                        title: "Birth place",
                        classifier: colorTrivariateFun,
                        width: legendWidth,
                        tooltip: map.tooltip,
                        texts: {
                            "0": "Over representation of persons<br>born outside the EU",
                            "1": "Over representation of persons<br>born in the country",
                            "2": "Over representation of persons<br>born in another EU member state",
                            "12": "Under representation of persons<br>born outside the EU",
                            "02": "Under representation of persons<br>born in the country",
                            "01": "Under representation of persons<br>born in another EU member state",
                            "center": "Balanced representation",
                        },
                        leftText: "Rest of the world",
                        topText: "Same country",
                        rightText: "EU",
                        //centerCoefficient: 0.5,
                    })]

                //population legend
                if (sbtp)
                    gridLayer.styles[0].addLegends(
                        gridviz.sizeDiscreteViewScaleLegend(
                            classNumberSize, {
                            title: "Population",
                            fillColor: "lightgray",
                            labelFormat: Math.round,
                        })
                    )

                //tooltip text
                if (theme == "age")
                    gridLayer.cellInfoHTML = (c) => {
                        const total = +c.Y_LT15 + +c["Y15-64"] + +c.Y_GE65
                        return '<b>' + total + '</b> person' + (total == 1 ? '' : 's') + "<br>" +
                            formatPercentage(c.sY_LT15) + "% under 15 years<br>" +
                            formatPercentage(c["sY15-64"]) + "% 15 to 64 years<br>" +
                            formatPercentage(c.sY_GE65) + "% 65 years and older"
                    }
                else if (theme == "mobility")
                    gridLayer.cellInfoHTML = (c) => {
                        const total = +c.CHG_IN + +c.SAME + +c.CHG_OUT
                        return '<b>' + total + '</b> person' + (total == 1 ? '' : 's') + "<br>" +
                            formatPercentage(c.sSAME) + "% residence unchanged<br>" +
                            formatPercentage(c.sCHG_IN) + "% moved within the country<br>" +
                            formatPercentage(c.sCHG_OUT) + "% moved from outside the country"
                    }
                else if (theme == "pob")
                    gridLayer.cellInfoHTML = (c) => {
                        const total = +c.NAT + +c.EU_OTH + +c.OTH
                        return '<b>' + total + '</b> person' + (total == 1 ? '' : 's') + "<br>" +
                            formatPercentage(c.sNAT) + "% born in the country<br>" +
                            formatPercentage(c.sEU_OTH) + "% born in another EU member state<br>" +
                            formatPercentage(c.sOTH) + "% born outside the EU"
                    }

            } else console.error('Unexpected layer code: ' + layCode)

            //redraw
            map.redraw()
        }


        //layer update
        document.querySelector('#layer').addEventListener('change', update)

        // show/hide labels
        document.querySelector('#label').addEventListener('change', function () {
            labelLayer.visible = () => this.checked
            map.redraw()
        })

        // show/hide boundaries
        document.querySelector('#boundary').addEventListener('change', function () {
            boundariesLayer.visible = () => this.checked
            map.redraw()
        })

        // show/hide background layer
        document.querySelector('#background').addEventListener('change', function () {
            if (this.checked) {
                backgroundLayer1.visible = (z) => z > 50
                backgroundLayer2.visible = (z) => z <= 50
            } else {
                backgroundLayer1.visible = () => false
                backgroundLayer2.visible = () => false
            }
            map.redraw()
        })

        //select layer from URL
        const ls = gridviz.getParameterByName('lay')
        if (ls) {
            const b = document.querySelector('#' + ls)
            if (b) b.checked = true
        }

        //initialise
        update()


    </script>
    <div style="
    position: absolute;
    right: 0px;
    bottom: 0px;
    width: auto;
    height: auto;
    padding: 1px;
    border: 0px;
    background: #ffffffcc;
">
        <span style="font-size: 0.8em">
            <a href="https://github.com/eurostat/gridviz" style="text-decoration: none">GridViz</a> |
            Â©<a href="https://eurogeographics.org" style="text-decoration: none">EuroGeographics</a></span>
    </div>


</body>