<!DOCTYPE html>
<html lang="en" style="height: 100%">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Relief in Europe</title>
</head>

<body style="margin: 0; height: 100%; font-family: Arial, Helvetica, sans-serif; overflow: hidden">

    <div id="map" style="height: 100%; width: 100%"></div>

    <div id="control" style="
                font-size: 0.9em;
                position: absolute;
                left: 10px;
                top: 10px;
                width: auto;
                height: auto;
                padding: 5px;
                border: 0px;
                border-radius: 5px;
                background: #ffffffcc;
                line-height: 1.6;
                box-shadow: 3px 3px 3px grey, -3px -3px 3px #ddd;
            ">
        <form id="form">
            <input type="radio" id="radio_hyps" name="rdreliefstyle" value="hyps" checked>
            <label for="radio_hyps">Relief - Hypsometric tints</label> <select id="hypscol"></select><br>
            <input type="radio" id="radio_joyplot" name="rdreliefstyle" value="joyplot">
            <label for="radio_joyplot">Relief - Joyplot</label><br>
            <label for="cbLabels"><input type="checkbox" id="cbLabels" checked>City names</label>
            <br>
            <label for="cbPopulation"><input type="checkbox" id="cbPopulation" checked>Population dots</label>
            <br>
            <label for="cbBoundaries"><input type="checkbox" id="cbBoundaries" checked>Boundaries</label>
            <br>
            <label for="cbRoads"><input type="checkbox" id="cbRoads">Roads</label>
            <br>
            <label for="cbCLC"><input type="checkbox" id="cbCLC" checked>Inland waters</label>
            <hr>
            <label>Relief smoothing (slow)</label>
            <input type="range" min="0" max="10" value="0" step="0.25" id="sReliefSmoothing" style="width: 200px" />
            <br>
            <label>Sea level rise: <span id="lbSeaLevel">0 m</span></label>
            <input type="range" id="sSeaLevel" min="0" max="100" step="1" value="0" style="width:200px;">
            <hr>
            <div id="hyps_div">
                <label for="cbTanaka"><input type="checkbox" id="cbTanaka">Relief tanaka style (slow)</label>
                <br>
                <label for="cbHillshading"><input type="checkbox" id="cbHillshading">Relief hillshading (slow)</label>
                <br>
                <label for="cbHillshadingRay"><input type="checkbox" id="cbHillshadingRay">Relief hillshading raycasting
                    (slow)</label>
                <br>
                <div id="rc_div" style="border: solid black 1px; padding: 1px;">
                    <label>Sun ray azimuth</label>
                    <input type="range" min="0" max="6.3" value="2.4" step="0.05" id="sunrayAzimuth"
                        style="width: 200px" />
                    <br>
                    <label>Sun altitude</label>
                    <input type="range" min="0.005" max="0.7" value="0.15" step="0.01" id="sunrayAltitude"
                        style="width: 200px" />
                    <br>
                    <label>Sun light opacity</label>
                    <input type="range" min="0" max="1" value="0.33" step="0.01" id="sunrayAlpha"
                        style="width: 200px" />
                </div>
                <div>
                    <label>Relief hypsometric tints number</label>
                    <input type="range" min="2" max="25" value="8" step="1" id="sReliefNb" style="width: 200px" />
                    <br>
                    <label>Relief exageration</label>
                    <input type="range" min="-15" max="15" value="0" step="1" id="sReliefExageration"
                        style="width: 200px" />
                    <br>
                    <label for="cbHypssea"><input type="checkbox" id="cbHypssea">Adjust hypsometric colors to sea level
                        rise</label>
                    <hr>
                    <label for="cbHD"><input type="checkbox" id="cbHD">HD (very slow)</label>
                </div>
            </div>
            <div id="joyplot_div" style="display: none;">
                <label>Relief exageration</label>
                <input type="range" min="1" max="20" value="10" step="1" id="sReliefExagerationJP"
                    style="width: 200px" />
            </div>
        </form>
    </div>

    <script src="../../dist/gridviz.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gridviz-eurostat@2.2.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/gridviz-parquet@1.1.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/gridviz-smoothing@3.0.3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-array@3.2.4"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale@4.0.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3"></script>
    <script>

        //TODO
        // no rayshade on sea margin ?
        //interpolateur for large scale - replace smoothing ?
        //slope-aspect styles
        //contour style based on d3 ? interpolated ?
        //better structure styles
        //Check doc and examples: tanaka, lego, contours, raycast shading.
        //add some rivers ?

        const seaColor = "#a4c8e1"

        // prepare color ramps
        const interpolateRamp = (colors) =>
            d3.scaleLinear()
                .domain(d3.range(colors.length).map(i => i / (colors.length - 1)))
                .range(colors).interpolate(d3.interpolateLab); //interpolateLab interpolateRgb
        ramps = {
            "Green - Yellow - Red": (t) => d3.interpolateRdYlGn(0.95 - t * 0.9),
            "Patterson-Jenny warm humid": interpolateRamp(["rgb(245,245,245)", "rgb(235,235,237)", "rgb(220,220,220)", "rgb(212,207,204)", "rgb(212,193,179)", "rgb(212,184,163)", "rgb(212,201,180)", "rgb(169,192,166)", "rgb(134,184,159)", "rgb(120,172,149)", "rgb(114,164,141)", "rgb(106,153,135)"].reverse()),
            "Bartholomew": interpolateRamp(["#bbcc9e", "#dde4c7", "#e0ebd9", "#e9f0d1", "#ece8c1", "#e9d6ad", "#e7c18c", "#e2b470", "#dda255", "#de8f4e", "#d57751", "#c8705e", "#d38487", "#dca3a4", "#edc7c2"]),
            "International map of the world": interpolateRamp(["#add7aa", "#d6e8b8", "#faf7c7", "#faf5be", "#fbcbb8", "#d9baca", "#f5e1e7"]),
            "Peuckers": interpolateRamp(["#a8bb9e", "#c9dcaa", "#f0f1af", "#fbf6b1", "#fde89f", "#f9a579", "#ea444b"]),
            "Green": (t) => d3.interpolateGreens(1 - t),
            "Gray": (t) => d3.interpolateGreys(0.8 - t * 0.8),
            "Viridis": d3.interpolateViridis,
            "Plasma": d3.interpolatePlasma,
            "Cubehelix": (t) => d3.interpolateCubehelixDefault(0.15 + 0.85 * t),
            "Rainbow": d3.interpolateRainbow,
        }

        // build colour ramps combo list
        const hypscol = document.getElementById("hypscol");
        for (let r in ramps) hypscol.add(new Option(r, r));


        const map = new gridviz.Map(document.getElementById('map'), {
            x: 4200000, y: 2800000, z: 50,
            backgroundColor: seaColor
        })
            .setZoomExtent([5, 5000])
            .addZoomButtons()
            .setViewFromURL()

        const datasetRelief = new gridviz.MultiResolutionDataset(
            [50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000],
            resolution => new gviz_par.TiledParquetGrid(map,
                "https://raw.githubusercontent.com/jgaffuri/tiled-euroDEM/main/pub/v1/tiles_" + resolution + "/"),
            { preprocess: (c) => c.v != undefined && c.v != 0 }
        )

        const datasetPop = new gridviz.MultiResolutionDataset(
            [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000],
            resolution => new gviz_par.TiledParquetGrid(map,
                "https://raw.githubusercontent.com/jgaffuri/europop100m/main/pub/JRC_100m/" + resolution + "/"),
        )

        const datasetCLC = new gridviz.MultiResolutionDataset(
            [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000],
            (resolution) => new gviz_par.TiledParquetGrid(map,
                'https://raw.githubusercontent.com/eurostat/LCMap/main/pub/clc/v1/2018/' + resolution + '/'),
            { preprocess: (c) => c.code == 40 || c.code == 41 || c.code == 42 || c.code == 43 || c.code == 44 }
        )

        //const styleCLCWater = new gridviz.ShapeColorSizeStyle({ color: () => seaColor, size: (c, r, z) => r + z * 0.3 })
        const styleCLCWater = new gridviz.SquareColorCategoryWebGLStyle({
            code: (cell) => "a",
            color: { 'a': seaColor },
        })

        const strokeWidthPix = 1
        const fillColor = "#fffc"
        const strokeColor = "#666"
        const radiusFactor = 1.4
        const scalePopulation = gridviz.logarithmicScale(-3)
        const bertinPointsStyle = new gridviz.Style({
            drawFun: (cells, cg, r) => {
                //keep only cells with population
                cells = cells.filter((c) => c.POP_2021);
                if (cells.length == 0) return;

                //sort cells by decreasing x and increasing y
                cells.sort((c1, c2) => (c2.y == c1.y ? c1.x - c2.x : c2.y - c1.y));

                const max = d3.max(cells, (c) => +c.POP_2021);
                if (!max) return;

                //set canvas color and line width
                const ctx = cg.offscreenCtx
                ctx.fillStyle = fillColor;
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = strokeWidthPix * cg.view.z;

                const z = cg.view.z;
                for (let c of cells) {
                    //get circle size
                    const sG = radiusFactor * r * scalePopulation(c.POP_2021 / max);
                    if (sG / z < 3) continue

                    //draw circle
                    ctx.beginPath();
                    ctx.arc(c.x + r / 2, c.y + r / 2, sG * 0.5, 0, 2 * Math.PI, false);
                    ctx.fill();
                    ctx.stroke();
                }
            }
        })

        const labelLayer = new gridviz.LabelLayer(gridviz_eurostat.getEuronymeLabelLayer('EUR', 20))
        const boundariesLayer = new gridviz.GeoJSONLayer(gridviz_eurostat.getEurostatBoundariesLayer({ col: "#cc6699", scale: "03M" }))
        const roadsLayer = new gridviz.BackgroundLayer({
            url: "https://raw.githubusercontent.com/jgaffuri/gridStatBaseMap/main/pub/road/",
            resolutions: Array.from({ length: 14 }, (_, i) => 114688 / Math.pow(2, i)),
            origin: [0, 6000000],
            nbPix: 512,
            //visible: (z) => z > 4, //&& z < 2100,
            pixelationCoefficient: 0.55,
            blendOperation: (z) => 'multiply',
        })

        // tooltip content
        const cellInfoHTMLPop = (c) => `Population: ${c.POP_2021}`
        const cellInfoHTMLRelief = (c) => `Elevation: ${c.v}`

        let scaleShadingCoeff = -2
        let shadingDiamond = false
        let quantile = false
        let rc = false

        function update() {

            //get sea level
            const seaLevel = +document.getElementById('sSeaLevel').value;
            document.getElementById("lbSeaLevel").textContent = seaLevel + ' m';

            //get relief style
            const rsty = document.querySelector('input[name="rdreliefstyle"]:checked').value;
            document.getElementById("hyps_div").style.display = rsty == "hyps" ? 'inline-block' : 'none'
            document.getElementById("joyplot_div").style.display = rsty == "joyplot" ? 'inline-block' : 'none'
            document.getElementById("rc_div").style.display = document.getElementById("cbHillshadingRay").checked ? 'inline-block' : 'none'

            //get HD parameter
            const hd = document.getElementById("cbHD").checked;

            // define smoothing function
            const sr = +document.getElementById('sReliefSmoothing').value
            let smoothingFunction = sr > 0 ?
                (style) => new gridviz_smoothing.KernelSmoothingStyle({
                    value: (cell) => +cell.v,
                    smoothedProperty: "v",
                    sigma: (r, z) => sr * r / 2, //r + sr * z, // in geo unit - sr is in screen pixel
                    resolutionSmoothed: (hd && rsty == "hyps" ? (r, z) => Math.ceil(z) : (r, z) => r),
                    filterSmoothed: (value) => value > 0.05,
                    styles: [style]
                })
                : style => style

            /*
            //test https://d3js.org/d3-contour/density
            const smm2 = new gridviz.Style()
            smm2.drawFun = (cells, geoCanvas, resolution) => {
                //keep only cells with population
                //cells = cells.filter((c) => c.v);
                if (cells.length == 0) return;

                //index cells by y and x
                const ind = gridviz.cellsToGrid(cells, c => c.v)

                //horn slope
                //horn z1,z2,z3,z4,z5,z6,z7,z8,z9
                //if null, replicate nearest
                const r8 = 2 * resolution
                const slopeX = (z3 + 2 * z6 + z9 - z1 - 2 * z4 - z7) / r8
                const slopeY = (z7 + 2 * z8 + z9 - z1 - 2 * z2 - z3) / r8
            }*/



            // set layers
            const layers = []

            //relief layer
            const reliefStyles = []
            if (rsty == "joyplot") {
                //white land
                reliefStyles.push(new gridviz.SquareColorCategoryWebGLStyle({ code: (c) => "a", color: { 'a': "white" }, filter: (c) => c.v >= 0, }))

                //const scaleRelief = t => t //gridviz.logarithmicScale(3) //exponentialScale logarithmicScale
                const fr = document.getElementById("sReliefExagerationJP").value
                const jpStyle = new gridviz.JoyPlotStyle({
                    viewScale: cells => d3.extent(cells, c => c.v),
                    height: (c, r, z, [min, max]) => fr * r * (c.v) / (max),
                    lineColor: (y, ys, r, z) => "#b58500",
                    lineWidth: (y, ys, r, z) => z / 1.5,
                    fillColor: (y, ys, r, z) => "white" //"#b5850011"
                })
                reliefStyles.push(smoothingFunction(jpStyle))
            } else {
                const adj = document.getElementById("cbHypssea").checked
                const scaleReliefCoeff = 3 + 0.3 * +document.getElementById('sReliefExageration').value
                const scaleRelief = gridviz.logarithmicScale(scaleReliefCoeff) //exponentialScale logarithmicScale
                const classNumber = document.getElementById('sReliefNb').value

                //hypso style
                const colors = []
                const colorRamp = ramps[document.getElementById("hypscol").value]
                for (let i = 0; i <= (classNumber - 1); i++) colors.push(colorRamp(i / (classNumber - 1)))

                //hypso style
                const hypsoStyle = new gridviz.SquareColorCategoryWebGLStyle({
                    viewScale: quantile ? gridviz.viewScaleQuantileClassifer({
                        valueFunction: (c) => c.v,
                        classNumber: classNumber,
                    }) :
                        cells => {
                            [min, max] = d3.extent(cells, c => c.v)
                            const min_ = adj ? Math.max(min, seaLevel) : min < 0 ? 0 : min
                            const breaks = []
                            for (let i = 1; i < classNumber; i++) {
                                let t = i / classNumber
                                t = scaleRelief(t)
                                breaks.push(min_ + (max - min_) * t)
                            }
                            return gridviz.classifier(breaks)
                        },
                    code: (c, r, z, classifier) => classifier(c.v),
                    color: { ...colors },
                })

                // hypso legend
                const legendWidth = Math.min(window.innerWidth - 40, 400)
                const legend = new gridviz.ColorDiscreteLegend({
                    title: "Elevation, in meters",
                    colors: () => colors,
                    breaks: (viewScale) => viewScale?.breaks.map((b) => Math.round(b)),
                    width: legendWidth,
                    //labelFormat: (text, i) => (+text).toFixed(0)
                })
                hypsoStyle.legends = [legend]
                reliefStyles.push(smoothingFunction(hypsoStyle))

                if (document.getElementById("cbTanaka").checked) {
                    const tanakaStyle = new gridviz.SideTanakaStyle({
                        classifier: quantile ? cells => {
                            const classifier = gridviz.viewScaleQuantileClassifer({
                                valueFunction: (c) => c.v,
                                classNumber: classNumber,
                            })(cells)
                            return c => classifier(c.v)
                        } : cells => {
                            // return a function which for each cell returns its class number
                            [min, max] = d3.extent(cells, c => c.v)
                            const min_ = adj ? Math.max(min, seaLevel) : min < 0 ? 0 : min
                            const breaks = []
                            for (let i = 1; i < classNumber; i++) {
                                let t = i / classNumber
                                t = scaleRelief(t)
                                breaks.push(min_ + (max - min_) * t)
                            }
                            const cs = gridviz.classifier(breaks)
                            return c => cs(c.v)
                        },
                        diamond: shadingDiamond,
                    })
                    reliefStyles.push(smoothingFunction(tanakaStyle))
                }
                if (document.getElementById("cbHillshading").checked) {
                    const scaleShading = gridviz.exponentialScale(scaleShadingCoeff) //gridviz.exponentialScale(-1)
                    const shadingStyle = new gridviz.ShadingStyle({
                        elevation: 'v',
                        scale: scaleShading,
                        diamond: shadingDiamond,
                    })
                    reliefStyles.push(smoothingFunction(shadingStyle))
                }
            }

            // resolution / definition
            const mppc = hd ? 0.7 : 1.4
            const mppcRelief = rsty == "joyplot" ? 3 : mppc

            layers.push(new gridviz.GridLayer(datasetRelief, reliefStyles, { minPixelsPerCell: mppcRelief, cellInfoHTML: cellInfoHTMLRelief }))

            // CLC waters
            if (document.getElementById("cbCLC").checked)
                layers.push(new gridviz.GridLayer(datasetCLC, [styleCLCWater], { minPixelsPerCell: mppc, cellInfoHTML: 'none' }))
            //roads
            if (document.getElementById("cbRoads").checked)
                layers.push(roadsLayer);
            // population
            if (document.getElementById("cbPopulation").checked)
                layers.push(new gridviz.GridLayer(datasetPop, [bertinPointsStyle], { minPixelsPerCell: 4, cellInfoHTML: 'none' }))
            //boundaries
            if (document.getElementById("cbBoundaries").checked)
                layers.push(boundariesLayer);
            // sea level
            if (seaLevel) {
                const styleWater = new gridviz.SquareColorCategoryWebGLStyle({
                    code: (c) => "a",
                    color: { 'a': seaColor },
                    filter: (c) => c.v <= seaLevel,
                    alpha: () => 0.85,
                })
                layers.push(new gridviz.GridLayer(datasetRelief, [smoothingFunction(styleWater)], { minPixelsPerCell: mppc, cellInfoHTML: 'none' }))
            }
            //raycasting hillshading
            if (document.getElementById("cbHillshadingRay").checked) {
                const rcStyle = new gridviz.ShadingRayStyle({
                    elevation: c => c.v,
                    alpha: () => +document.getElementById("sunrayAlpha").value,
                    sunAltitude: c => +document.getElementById("sunrayAltitude").value,
                    sunAzimuth: c => +document.getElementById("sunrayAzimuth").value,
                })
                layers.push(new gridviz.GridLayer(datasetRelief, [smoothingFunction(rcStyle)], { minPixelsPerCell: mppcRelief, cellInfoHTML: 'none' }))
            }
            // labels
            if (document.getElementById("cbLabels").checked)
                layers.push(labelLayer)
            map.layers = layers

            map.redraw()
        }

        //add form event listener
        document.getElementById("form").addEventListener('input', update);

        //keyboard events
        window.addEventListener('keypress', e => {
            if (e.key == "h") {
                const div = document.getElementById("control");
                if (div.style.display === "none") div.style.display = "block"; // or "inline", "flex", etc.
                else div.style.display = "none";
            }
            //else if (e.key == "t") { tanaka = !tanaka; update() }
            else if (e.key == "r") { rc = !rc; update() }
            else if (e.key == "q") { quantile = !quantile; update() }
            else if (e.key == "d") { shadingDiamond = !shadingDiamond; update() }
            else if (e.key == "w") { scaleShadingCoeff -= 0.25; console.log(scaleShadingCoeff); update() }
            else if (e.key == "x") { scaleShadingCoeff += 0.25; console.log(scaleShadingCoeff); update() }
            //else if (e.key == "+") { resolutionCoeff /= 1.2; console.log(resolutionCoeff); update() }
            //else if (e.key == "-") { resolutionCoeff *= 1.2; console.log(resolutionCoeff); update() }
        })

        update()

    </script>

</body>

</html>