<html lang="en" style="height: 100%">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relief in Europe</title>
</head>

<body style="margin: 0; height: 100%; font-family: Arial, Helvetica, sans-serif; overflow: hidden">

    <div id="map" style="height: 100%; width: 100%"></div>

    <div id="control" style="
                font-size: 0.9em;
                position: absolute;
                left: 10px;
                top: 10px;
                width: auto;
                height: auto;
                padding: 5px;
                border: 0px;
                border-radius: 5px;
                background: #ffffffcc;
                line-height: 1.6;
                box-shadow: 3px 3px 3px grey, -3px -3px 3px #ddd;
            ">
        <label for="cbLabels"><input type="checkbox" id="cbLabels" checked>City names</label>
        <br>
        <label for="cbPopulation"><input type="checkbox" id="cbPopulation" checked>Population dots</label>
        <br>
        <label for="cbBoundaries"><input type="checkbox" id="cbBoundaries" checked>Boundaries</label>
        <br>
        <label for="cbRoads"><input type="checkbox" id="cbRoads">Roads</label>
        <br>
        <label for="cbCLC"><input type="checkbox" id="cbCLC" checked>Land cover waters</label>
        <br>
        <label for="cbRelief"><input type="checkbox" id="cbRelief" checked>Relief hypsometric tints</label> <select
            id="hypscol"></select>
        <hr>
        <label>Sea level rise: <span id="lbSeaLevel">-</span></label>
        <br>
        <input type="range" id="sSeaLevel" min="0" max="100" step="1" value="0" style="width:300px;">
        <br>
        <label for="cbHypssea"><input type="checkbox" id="cbHypssea">Adjust hypsometric colors to sea level</label>
        <hr>
        <label for="cbTanaka"><input type="checkbox" id="cbTanaka">Relief tanaka style (slow)</label>
        <br>
        <label for="cbHillshading"><input type="checkbox" id="cbHillshading">Relief hillshading (slow)</label>
        <br>
        <label>Relief hypsometric tints number</label>
        <input type="range" min="2" max="20" value="8" step="1" id="sReliefNb" style="width: 200px" />
        <br>
        <label>Relief exageration</label>
        <input type="range" min="-15" max="15" value="0" step="1" id="sReliefExageration" style="width: 200px" />
        <br>
        <label>Relief smoothing (slow)</label>
        <input type="range" min="0" max="10" value="0" step="0.25" id="sReliefSmoothing" style="width: 200px" />
        <hr>
        <label for="cbHD"><input type="checkbox" id="cbHD">HD (very slow)</label>
    </div>

    <script src="../../dist/gridviz.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gridviz-eurostat@2.2.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/gridviz-parquet@1.1.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/gridviz-smoothing@3.0.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-array@3.2.4"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale@4.0.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3"></script>
    <script>

        //TODO
        //color ramp list
        //rayshading ?
        //joyplot: fix
        //Check doc and examples: tanaka, lego, contours.
        //add some rivers ?
        //legend ?
        //DEM 50m ?

        const seaColor = "#a4c8e1"
        const seaColorT = seaColor + "bb"

        // color ramps
        const colorsWH = [
            "rgb(245,245,245)",
            "rgb(235,235,237)",
            "rgb(220,220,220)",
            "rgb(212,207,204)",
            "rgb(212,193,179)",
            "rgb(212,184,163)",
            "rgb(212,201,180)",
            "rgb(169,192,166)",
            "rgb(134,184,159)",
            "rgb(120,172,149)",
            "rgb(114,164,141)",
            "rgb(106,153,135)"
        ].reverse();
        const domain = d3.range(colorsWH.length).map(i => i / (colorsWH.length - 1));
        const colorRampWH = d3.scaleLinear()
            .domain(domain)
            .range(colorsWH)
            .interpolate(d3.interpolateLab);
        //interpolateLab interpolateRgb

        ramps = {
            "Patterson-Jenny warm humid": colorRampWH,
            "Green - Yellow - Red": (t) => d3.interpolateRdYlGn(0.95 - t * 0.9),
            "Green": (t) => d3.interpolateGreens(1 - t),
            "Gray": (t) => d3.interpolateGreys(0.8 - t * 0.8),
            "Viridis": d3.interpolateViridis,
            "Plasma": d3.interpolatePlasma,
            "Cubehelix": (t) => d3.interpolateCubehelixDefault(0.1 + 0.9 * t),
            "Rainbow": d3.interpolateRainbow,
        }

        // build colour ramps list
        const hypscol = document.getElementById("hypscol");
        for (let r in ramps) hypscol.add(new Option(r, r));
        hypscol.addEventListener("change", update);


        const map = new gridviz.Map(document.getElementById('map'), {
            x: 4200000, y: 2800000, z: 1000,
            backgroundColor: seaColor
        })
            .setZoomExtent([10, 5000])
            .addZoomButtons()
            .setViewFromURL()

        const datasetRelief = new gridviz.MultiResolutionDataset(
            [100, 200, 500, 1000, 2000, 5000, 10000, 20000],
            resolution => new gviz_par.TiledParquetGrid(map,
                "https://raw.githubusercontent.com/jgaffuri/tiled-euroDEM/main/pub/v1/tiles_" + resolution + "/"),
            { preprocess: (c) => c.v != undefined && c.v != 0 }
        )

        const datasetPop = new gridviz.MultiResolutionDataset(
            [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000],
            resolution => new gviz_par.TiledParquetGrid(map,
                "https://raw.githubusercontent.com/jgaffuri/europop100m/main/pub/JRC_100m/" + resolution + "/"),
        )

        const datasetCLC = new gridviz.MultiResolutionDataset(
            [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000],
            (resolution) => new gviz_par.TiledParquetGrid(map,
                'https://raw.githubusercontent.com/eurostat/LCMap/main/pub/clc/v1/2018/' + resolution + '/'),
            { preprocess: (c) => c.code == 40 || c.code == 41 || c.code == 42 || c.code == 43 || c.code == 44 }
        )


        //const styleCLCWater = new gridviz.ShapeColorSizeStyle({ color: () => seaColor, size: (c, r, z) => r + z * 0.3 })
        const styleCLCWater = new gridviz.SquareColorCategoryWebGLStyle({
            code: (cell) => "a",
            color: { 'a': seaColor },
        })

        const strokeWidthPix = 1
        const fillColor = "#fffc"
        const strokeColor = "#666"
        const radiusFactor = 1.4
        const scalePopulation = gridviz.logarithmicScale(-3)
        const bertinPointsStyle = new gridviz.Style({
            drawFun: (cells, cg, r) => {
                //keep only cells with population
                cells = cells.filter((c) => c.POP_2021);
                if (cells.length == 0) return;

                //sort cells by decreasing x and increasing y
                cells.sort((c1, c2) => (c2.y == c1.y ? c1.x - c2.x : c2.y - c1.y));

                const max = d3.max(cells, (c) => +c.POP_2021);
                if (!max) return;

                //set canvas color and line width
                const ctx = cg.offscreenCtx
                ctx.fillStyle = fillColor;
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = strokeWidthPix * cg.view.z;

                const z = cg.view.z;
                for (let c of cells) {
                    //get circle size
                    const sG = radiusFactor * r * scalePopulation(c.POP_2021 / max);
                    if (sG / z < 3) continue

                    //draw circle
                    ctx.beginPath();
                    ctx.arc(c.x + r / 2, c.y + r / 2, sG * 0.5, 0, 2 * Math.PI, false);
                    ctx.fill();
                    ctx.stroke();
                }
            }
        })

        const labelLayer = new gridviz.LabelLayer(gridviz_eurostat.getEuronymeLabelLayer('EUR', 20))
        const boundariesLayer = new gridviz.GeoJSONLayer(gridviz_eurostat.getEurostatBoundariesLayer({ col: "#cc6699", scale: "03M" }))
        const roadsLayer = new gridviz.BackgroundLayer({
            url: "https://raw.githubusercontent.com/jgaffuri/gridStatBaseMap/main/pub/road/",
            resolutions: Array.from({ length: 14 }, (_, i) => 114688 / Math.pow(2, i)),
            origin: [0, 6000000],
            nbPix: 512,
            //visible: (z) => z > 4, //&& z < 2100,
            pixelationCoefficient: 0.55,
            blendOperation: (z) => 'multiply',
        })

        // tooltip content
        const cellInfoHTMLPop = (c) => `Population: ${c.POP_2021}`
        const cellInfoHTMLRelief = (c) => `Elevation: ${c.v}`


        const cbTanaka = document.getElementById("cbTanaka");
        const cbHillshading = document.getElementById("cbHillshading");
        const cbRelief = document.getElementById("cbRelief");
        const sReliefSmoothing = document.getElementById('sReliefSmoothing');
        const sReliefNb = document.getElementById('sReliefNb');
        const sReliefExageration = document.getElementById('sReliefExageration');
        const cbCLC = document.getElementById("cbCLC");
        const cbPopulation = document.getElementById("cbPopulation");
        const cbLabels = document.getElementById("cbLabels");
        const cbBoundaries = document.getElementById("cbBoundaries");
        const cbRoads = document.getElementById("cbRoads");
        const sSeaLevel = document.getElementById('sSeaLevel');
        const lbSeaLevel = document.getElementById("lbSeaLevel");
        const cbHypssea = document.getElementById("cbHypssea");
        const cbHD = document.getElementById("cbHD");

        let resolutionCoeff = 1
        let scaleShadingCoeff = -2
        let shadingDiamond = false
        let quantile = false
        let joyplot = false

        function update() {
            const seaLevel = +sSeaLevel.value;
            lbSeaLevel.textContent = seaLevel + ' m';

            let styleWater = new gridviz.ShapeColorSizeStyle({
                color: (c, r, z, vs) => {
                    if (c.v > seaLevel) return
                    return seaColorT
                }
            })
            /*let styleWater = new gridviz.SquareColorCategoryWebGLStyle({
                code: (c) => c.v > seaLevel ? undefined : "a",
                color: { 'a': seaColorT },
            })*/


            const adj = cbHypssea.checked
            const scaleReliefCoeff = 3 - 0.3 * +sReliefExageration.value
            const scaleRelief = gridviz.logarithmicScale(scaleReliefCoeff)
            //exponentialScale 

            //define style
            const classNumber = sReliefNb.value
            const colors = []
            const colorRamp = ramps[hypscol.value]
            for (let i = 0; i <= (classNumber - 1); i++) colors.push(colorRamp(i / (classNumber - 1)))

            /*let hypsoStyle = new gridviz.SquareColorWebGLStyle({
                viewScale: cells => {
                    [min, max] = d3.extent(cells, c => c.v)
                    const min_ = adj ? Math.max(min, seaLevel) : min < 0 ? 0 : min
                    const breaks = []
                    for (let i = 1; i < classNumber; i++) {
                        let t = i / classNumber
                        t = scaleRelief(t)
                        breaks.push(min_ + (max - min_) * t)
                    }
                    return gridviz.classifier(breaks)
                },
                tFun: (c, r, z, vs) => vs(c.v) / classNumber,
                colors: colors,
            })*/

            let hypsoStyle = new gridviz.SquareColorCategoryWebGLStyle({
                viewScale: quantile ? gridviz.viewScaleQuantileClassifer({
                    valueFunction: (c) => c.v,
                    classNumber: classNumber,
                }) :
                    cells => {
                        [min, max] = d3.extent(cells, c => c.v)
                        const min_ = adj ? Math.max(min, seaLevel) : min < 0 ? 0 : min
                        const breaks = []
                        for (let i = 1; i < classNumber; i++) {
                            let t = i / classNumber
                            t = scaleRelief(t)
                            breaks.push(min_ + (max - min_) * t)
                        }
                        return gridviz.classifier(breaks)
                    },
                code: (c, r, z, classifier) => classifier(c.v),
                color: { ...colors },
            })


            let tanakaStyle = new gridviz.SideTanakaStyle({
                classifier: quantile ? cells => {
                    const classifier = gridviz.viewScaleQuantileClassifer({
                        valueFunction: (c) => c.v,
                        classNumber: classNumber,
                    })(cells)
                    return c => classifier(c.v)
                } : cells => {
                    // return a function which for each cell returns its class number
                    [min, max] = d3.extent(cells, c => c.v)
                    const min_ = adj ? Math.max(min, seaLevel) : min < 0 ? 0 : min
                    const breaks = []
                    for (let i = 1; i < classNumber; i++) {
                        let t = i / classNumber
                        t = scaleRelief(t)
                        breaks.push(min_ + (max - min_) * t)
                    }
                    const cs = gridviz.classifier(breaks)
                    return c => cs(c.v)
                },
                diamond: shadingDiamond,
            })

            //- 0.3 * +sReliefExageration.value
            const scaleShading = gridviz.exponentialScale(scaleShadingCoeff) //gridviz.exponentialScale(-1)
            let shadingStyle = new gridviz.ShadingStyle({
                elevation: 'v',
                scale: scaleShading,
                diamond: shadingDiamond,
            })

            // joyplot style
            let joyplotStyle = new gridviz.JoyPlotStyle({
                viewScale: cells => d3.extent(cells, c => c.v),
                height: (c, r, z, [min, max]) => 3 * r * scaleRelief((c.v - min) / (max - min)),
                lineColor: (y, ys, r, z) => "#ddd",
                lineWidth: (y, ys, r, z) => z,
                fillColor: (y, ys, r, z) => "#777"
            })

            // definition
            const mppc = (cbHD.checked ? 0.7 : 1.4) * resolutionCoeff
            const mppcRelief = joyplot ? 8 * resolutionCoeff : mppc
            let reliefStyle = joyplot ? joyplotStyle : hypsoStyle

            // apply smoothing
            const sr = +sReliefSmoothing.value
            if (sr > 0) {
                const fun = (style) => new gridviz_smoothing.KernelSmoothingStyle({
                    value: (cell) => +cell.v,
                    smoothedProperty: "v",
                    sigma: (r, z) => r + sr * z, // in geo unit - sr is in screen pixel
                    factor: (cbHD.checked ? 1 : 3),
                    filterSmoothed: (value) => value > 0.05,
                    styles: [style]
                })
                reliefStyle = fun(reliefStyle)
                tanakaStyle = fun(tanakaStyle)
                shadingStyle = fun(shadingStyle)
                styleWater = fun(styleWater)
            }

            /*
            //test https://d3js.org/d3-contour/density
            const smm2 = new gridviz.Style()
            smm2.drawFun = (cells, geoCanvas, resolution) => {

            }*/



            // set layers
            const layers = []
            // relief
            if (cbRelief.checked) layers.push(new gridviz.GridLayer(datasetRelief, [reliefStyle], { minPixelsPerCell: mppcRelief, cellInfoHTML: cellInfoHTMLRelief }))
            // relief tanaka
            if (cbTanaka.checked) layers.push(new gridviz.GridLayer(datasetRelief, [tanakaStyle], { minPixelsPerCell: mppc, cellInfoHTML: 'none' }))
            //relief shading
            if (cbHillshading.checked) layers.push(new gridviz.GridLayer(datasetRelief, [shadingStyle], { minPixelsPerCell: mppc, cellInfoHTML: 'none' }))
            // CLC waters
            if (cbCLC.checked) layers.push(new gridviz.GridLayer(datasetCLC, [styleCLCWater], { minPixelsPerCell: mppc, cellInfoHTML: 'none' }))
            // population
            if (cbPopulation.checked) layers.push(new gridviz.GridLayer(datasetPop, [bertinPointsStyle], { minPixelsPerCell: 4, cellInfoHTML: 'none' }))
            //boundaries
            if (cbBoundaries.checked) layers.push(boundariesLayer);
            //roads
            if (cbRoads.checked) layers.push(roadsLayer);
            // sea level
            if (seaLevel) layers.push(new gridviz.GridLayer(datasetRelief, [styleWater], { minPixelsPerCell: mppc, cellInfoHTML: 'none' }))
            // labels
            if (cbLabels.checked) layers.push(labelLayer)
            map.layers = layers

            map.redraw()
        }

        //add event listeners
        sSeaLevel.addEventListener('input', update);
        cbTanaka.addEventListener("change", update);
        cbHillshading.addEventListener("change", update);
        cbRelief.addEventListener("change", update);
        sReliefSmoothing.addEventListener("input", update);
        sReliefNb.addEventListener("input", update);
        sReliefExageration.addEventListener("input", update);
        cbCLC.addEventListener("change", update);
        cbPopulation.addEventListener("change", update);
        cbLabels.addEventListener("change", update);
        cbBoundaries.addEventListener("change", update);
        cbRoads.addEventListener("change", update);
        cbHypssea.addEventListener("change", update);
        cbHD.addEventListener("change", update);



        //keyboard events
        let animation = undefined
        window.addEventListener('keypress', e => {
            if (e.key == "h") {
                const div = document.getElementById("control");
                if (div.style.display === "none") div.style.display = "block"; // or "inline", "flex", etc.
                else div.style.display = "none";
            }
            //else if (e.key == "t") { tanaka = !tanaka; update() }
            else if (e.key == "q") { quantile = !quantile; update() }
            else if (e.key == "j") { joyplot = !joyplot; update() }
            else if (e.key == "d") { shadingDiamond = !shadingDiamond; update() }
            else if (e.key == "w") { scaleShadingCoeff -= 0.25; console.log(scaleShadingCoeff); update() }
            else if (e.key == "x") { scaleShadingCoeff += 0.25; console.log(scaleShadingCoeff); update() }
            else if (e.key == "+") { resolutionCoeff /= 1.2; console.log(resolutionCoeff); update() }
            else if (e.key == "-") { resolutionCoeff *= 1.2; console.log(resolutionCoeff); update() }
        })

        update()

    </script>

</body>

</html>